<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>emblaze.thumbnails API documentation</title>
<meta name="description" content="Defines model classes to store thumbnail data in text and/or image formats." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="shortcut icon" type="image/x-icon" href="assets/favicon.ico"/>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>emblaze.thumbnails</code></h1>
</header>
<section id="section-intro">
<p>Defines model classes to store thumbnail data in text and/or image formats.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Defines model classes to store thumbnail data in text and/or image formats.
&#34;&#34;&#34;

import json
from typing import Text
import numpy as np
import pandas as pd
from io import BytesIO
from PIL import Image
import base64
import copy
from .datasets import ColumnarData
from .utils import Field, standardize_json

class Thumbnails:
    &#34;&#34;&#34;
    Defines a set of data suitable for displaying info about points visualized
    in an embedding set.
    &#34;&#34;&#34;
    def __init__(self, thumbnail_format):
        self.format = thumbnail_format

    def to_json(self):
        &#34;&#34;&#34;
        Converts this set of thumbnails into a JSON object.
        &#34;&#34;&#34;
        return {
            &#34;format&#34;: self.format
        }
        
    @classmethod
    def from_json(cls, data, ids=None):
        &#34;&#34;&#34;
        Loads this Thumbnails object from JSON. This base method chooses the
        appropriate Thumbnails subclass to initialize, based on the format
        declared in the given JSON object data. The ids parameter can be used
        to subset the point IDs that are loaded from the file.
        &#34;&#34;&#34;
        if data[&#34;format&#34;] == &#34;spritesheet_and_text&#34;:
            return CombinedThumbnails.from_json(data)
        elif data[&#34;format&#34;] == &#34;spritesheet&#34;:
            return ImageThumbnails.from_json(data, ids=ids)
        elif data[&#34;format&#34;] == &#34;text_descriptions&#34;:
            return TextThumbnails.from_json(data, ids=ids)
        raise ValueError(&#34;Unsupported data format &#39;{}&#39;&#34;.format(data[&#34;format&#34;]))
        
    def get_ids(self):
        &#34;&#34;&#34;Return a numpy array of the IDs used in this thumbnails object.&#34;&#34;&#34;
        raise NotImplementedError
    
    def save(self, file_path_or_buffer):
        &#34;&#34;&#34;
        Save this Thumbnails object to the given file path or file-like object
        (in JSON format).
        &#34;&#34;&#34;
        if isinstance(file_path_or_buffer, str):
            # File path
            with open(file_path_or_buffer, &#39;w&#39;) as file:
                json.dump(self.to_json(), file)
        else:
            # File object
            json.dump(self.to_json(), file_path_or_buffer)
            
    @classmethod
    def load(cls, file_path_or_buffer, ids=None):
        &#34;&#34;&#34;
        Load the appropriate Thumbnails subclass from the given file path or
        file-like object containing JSON data.
        &#34;&#34;&#34;
        if isinstance(file_path_or_buffer, str):
            # File path
            with open(file_path_or_buffer, &#39;r&#39;) as file:
                return cls.from_json(json.load(file), ids=ids)
        else:
            # File object
            return cls.from_json(json.load(file_path_or_buffer), ids=ids)
        
class TextThumbnails(Thumbnails):
    &#34;&#34;&#34;
    Defines a set of textual thumbnails.
    &#34;&#34;&#34;
    def __init__(self, names, descriptions=None, ids=None):
        &#34;&#34;&#34;
        names: String values corresponding to a name for each point in the
            dataset.
        descriptions: Optional longer string descriptions for each point in the
            dataset.
        ids: If not None, a list of IDs that these thumbnails correspond to.
            If not provided, the IDs are assumed to be zero-indexed ascending
            integers.
        &#34;&#34;&#34;
        super().__init__(&#34;text_descriptions&#34;)
        if ids is not None:
            assert len(names) == len(ids), &#34;Length mismatch: got {} names for {} IDs&#34;.format(len(names), len(ids))
            if descriptions is not None:
                assert len(descriptions) == len(ids), &#34;Length mismatch: got {} descriptions for {} IDs&#34;.format(len(descriptions), len(ids))
        self.data = ColumnarData({
            Field.NAME: names
        }, ids)
        if descriptions is not None:
            self.data.set_field(Field.DESCRIPTION, descriptions)

    def get_ids(self):
        return self.data.ids
    
    def name(self, ids=None):
        &#34;&#34;&#34;
        Returns the name(s) for the given set of IDs, or all points if
        ids is not provided.
        &#34;&#34;&#34;
        return self.data.field(Field.NAME, ids=ids)
    
    def description(self, ids=None):
        &#34;&#34;&#34;
        Returns the description(s) for the given set of IDs, or all points if
        ids is not provided. Returns None if descriptions are not present.
        &#34;&#34;&#34;
        return self.data.field(Field.DESCRIPTION, ids=ids)
        
    def to_json(self):
        result = super().to_json()
        names = self.data.field(Field.NAME)
        descriptions = self.data.field(Field.DESCRIPTION)
        def _make_json_item(i, id_val):
            item = {&#34;id&#34;: id_val, &#34;name&#34;: str(names[i])}
            if descriptions is not None and descriptions[i]:
                item[&#34;description&#34;] = str(descriptions[i])
            return item
        result[&#34;items&#34;] = {
            id_val: _make_json_item(i, id_val)
            for i, id_val in enumerate(self.data.ids)
            if names[i] or (descriptions is not None and descriptions[i])
        }
        return standardize_json(result)
    
    @classmethod
    def from_json(cls, data, ids=None):
        &#34;&#34;&#34;
        Builds a TextThumbnails object from a JSON object. The provided object should
        have an &#34;items&#34; key with a dictionary mapping ID values to text thumbnail
        objects, each of which must have a &#39;name&#39; and optionally &#39;description&#39; keys.
        &#34;&#34;&#34;
        assert &#34;items&#34; in data, &#34;JSON object must contain an &#39;items&#39; field&#34;
        items = data[&#34;items&#34;]
        if ids is None:
            try:
                ids = [int(id_val) for id_val in list(items.keys())]
                items = {int(k): v for k, v in items.items()}
            except:
                ids = list(items.keys())
            ids = sorted(ids)
        names = [items[id_val][&#34;name&#34;] for id_val in ids]
        descriptions = [items[id_val].get(&#34;description&#34;, &#34;&#34;) for id_val in ids]
        return cls(names, descriptions, ids)
   
    def __getitem__(self, ids):
        &#34;&#34;&#34;
        Returns text thumbnail information for the given IDs.
        &#34;&#34;&#34;
        if isinstance(ids, (list, np.ndarray, set)):
            return [self[id_val] for id_val in ids]
        else:
            result = { &#34;name&#34;: self.data.field(Field.NAME, ids) }
            if self.data.has_field(Field.DESCRIPTION):
                result[&#34;description&#34;] = self.data.field(Field.DESCRIPTION, ids)
            return result
    
MAX_IMAGE_DIM = 100
MAX_SPRITESHEET_DIM = 1000
 
class ImageThumbnails(Thumbnails):
    &#34;&#34;&#34;
    Defines a set of image thumbnails. All thumbnails are scaled to the same
    dimensions to fit in a set of spritesheets.
    &#34;&#34;&#34;
    def __init__(self, images, spritesheets=None, ids=None, grid_dimensions=None, image_size=None, names=None, descriptions=None):
        &#34;&#34;&#34;
        Args:
            images: An array of images, each represented as a numpy array. The
                images contained can be different sizes if the images object is
                provided as a list.
            spritesheets: If provided, ignores the other spritesheet-generating
                parameters and initializes the thumbnails object with previously
                generated spritesheets.
            ids: The IDs of the points to which each image belongs. If none, this
                is assumed to be a zero-indexed increasing index.
            grid_dimensions: Number of images per spritesheet, defined as
                (images per row, images per column). If this is not provided,
                it will be inferred to make the spritesheets a reasonable size.
            image_size: Number of pixels per image, defined as (rows, cols).
                If this is not defined, images will be resized to a maximum of
                MAX_IMAGE_DIM x MAX_IMAGE_DIM, maintaining aspect ratio if all
                images are the same size.
            names: If provided, adds text names to each point. Names are assumed
                to be in the same order as images.
            descriptions: Similar to names, but these descriptions may be longer
                and only show on the currently selected point(s).
        &#34;&#34;&#34;
        super().__init__(&#34;spritesheet&#34;)
        if spritesheets is not None:
            self.ids = ImageThumbnails._get_spritesheet_ids(spritesheets)
            self.spritesheets = spritesheets
            self.images = None
        else:
            self.images = images
            self.ids = ids if ids is not None else np.arange(len(images))
            self.make_spritesheets(images, self.ids, grid_dimensions, image_size)
        self._id_index = {id: i for i, id in enumerate(self.ids)}
        
        if names is not None:
            self.text_data = ColumnarData({
                Field.NAME: names
            }, ids)
            if descriptions is not None:
                self.text_data.set_field(Field.DESCRIPTION, descriptions)
        elif descriptions is not None:
            self.text_data = ColumnarData({
                Field.DESCRIPTION: descriptions
            }, ids)
        else:
            self.text_data = None
        
    def get_ids(self):
        return self.ids
        
    def __getitem__(self, ids):
        &#34;&#34;&#34;
        Returns image/text thumbnail information for the given IDs.
        &#34;&#34;&#34;
        if isinstance(ids, (list, np.ndarray, set)):
            return [self[id_val] for id_val in ids]
        else:
            result = {}
            result[&#34;image&#34;] = self.image(ids)
            if self.text_data is not None:
                result[&#34;name&#34;] = self.text_data.field(Field.NAME, ids)
                if self.text_data.has_field(Field.DESCRIPTION):
                    result[&#34;description&#34;] = self.text_data.field(Field.DESCRIPTION, ids)
            return result

    def image(self, ids=None):
        &#34;&#34;&#34;
        Returns the image(s) for the given ID or set of IDs, or all points if ids
        is not provided.
        &#34;&#34;&#34;
        if self.images is None:
            self.images = self._make_raw_images()
            
        if isinstance(ids, (list, np.ndarray, set)):
            index = [self._id_index.get(int(id_val), None) for id_val in ids]
            return [self.images[i] if i is not None else None for i in index]
        else:
            index = self._id_index.get(int(ids), None)
            if index is not None:
                return self.images[index] 
            return None
        
    def name(self, ids=None):
        &#34;&#34;&#34;
        Returns the name(s) for the given set of IDs, or all points if
        ids is not provided. Returns None if names are not available.
        &#34;&#34;&#34;
        if self.text_data is None: return None
        return self.text_data.field(Field.NAME, ids=ids)
    
    def description(self, ids=None):
        &#34;&#34;&#34;
        Returns the description(s) for the given set of IDs, or all points if
        ids is not provided. Returns None if descriptions are not present.
        &#34;&#34;&#34;
        if self.text_data is None: return None
        return self.text_data.field(Field.DESCRIPTION, ids=ids)
        
    def get_spritesheets(self):
        return self.spritesheets
    
    def to_json(self):
        result = super().to_json()
        result[&#34;spritesheets&#34;] = self.spritesheets
        if self.text_data is not None:
            names = self.text_data.field(Field.NAME)
            descriptions = self.text_data.field(Field.DESCRIPTION)
            result[&#34;items&#34;] = {
                id_val: {
                    &#34;id&#34;: id_val,
                    &#34;name&#34;: str(names[i]) if names is not None else &#34;&#34;,
                    &#34;description&#34;: str(descriptions[i]) if descriptions is not None else &#34;&#34;,
                    &#34;frames&#34;: {} # Not implemented
                } for i, id_val in enumerate(self.text_data.ids) if names[i] or descriptions[i]
            }

        return standardize_json(result)
    
    @classmethod
    def from_json(cls, data, ids=None):
        &#34;&#34;&#34;
        Builds an ImageThumbnails object from a JSON object. The provided object should
        have a &#34;spritesheets&#34; object that defines PIXI spritesheets, and an
        optional &#34;items&#34; key that contains text thumbnails (see TextThumbnails
        for more information about the &#34;items&#34; field).
        &#34;&#34;&#34;
        assert &#34;spritesheets&#34; in data, &#34;JSON object must contain a &#39;spritesheets&#39; field&#34;
        spritesheets = data[&#34;spritesheets&#34;]
        if ids is None:
            ids = cls._get_spritesheet_ids(spritesheets)
            
        names = None
        descriptions = None
        if &#34;items&#34; in data:
            items = data[&#34;items&#34;]
            names = [items[str(id_val)][&#34;name&#34;] for id_val in ids]
            descriptions = [items[str(id_val)].get(&#34;description&#34;, &#34;&#34;) for id_val in ids]

        return cls(None,
                   spritesheets=spritesheets,
                   ids=ids,
                   names=names,
                   descriptions=descriptions)

    @classmethod
    def _get_spritesheet_ids(cls, spritesheets):
        ids = sorted([k for sp in spritesheets.values() for k in sp[&#34;spec&#34;][&#34;frames&#34;].keys()])
        try:
            ids = [int(id_val) for id_val in ids]
        except:
            pass
        ids = sorted(ids)
        return np.array(ids)
        
    def _make_raw_images(self):
        &#34;&#34;&#34;
        Regenerates and returns the original images matrix based on self.spritesheets
        and self.ids.
        &#34;&#34;&#34;
        assert len(self.spritesheets), &#34;spritesheets is empty&#34;
        random_spec = self.spritesheets[list(self.spritesheets.keys())[0]][&#34;spec&#34;][&#34;frames&#34;]
        random_frame = random_spec[list(random_spec.keys())[0]][&#34;frame&#34;]
        cols = random_frame[&#34;w&#34;]
        rows = random_frame[&#34;h&#34;]
        
        result = np.zeros((len(self.ids), rows, cols, 4), dtype=np.uint8)
        seen_ids = set()
        for key, spritesheet in self.spritesheets.items():
            buffer = BytesIO(base64.b64decode(spritesheet[&#34;image&#34;].encode(&#39;ascii&#39;)))
            img = np.array(Image.open(buffer, formats=(&#39;PNG&#39;,)))
            
            for id_val, image_spec in spritesheet[&#34;spec&#34;][&#34;frames&#34;].items():
                frame = image_spec[&#34;frame&#34;]
                result[self._id_index[int(id_val)]] = img[frame[&#34;y&#34;]:frame[&#34;y&#34;] + frame[&#34;h&#34;],
                                                          frame[&#34;x&#34;]:frame[&#34;x&#34;] + frame[&#34;w&#34;]]
                seen_ids.add(int(id_val))
        if len(seen_ids &amp; set(self.ids.tolist())) != len(self.ids):
            print(&#34;missing ids when loading images from spritesheets:&#34;, set(self.ids.tolist()) - seen_ids)
        return result
        
    def make_spritesheets(self, images, ids, grid_dimensions=None, image_size=None):
        &#34;&#34;&#34;
        Generates a set of spritesheets from the given image data.
        
        Args:
            images: A matrix or list of images in RGBA format (e.g. shape = rows x cols x 4).
            ids: The point IDs to associate with each image.
            grid_dimensions: Number of images per spritesheet, defined as
                (images per row, images per column)
            image_size: Number of pixels per image, defined as (rows, cols)
        &#34;&#34;&#34;
        
        image_size = image_size or self._compute_image_size(images)
        grid_dimensions = grid_dimensions or self._compute_grid_dimensions(image_size)
        
        spritesheets = {}
        current_spritesheet = None

        current_image = None
        image_index = 0
        image_encoding_warning = False
        assert len(ids) == len(images), &#34;Number of IDs provided must be equal to number of images&#34;
        for i, id_val in enumerate(ids):
            if i % (grid_dimensions[0] * grid_dimensions[1]) == 0:
                if current_image is not None and current_spritesheet is not None:
                    img = Image.fromarray(current_image, &#39;RGBA&#39;)
                    with BytesIO() as output:
                        img.save(output, format=&#39;png&#39;)
                        contents = output.getvalue()
                    current_spritesheet[&#34;image&#34;] = base64.b64encode(contents).decode(&#39;ascii&#39;)
                    current_spritesheet[&#34;imageFormat&#34;] = &#34;image/png&#34;
                    image_index += 1
                    
                current_spritesheet = {
                    &#34;spec&#34;: {
                        &#34;meta&#34;: {
                            &#34;image&#34;: &#34;img_{}.png&#34;.format(image_index),
                            &#34;size&#34;: {
                                &#34;w&#34;: grid_dimensions[1] * image_size[1],
                                &#34;h&#34;: grid_dimensions[0] * image_size[0]},
                            &#34;format&#34;: &#34;RGBA8888&#34;
                        },
                        &#34;frames&#34;: {}
                    }
                }
                spritesheets[&#34;img_{}.json&#34;.format(image_index)] = current_spritesheet

                current_image = np.zeros((image_size[0] * grid_dimensions[0], image_size[1] * grid_dimensions[1], 4), dtype=np.uint8)
                
            relative_i = i % (grid_dimensions[0] * grid_dimensions[1])
            pos = (relative_i // grid_dimensions[1] * image_size[0], relative_i % grid_dimensions[1] * image_size[1])
            
            # First validate the image
            image = images[i]
            assert len(image.shape) == 3, &#34;Images must be 3-dimensional arrays (include a color channel)&#34;
            image = self._standardize_image_format(image, image.shape[:2])
            if np.max(image[:,:,:3]) &lt; 2 and not image_encoding_warning:
                print(&#34;Warning: Your image pixel values are very small. ImageThumbnails uses integer pixel values from 0-255.&#34;)
                image_encoding_warning = True
            
            # Resize the image if necessary
            if tuple(image.shape[:2]) != image_size:
                resized_image = Image.fromarray(image).resize((image_size[1], image_size[0]))
                image = np.array(resized_image)
                assert image.shape == (*image_size, 4), &#34;Incorrect resize shape! Something weird happened.&#34;
                
            # Place the image
            current_image[pos[0]:pos[0] + image_size[0], pos[1]:pos[1] + image_size[1],:] = image
            
            current_spritesheet[&#34;spec&#34;][&#34;frames&#34;][str(id_val)] = {
                &#34;frame&#34;: {
                    &#34;x&#34;: pos[1],
                    &#34;y&#34;: pos[0],
                    &#34;w&#34;: image_size[1],
                    &#34;h&#34;: image_size[0]
                },
                &#34;rotated&#34;: False,
                &#34;trimmed&#34;: False
            }

        img = Image.fromarray(current_image, &#39;RGBA&#39;)
        with BytesIO() as output:
            img.save(output, format=&#39;png&#39;)
            contents = output.getvalue()
        current_spritesheet[&#34;image&#34;] = base64.b64encode(contents).decode(&#39;ascii&#39;)
        current_spritesheet[&#34;imageFormat&#34;] = &#34;image/png&#34;
        
        self.spritesheets = spritesheets
        
    def _standardize_image_format(self, image, image_size):
        &#34;&#34;&#34;
        Converts the given image array to RGBA uint8 format.
        
        Args:
            image: An image matrix.
            image_size: The size of the image in (rows, cols).
        &#34;&#34;&#34;
        image = image.astype(np.uint8)
        result = np.zeros((image_size[0], image_size[1], 4), dtype=np.uint8)
        if image.shape[2] == 1:
            for channel in range(3):
                result[:,:,channel] = image[:,:,0]
            result[:,:,3] = 255
        elif image.shape[2] == 3:
            result[:,:,:3] = image
            result[:,:,3] = 255
        elif image.shape[2] == 4:
            result = image
        else:
            raise ValueError(&#34;Incorrect image shape, expected 3rd dimension to be 1, 3 or 4; got {} instead&#34;.format(image.shape[2]))
        return result
        
    def _compute_image_size(self, images):
        &#34;&#34;&#34;
        Computes a reasonable image size to rescale all images to.
        &#34;&#34;&#34;
        if len(images) == 0: return (0, 0)
        test_dim = images[0].shape[:2]
        if all(img.shape[:2] == test_dim for img in images):
            if max(*test_dim) &lt; MAX_IMAGE_DIM:
                # The images are already a reasonable size
                return test_dim
            
            # Resize preserving aspect ratio
            scale = min(MAX_IMAGE_DIM / test_dim[0], MAX_IMAGE_DIM / test_dim[1])
            return (int(test_dim[0] * scale), int(test_dim[1] * scale))
        else:
            # Get the average aspect ratio and choose a dimension so that no
            # image is scaled up
            aspect = np.mean([img.shape[0] / img.shape[1] for img in images])
            if aspect &lt; 1.0:
                min_dim = min(MAX_IMAGE_DIM, np.min(np.array([img.shape[1] for img in images])))
                return (int(min_dim * aspect), int(min_dim))
            else:
                min_dim = min(MAX_IMAGE_DIM, np.min(np.array([img.shape[0] for img in images])))
                return (int(min_dim), int(min_dim / aspect))
        
    def _compute_grid_dimensions(self, image_size):
        &#34;&#34;&#34;
        Computes a reasonable number of images per side of the spritesheet.
        &#34;&#34;&#34;
        return (MAX_SPRITESHEET_DIM // image_size[0], MAX_SPRITESHEET_DIM // image_size[1])
    
    
class CombinedThumbnails(Thumbnails):
    &#34;&#34;&#34;
    A class representing a combination of images and/or text thumbnails. The
    thumbnail objects that are merged may have overlapping IDs, but they may not
    have overlapping IDs for the same thumbnail type. For example, two
    ImageThumbnails objects cannot both have images for the same point ID.
    &#34;&#34;&#34;
    def __init__(self, thumbnail_objects):
        has_images = any(t.format == &#34;spritesheet&#34; for t in thumbnail_objects)
        has_texts = any(t.format == &#34;text_descriptions&#34; for t in thumbnail_objects)
        super().__init__((&#34;spritesheet_and_text&#34; if has_images else &#34;text_descriptions&#34;) if has_texts else &#34;spritesheet&#34;)
        
        # Merge the list of representations together
        self.ids = np.array(sorted(set.union(*(set(t.get_ids().tolist()) for t in thumbnail_objects))))
        self._id_index = {id_val: i for i, id_val in enumerate(self.ids)}
        
        names = None
        descriptions = None
        spritesheets = {}
        seen_images = set()
        seen_texts = set()
        for t, thumbnails in enumerate(thumbnail_objects):
            indexes = [self._id_index[id_val] for id_val in thumbnails.get_ids()]
            
            if thumbnails.format == &#34;spritesheet&#34;:
                assert not set(thumbnails.get_ids().tolist()) &amp; seen_images, &#34;Overlapping image thumbnails&#34;
                for spritesheet_name, value in thumbnails.get_spritesheets().items():
                    new_spritesheet_name = str(t) + &#34;_&#34; + spritesheet_name
                    spritesheet = copy.deepcopy(value)
                    spritesheet[&#34;spec&#34;][&#34;meta&#34;][&#34;image&#34;] = str(t) + &#34;_&#34; + spritesheet[&#34;spec&#34;][&#34;meta&#34;][&#34;image&#34;]
                    spritesheets[new_spritesheet_name] = spritesheet
                seen_images |= set(thumbnails.get_ids().tolist())
            
            if thumbnails.format == &#34;text_descriptions&#34; or (thumbnails.format == &#34;spritesheet&#34; and thumbnails.name() is not None):
                assert not set(thumbnails.get_ids().tolist()) &amp; seen_texts, &#34;Overlapping text thumbnails&#34;
                seen_texts |= set(thumbnails.get_ids().tolist())
            
            nm = thumbnails.name()
            if nm is not None:
                if names is None: names = np.empty(len(self.ids), dtype=&#39;O&#39;)
                names[indexes] = thumbnails.name()
            desc = thumbnails.description()
            if desc is not None:
                if descriptions is None: descriptions = np.empty(len(self.ids), dtype=&#39;O&#39;)
                descriptions[indexes] = desc
            
        # Store an internal ImageThumbnails and a TextThumbnails object
        self.image_thumbnails = ImageThumbnails(None, spritesheets=spritesheets) if spritesheets else None
        self.text_thumbnails = TextThumbnails(names, descriptions, ids=self.ids) if names is not None else None
        
    def get_ids(self):
        return self.ids

    def get_spritesheets(self):
        return self.image_thumbnails.spritesheets if self.image_thumbnails else None
    
    def to_json(self):
        result = super().to_json()
        
        if self.image_thumbnails is not None:
            result[&#34;spritesheets&#34;] = self.image_thumbnails.to_json()[&#34;spritesheets&#34;]
        if self.text_thumbnails is not None:
            result[&#34;items&#34;] = self.text_thumbnails.to_json()[&#34;items&#34;]
            
        return result
    
    @classmethod
    def from_json(cls, data, ids=None):
        thumbnails = []
        if &#34;spritesheets&#34; in data:
            thumbnails.append(ImageThumbnails.from_json({&#34;spritesheets&#34;: data[&#34;spritesheets&#34;]}))
            
        if &#34;items&#34; in data:
            thumbnails.append(TextThumbnails.from_json({&#34;items&#34;: data[&#34;items&#34;]}))
            
        return cls(thumbnails)
    
    def image(self, ids=None):
        &#34;&#34;&#34;
        Returns the image(s) for the given ID or set of IDs, or all points if ids
        is not provided.
        &#34;&#34;&#34;
        return self.image_thumbnails.image(ids=ids) if self.image_thumbnails else None
        
    def name(self, ids=None):
        &#34;&#34;&#34;
        Returns the name(s) for the given set of IDs, or all points if
        ids is not provided. Returns None if names are not available.
        &#34;&#34;&#34;
        return self.text_thumbnails.name(ids=ids) if self.text_thumbnails else None
    
    def description(self, ids=None):
        &#34;&#34;&#34;
        Returns the description(s) for the given set of IDs, or all points if
        ids is not provided. Returns None if descriptions are not present.
        &#34;&#34;&#34;
        return self.text_thumbnails.description(ids=ids) if self.text_thumbnails else None
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="emblaze.thumbnails.CombinedThumbnails"><code class="flex name class">
<span>class <span class="ident">CombinedThumbnails</span></span>
<span>(</span><span>thumbnail_objects)</span>
</code></dt>
<dd>
<div class="desc"><p>A class representing a combination of images and/or text thumbnails. The
thumbnail objects that are merged may have overlapping IDs, but they may not
have overlapping IDs for the same thumbnail type. For example, two
ImageThumbnails objects cannot both have images for the same point ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CombinedThumbnails(Thumbnails):
    &#34;&#34;&#34;
    A class representing a combination of images and/or text thumbnails. The
    thumbnail objects that are merged may have overlapping IDs, but they may not
    have overlapping IDs for the same thumbnail type. For example, two
    ImageThumbnails objects cannot both have images for the same point ID.
    &#34;&#34;&#34;
    def __init__(self, thumbnail_objects):
        has_images = any(t.format == &#34;spritesheet&#34; for t in thumbnail_objects)
        has_texts = any(t.format == &#34;text_descriptions&#34; for t in thumbnail_objects)
        super().__init__((&#34;spritesheet_and_text&#34; if has_images else &#34;text_descriptions&#34;) if has_texts else &#34;spritesheet&#34;)
        
        # Merge the list of representations together
        self.ids = np.array(sorted(set.union(*(set(t.get_ids().tolist()) for t in thumbnail_objects))))
        self._id_index = {id_val: i for i, id_val in enumerate(self.ids)}
        
        names = None
        descriptions = None
        spritesheets = {}
        seen_images = set()
        seen_texts = set()
        for t, thumbnails in enumerate(thumbnail_objects):
            indexes = [self._id_index[id_val] for id_val in thumbnails.get_ids()]
            
            if thumbnails.format == &#34;spritesheet&#34;:
                assert not set(thumbnails.get_ids().tolist()) &amp; seen_images, &#34;Overlapping image thumbnails&#34;
                for spritesheet_name, value in thumbnails.get_spritesheets().items():
                    new_spritesheet_name = str(t) + &#34;_&#34; + spritesheet_name
                    spritesheet = copy.deepcopy(value)
                    spritesheet[&#34;spec&#34;][&#34;meta&#34;][&#34;image&#34;] = str(t) + &#34;_&#34; + spritesheet[&#34;spec&#34;][&#34;meta&#34;][&#34;image&#34;]
                    spritesheets[new_spritesheet_name] = spritesheet
                seen_images |= set(thumbnails.get_ids().tolist())
            
            if thumbnails.format == &#34;text_descriptions&#34; or (thumbnails.format == &#34;spritesheet&#34; and thumbnails.name() is not None):
                assert not set(thumbnails.get_ids().tolist()) &amp; seen_texts, &#34;Overlapping text thumbnails&#34;
                seen_texts |= set(thumbnails.get_ids().tolist())
            
            nm = thumbnails.name()
            if nm is not None:
                if names is None: names = np.empty(len(self.ids), dtype=&#39;O&#39;)
                names[indexes] = thumbnails.name()
            desc = thumbnails.description()
            if desc is not None:
                if descriptions is None: descriptions = np.empty(len(self.ids), dtype=&#39;O&#39;)
                descriptions[indexes] = desc
            
        # Store an internal ImageThumbnails and a TextThumbnails object
        self.image_thumbnails = ImageThumbnails(None, spritesheets=spritesheets) if spritesheets else None
        self.text_thumbnails = TextThumbnails(names, descriptions, ids=self.ids) if names is not None else None
        
    def get_ids(self):
        return self.ids

    def get_spritesheets(self):
        return self.image_thumbnails.spritesheets if self.image_thumbnails else None
    
    def to_json(self):
        result = super().to_json()
        
        if self.image_thumbnails is not None:
            result[&#34;spritesheets&#34;] = self.image_thumbnails.to_json()[&#34;spritesheets&#34;]
        if self.text_thumbnails is not None:
            result[&#34;items&#34;] = self.text_thumbnails.to_json()[&#34;items&#34;]
            
        return result
    
    @classmethod
    def from_json(cls, data, ids=None):
        thumbnails = []
        if &#34;spritesheets&#34; in data:
            thumbnails.append(ImageThumbnails.from_json({&#34;spritesheets&#34;: data[&#34;spritesheets&#34;]}))
            
        if &#34;items&#34; in data:
            thumbnails.append(TextThumbnails.from_json({&#34;items&#34;: data[&#34;items&#34;]}))
            
        return cls(thumbnails)
    
    def image(self, ids=None):
        &#34;&#34;&#34;
        Returns the image(s) for the given ID or set of IDs, or all points if ids
        is not provided.
        &#34;&#34;&#34;
        return self.image_thumbnails.image(ids=ids) if self.image_thumbnails else None
        
    def name(self, ids=None):
        &#34;&#34;&#34;
        Returns the name(s) for the given set of IDs, or all points if
        ids is not provided. Returns None if names are not available.
        &#34;&#34;&#34;
        return self.text_thumbnails.name(ids=ids) if self.text_thumbnails else None
    
    def description(self, ids=None):
        &#34;&#34;&#34;
        Returns the description(s) for the given set of IDs, or all points if
        ids is not provided. Returns None if descriptions are not present.
        &#34;&#34;&#34;
        return self.text_thumbnails.description(ids=ids) if self.text_thumbnails else None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="emblaze.thumbnails.Thumbnails" href="#emblaze.thumbnails.Thumbnails">Thumbnails</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="emblaze.thumbnails.CombinedThumbnails.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the description(s) for the given set of IDs, or all points if
ids is not provided. Returns None if descriptions are not present.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self, ids=None):
    &#34;&#34;&#34;
    Returns the description(s) for the given set of IDs, or all points if
    ids is not provided. Returns None if descriptions are not present.
    &#34;&#34;&#34;
    return self.text_thumbnails.description(ids=ids) if self.text_thumbnails else None</code></pre>
</details>
</dd>
<dt id="emblaze.thumbnails.CombinedThumbnails.get_spritesheets"><code class="name flex">
<span>def <span class="ident">get_spritesheets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_spritesheets(self):
    return self.image_thumbnails.spritesheets if self.image_thumbnails else None</code></pre>
</details>
</dd>
<dt id="emblaze.thumbnails.CombinedThumbnails.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>self, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the image(s) for the given ID or set of IDs, or all points if ids
is not provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image(self, ids=None):
    &#34;&#34;&#34;
    Returns the image(s) for the given ID or set of IDs, or all points if ids
    is not provided.
    &#34;&#34;&#34;
    return self.image_thumbnails.image(ids=ids) if self.image_thumbnails else None</code></pre>
</details>
</dd>
<dt id="emblaze.thumbnails.CombinedThumbnails.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>self, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name(s) for the given set of IDs, or all points if
ids is not provided. Returns None if names are not available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def name(self, ids=None):
    &#34;&#34;&#34;
    Returns the name(s) for the given set of IDs, or all points if
    ids is not provided. Returns None if names are not available.
    &#34;&#34;&#34;
    return self.text_thumbnails.name(ids=ids) if self.text_thumbnails else None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="emblaze.thumbnails.Thumbnails" href="#emblaze.thumbnails.Thumbnails">Thumbnails</a></b></code>:
<ul class="hlist">
<li><code><a title="emblaze.thumbnails.Thumbnails.from_json" href="#emblaze.thumbnails.Thumbnails.from_json">from_json</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.get_ids" href="#emblaze.thumbnails.Thumbnails.get_ids">get_ids</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.load" href="#emblaze.thumbnails.Thumbnails.load">load</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.save" href="#emblaze.thumbnails.Thumbnails.save">save</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.to_json" href="#emblaze.thumbnails.Thumbnails.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="emblaze.thumbnails.ImageThumbnails"><code class="flex name class">
<span>class <span class="ident">ImageThumbnails</span></span>
<span>(</span><span>images, spritesheets=None, ids=None, grid_dimensions=None, image_size=None, names=None, descriptions=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a set of image thumbnails. All thumbnails are scaled to the same
dimensions to fit in a set of spritesheets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong></dt>
<dd>An array of images, each represented as a numpy array. The
images contained can be different sizes if the images object is
provided as a list.</dd>
<dt><strong><code>spritesheets</code></strong></dt>
<dd>If provided, ignores the other spritesheet-generating
parameters and initializes the thumbnails object with previously
generated spritesheets.</dd>
<dt><strong><code>ids</code></strong></dt>
<dd>The IDs of the points to which each image belongs. If none, this
is assumed to be a zero-indexed increasing index.</dd>
<dt><strong><code>grid_dimensions</code></strong></dt>
<dd>Number of images per spritesheet, defined as
(images per row, images per column). If this is not provided,
it will be inferred to make the spritesheets a reasonable size.</dd>
<dt><strong><code>image_size</code></strong></dt>
<dd>Number of pixels per image, defined as (rows, cols).
If this is not defined, images will be resized to a maximum of
MAX_IMAGE_DIM x MAX_IMAGE_DIM, maintaining aspect ratio if all
images are the same size.</dd>
<dt><strong><code>names</code></strong></dt>
<dd>If provided, adds text names to each point. Names are assumed
to be in the same order as images.</dd>
<dt><strong><code>descriptions</code></strong></dt>
<dd>Similar to names, but these descriptions may be longer
and only show on the currently selected point(s).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageThumbnails(Thumbnails):
    &#34;&#34;&#34;
    Defines a set of image thumbnails. All thumbnails are scaled to the same
    dimensions to fit in a set of spritesheets.
    &#34;&#34;&#34;
    def __init__(self, images, spritesheets=None, ids=None, grid_dimensions=None, image_size=None, names=None, descriptions=None):
        &#34;&#34;&#34;
        Args:
            images: An array of images, each represented as a numpy array. The
                images contained can be different sizes if the images object is
                provided as a list.
            spritesheets: If provided, ignores the other spritesheet-generating
                parameters and initializes the thumbnails object with previously
                generated spritesheets.
            ids: The IDs of the points to which each image belongs. If none, this
                is assumed to be a zero-indexed increasing index.
            grid_dimensions: Number of images per spritesheet, defined as
                (images per row, images per column). If this is not provided,
                it will be inferred to make the spritesheets a reasonable size.
            image_size: Number of pixels per image, defined as (rows, cols).
                If this is not defined, images will be resized to a maximum of
                MAX_IMAGE_DIM x MAX_IMAGE_DIM, maintaining aspect ratio if all
                images are the same size.
            names: If provided, adds text names to each point. Names are assumed
                to be in the same order as images.
            descriptions: Similar to names, but these descriptions may be longer
                and only show on the currently selected point(s).
        &#34;&#34;&#34;
        super().__init__(&#34;spritesheet&#34;)
        if spritesheets is not None:
            self.ids = ImageThumbnails._get_spritesheet_ids(spritesheets)
            self.spritesheets = spritesheets
            self.images = None
        else:
            self.images = images
            self.ids = ids if ids is not None else np.arange(len(images))
            self.make_spritesheets(images, self.ids, grid_dimensions, image_size)
        self._id_index = {id: i for i, id in enumerate(self.ids)}
        
        if names is not None:
            self.text_data = ColumnarData({
                Field.NAME: names
            }, ids)
            if descriptions is not None:
                self.text_data.set_field(Field.DESCRIPTION, descriptions)
        elif descriptions is not None:
            self.text_data = ColumnarData({
                Field.DESCRIPTION: descriptions
            }, ids)
        else:
            self.text_data = None
        
    def get_ids(self):
        return self.ids
        
    def __getitem__(self, ids):
        &#34;&#34;&#34;
        Returns image/text thumbnail information for the given IDs.
        &#34;&#34;&#34;
        if isinstance(ids, (list, np.ndarray, set)):
            return [self[id_val] for id_val in ids]
        else:
            result = {}
            result[&#34;image&#34;] = self.image(ids)
            if self.text_data is not None:
                result[&#34;name&#34;] = self.text_data.field(Field.NAME, ids)
                if self.text_data.has_field(Field.DESCRIPTION):
                    result[&#34;description&#34;] = self.text_data.field(Field.DESCRIPTION, ids)
            return result

    def image(self, ids=None):
        &#34;&#34;&#34;
        Returns the image(s) for the given ID or set of IDs, or all points if ids
        is not provided.
        &#34;&#34;&#34;
        if self.images is None:
            self.images = self._make_raw_images()
            
        if isinstance(ids, (list, np.ndarray, set)):
            index = [self._id_index.get(int(id_val), None) for id_val in ids]
            return [self.images[i] if i is not None else None for i in index]
        else:
            index = self._id_index.get(int(ids), None)
            if index is not None:
                return self.images[index] 
            return None
        
    def name(self, ids=None):
        &#34;&#34;&#34;
        Returns the name(s) for the given set of IDs, or all points if
        ids is not provided. Returns None if names are not available.
        &#34;&#34;&#34;
        if self.text_data is None: return None
        return self.text_data.field(Field.NAME, ids=ids)
    
    def description(self, ids=None):
        &#34;&#34;&#34;
        Returns the description(s) for the given set of IDs, or all points if
        ids is not provided. Returns None if descriptions are not present.
        &#34;&#34;&#34;
        if self.text_data is None: return None
        return self.text_data.field(Field.DESCRIPTION, ids=ids)
        
    def get_spritesheets(self):
        return self.spritesheets
    
    def to_json(self):
        result = super().to_json()
        result[&#34;spritesheets&#34;] = self.spritesheets
        if self.text_data is not None:
            names = self.text_data.field(Field.NAME)
            descriptions = self.text_data.field(Field.DESCRIPTION)
            result[&#34;items&#34;] = {
                id_val: {
                    &#34;id&#34;: id_val,
                    &#34;name&#34;: str(names[i]) if names is not None else &#34;&#34;,
                    &#34;description&#34;: str(descriptions[i]) if descriptions is not None else &#34;&#34;,
                    &#34;frames&#34;: {} # Not implemented
                } for i, id_val in enumerate(self.text_data.ids) if names[i] or descriptions[i]
            }

        return standardize_json(result)
    
    @classmethod
    def from_json(cls, data, ids=None):
        &#34;&#34;&#34;
        Builds an ImageThumbnails object from a JSON object. The provided object should
        have a &#34;spritesheets&#34; object that defines PIXI spritesheets, and an
        optional &#34;items&#34; key that contains text thumbnails (see TextThumbnails
        for more information about the &#34;items&#34; field).
        &#34;&#34;&#34;
        assert &#34;spritesheets&#34; in data, &#34;JSON object must contain a &#39;spritesheets&#39; field&#34;
        spritesheets = data[&#34;spritesheets&#34;]
        if ids is None:
            ids = cls._get_spritesheet_ids(spritesheets)
            
        names = None
        descriptions = None
        if &#34;items&#34; in data:
            items = data[&#34;items&#34;]
            names = [items[str(id_val)][&#34;name&#34;] for id_val in ids]
            descriptions = [items[str(id_val)].get(&#34;description&#34;, &#34;&#34;) for id_val in ids]

        return cls(None,
                   spritesheets=spritesheets,
                   ids=ids,
                   names=names,
                   descriptions=descriptions)

    @classmethod
    def _get_spritesheet_ids(cls, spritesheets):
        ids = sorted([k for sp in spritesheets.values() for k in sp[&#34;spec&#34;][&#34;frames&#34;].keys()])
        try:
            ids = [int(id_val) for id_val in ids]
        except:
            pass
        ids = sorted(ids)
        return np.array(ids)
        
    def _make_raw_images(self):
        &#34;&#34;&#34;
        Regenerates and returns the original images matrix based on self.spritesheets
        and self.ids.
        &#34;&#34;&#34;
        assert len(self.spritesheets), &#34;spritesheets is empty&#34;
        random_spec = self.spritesheets[list(self.spritesheets.keys())[0]][&#34;spec&#34;][&#34;frames&#34;]
        random_frame = random_spec[list(random_spec.keys())[0]][&#34;frame&#34;]
        cols = random_frame[&#34;w&#34;]
        rows = random_frame[&#34;h&#34;]
        
        result = np.zeros((len(self.ids), rows, cols, 4), dtype=np.uint8)
        seen_ids = set()
        for key, spritesheet in self.spritesheets.items():
            buffer = BytesIO(base64.b64decode(spritesheet[&#34;image&#34;].encode(&#39;ascii&#39;)))
            img = np.array(Image.open(buffer, formats=(&#39;PNG&#39;,)))
            
            for id_val, image_spec in spritesheet[&#34;spec&#34;][&#34;frames&#34;].items():
                frame = image_spec[&#34;frame&#34;]
                result[self._id_index[int(id_val)]] = img[frame[&#34;y&#34;]:frame[&#34;y&#34;] + frame[&#34;h&#34;],
                                                          frame[&#34;x&#34;]:frame[&#34;x&#34;] + frame[&#34;w&#34;]]
                seen_ids.add(int(id_val))
        if len(seen_ids &amp; set(self.ids.tolist())) != len(self.ids):
            print(&#34;missing ids when loading images from spritesheets:&#34;, set(self.ids.tolist()) - seen_ids)
        return result
        
    def make_spritesheets(self, images, ids, grid_dimensions=None, image_size=None):
        &#34;&#34;&#34;
        Generates a set of spritesheets from the given image data.
        
        Args:
            images: A matrix or list of images in RGBA format (e.g. shape = rows x cols x 4).
            ids: The point IDs to associate with each image.
            grid_dimensions: Number of images per spritesheet, defined as
                (images per row, images per column)
            image_size: Number of pixels per image, defined as (rows, cols)
        &#34;&#34;&#34;
        
        image_size = image_size or self._compute_image_size(images)
        grid_dimensions = grid_dimensions or self._compute_grid_dimensions(image_size)
        
        spritesheets = {}
        current_spritesheet = None

        current_image = None
        image_index = 0
        image_encoding_warning = False
        assert len(ids) == len(images), &#34;Number of IDs provided must be equal to number of images&#34;
        for i, id_val in enumerate(ids):
            if i % (grid_dimensions[0] * grid_dimensions[1]) == 0:
                if current_image is not None and current_spritesheet is not None:
                    img = Image.fromarray(current_image, &#39;RGBA&#39;)
                    with BytesIO() as output:
                        img.save(output, format=&#39;png&#39;)
                        contents = output.getvalue()
                    current_spritesheet[&#34;image&#34;] = base64.b64encode(contents).decode(&#39;ascii&#39;)
                    current_spritesheet[&#34;imageFormat&#34;] = &#34;image/png&#34;
                    image_index += 1
                    
                current_spritesheet = {
                    &#34;spec&#34;: {
                        &#34;meta&#34;: {
                            &#34;image&#34;: &#34;img_{}.png&#34;.format(image_index),
                            &#34;size&#34;: {
                                &#34;w&#34;: grid_dimensions[1] * image_size[1],
                                &#34;h&#34;: grid_dimensions[0] * image_size[0]},
                            &#34;format&#34;: &#34;RGBA8888&#34;
                        },
                        &#34;frames&#34;: {}
                    }
                }
                spritesheets[&#34;img_{}.json&#34;.format(image_index)] = current_spritesheet

                current_image = np.zeros((image_size[0] * grid_dimensions[0], image_size[1] * grid_dimensions[1], 4), dtype=np.uint8)
                
            relative_i = i % (grid_dimensions[0] * grid_dimensions[1])
            pos = (relative_i // grid_dimensions[1] * image_size[0], relative_i % grid_dimensions[1] * image_size[1])
            
            # First validate the image
            image = images[i]
            assert len(image.shape) == 3, &#34;Images must be 3-dimensional arrays (include a color channel)&#34;
            image = self._standardize_image_format(image, image.shape[:2])
            if np.max(image[:,:,:3]) &lt; 2 and not image_encoding_warning:
                print(&#34;Warning: Your image pixel values are very small. ImageThumbnails uses integer pixel values from 0-255.&#34;)
                image_encoding_warning = True
            
            # Resize the image if necessary
            if tuple(image.shape[:2]) != image_size:
                resized_image = Image.fromarray(image).resize((image_size[1], image_size[0]))
                image = np.array(resized_image)
                assert image.shape == (*image_size, 4), &#34;Incorrect resize shape! Something weird happened.&#34;
                
            # Place the image
            current_image[pos[0]:pos[0] + image_size[0], pos[1]:pos[1] + image_size[1],:] = image
            
            current_spritesheet[&#34;spec&#34;][&#34;frames&#34;][str(id_val)] = {
                &#34;frame&#34;: {
                    &#34;x&#34;: pos[1],
                    &#34;y&#34;: pos[0],
                    &#34;w&#34;: image_size[1],
                    &#34;h&#34;: image_size[0]
                },
                &#34;rotated&#34;: False,
                &#34;trimmed&#34;: False
            }

        img = Image.fromarray(current_image, &#39;RGBA&#39;)
        with BytesIO() as output:
            img.save(output, format=&#39;png&#39;)
            contents = output.getvalue()
        current_spritesheet[&#34;image&#34;] = base64.b64encode(contents).decode(&#39;ascii&#39;)
        current_spritesheet[&#34;imageFormat&#34;] = &#34;image/png&#34;
        
        self.spritesheets = spritesheets
        
    def _standardize_image_format(self, image, image_size):
        &#34;&#34;&#34;
        Converts the given image array to RGBA uint8 format.
        
        Args:
            image: An image matrix.
            image_size: The size of the image in (rows, cols).
        &#34;&#34;&#34;
        image = image.astype(np.uint8)
        result = np.zeros((image_size[0], image_size[1], 4), dtype=np.uint8)
        if image.shape[2] == 1:
            for channel in range(3):
                result[:,:,channel] = image[:,:,0]
            result[:,:,3] = 255
        elif image.shape[2] == 3:
            result[:,:,:3] = image
            result[:,:,3] = 255
        elif image.shape[2] == 4:
            result = image
        else:
            raise ValueError(&#34;Incorrect image shape, expected 3rd dimension to be 1, 3 or 4; got {} instead&#34;.format(image.shape[2]))
        return result
        
    def _compute_image_size(self, images):
        &#34;&#34;&#34;
        Computes a reasonable image size to rescale all images to.
        &#34;&#34;&#34;
        if len(images) == 0: return (0, 0)
        test_dim = images[0].shape[:2]
        if all(img.shape[:2] == test_dim for img in images):
            if max(*test_dim) &lt; MAX_IMAGE_DIM:
                # The images are already a reasonable size
                return test_dim
            
            # Resize preserving aspect ratio
            scale = min(MAX_IMAGE_DIM / test_dim[0], MAX_IMAGE_DIM / test_dim[1])
            return (int(test_dim[0] * scale), int(test_dim[1] * scale))
        else:
            # Get the average aspect ratio and choose a dimension so that no
            # image is scaled up
            aspect = np.mean([img.shape[0] / img.shape[1] for img in images])
            if aspect &lt; 1.0:
                min_dim = min(MAX_IMAGE_DIM, np.min(np.array([img.shape[1] for img in images])))
                return (int(min_dim * aspect), int(min_dim))
            else:
                min_dim = min(MAX_IMAGE_DIM, np.min(np.array([img.shape[0] for img in images])))
                return (int(min_dim), int(min_dim / aspect))
        
    def _compute_grid_dimensions(self, image_size):
        &#34;&#34;&#34;
        Computes a reasonable number of images per side of the spritesheet.
        &#34;&#34;&#34;
        return (MAX_SPRITESHEET_DIM // image_size[0], MAX_SPRITESHEET_DIM // image_size[1])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="emblaze.thumbnails.Thumbnails" href="#emblaze.thumbnails.Thumbnails">Thumbnails</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="emblaze.thumbnails.ImageThumbnails.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>data, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds an ImageThumbnails object from a JSON object. The provided object should
have a "spritesheets" object that defines PIXI spritesheets, and an
optional "items" key that contains text thumbnails (see TextThumbnails
for more information about the "items" field).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls, data, ids=None):
    &#34;&#34;&#34;
    Builds an ImageThumbnails object from a JSON object. The provided object should
    have a &#34;spritesheets&#34; object that defines PIXI spritesheets, and an
    optional &#34;items&#34; key that contains text thumbnails (see TextThumbnails
    for more information about the &#34;items&#34; field).
    &#34;&#34;&#34;
    assert &#34;spritesheets&#34; in data, &#34;JSON object must contain a &#39;spritesheets&#39; field&#34;
    spritesheets = data[&#34;spritesheets&#34;]
    if ids is None:
        ids = cls._get_spritesheet_ids(spritesheets)
        
    names = None
    descriptions = None
    if &#34;items&#34; in data:
        items = data[&#34;items&#34;]
        names = [items[str(id_val)][&#34;name&#34;] for id_val in ids]
        descriptions = [items[str(id_val)].get(&#34;description&#34;, &#34;&#34;) for id_val in ids]

    return cls(None,
               spritesheets=spritesheets,
               ids=ids,
               names=names,
               descriptions=descriptions)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="emblaze.thumbnails.ImageThumbnails.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the description(s) for the given set of IDs, or all points if
ids is not provided. Returns None if descriptions are not present.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self, ids=None):
    &#34;&#34;&#34;
    Returns the description(s) for the given set of IDs, or all points if
    ids is not provided. Returns None if descriptions are not present.
    &#34;&#34;&#34;
    if self.text_data is None: return None
    return self.text_data.field(Field.DESCRIPTION, ids=ids)</code></pre>
</details>
</dd>
<dt id="emblaze.thumbnails.ImageThumbnails.get_spritesheets"><code class="name flex">
<span>def <span class="ident">get_spritesheets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_spritesheets(self):
    return self.spritesheets</code></pre>
</details>
</dd>
<dt id="emblaze.thumbnails.ImageThumbnails.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>self, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the image(s) for the given ID or set of IDs, or all points if ids
is not provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image(self, ids=None):
    &#34;&#34;&#34;
    Returns the image(s) for the given ID or set of IDs, or all points if ids
    is not provided.
    &#34;&#34;&#34;
    if self.images is None:
        self.images = self._make_raw_images()
        
    if isinstance(ids, (list, np.ndarray, set)):
        index = [self._id_index.get(int(id_val), None) for id_val in ids]
        return [self.images[i] if i is not None else None for i in index]
    else:
        index = self._id_index.get(int(ids), None)
        if index is not None:
            return self.images[index] 
        return None</code></pre>
</details>
</dd>
<dt id="emblaze.thumbnails.ImageThumbnails.make_spritesheets"><code class="name flex">
<span>def <span class="ident">make_spritesheets</span></span>(<span>self, images, ids, grid_dimensions=None, image_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a set of spritesheets from the given image data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong></dt>
<dd>A matrix or list of images in RGBA format (e.g. shape = rows x cols x 4).</dd>
<dt><strong><code>ids</code></strong></dt>
<dd>The point IDs to associate with each image.</dd>
<dt><strong><code>grid_dimensions</code></strong></dt>
<dd>Number of images per spritesheet, defined as
(images per row, images per column)</dd>
<dt><strong><code>image_size</code></strong></dt>
<dd>Number of pixels per image, defined as (rows, cols)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_spritesheets(self, images, ids, grid_dimensions=None, image_size=None):
    &#34;&#34;&#34;
    Generates a set of spritesheets from the given image data.
    
    Args:
        images: A matrix or list of images in RGBA format (e.g. shape = rows x cols x 4).
        ids: The point IDs to associate with each image.
        grid_dimensions: Number of images per spritesheet, defined as
            (images per row, images per column)
        image_size: Number of pixels per image, defined as (rows, cols)
    &#34;&#34;&#34;
    
    image_size = image_size or self._compute_image_size(images)
    grid_dimensions = grid_dimensions or self._compute_grid_dimensions(image_size)
    
    spritesheets = {}
    current_spritesheet = None

    current_image = None
    image_index = 0
    image_encoding_warning = False
    assert len(ids) == len(images), &#34;Number of IDs provided must be equal to number of images&#34;
    for i, id_val in enumerate(ids):
        if i % (grid_dimensions[0] * grid_dimensions[1]) == 0:
            if current_image is not None and current_spritesheet is not None:
                img = Image.fromarray(current_image, &#39;RGBA&#39;)
                with BytesIO() as output:
                    img.save(output, format=&#39;png&#39;)
                    contents = output.getvalue()
                current_spritesheet[&#34;image&#34;] = base64.b64encode(contents).decode(&#39;ascii&#39;)
                current_spritesheet[&#34;imageFormat&#34;] = &#34;image/png&#34;
                image_index += 1
                
            current_spritesheet = {
                &#34;spec&#34;: {
                    &#34;meta&#34;: {
                        &#34;image&#34;: &#34;img_{}.png&#34;.format(image_index),
                        &#34;size&#34;: {
                            &#34;w&#34;: grid_dimensions[1] * image_size[1],
                            &#34;h&#34;: grid_dimensions[0] * image_size[0]},
                        &#34;format&#34;: &#34;RGBA8888&#34;
                    },
                    &#34;frames&#34;: {}
                }
            }
            spritesheets[&#34;img_{}.json&#34;.format(image_index)] = current_spritesheet

            current_image = np.zeros((image_size[0] * grid_dimensions[0], image_size[1] * grid_dimensions[1], 4), dtype=np.uint8)
            
        relative_i = i % (grid_dimensions[0] * grid_dimensions[1])
        pos = (relative_i // grid_dimensions[1] * image_size[0], relative_i % grid_dimensions[1] * image_size[1])
        
        # First validate the image
        image = images[i]
        assert len(image.shape) == 3, &#34;Images must be 3-dimensional arrays (include a color channel)&#34;
        image = self._standardize_image_format(image, image.shape[:2])
        if np.max(image[:,:,:3]) &lt; 2 and not image_encoding_warning:
            print(&#34;Warning: Your image pixel values are very small. ImageThumbnails uses integer pixel values from 0-255.&#34;)
            image_encoding_warning = True
        
        # Resize the image if necessary
        if tuple(image.shape[:2]) != image_size:
            resized_image = Image.fromarray(image).resize((image_size[1], image_size[0]))
            image = np.array(resized_image)
            assert image.shape == (*image_size, 4), &#34;Incorrect resize shape! Something weird happened.&#34;
            
        # Place the image
        current_image[pos[0]:pos[0] + image_size[0], pos[1]:pos[1] + image_size[1],:] = image
        
        current_spritesheet[&#34;spec&#34;][&#34;frames&#34;][str(id_val)] = {
            &#34;frame&#34;: {
                &#34;x&#34;: pos[1],
                &#34;y&#34;: pos[0],
                &#34;w&#34;: image_size[1],
                &#34;h&#34;: image_size[0]
            },
            &#34;rotated&#34;: False,
            &#34;trimmed&#34;: False
        }

    img = Image.fromarray(current_image, &#39;RGBA&#39;)
    with BytesIO() as output:
        img.save(output, format=&#39;png&#39;)
        contents = output.getvalue()
    current_spritesheet[&#34;image&#34;] = base64.b64encode(contents).decode(&#39;ascii&#39;)
    current_spritesheet[&#34;imageFormat&#34;] = &#34;image/png&#34;
    
    self.spritesheets = spritesheets</code></pre>
</details>
</dd>
<dt id="emblaze.thumbnails.ImageThumbnails.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>self, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name(s) for the given set of IDs, or all points if
ids is not provided. Returns None if names are not available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def name(self, ids=None):
    &#34;&#34;&#34;
    Returns the name(s) for the given set of IDs, or all points if
    ids is not provided. Returns None if names are not available.
    &#34;&#34;&#34;
    if self.text_data is None: return None
    return self.text_data.field(Field.NAME, ids=ids)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="emblaze.thumbnails.Thumbnails" href="#emblaze.thumbnails.Thumbnails">Thumbnails</a></b></code>:
<ul class="hlist">
<li><code><a title="emblaze.thumbnails.Thumbnails.get_ids" href="#emblaze.thumbnails.Thumbnails.get_ids">get_ids</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.load" href="#emblaze.thumbnails.Thumbnails.load">load</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.save" href="#emblaze.thumbnails.Thumbnails.save">save</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.to_json" href="#emblaze.thumbnails.Thumbnails.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="emblaze.thumbnails.TextThumbnails"><code class="flex name class">
<span>class <span class="ident">TextThumbnails</span></span>
<span>(</span><span>names, descriptions=None, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a set of textual thumbnails.</p>
<p>names: String values corresponding to a name for each point in the
dataset.
descriptions: Optional longer string descriptions for each point in the
dataset.
ids: If not None, a list of IDs that these thumbnails correspond to.
If not provided, the IDs are assumed to be zero-indexed ascending
integers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextThumbnails(Thumbnails):
    &#34;&#34;&#34;
    Defines a set of textual thumbnails.
    &#34;&#34;&#34;
    def __init__(self, names, descriptions=None, ids=None):
        &#34;&#34;&#34;
        names: String values corresponding to a name for each point in the
            dataset.
        descriptions: Optional longer string descriptions for each point in the
            dataset.
        ids: If not None, a list of IDs that these thumbnails correspond to.
            If not provided, the IDs are assumed to be zero-indexed ascending
            integers.
        &#34;&#34;&#34;
        super().__init__(&#34;text_descriptions&#34;)
        if ids is not None:
            assert len(names) == len(ids), &#34;Length mismatch: got {} names for {} IDs&#34;.format(len(names), len(ids))
            if descriptions is not None:
                assert len(descriptions) == len(ids), &#34;Length mismatch: got {} descriptions for {} IDs&#34;.format(len(descriptions), len(ids))
        self.data = ColumnarData({
            Field.NAME: names
        }, ids)
        if descriptions is not None:
            self.data.set_field(Field.DESCRIPTION, descriptions)

    def get_ids(self):
        return self.data.ids
    
    def name(self, ids=None):
        &#34;&#34;&#34;
        Returns the name(s) for the given set of IDs, or all points if
        ids is not provided.
        &#34;&#34;&#34;
        return self.data.field(Field.NAME, ids=ids)
    
    def description(self, ids=None):
        &#34;&#34;&#34;
        Returns the description(s) for the given set of IDs, or all points if
        ids is not provided. Returns None if descriptions are not present.
        &#34;&#34;&#34;
        return self.data.field(Field.DESCRIPTION, ids=ids)
        
    def to_json(self):
        result = super().to_json()
        names = self.data.field(Field.NAME)
        descriptions = self.data.field(Field.DESCRIPTION)
        def _make_json_item(i, id_val):
            item = {&#34;id&#34;: id_val, &#34;name&#34;: str(names[i])}
            if descriptions is not None and descriptions[i]:
                item[&#34;description&#34;] = str(descriptions[i])
            return item
        result[&#34;items&#34;] = {
            id_val: _make_json_item(i, id_val)
            for i, id_val in enumerate(self.data.ids)
            if names[i] or (descriptions is not None and descriptions[i])
        }
        return standardize_json(result)
    
    @classmethod
    def from_json(cls, data, ids=None):
        &#34;&#34;&#34;
        Builds a TextThumbnails object from a JSON object. The provided object should
        have an &#34;items&#34; key with a dictionary mapping ID values to text thumbnail
        objects, each of which must have a &#39;name&#39; and optionally &#39;description&#39; keys.
        &#34;&#34;&#34;
        assert &#34;items&#34; in data, &#34;JSON object must contain an &#39;items&#39; field&#34;
        items = data[&#34;items&#34;]
        if ids is None:
            try:
                ids = [int(id_val) for id_val in list(items.keys())]
                items = {int(k): v for k, v in items.items()}
            except:
                ids = list(items.keys())
            ids = sorted(ids)
        names = [items[id_val][&#34;name&#34;] for id_val in ids]
        descriptions = [items[id_val].get(&#34;description&#34;, &#34;&#34;) for id_val in ids]
        return cls(names, descriptions, ids)
   
    def __getitem__(self, ids):
        &#34;&#34;&#34;
        Returns text thumbnail information for the given IDs.
        &#34;&#34;&#34;
        if isinstance(ids, (list, np.ndarray, set)):
            return [self[id_val] for id_val in ids]
        else:
            result = { &#34;name&#34;: self.data.field(Field.NAME, ids) }
            if self.data.has_field(Field.DESCRIPTION):
                result[&#34;description&#34;] = self.data.field(Field.DESCRIPTION, ids)
            return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="emblaze.thumbnails.Thumbnails" href="#emblaze.thumbnails.Thumbnails">Thumbnails</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="emblaze.thumbnails.TextThumbnails.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>data, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds a TextThumbnails object from a JSON object. The provided object should
have an "items" key with a dictionary mapping ID values to text thumbnail
objects, each of which must have a 'name' and optionally 'description' keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls, data, ids=None):
    &#34;&#34;&#34;
    Builds a TextThumbnails object from a JSON object. The provided object should
    have an &#34;items&#34; key with a dictionary mapping ID values to text thumbnail
    objects, each of which must have a &#39;name&#39; and optionally &#39;description&#39; keys.
    &#34;&#34;&#34;
    assert &#34;items&#34; in data, &#34;JSON object must contain an &#39;items&#39; field&#34;
    items = data[&#34;items&#34;]
    if ids is None:
        try:
            ids = [int(id_val) for id_val in list(items.keys())]
            items = {int(k): v for k, v in items.items()}
        except:
            ids = list(items.keys())
        ids = sorted(ids)
    names = [items[id_val][&#34;name&#34;] for id_val in ids]
    descriptions = [items[id_val].get(&#34;description&#34;, &#34;&#34;) for id_val in ids]
    return cls(names, descriptions, ids)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="emblaze.thumbnails.TextThumbnails.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the description(s) for the given set of IDs, or all points if
ids is not provided. Returns None if descriptions are not present.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self, ids=None):
    &#34;&#34;&#34;
    Returns the description(s) for the given set of IDs, or all points if
    ids is not provided. Returns None if descriptions are not present.
    &#34;&#34;&#34;
    return self.data.field(Field.DESCRIPTION, ids=ids)</code></pre>
</details>
</dd>
<dt id="emblaze.thumbnails.TextThumbnails.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>self, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name(s) for the given set of IDs, or all points if
ids is not provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def name(self, ids=None):
    &#34;&#34;&#34;
    Returns the name(s) for the given set of IDs, or all points if
    ids is not provided.
    &#34;&#34;&#34;
    return self.data.field(Field.NAME, ids=ids)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="emblaze.thumbnails.Thumbnails" href="#emblaze.thumbnails.Thumbnails">Thumbnails</a></b></code>:
<ul class="hlist">
<li><code><a title="emblaze.thumbnails.Thumbnails.get_ids" href="#emblaze.thumbnails.Thumbnails.get_ids">get_ids</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.load" href="#emblaze.thumbnails.Thumbnails.load">load</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.save" href="#emblaze.thumbnails.Thumbnails.save">save</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.to_json" href="#emblaze.thumbnails.Thumbnails.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="emblaze.thumbnails.Thumbnails"><code class="flex name class">
<span>class <span class="ident">Thumbnails</span></span>
<span>(</span><span>thumbnail_format)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a set of data suitable for displaying info about points visualized
in an embedding set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Thumbnails:
    &#34;&#34;&#34;
    Defines a set of data suitable for displaying info about points visualized
    in an embedding set.
    &#34;&#34;&#34;
    def __init__(self, thumbnail_format):
        self.format = thumbnail_format

    def to_json(self):
        &#34;&#34;&#34;
        Converts this set of thumbnails into a JSON object.
        &#34;&#34;&#34;
        return {
            &#34;format&#34;: self.format
        }
        
    @classmethod
    def from_json(cls, data, ids=None):
        &#34;&#34;&#34;
        Loads this Thumbnails object from JSON. This base method chooses the
        appropriate Thumbnails subclass to initialize, based on the format
        declared in the given JSON object data. The ids parameter can be used
        to subset the point IDs that are loaded from the file.
        &#34;&#34;&#34;
        if data[&#34;format&#34;] == &#34;spritesheet_and_text&#34;:
            return CombinedThumbnails.from_json(data)
        elif data[&#34;format&#34;] == &#34;spritesheet&#34;:
            return ImageThumbnails.from_json(data, ids=ids)
        elif data[&#34;format&#34;] == &#34;text_descriptions&#34;:
            return TextThumbnails.from_json(data, ids=ids)
        raise ValueError(&#34;Unsupported data format &#39;{}&#39;&#34;.format(data[&#34;format&#34;]))
        
    def get_ids(self):
        &#34;&#34;&#34;Return a numpy array of the IDs used in this thumbnails object.&#34;&#34;&#34;
        raise NotImplementedError
    
    def save(self, file_path_or_buffer):
        &#34;&#34;&#34;
        Save this Thumbnails object to the given file path or file-like object
        (in JSON format).
        &#34;&#34;&#34;
        if isinstance(file_path_or_buffer, str):
            # File path
            with open(file_path_or_buffer, &#39;w&#39;) as file:
                json.dump(self.to_json(), file)
        else:
            # File object
            json.dump(self.to_json(), file_path_or_buffer)
            
    @classmethod
    def load(cls, file_path_or_buffer, ids=None):
        &#34;&#34;&#34;
        Load the appropriate Thumbnails subclass from the given file path or
        file-like object containing JSON data.
        &#34;&#34;&#34;
        if isinstance(file_path_or_buffer, str):
            # File path
            with open(file_path_or_buffer, &#39;r&#39;) as file:
                return cls.from_json(json.load(file), ids=ids)
        else:
            # File object
            return cls.from_json(json.load(file_path_or_buffer), ids=ids)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="emblaze.thumbnails.CombinedThumbnails" href="#emblaze.thumbnails.CombinedThumbnails">CombinedThumbnails</a></li>
<li><a title="emblaze.thumbnails.ImageThumbnails" href="#emblaze.thumbnails.ImageThumbnails">ImageThumbnails</a></li>
<li><a title="emblaze.thumbnails.TextThumbnails" href="#emblaze.thumbnails.TextThumbnails">TextThumbnails</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="emblaze.thumbnails.Thumbnails.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>data, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads this Thumbnails object from JSON. This base method chooses the
appropriate Thumbnails subclass to initialize, based on the format
declared in the given JSON object data. The ids parameter can be used
to subset the point IDs that are loaded from the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls, data, ids=None):
    &#34;&#34;&#34;
    Loads this Thumbnails object from JSON. This base method chooses the
    appropriate Thumbnails subclass to initialize, based on the format
    declared in the given JSON object data. The ids parameter can be used
    to subset the point IDs that are loaded from the file.
    &#34;&#34;&#34;
    if data[&#34;format&#34;] == &#34;spritesheet_and_text&#34;:
        return CombinedThumbnails.from_json(data)
    elif data[&#34;format&#34;] == &#34;spritesheet&#34;:
        return ImageThumbnails.from_json(data, ids=ids)
    elif data[&#34;format&#34;] == &#34;text_descriptions&#34;:
        return TextThumbnails.from_json(data, ids=ids)
    raise ValueError(&#34;Unsupported data format &#39;{}&#39;&#34;.format(data[&#34;format&#34;]))</code></pre>
</details>
</dd>
<dt id="emblaze.thumbnails.Thumbnails.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>file_path_or_buffer, ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the appropriate Thumbnails subclass from the given file path or
file-like object containing JSON data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, file_path_or_buffer, ids=None):
    &#34;&#34;&#34;
    Load the appropriate Thumbnails subclass from the given file path or
    file-like object containing JSON data.
    &#34;&#34;&#34;
    if isinstance(file_path_or_buffer, str):
        # File path
        with open(file_path_or_buffer, &#39;r&#39;) as file:
            return cls.from_json(json.load(file), ids=ids)
    else:
        # File object
        return cls.from_json(json.load(file_path_or_buffer), ids=ids)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="emblaze.thumbnails.Thumbnails.get_ids"><code class="name flex">
<span>def <span class="ident">get_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a numpy array of the IDs used in this thumbnails object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ids(self):
    &#34;&#34;&#34;Return a numpy array of the IDs used in this thumbnails object.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="emblaze.thumbnails.Thumbnails.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file_path_or_buffer)</span>
</code></dt>
<dd>
<div class="desc"><p>Save this Thumbnails object to the given file path or file-like object
(in JSON format).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, file_path_or_buffer):
    &#34;&#34;&#34;
    Save this Thumbnails object to the given file path or file-like object
    (in JSON format).
    &#34;&#34;&#34;
    if isinstance(file_path_or_buffer, str):
        # File path
        with open(file_path_or_buffer, &#39;w&#39;) as file:
            json.dump(self.to_json(), file)
    else:
        # File object
        json.dump(self.to_json(), file_path_or_buffer)</code></pre>
</details>
</dd>
<dt id="emblaze.thumbnails.Thumbnails.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts this set of thumbnails into a JSON object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self):
    &#34;&#34;&#34;
    Converts this set of thumbnails into a JSON object.
    &#34;&#34;&#34;
    return {
        &#34;format&#34;: self.format
    }</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="emblaze" href="index.html">emblaze</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="emblaze.thumbnails.CombinedThumbnails" href="#emblaze.thumbnails.CombinedThumbnails">CombinedThumbnails</a></code></h4>
<ul class="">
<li><code><a title="emblaze.thumbnails.CombinedThumbnails.description" href="#emblaze.thumbnails.CombinedThumbnails.description">description</a></code></li>
<li><code><a title="emblaze.thumbnails.CombinedThumbnails.get_spritesheets" href="#emblaze.thumbnails.CombinedThumbnails.get_spritesheets">get_spritesheets</a></code></li>
<li><code><a title="emblaze.thumbnails.CombinedThumbnails.image" href="#emblaze.thumbnails.CombinedThumbnails.image">image</a></code></li>
<li><code><a title="emblaze.thumbnails.CombinedThumbnails.name" href="#emblaze.thumbnails.CombinedThumbnails.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="emblaze.thumbnails.ImageThumbnails" href="#emblaze.thumbnails.ImageThumbnails">ImageThumbnails</a></code></h4>
<ul class="two-column">
<li><code><a title="emblaze.thumbnails.ImageThumbnails.description" href="#emblaze.thumbnails.ImageThumbnails.description">description</a></code></li>
<li><code><a title="emblaze.thumbnails.ImageThumbnails.from_json" href="#emblaze.thumbnails.ImageThumbnails.from_json">from_json</a></code></li>
<li><code><a title="emblaze.thumbnails.ImageThumbnails.get_spritesheets" href="#emblaze.thumbnails.ImageThumbnails.get_spritesheets">get_spritesheets</a></code></li>
<li><code><a title="emblaze.thumbnails.ImageThumbnails.image" href="#emblaze.thumbnails.ImageThumbnails.image">image</a></code></li>
<li><code><a title="emblaze.thumbnails.ImageThumbnails.make_spritesheets" href="#emblaze.thumbnails.ImageThumbnails.make_spritesheets">make_spritesheets</a></code></li>
<li><code><a title="emblaze.thumbnails.ImageThumbnails.name" href="#emblaze.thumbnails.ImageThumbnails.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="emblaze.thumbnails.TextThumbnails" href="#emblaze.thumbnails.TextThumbnails">TextThumbnails</a></code></h4>
<ul class="">
<li><code><a title="emblaze.thumbnails.TextThumbnails.description" href="#emblaze.thumbnails.TextThumbnails.description">description</a></code></li>
<li><code><a title="emblaze.thumbnails.TextThumbnails.from_json" href="#emblaze.thumbnails.TextThumbnails.from_json">from_json</a></code></li>
<li><code><a title="emblaze.thumbnails.TextThumbnails.name" href="#emblaze.thumbnails.TextThumbnails.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="emblaze.thumbnails.Thumbnails" href="#emblaze.thumbnails.Thumbnails">Thumbnails</a></code></h4>
<ul class="">
<li><code><a title="emblaze.thumbnails.Thumbnails.from_json" href="#emblaze.thumbnails.Thumbnails.from_json">from_json</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.get_ids" href="#emblaze.thumbnails.Thumbnails.get_ids">get_ids</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.load" href="#emblaze.thumbnails.Thumbnails.load">load</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.save" href="#emblaze.thumbnails.Thumbnails.save">save</a></code></li>
<li><code><a title="emblaze.thumbnails.Thumbnails.to_json" href="#emblaze.thumbnails.Thumbnails.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>