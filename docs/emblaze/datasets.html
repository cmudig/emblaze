<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>emblaze.datasets API documentation</title>
<meta name="description" content="Defines model classes to store embedding data in both high-dimensional and
dimensionally-reduced spaces." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="shortcut icon" type="image/x-icon" href="assets/favicon.ico"/>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>emblaze.datasets</code></h1>
</header>
<section id="section-intro">
<p>Defines model classes to store embedding data in both high-dimensional and
dimensionally-reduced spaces.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Defines model classes to store embedding data in both high-dimensional and
dimensionally-reduced spaces.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from sklearn.metrics.pairwise import cosine_distances, euclidean_distances
from sklearn.neighbors import NearestNeighbors
from sklearn.manifold import TSNE
from sklearn.decomposition import PCA
from scipy.spatial.transform import Rotation
from affine import Affine
from .utils import *
from .neighbors import Neighbors, NeighborSet
    
class ColumnarData:
    &#34;&#34;&#34;
    A data structure that contains multiple fields, each of which stores a
    numpy array of values with the same number of rows.
    &#34;&#34;&#34;
    def __init__(self, data, ids=None):
        &#34;&#34;&#34;
        Args:
            data: A dictionary where the keys are members from the Field class and
                the values are numpy or regular arrays.
            ids: An optional array of ID numbers of the same length of each
                array in the `data` argument. If not provided, the IDs are set
                to a zero-indexed range of integers.
        &#34;&#34;&#34;
        self.data = {}
        length = None
        for field, values in data.items():
            assert isinstance(field, str), &#34;Field name not string: {}&#34;.format(field)
            if length is None:
                length = len(values)
            assert length == len(values), &#34;Field &#39;{}&#39; has mismatched length (expected {}, got {})&#34;.format(field, length, len(values))
            self.data[field] = np.array(values)

        self.length = length
        self.ids = np.array(ids) if ids is not None else np.arange(length)
        self._id_index = {id: i for i, id in enumerate(self.ids)}
        
    def set_ids(self, new_ids):
        &#34;&#34;&#34;
        Gives the ColumnarData a new set of ID numbers.
        &#34;&#34;&#34;
        self.ids = np.array(new_ids) if new_ids is not None else np.arange(len(self))
        self._id_index = {id: i for i, id in enumerate(self.ids)}
        
    def copy(self):
        return ColumnarData(self.data, self.ids)
    
    def __str__(self):
        return &#34;&lt;{} with {} items, {} fields ({})&gt;&#34;.format(
            type(self).__name__,
            len(self),
            len(self.data),
            &#39;, &#39;.join(list(self.data.keys())))
    
    def __repr__(self):
        return str(self)
    
    def copy_with_fields(self, updated_fields):
        copy = self.copy()
        for field, vals in updated_fields.items():
            copy.set_field(field, vals)
        return copy

    def __len__(self):
        return self.length
    
    def __contains__(self, id_val):
        &#34;&#34;&#34;
        Returns whether the data has the given ID.
        &#34;&#34;&#34;
        return int(id_val) in self._id_index
    
    def index(self, id_vals):
        &#34;&#34;&#34;
        Returns the index(es) of the given IDs.
        &#34;&#34;&#34;
        if isinstance(id_vals, (list, np.ndarray, set)):
            return [self._id_index[int(id_val)] for id_val in id_vals]
        else:
            return self._id_index[int(id_vals)]

    def has_field(self, field):
        return field in self.data
    
    def field(self, field, ids=None):
        &#34;&#34;&#34;
        Return the contents of the given field for the given IDs.
        
        Args:
            field: The field to retrieve data from.
            ids: The IDs for which to retrieve data. If `None`, data for all
                points are returned.
            
        Returns:
            A numpy array representing the contents of the given field forr the
            given IDs. If `field` is not present in the data, returns `None`.
        &#34;&#34;&#34;
        if field not in self.data:
            return None
        if ids is not None:
            return self.data[field][self.index(ids)]
        return self.data[field]
    
    def stack_fields(self, fields, ids=None):
        return np.hstack([self.field(field, ids) for field in fields])
    
    def concat(self, other):
        &#34;&#34;&#34;
        Returns a new ColumnarData with this ColumnarData and the given one
        stacked together. Must have the same set of fields, and a disjoint set of
        IDs.
        &#34;&#34;&#34;
        assert set(self.data.keys()) == set(other.data.keys()), &#34;Cannot concatenate ColumnarData objects with different sets of fields&#34;
        assert not (set(self.ids.tolist()) &amp; set(other.ids.tolist())), &#34;Cannot concatenate ColumnarData objects with overlapping ID values&#34;
        
        return ColumnarData({k: np.concatenate([self.field(k), other.field(k)])
                             for k in self.data.keys()},
                            ids=np.concatenate([self.ids, other.ids]))
    
    def set_field(self, field, values):
        assert self.length == len(values), &#34;Field &#39;{}&#39; has mismatched length (expected {}, got {})&#34;.format(field, self.length, len(values))
        self.data[field] = np.array(values)
        
    def guess_data_type(self, field):
        &#34;&#34;&#34;
        Guesses the likely data type for the given field, returning either
        DataType.CATEGORICAL or DataType.CONTINUOUS.
        &#34;&#34;&#34;
        if field not in self.data:
            return None
        if np.issubdtype(self.data[field].dtype, np.number) and len(np.unique(self.data[field])) &gt;= 12:
            return DataType.CONTINUOUS
        return DataType.CATEGORICAL
    
class Embedding(ColumnarData):
    &#34;&#34;&#34;
    A single set of high-dimensional embeddings, which can be represented as an
    n x k 2D numpy array (n = number of points, k = dimensionality).
    &#34;&#34;&#34;
    def __init__(self, data, ids=None, label=None, metric=&#39;euclidean&#39;, n_neighbors=100, neighbors=None, parent=None):
        &#34;&#34;&#34;        
        Args:
            data: Dictionary of data fields. Must contain two fields: [`emblaze.Field.POSITION`](utils.html#emblaze.utils.Field.POSITION)
                (an n x k numpy array of coordinates), and [`emblaze.Field.COLOR`](utils.html#emblaze.utils.Field.COLOR) (a
                length-n vector of &#39;color&#39; values, which can be either continuous
                quantitative values or string labels to assign categorical colors to).
            ids: An optional array of ID numbers corresponding to each of the n points
                in data. If not provided, the point IDs will simply be assigned as
                `np.arange(n)`.
            label: A string label describing this embedding. In an `emblaze.Viewer`
                instance, this will be displayed as the name of this embedding frame
                in the thumbnail sidebar.
            metric: The distance metric used to compute distances and nearest
                neighbors. Most high-dimensional embeddings should use &#39;cosine&#39;, but
                this can be set to any distance metric supported by scikit-learn.
            n_neighbors: The number of neighbors to precompute and save when
                compute_neighbors() is called.
            neighbors: an optional Neighbors object to initialize with, if the
                nearest neighbors for the embedding have already previously been
                computed.
            parent: The parent Embedding of this Embedding object. This is
                automatically assigned when creating new Embedding objects with
                the `project()` method.
        &#34;&#34;&#34;
        super().__init__(data, ids)
        assert Field.POSITION in data, &#34;Field.POSITION is required&#34;
        assert Field.COLOR in data, &#34;Field.COLOR is required&#34;
        self.label = label
        self.metric = metric
        self.n_neighbors = n_neighbors
        self._distances = {}
        self.parent = parent # keep track of where this embedding came from
        self.neighbors = neighbors

    def copy(self):
        return Embedding(self.data,
                         self.ids,
                         label=self.label,
                         metric=self.metric,
                         n_neighbors=self.n_neighbors,
                         neighbors=self.neighbors,
                         parent=self)
    
    def copy_with_fields(self, updated_fields, clear_neighbors=False):
        copy = self.copy()
        for field, vals in updated_fields.items():
            copy.set_field(field, vals)
        if clear_neighbors:
            copy.clear_neighbors()
        return copy

    def concat(self, other):
        &#34;&#34;&#34;
        Returns a new `Embedding` with this `Embedding` and the given one
        stacked together. Must have the same set of fields, and a disjoint set of
        IDs.
        &#34;&#34;&#34;
        assert set(self.data.keys()) == set(other.data.keys()), &#34;Cannot concatenate Embedding objects with different sets of fields&#34;
        assert not (set(self.ids.tolist()) &amp; set(other.ids.tolist())), &#34;Cannot concatenate Embedding objects with overlapping ID values&#34;
        assert self.has_neighbors() == other.has_neighbors(), &#34;Either both or neither Embedding object must have a Neighbors&#34;
        
        return Embedding({k: np.concatenate([self.field(k), other.field(k)])
                          for k in self.data.keys()},
                         ids=np.concatenate([self.ids, other.ids]),
                         neighbors=self.get_neighbors().concat(other.get_neighbors()) if self.has_neighbors() else None,
                         n_neighbors=max(self.n_neighbors, other.n_neighbors),
                         label=self.label, metric=self.metric)
    
    def get_root(self):
        &#34;&#34;&#34;Returns the root parent of this embedding.&#34;&#34;&#34;
        if self.parent is None: return self
        return self.parent.get_root()
    
    def has_neighbors(self):
        return self.neighbors is not None
    
    def any_ancestor_has_neighbors(self):
        &#34;&#34;&#34;
        Returns `True` if any of the Embeddings in the parent tree have embeddings
        computed.
        &#34;&#34;&#34;
        return self.find_recent_neighbor_embedding() is not None
    
    def get_neighbors(self):
        return self.neighbors
    
    def find_ancestor_neighbor_embedding(self):
        &#34;&#34;&#34;
        Returns the `Embedding` that is furthest along this `Embedding`&#39;s parent
        tree and has a neighbor set.
        &#34;&#34;&#34;
        ancestor = None
        curr = self
        while curr is not None:
            ancestor = curr if curr.has_neighbors() else ancestor
            curr = curr.parent
        return ancestor
                
    def get_ancestor_neighbors(self):
        &#34;&#34;&#34;
        Gets the neighbor set of the `Embedding` that is furthest along this
        `Embedding`&#39;s ancestry tree and has a neighbor set.
        &#34;&#34;&#34;
        ancestor = self.find_ancestor_neighbor_embedding()
        if ancestor:
            return ancestor.get_neighbors()
    
    def find_recent_neighbor_embedding(self):
        &#34;&#34;&#34;
        Returns the `Embedding` that is closest to this `Embedding` in the parent
        tree (including this `Embedding`) that has a neighbor set.
        &#34;&#34;&#34;
        curr = self
        while curr is not None and not curr.has_neighbors():
            curr = curr.parent
        return curr
    
    def get_recent_neighbors(self):
        &#34;&#34;&#34;
        Gets the neighbor set of the `Embedding` that is closest to this `Embedding`
        in the parent tree (including itself) and that has a neighbor set.
        &#34;&#34;&#34;
        recent = self.find_recent_neighbor_embedding()
        if recent:
            return recent.get_neighbors()
    
    def dimension(self):
        &#34;&#34;&#34;Returns the dimensionality of the `Field.POSITION` field.&#34;&#34;&#34;
        return self.field(Field.POSITION).shape[1]

    def project(self, method=ProjectionTechnique.UMAP, **params):
        &#34;&#34;&#34;
        Projects this embedding space into a lower dimensionality. The method
        parameter can be a callable, which will define a dimensionality
        reduction technique that takes as input a numpy array and a list of IDs,
        as well as any keyword arguments given to the params argument of this
        method, and returns a dimension-reduced matrix. If no metric is provided
        in the keyword params, the default metric of this Embedding is used.
        
        Returns: A new `Embedding` object with the `Field.POSITION` value set to the
            result of the projection.
        &#34;&#34;&#34;
        hi_d = self.field(Field.POSITION)
        params = params or {}
        if method != ProjectionTechnique.PCA:
            params[&#34;metric&#34;] = params.get(&#34;metric&#34;, self.metric)
        
        if method == ProjectionTechnique.UMAP:
            import umap
            lo_d = umap.UMAP(**params).fit_transform(hi_d)
        elif method == ProjectionTechnique.TSNE:
            lo_d = TSNE(**params).fit_transform(hi_d)
        elif method == ProjectionTechnique.PCA:
            lo_d = PCA(**params).fit_transform(hi_d)
        elif callable(method):
            lo_d = method(hi_d, self.ids, **params)
        else:
            raise ValueError(&#34;Unrecognized projection technique &#39;{}&#39;. Please choose from the constants listed in emblaze.ProjectionTechnique, or pass a callable (see method docstring).&#34;.format(method))
        
        return self.copy_with_fields({Field.POSITION: lo_d}, clear_neighbors=True)
    
    def get_relations(self, other_emb):
        &#34;&#34;&#34;
        Computes a mapping from the IDs in this embedding to the positions
        in the other embedding (used for `AlignedUMAP`).
        &#34;&#34;&#34;
        return {self.index(id_val): other_emb.index(id_val)
                for id_val in self.ids if id_val in other_emb}
    
    def compute_neighbors(self, n_neighbors=None, metric=None):
        &#34;&#34;&#34;
        Computes and saves a set of nearest neighbors in this embedding according
        to the `Field.POSITION` values. This can be accessed after completing this
        step through the `neighbors` property.
        
        If this `Embedding` is copied or projected, it will inherit the same
        `Neighbors`.
        
        Args:
            n_neighbors: The number of neighbors to compute for each point. If
                not provided, the default `n_neighbors` for this `Embedding` is used.
            metric: The distance metric to use to compute neighbors. If
                not provided, the default `metric` for this `Embedding` is used.
        &#34;&#34;&#34;
        pos = self.field(Field.POSITION)
        # Save the metric and n_neighbors here so that they can be used to
        # re-generate the Neighbors later if needed
        self.metric = metric or self.metric
        self.n_neighbors = n_neighbors or self.n_neighbors
        self.neighbors = Neighbors.compute(pos,
                                             ids=self.ids,
                                             metric=metric or self.metric,
                                             n_neighbors=self.n_neighbors)
        
    def clear_neighbors(self):
        &#34;&#34;&#34;
        Removes the saved `Neighbors` associated with this `Embedding`. This can
        be used to determine which Neighbors is returned by `get_ancestor_neighbors()`.
        &#34;&#34;&#34;
        self.neighbors = None
        
    def clear_upstream_neighbors(self):
        &#34;&#34;&#34;
        Clears the neighbor sets for all `Embedding`s in the parent tree of this
        `Embedding` (but not this one).
        &#34;&#34;&#34;
        curr = self.parent
        while curr is not None:
            curr.clear_neighbors()
            curr = curr.parent
        
    def neighbor_distances(self, ids=None, n_neighbors=100, metric=None):
        &#34;&#34;&#34;
        Returns the list of nearest neighbors for each of the given IDs and the
        distances to each of those points. This does NOT use the `Neighbors`
        object, and is therefore based only on the locations of the points in 
        this `Embedding` (not potentially on its parents).
        &#34;&#34;&#34;
        pos = self.field(Field.POSITION, ids=ids)
        neighbor_clf = NearestNeighbors(metric=metric or self.metric).fit(self.field(Field.POSITION))
        neigh_distances, neigh_indexes = neighbor_clf.kneighbors(pos, n_neighbors=min(n_neighbors + 1, len(self)))
        return neigh_indexes[:,1:], neigh_distances[:,1:]
        
    def distances(self, ids=None, comparison_ids=None, metric=None):
        &#34;&#34;&#34;
        Returns the pairwise distances from the given IDs to each other (or all
        points to each other, if ids is None). If the metric is not provided,
        the default metric for this `Embedding` object is used.
        &#34;&#34;&#34;
        metric = metric or self.metric
        
        if ids is None:
            indexes = np.arange(len(self))
        else:
            indexes = self.index(ids)
            
        if comparison_ids is None:
            comparison_indexes = indexes
        else:
            comparison_indexes = self.index(comparison_ids)

        if len(self) &gt; 2000 and len(indexes) &lt; 2000 and len(comparison_indexes) &lt; 2000:
            # Just compute the requested distances
            if metric == &#34;euclidean&#34;:
                return euclidean_distances(self.field(Field.POSITION, indexes),
                                           self.field(Field.POSITION, comparison_indexes))
            elif metric == &#34;cosine&#34;:
                return cosine_distances(self.field(Field.POSITION, indexes),
                                        self.field(Field.POSITION, comparison_indexes))
            elif metric == &#34;precomputed&#34;:
                return self.field(Field.POSITION, indexes)
            else:
                raise NotImplementedError(&#34;Unsupported metric for distances&#34;)
        else:
            # Cache all pairwise distances
            if metric not in self._distances:
                locations = self.field(Field.POSITION)
                if metric == &#34;euclidean&#34;:
                    self._distances[metric] = euclidean_distances(locations, locations)
                elif metric == &#34;cosine&#34;:
                    self._distances[metric] = cosine_distances(locations, locations)
                elif metric == &#34;precomputed&#34;:
                    self._distances[metric] = locations
                else:
                    raise NotImplementedError(&#34;Unsupported metric for distances&#34;)
        
            return self._distances[metric][indexes,:][:,comparison_indexes]

    def within_bbox(self, bbox):
        &#34;&#34;&#34;
        Returns the list of IDs whose points are within the given bounding box.
        Only supports 2D embeddings.
        
        Args:
            bbox: The bounding box within which to retrieve points, specified as
                (xmin, xmax, ymin, ymax).
                
        Returns:
            A list of ID values corresponding to points within the bounding box.
        &#34;&#34;&#34;
        assert self.dimension() == 2, &#34;Non-2D embeddings are not supported by within_bbox()&#34;
        positions = self.field(Field.POSITION)
        return [id_val for id_val, pos in zip(self.ids, positions)
                if (pos[0] &gt;= bbox[0] and pos[0] &lt;= bbox[1] and
                    pos[1] &gt;= bbox[2] and pos[1] &lt;= bbox[3])]

    def to_json(self, compressed=True, save_neighbors=True, num_neighbors=None):
        &#34;&#34;&#34;
        Converts this embedding into a JSON object. If the embedding is 2D, saves
        coordinates as separate x and y fields; otherwise, saves coordinates as
        n x d arrays.
        
        Args:
            compressed: whether to format JSON objects using base64 strings
                instead of as human-readable float arrays
            save_neighbors: If `True`, serialize the `Neighbors` object within
                the embedding JSON.
                
        Returns:
            A JSON-serializable dictionary representing the embedding.
        &#34;&#34;&#34;
        result = {}
        indexes = self.index(self.ids)
        
        positions = self.field(Field.POSITION)
        colors = self.field(Field.COLOR)
        alphas = self.field(Field.ALPHA)
        sizes = self.field(Field.RADIUS)
        
        if compressed:
            result[&#34;_format&#34;] = &#34;compressed&#34;
            # Specify the type name that will be used to encode the point IDs.
            # This is important because the highlight array takes up the bulk
            # of the space when transferring to file/widget.
            dtype, type_name = choose_integer_type(self.ids)
            result[&#34;_idtype&#34;] = type_name
            result[&#34;_length&#34;] = len(self)
            result[&#34;ids&#34;] = encode_numerical_array(self.ids, dtype)
            
            if self.dimension() == 2:
                result[&#34;x&#34;] = encode_numerical_array(positions[:,0])
                result[&#34;y&#34;] = encode_numerical_array(positions[:,1])
            else:
                result[&#34;position&#34;] = encode_numerical_array(positions, interval=self.dimension())
                
            result[&#34;color&#34;] = encode_object_array(colors)
            if alphas is not None:
                result[&#34;alpha&#34;] = encode_numerical_array(alphas)
            if sizes is not None:
                result[&#34;r&#34;] = encode_numerical_array(sizes)
        else:
            result[&#34;points&#34;] = {}
            for id_val, index in zip(self.ids, indexes):
                obj = {}
                if self.dimension() == 2:
                    obj[&#34;x&#34;] = positions[index, 0]
                    obj[&#34;y&#34;] = positions[index, 1]
                else:
                    obj[&#34;position&#34;] = positions[index].tolist()

                obj[&#34;color&#34;] = colors[index]
                if alphas is not None:
                    obj[&#34;alpha&#34;] = alphas[index]
                if sizes is not None:
                    obj[&#34;r&#34;] = sizes[index]
                result[&#34;points&#34;][id_val] = obj

        if save_neighbors and self.has_neighbors():
            result[&#34;neighbors&#34;] = self.get_neighbors().to_json(compressed=compressed, num_neighbors=num_neighbors)
        result[&#34;metric&#34;] = self.metric
        result[&#34;n_neighbors&#34;] = self.n_neighbors
        return standardize_json(result)
    
    @classmethod
    def from_json(cls, data, label=None, parent=None):
        &#34;&#34;&#34;
        Builds an Embedding object from the given JSON object.
        
        Args:
            data: The JSON-serializable dictionary representing the embedding.
            label: A string label to use to represent this embedding.
            parent: An `Embedding` to record as the new `Embedding`&#39;s parent.
            
        Returns:
            An `Embedding` instance loaded with the specified data.
        &#34;&#34;&#34;
        mats = {}
        if data.get(&#34;_format&#34;, &#34;expanded&#34;) == &#34;compressed&#34;:
            dtype = np.dtype(data[&#34;_idtype&#34;])
            ids = decode_numerical_array(data[&#34;ids&#34;], dtype)
            
            if &#34;position&#34; in data:
                mats[Field.POSITION] = decode_numerical_array(data[&#34;position&#34;])
            else:
                mats[Field.POSITION] = np.hstack([
                    decode_numerical_array(data[&#34;x&#34;]).reshape(-1, 1),
                    decode_numerical_array(data[&#34;y&#34;]).reshape(-1, 1),
                ])

            mats[Field.COLOR] = np.array(decode_object_array(data[&#34;color&#34;]))
            if &#34;alpha&#34; in data:
                mats[Field.ALPHA] = decode_numerical_array(data[&#34;alpha&#34;])
            if &#34;r&#34; in data:
                mats[Field.RADIUS] = decode_numerical_array(data[&#34;r&#34;])
        else:
            point_data = data[&#34;points&#34;]
            try:
                ids = [int(id_val) for id_val in list(point_data.keys())]
                point_data = {int(k): v for k, v in point_data.items()}
            except:
                ids = list(point_data.keys())
            ids = sorted(ids)
            
            try:
                mats[Field.POSITION] = np.array([point_data[id_val][&#34;position&#34;] for id_val in ids])
            except KeyError:   
                mats[Field.POSITION] = np.array([[point_data[id_val][&#34;x&#34;], point_data[id_val][&#34;y&#34;]] for id_val in ids])

            mats[Field.COLOR] = np.array([point_data[id_val][&#34;color&#34;] for id_val in ids])
            if &#34;alpha&#34; in data[ids[0]]:
                mats[Field.ALPHA] = np.array([point_data[id_val][&#34;alpha&#34;] for id_val in ids])
            if &#34;r&#34; in data[ids[0]]:
                mats[Field.RADIUS] = np.array([point_data[id_val][&#34;r&#34;] for id_val in ids])

        if &#34;neighbors&#34; in data:
            neighbors = Neighbors.from_json(data[&#34;neighbors&#34;])
        else:
            neighbors = None
        metric = data.get(&#34;metric&#34;, &#34;euclidean&#34;)
        n_neighbors = data.get(&#34;n_neighbors&#34;, 100)
        return cls(mats, ids=ids, label=label, metric=metric, n_neighbors=n_neighbors, neighbors=neighbors, parent=parent)
    
    def save(self, file_path_or_buffer, **kwargs):
        &#34;&#34;&#34;
        Save this Embedding object to the given file path or file-like object
        (in JSON format). See [`Embedding.to_json`](#emblaze.datasets.Embedding.to_json)
        for acceptable keyword arguments.
        
        Args:
            file_path_or_buffer: A file path or file-like object to write the
                embedding to.
        &#34;&#34;&#34;
        if isinstance(file_path_or_buffer, str):
            # File path
            with open(file_path_or_buffer, &#39;w&#39;) as file:
                json.dump(self.to_json(**kwargs), file)
        else:
            # File object
            json.dump(self.to_json(**kwargs), file_path_or_buffer)
            
    @classmethod
    def load(cls, file_path_or_buffer, **kwargs):
        &#34;&#34;&#34;
        Load the Embedding object from the given file path or
        file-like object containing JSON data.
        
        Args:
            file_path_or_buffer: A file path or file-like object to read the
                embedding from.
        &#34;&#34;&#34;
        if isinstance(file_path_or_buffer, str):
            # File path
            with open(file_path_or_buffer, &#39;r&#39;) as file:
                return cls.from_json(json.load(file), **kwargs)
        else:
            # File object
            return cls.from_json(json.load(file_path_or_buffer), **kwargs)
        
    def align_to(self, base_frame, ids=None, return_transform=False, base_transform=None, allow_flips=True):
        &#34;&#34;&#34;
        Aligns this embedding to the base frame. The frames are aligned based
        on the keys they have in common. This requires both embeddings to have
        a dimensionality of 2.
        
        Args:
            base_frame: An Embedding to use as the base.
            frame: An Embedding to transform.
            ids: Point IDs to use for alignment (default None, which results in an
                alignment using the intersection of IDs between the two frames).
            return_transform: If true, return just the Affine object instead of the
                rotated data.
            base_transform: If not None, an Affine object representing the
                transformation to apply to the base frame before aligning.
            allow_flips: If true, test inversions as possible candidates for alignment.
            
        Returns:
            A new `Embedding` object representing the second input frame (the first
            input frame is assumed to stay the same). Or, if `return_transform` is
            `True`, returns the optimal transformation as an `Affine` object.
        &#34;&#34;&#34;
        # Determine a set of points to use for comparison
        ids_to_compare = list(ids) if ids is not None else list(set(self.ids) &amp; set(base_frame.ids))
        
        proj_subset = self.field(Field.POSITION, ids=ids_to_compare)
        assert proj_subset.shape[1] == 2, &#34;Alignment of embeddings with dimension &gt; 2 not supported&#34;
        proj_scaler = projection_standardizer(proj_subset)
        
        base_proj_subset = base_frame.field(Field.POSITION, ids=ids_to_compare)
        assert base_proj_subset.shape[1] == 2, &#34;Alignment of embeddings with dimension &gt; 2 not supported&#34;
        if base_transform is not None:
            base_proj_subset = affine_transform(base_transform, base_proj_subset)    
        base_proj_scaler = projection_standardizer(base_proj_subset)
        
        proj = np.hstack([
            affine_transform(proj_scaler, proj_subset),
            np.zeros((len(proj_subset), 1))
        ])
        base_proj = np.hstack([
            affine_transform(base_proj_scaler, base_proj_subset),
            np.zeros((len(base_proj_subset), 1))
        ])
        
        # Test flips
        min_rmsd = 1e9
        best_variant = None
        for factor in (FLIP_FACTORS if allow_flips else FLIP_FACTORS[:1]):
            opt_rotation, rmsd = Rotation.align_vectors( # pylint: disable=unbalanced-tuple-unpacking
                base_proj,
                proj * factor)
            if rmsd &lt; min_rmsd:
                min_rmsd = rmsd
                transform = ~base_proj_scaler * matrix_to_affine(opt_rotation.as_matrix()) * Affine.scale(*factor[:2]) * proj_scaler
                if return_transform:
                    best_variant = transform
                else:
                    best_variant = affine_transform(transform,
                        self.field(Field.POSITION))

        if return_transform:
            return best_variant
        return self.copy_with_fields({Field.POSITION: best_variant})

class NeighborOnlyEmbedding(Embedding):
    &#34;&#34;&#34;
    An `Embedding` object that contains no point locations, just neighbor IDs.
    &#34;&#34;&#34;
    def __init__(self, neighbors, label=None, metric=&#39;euclidean&#39;, n_neighbors=100, parent=None):
        super().__init__({Field.POSITION: np.zeros((len(neighbors), 1)),
                          Field.COLOR: np.zeros((len(neighbors), 1))},
                          neighbors.ids,
                          label=label,
                          metric=metric,
                          n_neighbors=n_neighbors,
                          neighbors=neighbors,
                          parent=parent)

    @staticmethod
    def from_embedding(emb):
        &#34;&#34;&#34;
        Creates a NeighborOnlyEmbedding that mocks an existing embedding, but
        contains only its neighbor set with no positions or color data.
        &#34;&#34;&#34;
        return NeighborOnlyEmbedding(emb.get_neighbors(),
                                     metric=emb.metric,
                                     n_neighbors=emb.n_neighbors)
    
    def copy(self):
        return NeighborOnlyEmbedding(self.neighbors,
                                    label=self.label,
                                    metric=self.metric,
                                    n_neighbors=self.n_neighbors,
                                    parent=self)
    
    def concat(self, other):
        &#34;&#34;&#34;
        Returns a new Embedding with this Embedding and the given one
        stacked together. Must have the same set of fields, and a disjoint set of
        IDs.
        &#34;&#34;&#34;
        assert isinstance(other, NeighborOnlyEmbedding), &#34;Cannot concatenate non-neighbor-only to neighbor-only Embedding&#34;
        assert not (set(self.ids.tolist()) &amp; set(other.ids.tolist())), &#34;Cannot concatenate Embedding objects with overlapping ID values&#34;
        assert self.has_neighbors() and other.has_neighbors(), &#34;Both NeighborOnlyEmbedding objects must have a Neighbors&#34;
        
        return NeighborOnlyEmbedding(self.get_neighbors().concat(other.get_neighbors()),
                                     n_neighbors=max(self.n_neighbors, other.n_neighbors),
                                     label=self.label, metric=self.metric)
    
    def project(self, method=ProjectionTechnique.UMAP, **params):
        raise NotImplementedError
    
    def compute_neighbors(self, n_neighbors=None, metric=None):
        raise NotImplementedError
        
    def clear_neighbors(self):
        self.neighbors = None
         
    def neighbor_distances(self, ids=None, n_neighbors=100, metric=None):
        raise NotImplementedError
        
    def distances(self, ids=None, comparison_ids=None, metric=None):
        raise NotImplementedError

    def within_bbox(self, bbox):
        raise NotImplementedError

    def to_json(self, compressed=True, save_neighbors=True, num_neighbors=None):
        &#34;&#34;&#34;
        Converts this embedding into a (neighbor-only) JSON object.
        
        compressed: whether to format JSON objects using base64 strings
            instead of as human-readable float arrays
        &#34;&#34;&#34;
        result = {}
        result[&#34;_format&#34;] = &#34;neighbor_only&#34;
        
        if save_neighbors and self.has_neighbors():
            result[&#34;neighbors&#34;] = self.get_neighbors().to_json(compressed=compressed, num_neighbors=num_neighbors)
        result[&#34;metric&#34;] = self.metric
        result[&#34;n_neighbors&#34;] = self.n_neighbors
        return standardize_json(result)
    
    @classmethod
    def from_json(cls, data, label=None, parent=None):
        &#34;&#34;&#34;
        Builds a neighbor-only Embedding object from the given JSON object.
        &#34;&#34;&#34;
        format = data.get(&#34;_format&#34;, &#34;expanded&#34;)
        if format != &#34;neighbor_only&#34;:
            raise ValueError(&#34;Cannot load NeighborOnlyEmbedding from JSON with format &#39;{}&#39;&#34;.format(data))
        
        assert &#34;neighbors&#34; in data
        neighbors = Neighbors.from_json(data[&#34;neighbors&#34;])
        metric = data.get(&#34;metric&#34;, &#34;euclidean&#34;)
        n_neighbors = data.get(&#34;n_neighbors&#34;, 100)
        return cls(neighbors, label=label, metric=metric, n_neighbors=n_neighbors, parent=parent)
    
    def align_to(self, base_frame, ids=None, return_transform=False, base_transform=None, allow_flips=True):
        raise NotImplementedError
    
class EmbeddingSet:
    &#34;&#34;&#34;
    A set of high-dimensional embeddings, composed of a series of `Embedding`
    objects.
    &#34;&#34;&#34;
    def __init__(self, embs, align=True):
        if align:
            if not all(emb.dimension() == 2 for emb in embs):
                print(&#34;Embeddings are not 2D, skipping alignment&#34;)
                self.embeddings = embs
            else:
                self.embeddings = [embs[0]] + [emb.align_to(embs[0]) for emb in embs[1:]]
        else:
            self.embeddings = embs

        self.ids = np.array(sorted(set.union(*(set(emb.ids.tolist()) for emb in self.embeddings))))
    
    def __str__(self):
        return &#34;&lt;{} with {} embeddings:\n\t{}&gt;&#34;.format(
            type(self).__name__,
            len(self.embeddings),
            &#34;\n\t&#34;.join(str(emb) for emb in self.embeddings)
        )
        
    def __repr__(self):
        return str(self)
        
    def __getitem__(self, idx):
        return self.embeddings[idx]

    def __len__(self):
        return len(self.embeddings)
    
    def identical(self):
        if len(self) == 0: return True
        return all(e == self[0] for e in self.embeddings)
    
    def project(self, method=ProjectionTechnique.ALIGNED_UMAP, align=True, **params):
        &#34;&#34;&#34;
        Projects the embedding set into 2D. The method parameter can be a
        callable, which will define a dimensionality reduction technique that
        takes as input a list of numpy arrays and a list of lists of IDs, as
        well as any keyword arguments given to the params argument of this
        method, and returns a list of dimension-reduced arrays.
        
        Returns: A new `EmbeddingSet` object with (optionally aligned) projected
            data.
        &#34;&#34;&#34;
        params = params or {}
        hi_ds = [emb.field(Field.POSITION) for emb in self.embeddings]
        id_sets = [emb.ids for emb in self.embeddings]
        pre_aligned = False
        if method == ProjectionTechnique.ALIGNED_UMAP:
            import umap
            lo_d_mats = umap.AlignedUMAP(**params).fit_transform(
                hi_ds,
                relations=[self.embeddings[i].get_relations(self.embeddings[i + 1])
                            for i in range(len(self.embeddings) - 1)])
            pre_aligned = True
            lo_ds = [emb.copy_with_fields({Field.POSITION: lo_d}, clear_neighbors=True)
                     for emb, lo_d in zip(self.embeddings, lo_d_mats)]
        elif callable(method):
            lo_d_mats = method(hi_ds, id_sets, **params)
            lo_ds = [emb.copy_with_fields({Field.POSITION: lo_d}, clear_neighbors=True)
                     for emb, lo_d in zip(self.embeddings, lo_d_mats)]
        else:
            lo_ds = [emb.project(method=method, **params)
                     for emb in self.embeddings]

        return EmbeddingSet(lo_ds, align=align and not pre_aligned)
    
    def compute_neighbors(self, n_neighbors=100, metric=None):
        &#34;&#34;&#34;
        Computes and saves a set of nearest neighbors in each embedding set according
        to the `Field.POSITION` values. This can be accessed after completing this
        step by inspecting the `neighbors` property of the embedding.
        &#34;&#34;&#34;
        for emb in self.embeddings:
            emb.compute_neighbors(n_neighbors=n_neighbors, metric=metric)

    def clear_neighbors(self):
        &#34;&#34;&#34;
        Removes the saved `Neighbors` associated with each `Embedding`. This can
        be used to determine which `Neighbors` is returned by `get_ancestor_neighbors()`.
        &#34;&#34;&#34;
        for emb in self.embeddings:
            emb.clear_neighbors()
                
    def get_neighbors(self):
        &#34;&#34;&#34;
        Returns a `NeighborSet` object corresponding to the nearest neighbors
        of each embedding in the `EmbeddingSet`.
        &#34;&#34;&#34;
        return NeighborSet([emb.get_neighbors() for emb in self.embeddings])

    def get_recent_neighbors(self):
        &#34;&#34;&#34;
        Returns a `NeighborSet` containing ancestor `Neighbors` for each embedding in the
        `EmbeddingSet`. This corresponds to the lowest-level `Embedding` in each
        `Embedding`&#39;s parent tree (including the `Embedding` itself) that has a
        neighbor set associated with it.
        &#34;&#34;&#34;
        return NeighborSet([emb.get_recent_neighbors() for emb in self.embeddings])
                
    def get_ancestor_neighbors(self):
        &#34;&#34;&#34;
        Returns a `NeighborSet` containing ancestor `Neighbors` for each embedding in the
        `EmbeddingSet`. This corresponds to the highest-level `Embedding` in each
        `Embedding`&#39;s parent tree that has a neighbor set associated with it.
        &#34;&#34;&#34;
        return NeighborSet([emb.get_ancestor_neighbors() for emb in self.embeddings])
            
    def to_json(self, compressed=True, save_neighbors=True, num_neighbors=None):
        &#34;&#34;&#34;
        Converts this set of embeddings into a JSON object.
        
        Args:
            compressed: whether to format `Embedding` JSON objects using base64 strings
                instead of as human-readable float arrays
            save_neighbors: If `True`, save the `Neighbors` into the &#34;neighbors&#34; key
                of each individual embedding
            num_neighbors: number of neighbors to write for each point (can considerably
                save memory)
        &#34;&#34;&#34;
        return {
            &#34;data&#34;: [emb.to_json(compressed=compressed,
                                 save_neighbors=save_neighbors,
                                 num_neighbors=num_neighbors) for emb in self.embeddings],
            &#34;frameLabels&#34;: [emb.label or &#34;Frame {}&#34;.format(i) for i, emb in enumerate(self.embeddings)]
        }

    @classmethod
    def from_json(cls, data, parents=None):
        &#34;&#34;&#34;
        Builds an `EmbeddingSet` from a JSON object.
        
        Args:
            data: A JSON-serializable dictionary representing the `EmbeddingSet`,
                such as that generated by [`EmbeddingSet.to_json`](#emblaze.datasets.EmbeddingSet.to_json).
            parents: An optional list of `Embedding` objects to use as parents
                for each of the created embeddings.
                
        Returns:
            An initialized `EmbeddingSet` object.
        &#34;&#34;&#34;
        assert &#34;data&#34; in data, &#34;JSON object must contain a &#39;data&#39; field&#34;
        embs = data[&#34;data&#34;]
        labels = data.get(&#34;frameLabels&#34;, [None for _ in range(len(embs))])
        if parents is None:
            parents = [None for _ in range(len(embs))]
        elif len(parents) == 1:
            parents = [parents[0] for _ in range(len(embs))]
        embs = [Embedding.from_json(frame, label=label, parent=parent) for frame, label, parent in zip(embs, labels, parents)]
        return cls(embs, align=False)
    
    def save(self, file_path_or_buffer, **kwargs):
        &#34;&#34;&#34;
        Save this EmbeddingSet object to the given file path or file-like object
        (in JSON format). See [`EmbeddingSet.to_json`](#emblaze.datasets.EmbeddingSet.to_json)
        for acceptable keyword arguments.
        
        Args:
            file_path_or_buffer: A file path or file-like object to write the
                embedding to.
        &#34;&#34;&#34;
        if isinstance(file_path_or_buffer, str):
            # File path
            with open(file_path_or_buffer, &#39;w&#39;) as file:
                json.dump(self.to_json(**kwargs), file)
        else:
            # File object
            json.dump(self.to_json(**kwargs), file_path_or_buffer)
            
    @classmethod
    def load(cls, file_path_or_buffer, **kwargs):
        &#34;&#34;&#34;
        Load the EmbeddingSet object from the given file path or
        file-like object containing JSON data.

        Args:
            file_path_or_buffer: A file path or file-like object to read the
                embedding from.
        &#34;&#34;&#34;
        if isinstance(file_path_or_buffer, str):
            # File path
            with open(file_path_or_buffer, &#39;r&#39;) as file:
                return cls.from_json(json.load(file), **kwargs)
        else:
            # File object
            return cls.from_json(json.load(file_path_or_buffer), **kwargs)
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="emblaze.datasets.Embedding"><code class="flex name class">
<span>class <span class="ident">Embedding</span></span>
<span>(</span><span>data, ids=None, label=None, metric='euclidean', n_neighbors=100, neighbors=None, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A single set of high-dimensional embeddings, which can be represented as an
n x k 2D numpy array (n = number of points, k = dimensionality).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Dictionary of data fields. Must contain two fields: <a href="utils.html#emblaze.utils.Field.POSITION"><code>emblaze.Field.POSITION</code></a>
(an n x k numpy array of coordinates), and <a href="utils.html#emblaze.utils.Field.COLOR"><code>emblaze.Field.COLOR</code></a> (a
length-n vector of 'color' values, which can be either continuous
quantitative values or string labels to assign categorical colors to).</dd>
<dt><strong><code>ids</code></strong></dt>
<dd>An optional array of ID numbers corresponding to each of the n points
in data. If not provided, the point IDs will simply be assigned as
<code>np.arange(n)</code>.</dd>
<dt><strong><code>label</code></strong></dt>
<dd>A string label describing this embedding. In an <code>emblaze.Viewer</code>
instance, this will be displayed as the name of this embedding frame
in the thumbnail sidebar.</dd>
<dt><strong><code>metric</code></strong></dt>
<dd>The distance metric used to compute distances and nearest
neighbors. Most high-dimensional embeddings should use 'cosine', but
this can be set to any distance metric supported by scikit-learn.</dd>
<dt><strong><code>n_neighbors</code></strong></dt>
<dd>The number of neighbors to precompute and save when
compute_neighbors() is called.</dd>
<dt><strong><code>neighbors</code></strong></dt>
<dd>an optional Neighbors object to initialize with, if the
nearest neighbors for the embedding have already previously been
computed.</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>The parent Embedding of this Embedding object. This is
automatically assigned when creating new Embedding objects with
the <code>project()</code> method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Embedding(ColumnarData):
    &#34;&#34;&#34;
    A single set of high-dimensional embeddings, which can be represented as an
    n x k 2D numpy array (n = number of points, k = dimensionality).
    &#34;&#34;&#34;
    def __init__(self, data, ids=None, label=None, metric=&#39;euclidean&#39;, n_neighbors=100, neighbors=None, parent=None):
        &#34;&#34;&#34;        
        Args:
            data: Dictionary of data fields. Must contain two fields: [`emblaze.Field.POSITION`](utils.html#emblaze.utils.Field.POSITION)
                (an n x k numpy array of coordinates), and [`emblaze.Field.COLOR`](utils.html#emblaze.utils.Field.COLOR) (a
                length-n vector of &#39;color&#39; values, which can be either continuous
                quantitative values or string labels to assign categorical colors to).
            ids: An optional array of ID numbers corresponding to each of the n points
                in data. If not provided, the point IDs will simply be assigned as
                `np.arange(n)`.
            label: A string label describing this embedding. In an `emblaze.Viewer`
                instance, this will be displayed as the name of this embedding frame
                in the thumbnail sidebar.
            metric: The distance metric used to compute distances and nearest
                neighbors. Most high-dimensional embeddings should use &#39;cosine&#39;, but
                this can be set to any distance metric supported by scikit-learn.
            n_neighbors: The number of neighbors to precompute and save when
                compute_neighbors() is called.
            neighbors: an optional Neighbors object to initialize with, if the
                nearest neighbors for the embedding have already previously been
                computed.
            parent: The parent Embedding of this Embedding object. This is
                automatically assigned when creating new Embedding objects with
                the `project()` method.
        &#34;&#34;&#34;
        super().__init__(data, ids)
        assert Field.POSITION in data, &#34;Field.POSITION is required&#34;
        assert Field.COLOR in data, &#34;Field.COLOR is required&#34;
        self.label = label
        self.metric = metric
        self.n_neighbors = n_neighbors
        self._distances = {}
        self.parent = parent # keep track of where this embedding came from
        self.neighbors = neighbors

    def copy(self):
        return Embedding(self.data,
                         self.ids,
                         label=self.label,
                         metric=self.metric,
                         n_neighbors=self.n_neighbors,
                         neighbors=self.neighbors,
                         parent=self)
    
    def copy_with_fields(self, updated_fields, clear_neighbors=False):
        copy = self.copy()
        for field, vals in updated_fields.items():
            copy.set_field(field, vals)
        if clear_neighbors:
            copy.clear_neighbors()
        return copy

    def concat(self, other):
        &#34;&#34;&#34;
        Returns a new `Embedding` with this `Embedding` and the given one
        stacked together. Must have the same set of fields, and a disjoint set of
        IDs.
        &#34;&#34;&#34;
        assert set(self.data.keys()) == set(other.data.keys()), &#34;Cannot concatenate Embedding objects with different sets of fields&#34;
        assert not (set(self.ids.tolist()) &amp; set(other.ids.tolist())), &#34;Cannot concatenate Embedding objects with overlapping ID values&#34;
        assert self.has_neighbors() == other.has_neighbors(), &#34;Either both or neither Embedding object must have a Neighbors&#34;
        
        return Embedding({k: np.concatenate([self.field(k), other.field(k)])
                          for k in self.data.keys()},
                         ids=np.concatenate([self.ids, other.ids]),
                         neighbors=self.get_neighbors().concat(other.get_neighbors()) if self.has_neighbors() else None,
                         n_neighbors=max(self.n_neighbors, other.n_neighbors),
                         label=self.label, metric=self.metric)
    
    def get_root(self):
        &#34;&#34;&#34;Returns the root parent of this embedding.&#34;&#34;&#34;
        if self.parent is None: return self
        return self.parent.get_root()
    
    def has_neighbors(self):
        return self.neighbors is not None
    
    def any_ancestor_has_neighbors(self):
        &#34;&#34;&#34;
        Returns `True` if any of the Embeddings in the parent tree have embeddings
        computed.
        &#34;&#34;&#34;
        return self.find_recent_neighbor_embedding() is not None
    
    def get_neighbors(self):
        return self.neighbors
    
    def find_ancestor_neighbor_embedding(self):
        &#34;&#34;&#34;
        Returns the `Embedding` that is furthest along this `Embedding`&#39;s parent
        tree and has a neighbor set.
        &#34;&#34;&#34;
        ancestor = None
        curr = self
        while curr is not None:
            ancestor = curr if curr.has_neighbors() else ancestor
            curr = curr.parent
        return ancestor
                
    def get_ancestor_neighbors(self):
        &#34;&#34;&#34;
        Gets the neighbor set of the `Embedding` that is furthest along this
        `Embedding`&#39;s ancestry tree and has a neighbor set.
        &#34;&#34;&#34;
        ancestor = self.find_ancestor_neighbor_embedding()
        if ancestor:
            return ancestor.get_neighbors()
    
    def find_recent_neighbor_embedding(self):
        &#34;&#34;&#34;
        Returns the `Embedding` that is closest to this `Embedding` in the parent
        tree (including this `Embedding`) that has a neighbor set.
        &#34;&#34;&#34;
        curr = self
        while curr is not None and not curr.has_neighbors():
            curr = curr.parent
        return curr
    
    def get_recent_neighbors(self):
        &#34;&#34;&#34;
        Gets the neighbor set of the `Embedding` that is closest to this `Embedding`
        in the parent tree (including itself) and that has a neighbor set.
        &#34;&#34;&#34;
        recent = self.find_recent_neighbor_embedding()
        if recent:
            return recent.get_neighbors()
    
    def dimension(self):
        &#34;&#34;&#34;Returns the dimensionality of the `Field.POSITION` field.&#34;&#34;&#34;
        return self.field(Field.POSITION).shape[1]

    def project(self, method=ProjectionTechnique.UMAP, **params):
        &#34;&#34;&#34;
        Projects this embedding space into a lower dimensionality. The method
        parameter can be a callable, which will define a dimensionality
        reduction technique that takes as input a numpy array and a list of IDs,
        as well as any keyword arguments given to the params argument of this
        method, and returns a dimension-reduced matrix. If no metric is provided
        in the keyword params, the default metric of this Embedding is used.
        
        Returns: A new `Embedding` object with the `Field.POSITION` value set to the
            result of the projection.
        &#34;&#34;&#34;
        hi_d = self.field(Field.POSITION)
        params = params or {}
        if method != ProjectionTechnique.PCA:
            params[&#34;metric&#34;] = params.get(&#34;metric&#34;, self.metric)
        
        if method == ProjectionTechnique.UMAP:
            import umap
            lo_d = umap.UMAP(**params).fit_transform(hi_d)
        elif method == ProjectionTechnique.TSNE:
            lo_d = TSNE(**params).fit_transform(hi_d)
        elif method == ProjectionTechnique.PCA:
            lo_d = PCA(**params).fit_transform(hi_d)
        elif callable(method):
            lo_d = method(hi_d, self.ids, **params)
        else:
            raise ValueError(&#34;Unrecognized projection technique &#39;{}&#39;. Please choose from the constants listed in emblaze.ProjectionTechnique, or pass a callable (see method docstring).&#34;.format(method))
        
        return self.copy_with_fields({Field.POSITION: lo_d}, clear_neighbors=True)
    
    def get_relations(self, other_emb):
        &#34;&#34;&#34;
        Computes a mapping from the IDs in this embedding to the positions
        in the other embedding (used for `AlignedUMAP`).
        &#34;&#34;&#34;
        return {self.index(id_val): other_emb.index(id_val)
                for id_val in self.ids if id_val in other_emb}
    
    def compute_neighbors(self, n_neighbors=None, metric=None):
        &#34;&#34;&#34;
        Computes and saves a set of nearest neighbors in this embedding according
        to the `Field.POSITION` values. This can be accessed after completing this
        step through the `neighbors` property.
        
        If this `Embedding` is copied or projected, it will inherit the same
        `Neighbors`.
        
        Args:
            n_neighbors: The number of neighbors to compute for each point. If
                not provided, the default `n_neighbors` for this `Embedding` is used.
            metric: The distance metric to use to compute neighbors. If
                not provided, the default `metric` for this `Embedding` is used.
        &#34;&#34;&#34;
        pos = self.field(Field.POSITION)
        # Save the metric and n_neighbors here so that they can be used to
        # re-generate the Neighbors later if needed
        self.metric = metric or self.metric
        self.n_neighbors = n_neighbors or self.n_neighbors
        self.neighbors = Neighbors.compute(pos,
                                             ids=self.ids,
                                             metric=metric or self.metric,
                                             n_neighbors=self.n_neighbors)
        
    def clear_neighbors(self):
        &#34;&#34;&#34;
        Removes the saved `Neighbors` associated with this `Embedding`. This can
        be used to determine which Neighbors is returned by `get_ancestor_neighbors()`.
        &#34;&#34;&#34;
        self.neighbors = None
        
    def clear_upstream_neighbors(self):
        &#34;&#34;&#34;
        Clears the neighbor sets for all `Embedding`s in the parent tree of this
        `Embedding` (but not this one).
        &#34;&#34;&#34;
        curr = self.parent
        while curr is not None:
            curr.clear_neighbors()
            curr = curr.parent
        
    def neighbor_distances(self, ids=None, n_neighbors=100, metric=None):
        &#34;&#34;&#34;
        Returns the list of nearest neighbors for each of the given IDs and the
        distances to each of those points. This does NOT use the `Neighbors`
        object, and is therefore based only on the locations of the points in 
        this `Embedding` (not potentially on its parents).
        &#34;&#34;&#34;
        pos = self.field(Field.POSITION, ids=ids)
        neighbor_clf = NearestNeighbors(metric=metric or self.metric).fit(self.field(Field.POSITION))
        neigh_distances, neigh_indexes = neighbor_clf.kneighbors(pos, n_neighbors=min(n_neighbors + 1, len(self)))
        return neigh_indexes[:,1:], neigh_distances[:,1:]
        
    def distances(self, ids=None, comparison_ids=None, metric=None):
        &#34;&#34;&#34;
        Returns the pairwise distances from the given IDs to each other (or all
        points to each other, if ids is None). If the metric is not provided,
        the default metric for this `Embedding` object is used.
        &#34;&#34;&#34;
        metric = metric or self.metric
        
        if ids is None:
            indexes = np.arange(len(self))
        else:
            indexes = self.index(ids)
            
        if comparison_ids is None:
            comparison_indexes = indexes
        else:
            comparison_indexes = self.index(comparison_ids)

        if len(self) &gt; 2000 and len(indexes) &lt; 2000 and len(comparison_indexes) &lt; 2000:
            # Just compute the requested distances
            if metric == &#34;euclidean&#34;:
                return euclidean_distances(self.field(Field.POSITION, indexes),
                                           self.field(Field.POSITION, comparison_indexes))
            elif metric == &#34;cosine&#34;:
                return cosine_distances(self.field(Field.POSITION, indexes),
                                        self.field(Field.POSITION, comparison_indexes))
            elif metric == &#34;precomputed&#34;:
                return self.field(Field.POSITION, indexes)
            else:
                raise NotImplementedError(&#34;Unsupported metric for distances&#34;)
        else:
            # Cache all pairwise distances
            if metric not in self._distances:
                locations = self.field(Field.POSITION)
                if metric == &#34;euclidean&#34;:
                    self._distances[metric] = euclidean_distances(locations, locations)
                elif metric == &#34;cosine&#34;:
                    self._distances[metric] = cosine_distances(locations, locations)
                elif metric == &#34;precomputed&#34;:
                    self._distances[metric] = locations
                else:
                    raise NotImplementedError(&#34;Unsupported metric for distances&#34;)
        
            return self._distances[metric][indexes,:][:,comparison_indexes]

    def within_bbox(self, bbox):
        &#34;&#34;&#34;
        Returns the list of IDs whose points are within the given bounding box.
        Only supports 2D embeddings.
        
        Args:
            bbox: The bounding box within which to retrieve points, specified as
                (xmin, xmax, ymin, ymax).
                
        Returns:
            A list of ID values corresponding to points within the bounding box.
        &#34;&#34;&#34;
        assert self.dimension() == 2, &#34;Non-2D embeddings are not supported by within_bbox()&#34;
        positions = self.field(Field.POSITION)
        return [id_val for id_val, pos in zip(self.ids, positions)
                if (pos[0] &gt;= bbox[0] and pos[0] &lt;= bbox[1] and
                    pos[1] &gt;= bbox[2] and pos[1] &lt;= bbox[3])]

    def to_json(self, compressed=True, save_neighbors=True, num_neighbors=None):
        &#34;&#34;&#34;
        Converts this embedding into a JSON object. If the embedding is 2D, saves
        coordinates as separate x and y fields; otherwise, saves coordinates as
        n x d arrays.
        
        Args:
            compressed: whether to format JSON objects using base64 strings
                instead of as human-readable float arrays
            save_neighbors: If `True`, serialize the `Neighbors` object within
                the embedding JSON.
                
        Returns:
            A JSON-serializable dictionary representing the embedding.
        &#34;&#34;&#34;
        result = {}
        indexes = self.index(self.ids)
        
        positions = self.field(Field.POSITION)
        colors = self.field(Field.COLOR)
        alphas = self.field(Field.ALPHA)
        sizes = self.field(Field.RADIUS)
        
        if compressed:
            result[&#34;_format&#34;] = &#34;compressed&#34;
            # Specify the type name that will be used to encode the point IDs.
            # This is important because the highlight array takes up the bulk
            # of the space when transferring to file/widget.
            dtype, type_name = choose_integer_type(self.ids)
            result[&#34;_idtype&#34;] = type_name
            result[&#34;_length&#34;] = len(self)
            result[&#34;ids&#34;] = encode_numerical_array(self.ids, dtype)
            
            if self.dimension() == 2:
                result[&#34;x&#34;] = encode_numerical_array(positions[:,0])
                result[&#34;y&#34;] = encode_numerical_array(positions[:,1])
            else:
                result[&#34;position&#34;] = encode_numerical_array(positions, interval=self.dimension())
                
            result[&#34;color&#34;] = encode_object_array(colors)
            if alphas is not None:
                result[&#34;alpha&#34;] = encode_numerical_array(alphas)
            if sizes is not None:
                result[&#34;r&#34;] = encode_numerical_array(sizes)
        else:
            result[&#34;points&#34;] = {}
            for id_val, index in zip(self.ids, indexes):
                obj = {}
                if self.dimension() == 2:
                    obj[&#34;x&#34;] = positions[index, 0]
                    obj[&#34;y&#34;] = positions[index, 1]
                else:
                    obj[&#34;position&#34;] = positions[index].tolist()

                obj[&#34;color&#34;] = colors[index]
                if alphas is not None:
                    obj[&#34;alpha&#34;] = alphas[index]
                if sizes is not None:
                    obj[&#34;r&#34;] = sizes[index]
                result[&#34;points&#34;][id_val] = obj

        if save_neighbors and self.has_neighbors():
            result[&#34;neighbors&#34;] = self.get_neighbors().to_json(compressed=compressed, num_neighbors=num_neighbors)
        result[&#34;metric&#34;] = self.metric
        result[&#34;n_neighbors&#34;] = self.n_neighbors
        return standardize_json(result)
    
    @classmethod
    def from_json(cls, data, label=None, parent=None):
        &#34;&#34;&#34;
        Builds an Embedding object from the given JSON object.
        
        Args:
            data: The JSON-serializable dictionary representing the embedding.
            label: A string label to use to represent this embedding.
            parent: An `Embedding` to record as the new `Embedding`&#39;s parent.
            
        Returns:
            An `Embedding` instance loaded with the specified data.
        &#34;&#34;&#34;
        mats = {}
        if data.get(&#34;_format&#34;, &#34;expanded&#34;) == &#34;compressed&#34;:
            dtype = np.dtype(data[&#34;_idtype&#34;])
            ids = decode_numerical_array(data[&#34;ids&#34;], dtype)
            
            if &#34;position&#34; in data:
                mats[Field.POSITION] = decode_numerical_array(data[&#34;position&#34;])
            else:
                mats[Field.POSITION] = np.hstack([
                    decode_numerical_array(data[&#34;x&#34;]).reshape(-1, 1),
                    decode_numerical_array(data[&#34;y&#34;]).reshape(-1, 1),
                ])

            mats[Field.COLOR] = np.array(decode_object_array(data[&#34;color&#34;]))
            if &#34;alpha&#34; in data:
                mats[Field.ALPHA] = decode_numerical_array(data[&#34;alpha&#34;])
            if &#34;r&#34; in data:
                mats[Field.RADIUS] = decode_numerical_array(data[&#34;r&#34;])
        else:
            point_data = data[&#34;points&#34;]
            try:
                ids = [int(id_val) for id_val in list(point_data.keys())]
                point_data = {int(k): v for k, v in point_data.items()}
            except:
                ids = list(point_data.keys())
            ids = sorted(ids)
            
            try:
                mats[Field.POSITION] = np.array([point_data[id_val][&#34;position&#34;] for id_val in ids])
            except KeyError:   
                mats[Field.POSITION] = np.array([[point_data[id_val][&#34;x&#34;], point_data[id_val][&#34;y&#34;]] for id_val in ids])

            mats[Field.COLOR] = np.array([point_data[id_val][&#34;color&#34;] for id_val in ids])
            if &#34;alpha&#34; in data[ids[0]]:
                mats[Field.ALPHA] = np.array([point_data[id_val][&#34;alpha&#34;] for id_val in ids])
            if &#34;r&#34; in data[ids[0]]:
                mats[Field.RADIUS] = np.array([point_data[id_val][&#34;r&#34;] for id_val in ids])

        if &#34;neighbors&#34; in data:
            neighbors = Neighbors.from_json(data[&#34;neighbors&#34;])
        else:
            neighbors = None
        metric = data.get(&#34;metric&#34;, &#34;euclidean&#34;)
        n_neighbors = data.get(&#34;n_neighbors&#34;, 100)
        return cls(mats, ids=ids, label=label, metric=metric, n_neighbors=n_neighbors, neighbors=neighbors, parent=parent)
    
    def save(self, file_path_or_buffer, **kwargs):
        &#34;&#34;&#34;
        Save this Embedding object to the given file path or file-like object
        (in JSON format). See [`Embedding.to_json`](#emblaze.datasets.Embedding.to_json)
        for acceptable keyword arguments.
        
        Args:
            file_path_or_buffer: A file path or file-like object to write the
                embedding to.
        &#34;&#34;&#34;
        if isinstance(file_path_or_buffer, str):
            # File path
            with open(file_path_or_buffer, &#39;w&#39;) as file:
                json.dump(self.to_json(**kwargs), file)
        else:
            # File object
            json.dump(self.to_json(**kwargs), file_path_or_buffer)
            
    @classmethod
    def load(cls, file_path_or_buffer, **kwargs):
        &#34;&#34;&#34;
        Load the Embedding object from the given file path or
        file-like object containing JSON data.
        
        Args:
            file_path_or_buffer: A file path or file-like object to read the
                embedding from.
        &#34;&#34;&#34;
        if isinstance(file_path_or_buffer, str):
            # File path
            with open(file_path_or_buffer, &#39;r&#39;) as file:
                return cls.from_json(json.load(file), **kwargs)
        else:
            # File object
            return cls.from_json(json.load(file_path_or_buffer), **kwargs)
        
    def align_to(self, base_frame, ids=None, return_transform=False, base_transform=None, allow_flips=True):
        &#34;&#34;&#34;
        Aligns this embedding to the base frame. The frames are aligned based
        on the keys they have in common. This requires both embeddings to have
        a dimensionality of 2.
        
        Args:
            base_frame: An Embedding to use as the base.
            frame: An Embedding to transform.
            ids: Point IDs to use for alignment (default None, which results in an
                alignment using the intersection of IDs between the two frames).
            return_transform: If true, return just the Affine object instead of the
                rotated data.
            base_transform: If not None, an Affine object representing the
                transformation to apply to the base frame before aligning.
            allow_flips: If true, test inversions as possible candidates for alignment.
            
        Returns:
            A new `Embedding` object representing the second input frame (the first
            input frame is assumed to stay the same). Or, if `return_transform` is
            `True`, returns the optimal transformation as an `Affine` object.
        &#34;&#34;&#34;
        # Determine a set of points to use for comparison
        ids_to_compare = list(ids) if ids is not None else list(set(self.ids) &amp; set(base_frame.ids))
        
        proj_subset = self.field(Field.POSITION, ids=ids_to_compare)
        assert proj_subset.shape[1] == 2, &#34;Alignment of embeddings with dimension &gt; 2 not supported&#34;
        proj_scaler = projection_standardizer(proj_subset)
        
        base_proj_subset = base_frame.field(Field.POSITION, ids=ids_to_compare)
        assert base_proj_subset.shape[1] == 2, &#34;Alignment of embeddings with dimension &gt; 2 not supported&#34;
        if base_transform is not None:
            base_proj_subset = affine_transform(base_transform, base_proj_subset)    
        base_proj_scaler = projection_standardizer(base_proj_subset)
        
        proj = np.hstack([
            affine_transform(proj_scaler, proj_subset),
            np.zeros((len(proj_subset), 1))
        ])
        base_proj = np.hstack([
            affine_transform(base_proj_scaler, base_proj_subset),
            np.zeros((len(base_proj_subset), 1))
        ])
        
        # Test flips
        min_rmsd = 1e9
        best_variant = None
        for factor in (FLIP_FACTORS if allow_flips else FLIP_FACTORS[:1]):
            opt_rotation, rmsd = Rotation.align_vectors( # pylint: disable=unbalanced-tuple-unpacking
                base_proj,
                proj * factor)
            if rmsd &lt; min_rmsd:
                min_rmsd = rmsd
                transform = ~base_proj_scaler * matrix_to_affine(opt_rotation.as_matrix()) * Affine.scale(*factor[:2]) * proj_scaler
                if return_transform:
                    best_variant = transform
                else:
                    best_variant = affine_transform(transform,
                        self.field(Field.POSITION))

        if return_transform:
            return best_variant
        return self.copy_with_fields({Field.POSITION: best_variant})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>emblaze.datasets.ColumnarData</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>emblaze.datasets.NeighborOnlyEmbedding</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="emblaze.datasets.Embedding.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>data, label=None, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds an Embedding object from the given JSON object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>The JSON-serializable dictionary representing the embedding.</dd>
<dt><strong><code>label</code></strong></dt>
<dd>A string label to use to represent this embedding.</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>An <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> to record as the new <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code>'s parent.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> instance loaded with the specified data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls, data, label=None, parent=None):
    &#34;&#34;&#34;
    Builds an Embedding object from the given JSON object.
    
    Args:
        data: The JSON-serializable dictionary representing the embedding.
        label: A string label to use to represent this embedding.
        parent: An `Embedding` to record as the new `Embedding`&#39;s parent.
        
    Returns:
        An `Embedding` instance loaded with the specified data.
    &#34;&#34;&#34;
    mats = {}
    if data.get(&#34;_format&#34;, &#34;expanded&#34;) == &#34;compressed&#34;:
        dtype = np.dtype(data[&#34;_idtype&#34;])
        ids = decode_numerical_array(data[&#34;ids&#34;], dtype)
        
        if &#34;position&#34; in data:
            mats[Field.POSITION] = decode_numerical_array(data[&#34;position&#34;])
        else:
            mats[Field.POSITION] = np.hstack([
                decode_numerical_array(data[&#34;x&#34;]).reshape(-1, 1),
                decode_numerical_array(data[&#34;y&#34;]).reshape(-1, 1),
            ])

        mats[Field.COLOR] = np.array(decode_object_array(data[&#34;color&#34;]))
        if &#34;alpha&#34; in data:
            mats[Field.ALPHA] = decode_numerical_array(data[&#34;alpha&#34;])
        if &#34;r&#34; in data:
            mats[Field.RADIUS] = decode_numerical_array(data[&#34;r&#34;])
    else:
        point_data = data[&#34;points&#34;]
        try:
            ids = [int(id_val) for id_val in list(point_data.keys())]
            point_data = {int(k): v for k, v in point_data.items()}
        except:
            ids = list(point_data.keys())
        ids = sorted(ids)
        
        try:
            mats[Field.POSITION] = np.array([point_data[id_val][&#34;position&#34;] for id_val in ids])
        except KeyError:   
            mats[Field.POSITION] = np.array([[point_data[id_val][&#34;x&#34;], point_data[id_val][&#34;y&#34;]] for id_val in ids])

        mats[Field.COLOR] = np.array([point_data[id_val][&#34;color&#34;] for id_val in ids])
        if &#34;alpha&#34; in data[ids[0]]:
            mats[Field.ALPHA] = np.array([point_data[id_val][&#34;alpha&#34;] for id_val in ids])
        if &#34;r&#34; in data[ids[0]]:
            mats[Field.RADIUS] = np.array([point_data[id_val][&#34;r&#34;] for id_val in ids])

    if &#34;neighbors&#34; in data:
        neighbors = Neighbors.from_json(data[&#34;neighbors&#34;])
    else:
        neighbors = None
    metric = data.get(&#34;metric&#34;, &#34;euclidean&#34;)
    n_neighbors = data.get(&#34;n_neighbors&#34;, 100)
    return cls(mats, ids=ids, label=label, metric=metric, n_neighbors=n_neighbors, neighbors=neighbors, parent=parent)</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>file_path_or_buffer, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the Embedding object from the given file path or
file-like object containing JSON data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path_or_buffer</code></strong></dt>
<dd>A file path or file-like object to read the
embedding from.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, file_path_or_buffer, **kwargs):
    &#34;&#34;&#34;
    Load the Embedding object from the given file path or
    file-like object containing JSON data.
    
    Args:
        file_path_or_buffer: A file path or file-like object to read the
            embedding from.
    &#34;&#34;&#34;
    if isinstance(file_path_or_buffer, str):
        # File path
        with open(file_path_or_buffer, &#39;r&#39;) as file:
            return cls.from_json(json.load(file), **kwargs)
    else:
        # File object
        return cls.from_json(json.load(file_path_or_buffer), **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="emblaze.datasets.Embedding.align_to"><code class="name flex">
<span>def <span class="ident">align_to</span></span>(<span>self, base_frame, ids=None, return_transform=False, base_transform=None, allow_flips=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Aligns this embedding to the base frame. The frames are aligned based
on the keys they have in common. This requires both embeddings to have
a dimensionality of 2.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_frame</code></strong></dt>
<dd>An Embedding to use as the base.</dd>
<dt><strong><code>frame</code></strong></dt>
<dd>An Embedding to transform.</dd>
<dt><strong><code>ids</code></strong></dt>
<dd>Point IDs to use for alignment (default None, which results in an
alignment using the intersection of IDs between the two frames).</dd>
<dt><strong><code>return_transform</code></strong></dt>
<dd>If true, return just the Affine object instead of the
rotated data.</dd>
<dt><strong><code>base_transform</code></strong></dt>
<dd>If not None, an Affine object representing the
transformation to apply to the base frame before aligning.</dd>
<dt><strong><code>allow_flips</code></strong></dt>
<dd>If true, test inversions as possible candidates for alignment.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> object representing the second input frame (the first
input frame is assumed to stay the same). Or, if <code>return_transform</code> is
<code>True</code>, returns the optimal transformation as an <code>Affine</code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_to(self, base_frame, ids=None, return_transform=False, base_transform=None, allow_flips=True):
    &#34;&#34;&#34;
    Aligns this embedding to the base frame. The frames are aligned based
    on the keys they have in common. This requires both embeddings to have
    a dimensionality of 2.
    
    Args:
        base_frame: An Embedding to use as the base.
        frame: An Embedding to transform.
        ids: Point IDs to use for alignment (default None, which results in an
            alignment using the intersection of IDs between the two frames).
        return_transform: If true, return just the Affine object instead of the
            rotated data.
        base_transform: If not None, an Affine object representing the
            transformation to apply to the base frame before aligning.
        allow_flips: If true, test inversions as possible candidates for alignment.
        
    Returns:
        A new `Embedding` object representing the second input frame (the first
        input frame is assumed to stay the same). Or, if `return_transform` is
        `True`, returns the optimal transformation as an `Affine` object.
    &#34;&#34;&#34;
    # Determine a set of points to use for comparison
    ids_to_compare = list(ids) if ids is not None else list(set(self.ids) &amp; set(base_frame.ids))
    
    proj_subset = self.field(Field.POSITION, ids=ids_to_compare)
    assert proj_subset.shape[1] == 2, &#34;Alignment of embeddings with dimension &gt; 2 not supported&#34;
    proj_scaler = projection_standardizer(proj_subset)
    
    base_proj_subset = base_frame.field(Field.POSITION, ids=ids_to_compare)
    assert base_proj_subset.shape[1] == 2, &#34;Alignment of embeddings with dimension &gt; 2 not supported&#34;
    if base_transform is not None:
        base_proj_subset = affine_transform(base_transform, base_proj_subset)    
    base_proj_scaler = projection_standardizer(base_proj_subset)
    
    proj = np.hstack([
        affine_transform(proj_scaler, proj_subset),
        np.zeros((len(proj_subset), 1))
    ])
    base_proj = np.hstack([
        affine_transform(base_proj_scaler, base_proj_subset),
        np.zeros((len(base_proj_subset), 1))
    ])
    
    # Test flips
    min_rmsd = 1e9
    best_variant = None
    for factor in (FLIP_FACTORS if allow_flips else FLIP_FACTORS[:1]):
        opt_rotation, rmsd = Rotation.align_vectors( # pylint: disable=unbalanced-tuple-unpacking
            base_proj,
            proj * factor)
        if rmsd &lt; min_rmsd:
            min_rmsd = rmsd
            transform = ~base_proj_scaler * matrix_to_affine(opt_rotation.as_matrix()) * Affine.scale(*factor[:2]) * proj_scaler
            if return_transform:
                best_variant = transform
            else:
                best_variant = affine_transform(transform,
                    self.field(Field.POSITION))

    if return_transform:
        return best_variant
    return self.copy_with_fields({Field.POSITION: best_variant})</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.any_ancestor_has_neighbors"><code class="name flex">
<span>def <span class="ident">any_ancestor_has_neighbors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>True</code> if any of the Embeddings in the parent tree have embeddings
computed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def any_ancestor_has_neighbors(self):
    &#34;&#34;&#34;
    Returns `True` if any of the Embeddings in the parent tree have embeddings
    computed.
    &#34;&#34;&#34;
    return self.find_recent_neighbor_embedding() is not None</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.clear_neighbors"><code class="name flex">
<span>def <span class="ident">clear_neighbors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the saved <code>Neighbors</code> associated with this <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code>. This can
be used to determine which Neighbors is returned by <code>get_ancestor_neighbors()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_neighbors(self):
    &#34;&#34;&#34;
    Removes the saved `Neighbors` associated with this `Embedding`. This can
    be used to determine which Neighbors is returned by `get_ancestor_neighbors()`.
    &#34;&#34;&#34;
    self.neighbors = None</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.clear_upstream_neighbors"><code class="name flex">
<span>def <span class="ident">clear_upstream_neighbors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the neighbor sets for all <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code>s in the parent tree of this
<code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> (but not this one).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_upstream_neighbors(self):
    &#34;&#34;&#34;
    Clears the neighbor sets for all `Embedding`s in the parent tree of this
    `Embedding` (but not this one).
    &#34;&#34;&#34;
    curr = self.parent
    while curr is not None:
        curr.clear_neighbors()
        curr = curr.parent</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.compute_neighbors"><code class="name flex">
<span>def <span class="ident">compute_neighbors</span></span>(<span>self, n_neighbors=None, metric=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and saves a set of nearest neighbors in this embedding according
to the <code>Field.POSITION</code> values. This can be accessed after completing this
step through the <code>neighbors</code> property.</p>
<p>If this <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> is copied or projected, it will inherit the same
<code>Neighbors</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_neighbors</code></strong></dt>
<dd>The number of neighbors to compute for each point. If
not provided, the default <code>n_neighbors</code> for this <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> is used.</dd>
<dt><strong><code>metric</code></strong></dt>
<dd>The distance metric to use to compute neighbors. If
not provided, the default <code>metric</code> for this <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> is used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_neighbors(self, n_neighbors=None, metric=None):
    &#34;&#34;&#34;
    Computes and saves a set of nearest neighbors in this embedding according
    to the `Field.POSITION` values. This can be accessed after completing this
    step through the `neighbors` property.
    
    If this `Embedding` is copied or projected, it will inherit the same
    `Neighbors`.
    
    Args:
        n_neighbors: The number of neighbors to compute for each point. If
            not provided, the default `n_neighbors` for this `Embedding` is used.
        metric: The distance metric to use to compute neighbors. If
            not provided, the default `metric` for this `Embedding` is used.
    &#34;&#34;&#34;
    pos = self.field(Field.POSITION)
    # Save the metric and n_neighbors here so that they can be used to
    # re-generate the Neighbors later if needed
    self.metric = metric or self.metric
    self.n_neighbors = n_neighbors or self.n_neighbors
    self.neighbors = Neighbors.compute(pos,
                                         ids=self.ids,
                                         metric=metric or self.metric,
                                         n_neighbors=self.n_neighbors)</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> with this <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> and the given one
stacked together. Must have the same set of fields, and a disjoint set of
IDs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat(self, other):
    &#34;&#34;&#34;
    Returns a new `Embedding` with this `Embedding` and the given one
    stacked together. Must have the same set of fields, and a disjoint set of
    IDs.
    &#34;&#34;&#34;
    assert set(self.data.keys()) == set(other.data.keys()), &#34;Cannot concatenate Embedding objects with different sets of fields&#34;
    assert not (set(self.ids.tolist()) &amp; set(other.ids.tolist())), &#34;Cannot concatenate Embedding objects with overlapping ID values&#34;
    assert self.has_neighbors() == other.has_neighbors(), &#34;Either both or neither Embedding object must have a Neighbors&#34;
    
    return Embedding({k: np.concatenate([self.field(k), other.field(k)])
                      for k in self.data.keys()},
                     ids=np.concatenate([self.ids, other.ids]),
                     neighbors=self.get_neighbors().concat(other.get_neighbors()) if self.has_neighbors() else None,
                     n_neighbors=max(self.n_neighbors, other.n_neighbors),
                     label=self.label, metric=self.metric)</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return Embedding(self.data,
                     self.ids,
                     label=self.label,
                     metric=self.metric,
                     n_neighbors=self.n_neighbors,
                     neighbors=self.neighbors,
                     parent=self)</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.copy_with_fields"><code class="name flex">
<span>def <span class="ident">copy_with_fields</span></span>(<span>self, updated_fields, clear_neighbors=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_with_fields(self, updated_fields, clear_neighbors=False):
    copy = self.copy()
    for field, vals in updated_fields.items():
        copy.set_field(field, vals)
    if clear_neighbors:
        copy.clear_neighbors()
    return copy</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.dimension"><code class="name flex">
<span>def <span class="ident">dimension</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the dimensionality of the <code>Field.POSITION</code> field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dimension(self):
    &#34;&#34;&#34;Returns the dimensionality of the `Field.POSITION` field.&#34;&#34;&#34;
    return self.field(Field.POSITION).shape[1]</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.distances"><code class="name flex">
<span>def <span class="ident">distances</span></span>(<span>self, ids=None, comparison_ids=None, metric=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the pairwise distances from the given IDs to each other (or all
points to each other, if ids is None). If the metric is not provided,
the default metric for this <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> object is used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distances(self, ids=None, comparison_ids=None, metric=None):
    &#34;&#34;&#34;
    Returns the pairwise distances from the given IDs to each other (or all
    points to each other, if ids is None). If the metric is not provided,
    the default metric for this `Embedding` object is used.
    &#34;&#34;&#34;
    metric = metric or self.metric
    
    if ids is None:
        indexes = np.arange(len(self))
    else:
        indexes = self.index(ids)
        
    if comparison_ids is None:
        comparison_indexes = indexes
    else:
        comparison_indexes = self.index(comparison_ids)

    if len(self) &gt; 2000 and len(indexes) &lt; 2000 and len(comparison_indexes) &lt; 2000:
        # Just compute the requested distances
        if metric == &#34;euclidean&#34;:
            return euclidean_distances(self.field(Field.POSITION, indexes),
                                       self.field(Field.POSITION, comparison_indexes))
        elif metric == &#34;cosine&#34;:
            return cosine_distances(self.field(Field.POSITION, indexes),
                                    self.field(Field.POSITION, comparison_indexes))
        elif metric == &#34;precomputed&#34;:
            return self.field(Field.POSITION, indexes)
        else:
            raise NotImplementedError(&#34;Unsupported metric for distances&#34;)
    else:
        # Cache all pairwise distances
        if metric not in self._distances:
            locations = self.field(Field.POSITION)
            if metric == &#34;euclidean&#34;:
                self._distances[metric] = euclidean_distances(locations, locations)
            elif metric == &#34;cosine&#34;:
                self._distances[metric] = cosine_distances(locations, locations)
            elif metric == &#34;precomputed&#34;:
                self._distances[metric] = locations
            else:
                raise NotImplementedError(&#34;Unsupported metric for distances&#34;)
    
        return self._distances[metric][indexes,:][:,comparison_indexes]</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.find_ancestor_neighbor_embedding"><code class="name flex">
<span>def <span class="ident">find_ancestor_neighbor_embedding</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> that is furthest along this <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code>'s parent
tree and has a neighbor set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_ancestor_neighbor_embedding(self):
    &#34;&#34;&#34;
    Returns the `Embedding` that is furthest along this `Embedding`&#39;s parent
    tree and has a neighbor set.
    &#34;&#34;&#34;
    ancestor = None
    curr = self
    while curr is not None:
        ancestor = curr if curr.has_neighbors() else ancestor
        curr = curr.parent
    return ancestor</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.find_recent_neighbor_embedding"><code class="name flex">
<span>def <span class="ident">find_recent_neighbor_embedding</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> that is closest to this <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> in the parent
tree (including this <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code>) that has a neighbor set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_recent_neighbor_embedding(self):
    &#34;&#34;&#34;
    Returns the `Embedding` that is closest to this `Embedding` in the parent
    tree (including this `Embedding`) that has a neighbor set.
    &#34;&#34;&#34;
    curr = self
    while curr is not None and not curr.has_neighbors():
        curr = curr.parent
    return curr</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.get_ancestor_neighbors"><code class="name flex">
<span>def <span class="ident">get_ancestor_neighbors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the neighbor set of the <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> that is furthest along this
<code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code>'s ancestry tree and has a neighbor set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ancestor_neighbors(self):
    &#34;&#34;&#34;
    Gets the neighbor set of the `Embedding` that is furthest along this
    `Embedding`&#39;s ancestry tree and has a neighbor set.
    &#34;&#34;&#34;
    ancestor = self.find_ancestor_neighbor_embedding()
    if ancestor:
        return ancestor.get_neighbors()</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.get_neighbors"><code class="name flex">
<span>def <span class="ident">get_neighbors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbors(self):
    return self.neighbors</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.get_recent_neighbors"><code class="name flex">
<span>def <span class="ident">get_recent_neighbors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the neighbor set of the <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> that is closest to this <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code>
in the parent tree (including itself) and that has a neighbor set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_recent_neighbors(self):
    &#34;&#34;&#34;
    Gets the neighbor set of the `Embedding` that is closest to this `Embedding`
    in the parent tree (including itself) and that has a neighbor set.
    &#34;&#34;&#34;
    recent = self.find_recent_neighbor_embedding()
    if recent:
        return recent.get_neighbors()</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.get_relations"><code class="name flex">
<span>def <span class="ident">get_relations</span></span>(<span>self, other_emb)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes a mapping from the IDs in this embedding to the positions
in the other embedding (used for <code>AlignedUMAP</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_relations(self, other_emb):
    &#34;&#34;&#34;
    Computes a mapping from the IDs in this embedding to the positions
    in the other embedding (used for `AlignedUMAP`).
    &#34;&#34;&#34;
    return {self.index(id_val): other_emb.index(id_val)
            for id_val in self.ids if id_val in other_emb}</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.get_root"><code class="name flex">
<span>def <span class="ident">get_root</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the root parent of this embedding.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_root(self):
    &#34;&#34;&#34;Returns the root parent of this embedding.&#34;&#34;&#34;
    if self.parent is None: return self
    return self.parent.get_root()</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.has_neighbors"><code class="name flex">
<span>def <span class="ident">has_neighbors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_neighbors(self):
    return self.neighbors is not None</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.neighbor_distances"><code class="name flex">
<span>def <span class="ident">neighbor_distances</span></span>(<span>self, ids=None, n_neighbors=100, metric=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list of nearest neighbors for each of the given IDs and the
distances to each of those points. This does NOT use the <code>Neighbors</code>
object, and is therefore based only on the locations of the points in
this <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> (not potentially on its parents).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neighbor_distances(self, ids=None, n_neighbors=100, metric=None):
    &#34;&#34;&#34;
    Returns the list of nearest neighbors for each of the given IDs and the
    distances to each of those points. This does NOT use the `Neighbors`
    object, and is therefore based only on the locations of the points in 
    this `Embedding` (not potentially on its parents).
    &#34;&#34;&#34;
    pos = self.field(Field.POSITION, ids=ids)
    neighbor_clf = NearestNeighbors(metric=metric or self.metric).fit(self.field(Field.POSITION))
    neigh_distances, neigh_indexes = neighbor_clf.kneighbors(pos, n_neighbors=min(n_neighbors + 1, len(self)))
    return neigh_indexes[:,1:], neigh_distances[:,1:]</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, method='umap', **params)</span>
</code></dt>
<dd>
<div class="desc"><p>Projects this embedding space into a lower dimensionality. The method
parameter can be a callable, which will define a dimensionality
reduction technique that takes as input a numpy array and a list of IDs,
as well as any keyword arguments given to the params argument of this
method, and returns a dimension-reduced matrix. If no metric is provided
in the keyword params, the default metric of this Embedding is used.</p>
<p>Returns: A new <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> object with the <code>Field.POSITION</code> value set to the
result of the projection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self, method=ProjectionTechnique.UMAP, **params):
    &#34;&#34;&#34;
    Projects this embedding space into a lower dimensionality. The method
    parameter can be a callable, which will define a dimensionality
    reduction technique that takes as input a numpy array and a list of IDs,
    as well as any keyword arguments given to the params argument of this
    method, and returns a dimension-reduced matrix. If no metric is provided
    in the keyword params, the default metric of this Embedding is used.
    
    Returns: A new `Embedding` object with the `Field.POSITION` value set to the
        result of the projection.
    &#34;&#34;&#34;
    hi_d = self.field(Field.POSITION)
    params = params or {}
    if method != ProjectionTechnique.PCA:
        params[&#34;metric&#34;] = params.get(&#34;metric&#34;, self.metric)
    
    if method == ProjectionTechnique.UMAP:
        import umap
        lo_d = umap.UMAP(**params).fit_transform(hi_d)
    elif method == ProjectionTechnique.TSNE:
        lo_d = TSNE(**params).fit_transform(hi_d)
    elif method == ProjectionTechnique.PCA:
        lo_d = PCA(**params).fit_transform(hi_d)
    elif callable(method):
        lo_d = method(hi_d, self.ids, **params)
    else:
        raise ValueError(&#34;Unrecognized projection technique &#39;{}&#39;. Please choose from the constants listed in emblaze.ProjectionTechnique, or pass a callable (see method docstring).&#34;.format(method))
    
    return self.copy_with_fields({Field.POSITION: lo_d}, clear_neighbors=True)</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file_path_or_buffer, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Save this Embedding object to the given file path or file-like object
(in JSON format). See <a href="#emblaze.datasets.Embedding.to_json"><code>Embedding.to_json</code></a>
for acceptable keyword arguments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path_or_buffer</code></strong></dt>
<dd>A file path or file-like object to write the
embedding to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, file_path_or_buffer, **kwargs):
    &#34;&#34;&#34;
    Save this Embedding object to the given file path or file-like object
    (in JSON format). See [`Embedding.to_json`](#emblaze.datasets.Embedding.to_json)
    for acceptable keyword arguments.
    
    Args:
        file_path_or_buffer: A file path or file-like object to write the
            embedding to.
    &#34;&#34;&#34;
    if isinstance(file_path_or_buffer, str):
        # File path
        with open(file_path_or_buffer, &#39;w&#39;) as file:
            json.dump(self.to_json(**kwargs), file)
    else:
        # File object
        json.dump(self.to_json(**kwargs), file_path_or_buffer)</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, compressed=True, save_neighbors=True, num_neighbors=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts this embedding into a JSON object. If the embedding is 2D, saves
coordinates as separate x and y fields; otherwise, saves coordinates as
n x d arrays.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>compressed</code></strong></dt>
<dd>whether to format JSON objects using base64 strings
instead of as human-readable float arrays</dd>
<dt><strong><code>save_neighbors</code></strong></dt>
<dd>If <code>True</code>, serialize the <code>Neighbors</code> object within
the embedding JSON.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A JSON-serializable dictionary representing the embedding.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self, compressed=True, save_neighbors=True, num_neighbors=None):
    &#34;&#34;&#34;
    Converts this embedding into a JSON object. If the embedding is 2D, saves
    coordinates as separate x and y fields; otherwise, saves coordinates as
    n x d arrays.
    
    Args:
        compressed: whether to format JSON objects using base64 strings
            instead of as human-readable float arrays
        save_neighbors: If `True`, serialize the `Neighbors` object within
            the embedding JSON.
            
    Returns:
        A JSON-serializable dictionary representing the embedding.
    &#34;&#34;&#34;
    result = {}
    indexes = self.index(self.ids)
    
    positions = self.field(Field.POSITION)
    colors = self.field(Field.COLOR)
    alphas = self.field(Field.ALPHA)
    sizes = self.field(Field.RADIUS)
    
    if compressed:
        result[&#34;_format&#34;] = &#34;compressed&#34;
        # Specify the type name that will be used to encode the point IDs.
        # This is important because the highlight array takes up the bulk
        # of the space when transferring to file/widget.
        dtype, type_name = choose_integer_type(self.ids)
        result[&#34;_idtype&#34;] = type_name
        result[&#34;_length&#34;] = len(self)
        result[&#34;ids&#34;] = encode_numerical_array(self.ids, dtype)
        
        if self.dimension() == 2:
            result[&#34;x&#34;] = encode_numerical_array(positions[:,0])
            result[&#34;y&#34;] = encode_numerical_array(positions[:,1])
        else:
            result[&#34;position&#34;] = encode_numerical_array(positions, interval=self.dimension())
            
        result[&#34;color&#34;] = encode_object_array(colors)
        if alphas is not None:
            result[&#34;alpha&#34;] = encode_numerical_array(alphas)
        if sizes is not None:
            result[&#34;r&#34;] = encode_numerical_array(sizes)
    else:
        result[&#34;points&#34;] = {}
        for id_val, index in zip(self.ids, indexes):
            obj = {}
            if self.dimension() == 2:
                obj[&#34;x&#34;] = positions[index, 0]
                obj[&#34;y&#34;] = positions[index, 1]
            else:
                obj[&#34;position&#34;] = positions[index].tolist()

            obj[&#34;color&#34;] = colors[index]
            if alphas is not None:
                obj[&#34;alpha&#34;] = alphas[index]
            if sizes is not None:
                obj[&#34;r&#34;] = sizes[index]
            result[&#34;points&#34;][id_val] = obj

    if save_neighbors and self.has_neighbors():
        result[&#34;neighbors&#34;] = self.get_neighbors().to_json(compressed=compressed, num_neighbors=num_neighbors)
    result[&#34;metric&#34;] = self.metric
    result[&#34;n_neighbors&#34;] = self.n_neighbors
    return standardize_json(result)</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.Embedding.within_bbox"><code class="name flex">
<span>def <span class="ident">within_bbox</span></span>(<span>self, bbox)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list of IDs whose points are within the given bounding box.
Only supports 2D embeddings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bbox</code></strong></dt>
<dd>The bounding box within which to retrieve points, specified as
(xmin, xmax, ymin, ymax).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of ID values corresponding to points within the bounding box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def within_bbox(self, bbox):
    &#34;&#34;&#34;
    Returns the list of IDs whose points are within the given bounding box.
    Only supports 2D embeddings.
    
    Args:
        bbox: The bounding box within which to retrieve points, specified as
            (xmin, xmax, ymin, ymax).
            
    Returns:
        A list of ID values corresponding to points within the bounding box.
    &#34;&#34;&#34;
    assert self.dimension() == 2, &#34;Non-2D embeddings are not supported by within_bbox()&#34;
    positions = self.field(Field.POSITION)
    return [id_val for id_val, pos in zip(self.ids, positions)
            if (pos[0] &gt;= bbox[0] and pos[0] &lt;= bbox[1] and
                pos[1] &gt;= bbox[2] and pos[1] &lt;= bbox[3])]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="emblaze.datasets.EmbeddingSet"><code class="flex name class">
<span>class <span class="ident">EmbeddingSet</span></span>
<span>(</span><span>embs, align=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A set of high-dimensional embeddings, composed of a series of <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code>
objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmbeddingSet:
    &#34;&#34;&#34;
    A set of high-dimensional embeddings, composed of a series of `Embedding`
    objects.
    &#34;&#34;&#34;
    def __init__(self, embs, align=True):
        if align:
            if not all(emb.dimension() == 2 for emb in embs):
                print(&#34;Embeddings are not 2D, skipping alignment&#34;)
                self.embeddings = embs
            else:
                self.embeddings = [embs[0]] + [emb.align_to(embs[0]) for emb in embs[1:]]
        else:
            self.embeddings = embs

        self.ids = np.array(sorted(set.union(*(set(emb.ids.tolist()) for emb in self.embeddings))))
    
    def __str__(self):
        return &#34;&lt;{} with {} embeddings:\n\t{}&gt;&#34;.format(
            type(self).__name__,
            len(self.embeddings),
            &#34;\n\t&#34;.join(str(emb) for emb in self.embeddings)
        )
        
    def __repr__(self):
        return str(self)
        
    def __getitem__(self, idx):
        return self.embeddings[idx]

    def __len__(self):
        return len(self.embeddings)
    
    def identical(self):
        if len(self) == 0: return True
        return all(e == self[0] for e in self.embeddings)
    
    def project(self, method=ProjectionTechnique.ALIGNED_UMAP, align=True, **params):
        &#34;&#34;&#34;
        Projects the embedding set into 2D. The method parameter can be a
        callable, which will define a dimensionality reduction technique that
        takes as input a list of numpy arrays and a list of lists of IDs, as
        well as any keyword arguments given to the params argument of this
        method, and returns a list of dimension-reduced arrays.
        
        Returns: A new `EmbeddingSet` object with (optionally aligned) projected
            data.
        &#34;&#34;&#34;
        params = params or {}
        hi_ds = [emb.field(Field.POSITION) for emb in self.embeddings]
        id_sets = [emb.ids for emb in self.embeddings]
        pre_aligned = False
        if method == ProjectionTechnique.ALIGNED_UMAP:
            import umap
            lo_d_mats = umap.AlignedUMAP(**params).fit_transform(
                hi_ds,
                relations=[self.embeddings[i].get_relations(self.embeddings[i + 1])
                            for i in range(len(self.embeddings) - 1)])
            pre_aligned = True
            lo_ds = [emb.copy_with_fields({Field.POSITION: lo_d}, clear_neighbors=True)
                     for emb, lo_d in zip(self.embeddings, lo_d_mats)]
        elif callable(method):
            lo_d_mats = method(hi_ds, id_sets, **params)
            lo_ds = [emb.copy_with_fields({Field.POSITION: lo_d}, clear_neighbors=True)
                     for emb, lo_d in zip(self.embeddings, lo_d_mats)]
        else:
            lo_ds = [emb.project(method=method, **params)
                     for emb in self.embeddings]

        return EmbeddingSet(lo_ds, align=align and not pre_aligned)
    
    def compute_neighbors(self, n_neighbors=100, metric=None):
        &#34;&#34;&#34;
        Computes and saves a set of nearest neighbors in each embedding set according
        to the `Field.POSITION` values. This can be accessed after completing this
        step by inspecting the `neighbors` property of the embedding.
        &#34;&#34;&#34;
        for emb in self.embeddings:
            emb.compute_neighbors(n_neighbors=n_neighbors, metric=metric)

    def clear_neighbors(self):
        &#34;&#34;&#34;
        Removes the saved `Neighbors` associated with each `Embedding`. This can
        be used to determine which `Neighbors` is returned by `get_ancestor_neighbors()`.
        &#34;&#34;&#34;
        for emb in self.embeddings:
            emb.clear_neighbors()
                
    def get_neighbors(self):
        &#34;&#34;&#34;
        Returns a `NeighborSet` object corresponding to the nearest neighbors
        of each embedding in the `EmbeddingSet`.
        &#34;&#34;&#34;
        return NeighborSet([emb.get_neighbors() for emb in self.embeddings])

    def get_recent_neighbors(self):
        &#34;&#34;&#34;
        Returns a `NeighborSet` containing ancestor `Neighbors` for each embedding in the
        `EmbeddingSet`. This corresponds to the lowest-level `Embedding` in each
        `Embedding`&#39;s parent tree (including the `Embedding` itself) that has a
        neighbor set associated with it.
        &#34;&#34;&#34;
        return NeighborSet([emb.get_recent_neighbors() for emb in self.embeddings])
                
    def get_ancestor_neighbors(self):
        &#34;&#34;&#34;
        Returns a `NeighborSet` containing ancestor `Neighbors` for each embedding in the
        `EmbeddingSet`. This corresponds to the highest-level `Embedding` in each
        `Embedding`&#39;s parent tree that has a neighbor set associated with it.
        &#34;&#34;&#34;
        return NeighborSet([emb.get_ancestor_neighbors() for emb in self.embeddings])
            
    def to_json(self, compressed=True, save_neighbors=True, num_neighbors=None):
        &#34;&#34;&#34;
        Converts this set of embeddings into a JSON object.
        
        Args:
            compressed: whether to format `Embedding` JSON objects using base64 strings
                instead of as human-readable float arrays
            save_neighbors: If `True`, save the `Neighbors` into the &#34;neighbors&#34; key
                of each individual embedding
            num_neighbors: number of neighbors to write for each point (can considerably
                save memory)
        &#34;&#34;&#34;
        return {
            &#34;data&#34;: [emb.to_json(compressed=compressed,
                                 save_neighbors=save_neighbors,
                                 num_neighbors=num_neighbors) for emb in self.embeddings],
            &#34;frameLabels&#34;: [emb.label or &#34;Frame {}&#34;.format(i) for i, emb in enumerate(self.embeddings)]
        }

    @classmethod
    def from_json(cls, data, parents=None):
        &#34;&#34;&#34;
        Builds an `EmbeddingSet` from a JSON object.
        
        Args:
            data: A JSON-serializable dictionary representing the `EmbeddingSet`,
                such as that generated by [`EmbeddingSet.to_json`](#emblaze.datasets.EmbeddingSet.to_json).
            parents: An optional list of `Embedding` objects to use as parents
                for each of the created embeddings.
                
        Returns:
            An initialized `EmbeddingSet` object.
        &#34;&#34;&#34;
        assert &#34;data&#34; in data, &#34;JSON object must contain a &#39;data&#39; field&#34;
        embs = data[&#34;data&#34;]
        labels = data.get(&#34;frameLabels&#34;, [None for _ in range(len(embs))])
        if parents is None:
            parents = [None for _ in range(len(embs))]
        elif len(parents) == 1:
            parents = [parents[0] for _ in range(len(embs))]
        embs = [Embedding.from_json(frame, label=label, parent=parent) for frame, label, parent in zip(embs, labels, parents)]
        return cls(embs, align=False)
    
    def save(self, file_path_or_buffer, **kwargs):
        &#34;&#34;&#34;
        Save this EmbeddingSet object to the given file path or file-like object
        (in JSON format). See [`EmbeddingSet.to_json`](#emblaze.datasets.EmbeddingSet.to_json)
        for acceptable keyword arguments.
        
        Args:
            file_path_or_buffer: A file path or file-like object to write the
                embedding to.
        &#34;&#34;&#34;
        if isinstance(file_path_or_buffer, str):
            # File path
            with open(file_path_or_buffer, &#39;w&#39;) as file:
                json.dump(self.to_json(**kwargs), file)
        else:
            # File object
            json.dump(self.to_json(**kwargs), file_path_or_buffer)
            
    @classmethod
    def load(cls, file_path_or_buffer, **kwargs):
        &#34;&#34;&#34;
        Load the EmbeddingSet object from the given file path or
        file-like object containing JSON data.

        Args:
            file_path_or_buffer: A file path or file-like object to read the
                embedding from.
        &#34;&#34;&#34;
        if isinstance(file_path_or_buffer, str):
            # File path
            with open(file_path_or_buffer, &#39;r&#39;) as file:
                return cls.from_json(json.load(file), **kwargs)
        else:
            # File object
            return cls.from_json(json.load(file_path_or_buffer), **kwargs)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="emblaze.datasets.EmbeddingSet.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>data, parents=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds an <code><a title="emblaze.datasets.EmbeddingSet" href="#emblaze.datasets.EmbeddingSet">EmbeddingSet</a></code> from a JSON object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>A JSON-serializable dictionary representing the <code><a title="emblaze.datasets.EmbeddingSet" href="#emblaze.datasets.EmbeddingSet">EmbeddingSet</a></code>,
such as that generated by <a href="#emblaze.datasets.EmbeddingSet.to_json"><code>EmbeddingSet.to_json</code></a>.</dd>
<dt><strong><code>parents</code></strong></dt>
<dd>An optional list of <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> objects to use as parents
for each of the created embeddings.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An initialized <code><a title="emblaze.datasets.EmbeddingSet" href="#emblaze.datasets.EmbeddingSet">EmbeddingSet</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls, data, parents=None):
    &#34;&#34;&#34;
    Builds an `EmbeddingSet` from a JSON object.
    
    Args:
        data: A JSON-serializable dictionary representing the `EmbeddingSet`,
            such as that generated by [`EmbeddingSet.to_json`](#emblaze.datasets.EmbeddingSet.to_json).
        parents: An optional list of `Embedding` objects to use as parents
            for each of the created embeddings.
            
    Returns:
        An initialized `EmbeddingSet` object.
    &#34;&#34;&#34;
    assert &#34;data&#34; in data, &#34;JSON object must contain a &#39;data&#39; field&#34;
    embs = data[&#34;data&#34;]
    labels = data.get(&#34;frameLabels&#34;, [None for _ in range(len(embs))])
    if parents is None:
        parents = [None for _ in range(len(embs))]
    elif len(parents) == 1:
        parents = [parents[0] for _ in range(len(embs))]
    embs = [Embedding.from_json(frame, label=label, parent=parent) for frame, label, parent in zip(embs, labels, parents)]
    return cls(embs, align=False)</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.EmbeddingSet.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>file_path_or_buffer, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the EmbeddingSet object from the given file path or
file-like object containing JSON data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path_or_buffer</code></strong></dt>
<dd>A file path or file-like object to read the
embedding from.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, file_path_or_buffer, **kwargs):
    &#34;&#34;&#34;
    Load the EmbeddingSet object from the given file path or
    file-like object containing JSON data.

    Args:
        file_path_or_buffer: A file path or file-like object to read the
            embedding from.
    &#34;&#34;&#34;
    if isinstance(file_path_or_buffer, str):
        # File path
        with open(file_path_or_buffer, &#39;r&#39;) as file:
            return cls.from_json(json.load(file), **kwargs)
    else:
        # File object
        return cls.from_json(json.load(file_path_or_buffer), **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="emblaze.datasets.EmbeddingSet.clear_neighbors"><code class="name flex">
<span>def <span class="ident">clear_neighbors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the saved <code>Neighbors</code> associated with each <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code>. This can
be used to determine which <code>Neighbors</code> is returned by <code>get_ancestor_neighbors()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_neighbors(self):
    &#34;&#34;&#34;
    Removes the saved `Neighbors` associated with each `Embedding`. This can
    be used to determine which `Neighbors` is returned by `get_ancestor_neighbors()`.
    &#34;&#34;&#34;
    for emb in self.embeddings:
        emb.clear_neighbors()</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.EmbeddingSet.compute_neighbors"><code class="name flex">
<span>def <span class="ident">compute_neighbors</span></span>(<span>self, n_neighbors=100, metric=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and saves a set of nearest neighbors in each embedding set according
to the <code>Field.POSITION</code> values. This can be accessed after completing this
step by inspecting the <code>neighbors</code> property of the embedding.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_neighbors(self, n_neighbors=100, metric=None):
    &#34;&#34;&#34;
    Computes and saves a set of nearest neighbors in each embedding set according
    to the `Field.POSITION` values. This can be accessed after completing this
    step by inspecting the `neighbors` property of the embedding.
    &#34;&#34;&#34;
    for emb in self.embeddings:
        emb.compute_neighbors(n_neighbors=n_neighbors, metric=metric)</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.EmbeddingSet.get_ancestor_neighbors"><code class="name flex">
<span>def <span class="ident">get_ancestor_neighbors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a <code>NeighborSet</code> containing ancestor <code>Neighbors</code> for each embedding in the
<code><a title="emblaze.datasets.EmbeddingSet" href="#emblaze.datasets.EmbeddingSet">EmbeddingSet</a></code>. This corresponds to the highest-level <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> in each
<code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code>'s parent tree that has a neighbor set associated with it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ancestor_neighbors(self):
    &#34;&#34;&#34;
    Returns a `NeighborSet` containing ancestor `Neighbors` for each embedding in the
    `EmbeddingSet`. This corresponds to the highest-level `Embedding` in each
    `Embedding`&#39;s parent tree that has a neighbor set associated with it.
    &#34;&#34;&#34;
    return NeighborSet([emb.get_ancestor_neighbors() for emb in self.embeddings])</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.EmbeddingSet.get_neighbors"><code class="name flex">
<span>def <span class="ident">get_neighbors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a <code>NeighborSet</code> object corresponding to the nearest neighbors
of each embedding in the <code><a title="emblaze.datasets.EmbeddingSet" href="#emblaze.datasets.EmbeddingSet">EmbeddingSet</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbors(self):
    &#34;&#34;&#34;
    Returns a `NeighborSet` object corresponding to the nearest neighbors
    of each embedding in the `EmbeddingSet`.
    &#34;&#34;&#34;
    return NeighborSet([emb.get_neighbors() for emb in self.embeddings])</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.EmbeddingSet.get_recent_neighbors"><code class="name flex">
<span>def <span class="ident">get_recent_neighbors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a <code>NeighborSet</code> containing ancestor <code>Neighbors</code> for each embedding in the
<code><a title="emblaze.datasets.EmbeddingSet" href="#emblaze.datasets.EmbeddingSet">EmbeddingSet</a></code>. This corresponds to the lowest-level <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> in each
<code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code>'s parent tree (including the <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> itself) that has a
neighbor set associated with it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_recent_neighbors(self):
    &#34;&#34;&#34;
    Returns a `NeighborSet` containing ancestor `Neighbors` for each embedding in the
    `EmbeddingSet`. This corresponds to the lowest-level `Embedding` in each
    `Embedding`&#39;s parent tree (including the `Embedding` itself) that has a
    neighbor set associated with it.
    &#34;&#34;&#34;
    return NeighborSet([emb.get_recent_neighbors() for emb in self.embeddings])</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.EmbeddingSet.identical"><code class="name flex">
<span>def <span class="ident">identical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identical(self):
    if len(self) == 0: return True
    return all(e == self[0] for e in self.embeddings)</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.EmbeddingSet.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, method='aligned-umap', align=True, **params)</span>
</code></dt>
<dd>
<div class="desc"><p>Projects the embedding set into 2D. The method parameter can be a
callable, which will define a dimensionality reduction technique that
takes as input a list of numpy arrays and a list of lists of IDs, as
well as any keyword arguments given to the params argument of this
method, and returns a list of dimension-reduced arrays.</p>
<p>Returns: A new <code><a title="emblaze.datasets.EmbeddingSet" href="#emblaze.datasets.EmbeddingSet">EmbeddingSet</a></code> object with (optionally aligned) projected
data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self, method=ProjectionTechnique.ALIGNED_UMAP, align=True, **params):
    &#34;&#34;&#34;
    Projects the embedding set into 2D. The method parameter can be a
    callable, which will define a dimensionality reduction technique that
    takes as input a list of numpy arrays and a list of lists of IDs, as
    well as any keyword arguments given to the params argument of this
    method, and returns a list of dimension-reduced arrays.
    
    Returns: A new `EmbeddingSet` object with (optionally aligned) projected
        data.
    &#34;&#34;&#34;
    params = params or {}
    hi_ds = [emb.field(Field.POSITION) for emb in self.embeddings]
    id_sets = [emb.ids for emb in self.embeddings]
    pre_aligned = False
    if method == ProjectionTechnique.ALIGNED_UMAP:
        import umap
        lo_d_mats = umap.AlignedUMAP(**params).fit_transform(
            hi_ds,
            relations=[self.embeddings[i].get_relations(self.embeddings[i + 1])
                        for i in range(len(self.embeddings) - 1)])
        pre_aligned = True
        lo_ds = [emb.copy_with_fields({Field.POSITION: lo_d}, clear_neighbors=True)
                 for emb, lo_d in zip(self.embeddings, lo_d_mats)]
    elif callable(method):
        lo_d_mats = method(hi_ds, id_sets, **params)
        lo_ds = [emb.copy_with_fields({Field.POSITION: lo_d}, clear_neighbors=True)
                 for emb, lo_d in zip(self.embeddings, lo_d_mats)]
    else:
        lo_ds = [emb.project(method=method, **params)
                 for emb in self.embeddings]

    return EmbeddingSet(lo_ds, align=align and not pre_aligned)</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.EmbeddingSet.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file_path_or_buffer, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Save this EmbeddingSet object to the given file path or file-like object
(in JSON format). See <a href="#emblaze.datasets.EmbeddingSet.to_json"><code>EmbeddingSet.to_json</code></a>
for acceptable keyword arguments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path_or_buffer</code></strong></dt>
<dd>A file path or file-like object to write the
embedding to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, file_path_or_buffer, **kwargs):
    &#34;&#34;&#34;
    Save this EmbeddingSet object to the given file path or file-like object
    (in JSON format). See [`EmbeddingSet.to_json`](#emblaze.datasets.EmbeddingSet.to_json)
    for acceptable keyword arguments.
    
    Args:
        file_path_or_buffer: A file path or file-like object to write the
            embedding to.
    &#34;&#34;&#34;
    if isinstance(file_path_or_buffer, str):
        # File path
        with open(file_path_or_buffer, &#39;w&#39;) as file:
            json.dump(self.to_json(**kwargs), file)
    else:
        # File object
        json.dump(self.to_json(**kwargs), file_path_or_buffer)</code></pre>
</details>
</dd>
<dt id="emblaze.datasets.EmbeddingSet.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, compressed=True, save_neighbors=True, num_neighbors=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts this set of embeddings into a JSON object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>compressed</code></strong></dt>
<dd>whether to format <code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code> JSON objects using base64 strings
instead of as human-readable float arrays</dd>
<dt><strong><code>save_neighbors</code></strong></dt>
<dd>If <code>True</code>, save the <code>Neighbors</code> into the "neighbors" key
of each individual embedding</dd>
<dt><strong><code>num_neighbors</code></strong></dt>
<dd>number of neighbors to write for each point (can considerably
save memory)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self, compressed=True, save_neighbors=True, num_neighbors=None):
    &#34;&#34;&#34;
    Converts this set of embeddings into a JSON object.
    
    Args:
        compressed: whether to format `Embedding` JSON objects using base64 strings
            instead of as human-readable float arrays
        save_neighbors: If `True`, save the `Neighbors` into the &#34;neighbors&#34; key
            of each individual embedding
        num_neighbors: number of neighbors to write for each point (can considerably
            save memory)
    &#34;&#34;&#34;
    return {
        &#34;data&#34;: [emb.to_json(compressed=compressed,
                             save_neighbors=save_neighbors,
                             num_neighbors=num_neighbors) for emb in self.embeddings],
        &#34;frameLabels&#34;: [emb.label or &#34;Frame {}&#34;.format(i) for i, emb in enumerate(self.embeddings)]
    }</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="emblaze" href="index.html">emblaze</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="emblaze.datasets.Embedding" href="#emblaze.datasets.Embedding">Embedding</a></code></h4>
<ul class="">
<li><code><a title="emblaze.datasets.Embedding.align_to" href="#emblaze.datasets.Embedding.align_to">align_to</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.any_ancestor_has_neighbors" href="#emblaze.datasets.Embedding.any_ancestor_has_neighbors">any_ancestor_has_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.clear_neighbors" href="#emblaze.datasets.Embedding.clear_neighbors">clear_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.clear_upstream_neighbors" href="#emblaze.datasets.Embedding.clear_upstream_neighbors">clear_upstream_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.compute_neighbors" href="#emblaze.datasets.Embedding.compute_neighbors">compute_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.concat" href="#emblaze.datasets.Embedding.concat">concat</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.copy" href="#emblaze.datasets.Embedding.copy">copy</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.copy_with_fields" href="#emblaze.datasets.Embedding.copy_with_fields">copy_with_fields</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.dimension" href="#emblaze.datasets.Embedding.dimension">dimension</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.distances" href="#emblaze.datasets.Embedding.distances">distances</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.find_ancestor_neighbor_embedding" href="#emblaze.datasets.Embedding.find_ancestor_neighbor_embedding">find_ancestor_neighbor_embedding</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.find_recent_neighbor_embedding" href="#emblaze.datasets.Embedding.find_recent_neighbor_embedding">find_recent_neighbor_embedding</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.from_json" href="#emblaze.datasets.Embedding.from_json">from_json</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.get_ancestor_neighbors" href="#emblaze.datasets.Embedding.get_ancestor_neighbors">get_ancestor_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.get_neighbors" href="#emblaze.datasets.Embedding.get_neighbors">get_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.get_recent_neighbors" href="#emblaze.datasets.Embedding.get_recent_neighbors">get_recent_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.get_relations" href="#emblaze.datasets.Embedding.get_relations">get_relations</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.get_root" href="#emblaze.datasets.Embedding.get_root">get_root</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.has_neighbors" href="#emblaze.datasets.Embedding.has_neighbors">has_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.load" href="#emblaze.datasets.Embedding.load">load</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.neighbor_distances" href="#emblaze.datasets.Embedding.neighbor_distances">neighbor_distances</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.project" href="#emblaze.datasets.Embedding.project">project</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.save" href="#emblaze.datasets.Embedding.save">save</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.to_json" href="#emblaze.datasets.Embedding.to_json">to_json</a></code></li>
<li><code><a title="emblaze.datasets.Embedding.within_bbox" href="#emblaze.datasets.Embedding.within_bbox">within_bbox</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="emblaze.datasets.EmbeddingSet" href="#emblaze.datasets.EmbeddingSet">EmbeddingSet</a></code></h4>
<ul class="">
<li><code><a title="emblaze.datasets.EmbeddingSet.clear_neighbors" href="#emblaze.datasets.EmbeddingSet.clear_neighbors">clear_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.EmbeddingSet.compute_neighbors" href="#emblaze.datasets.EmbeddingSet.compute_neighbors">compute_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.EmbeddingSet.from_json" href="#emblaze.datasets.EmbeddingSet.from_json">from_json</a></code></li>
<li><code><a title="emblaze.datasets.EmbeddingSet.get_ancestor_neighbors" href="#emblaze.datasets.EmbeddingSet.get_ancestor_neighbors">get_ancestor_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.EmbeddingSet.get_neighbors" href="#emblaze.datasets.EmbeddingSet.get_neighbors">get_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.EmbeddingSet.get_recent_neighbors" href="#emblaze.datasets.EmbeddingSet.get_recent_neighbors">get_recent_neighbors</a></code></li>
<li><code><a title="emblaze.datasets.EmbeddingSet.identical" href="#emblaze.datasets.EmbeddingSet.identical">identical</a></code></li>
<li><code><a title="emblaze.datasets.EmbeddingSet.load" href="#emblaze.datasets.EmbeddingSet.load">load</a></code></li>
<li><code><a title="emblaze.datasets.EmbeddingSet.project" href="#emblaze.datasets.EmbeddingSet.project">project</a></code></li>
<li><code><a title="emblaze.datasets.EmbeddingSet.save" href="#emblaze.datasets.EmbeddingSet.save">save</a></code></li>
<li><code><a title="emblaze.datasets.EmbeddingSet.to_json" href="#emblaze.datasets.EmbeddingSet.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>