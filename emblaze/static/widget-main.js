var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function noop$3() {
}
const identity$5 = (x) => x;
function assign$2(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
let src_url_equal_anchor;
function src_url_equal(element_src, url2) {
  if (element_src === url2)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url2;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop$3;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign$2($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
const is_client = typeof window !== "undefined";
let now$1 = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop$3;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
const globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);
function append(target, node) {
  target.appendChild(node);
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root2 && /** @type {ShadowRoot} */
  root2.host) {
    return (
      /** @type {ShadowRoot} */
      root2
    );
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element$2("style");
  style_element.textContent = "/* empty */";
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element$2(name2) {
  return document.createElement(name2);
}
function svg_element(name2) {
  return document.createElementNS("http://www.w3.org/2000/svg", name2);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty$2() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function init_binding_group(group) {
  let _inputs;
  return {
    /* push */
    p(...inputs) {
      _inputs = inputs;
      _inputs.forEach((input) => group.push(input));
    },
    /* remove */
    r() {
      _inputs.forEach((input) => group.splice(group.indexOf(input), 1));
    }
  };
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children$1(element) {
  return Array.from(element.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select2, value, mounting) {
  for (let i = 0; i < select2.options.length; i += 1) {
    const option = select2.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select2.selectedIndex = -1;
  }
}
function select_value(select2) {
  const selected_option = select2.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element, name2, toggle) {
  element.classList.toggle(name2, !!toggle);
}
function custom_event(type2, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type2, { detail, bubbles, cancelable });
}
class HtmlTag {
  constructor(is_svg = false) {
    /**
     * @private
     * @default false
     */
    __publicField(this, "is_svg", false);
    /** parent for creating node */
    __publicField(this, "e");
    /** html tag nodes */
    __publicField(this, "n");
    /** target */
    __publicField(this, "t");
    /** anchor */
    __publicField(this, "a");
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element$2(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid2 = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name2 = `__svelte_${hash(rule)}_${uid2}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name2]) {
    rules[name2] = true;
    stylesheet.insertRule(`@keyframes ${name2} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name2} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name2;
}
function delete_rule(node, name2) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name2 ? (anim) => anim.indexOf(name2) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type2, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type2];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type2,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c2) => fns.indexOf(c2) === -1 ? filtered.push(c2) : targets.push(c2));
  targets.forEach((c2) => c2());
  render_callbacks = filtered;
}
let promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch$2(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
const null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config3 = fn(node, params, options);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  let original_inert_value;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = (
      /** @type {Program['d']} */
      program.b - t
    );
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const {
      delay = 0,
      duration = 300,
      easing = identity$5,
      tick = noop$3,
      css
    } = config3 || null_transition;
    const program = {
      start: now$1() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if ("inert" in node) {
      if (b) {
        if (original_inert_value !== void 0) {
          node.inert = original_inert_value;
        }
      } else {
        original_inert_value = /** @type {HTMLElement} */
        node.inert;
        node.inert = true;
      }
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch$2(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch$2(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(
              node,
              t,
              running_program.b,
              running_program.duration,
              0,
              easing,
              config3.css
            );
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick(t = running_program.b, 1 - t);
            dispatch$2(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config3)) {
        wait().then(() => {
          const opts = { direction: b ? "in" : "out" };
          config3 = config3(opts);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function bind$4(component, name2, callback) {
  const index = component.$$.props[name2];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment: fragment2, after_update } = component.$$;
  fragment2 && fragment2.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init$2(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop$3,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children$1(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop$3;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type2, callback) {
    if (!is_function(callback)) {
      return noop$3;
    }
    const callbacks = this.$$.callbacks[type2] || (this.$$.callbacks[type2] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
}
const PUBLIC_VERSION = "4";
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value] of entries)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
const e10$1 = Math.sqrt(50), e5$1 = Math.sqrt(10), e2$1 = Math.sqrt(2);
function tickSpec(start2, stop, count) {
  const step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start2)
      ++i1;
    if (i2 / inc > stop)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start2)
      ++i1;
    if (i2 * inc > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2)
    return tickSpec(start2, stop, count * 2);
  return [i1, i2, inc];
}
function ticks$1(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  if (!(count > 0))
    return [];
  if (start2 === stop)
    return [start2];
  const reverse = stop < start2, [i1, i2, inc] = reverse ? tickSpec(stop, start2, count) : tickSpec(start2, stop, count);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  return tickSpec(start2, stop, count)[2];
}
function tickStep$1(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  const reverse = stop < start2, inc = reverse ? tickIncrement(stop, start2, count) : tickIncrement(start2, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
function range$1(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range2 = new Array(n);
  while (++i < n) {
    range2[i] = start2 + i * step;
  }
  return range2;
}
var noop$2 = { value: () => {
} };
function dispatch$1() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch$1(_);
}
function Dispatch$1(_) {
  this._ = _;
}
function parseTypenames$3(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name: name2 };
  });
}
Dispatch$1.prototype = dispatch$1.prototype = {
  constructor: Dispatch$1,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames$3(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get$3(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set$2(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set$2(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _ = this._;
    for (var t in _)
      copy2[t] = _[t].slice();
    return new Dispatch$1(copy2);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get$3(type2, name2) {
  for (var i = 0, n = type2.length, c2; i < n; ++i) {
    if ((c2 = type2[i]).name === name2) {
      return c2.value;
    }
  }
}
function set$2(type2, name2, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name2) {
      type2[i] = noop$2, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name: name2, value: callback });
  return type2;
}
var xhtml$1 = "http://www.w3.org/1999/xhtml";
const namespaces$1 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml$1,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace$1(name2) {
  var prefix2 = name2 += "", i = prefix2.indexOf(":");
  if (i >= 0 && (prefix2 = name2.slice(0, i)) !== "xmlns")
    name2 = name2.slice(i + 1);
  return namespaces$1.hasOwnProperty(prefix2) ? { space: namespaces$1[prefix2], local: name2 } : name2;
}
function creatorInherit$1(name2) {
  return function() {
    var document2 = this.ownerDocument, uri2 = this.namespaceURI;
    return uri2 === xhtml$1 && document2.documentElement.namespaceURI === xhtml$1 ? document2.createElement(name2) : document2.createElementNS(uri2, name2);
  };
}
function creatorFixed$1(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator$1(name2) {
  var fullname = namespace$1(name2);
  return (fullname.local ? creatorFixed$1 : creatorInherit$1)(fullname);
}
function none$1() {
}
function selector$1(selector2) {
  return selector2 == null ? none$1 : function() {
    return this.querySelector(selector2);
  };
}
function selection_select$1(select2) {
  if (typeof select2 !== "function")
    select2 = selector$1(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection$2(subgroups, this._parents);
}
function array$1(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}
function empty$1() {
  return [];
}
function selectorAll$1(selector2) {
  return selector2 == null ? empty$1 : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array$1(select2.apply(this, arguments));
  };
}
function selection_selectAll$1(select2) {
  if (typeof select2 === "function")
    select2 = arrayAll(select2);
  else
    select2 = selectorAll$1(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select2.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection$2(subgroups, parents);
}
function matcher$2(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node) {
    return node.matches(selector2);
  };
}
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}
function selection_filter$1(match) {
  if (typeof match !== "function")
    match = matcher$2(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection$2(subgroups, this._parents);
}
function sparse$1(update2) {
  return new Array(update2.length);
}
function selection_enter$1() {
  return new Selection$2(this._enter || this._groups.map(sparse$1), this._parents);
}
function EnterNode$1(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode$1.prototype = {
  constructor: EnterNode$1,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$4(x) {
  return function() {
    return x;
  };
}
function bindIndex$1(parent, group, enter, update2, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update2[i] = node;
    } else {
      enter[i] = new EnterNode$1(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey$1(parent, group, enter, update2, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update2[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode$1(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function selection_data$1(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind2 = key ? bindKey$1 : bindIndex$1, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant$4(value);
  for (var m = groups.length, update2 = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update2[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind2(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update2 = new Selection$2(update2, parents);
  update2._enter = enter;
  update2._exit = exit;
  return update2;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
function selection_exit$1() {
  return new Selection$2(this._exit || this._groups.map(sparse$1), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update2 = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update2 = onupdate(update2);
    if (update2)
      update2 = update2.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update2 ? enter.merge(update2).order() : update2;
}
function selection_merge$1(context2) {
  var selection2 = context2.selection ? context2.selection() : context2;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge3 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge3[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection$2(merges, this._parents);
}
function selection_order$1() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
function selection_sort$1(compare) {
  if (!compare)
    compare = ascending$2;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$2(sortgroups, this._parents).order();
}
function ascending$2(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call$1() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes$1() {
  return Array.from(this);
}
function selection_node$1() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node)
        return node;
    }
  }
  return null;
}
function selection_size$1() {
  let size2 = 0;
  for (const node of this)
    ++size2;
  return size2;
}
function selection_empty$1() {
  return !this.node();
}
function selection_each$1(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}
function attrRemove$2(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS$2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$2(name2, value) {
  return function() {
    this.setAttribute(name2, value);
  };
}
function attrConstantNS$2(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$2(name2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.removeAttribute(name2);
    else
      this.setAttribute(name2, v2);
  };
}
function attrFunctionNS$2(fullname, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v2);
  };
}
function selection_attr$1(name2, value) {
  var fullname = namespace$1(name2);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$2 : attrRemove$2 : typeof value === "function" ? fullname.local ? attrFunctionNS$2 : attrFunction$2 : fullname.local ? attrConstantNS$2 : attrConstant$2)(fullname, value));
}
function defaultView$1(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
function styleRemove$2(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant$2(name2, value, priority) {
  return function() {
    this.style.setProperty(name2, value, priority);
  };
}
function styleFunction$2(name2, value, priority) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.style.removeProperty(name2);
    else
      this.style.setProperty(name2, v2, priority);
  };
}
function selection_style$1(name2, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$2 : typeof value === "function" ? styleFunction$2 : styleConstant$2)(name2, value, priority == null ? "" : priority)) : styleValue(this.node(), name2);
}
function styleValue(node, name2) {
  return node.style.getPropertyValue(name2) || defaultView$1(node).getComputedStyle(node, null).getPropertyValue(name2);
}
function propertyRemove$1(name2) {
  return function() {
    delete this[name2];
  };
}
function propertyConstant$1(name2, value) {
  return function() {
    this[name2] = value;
  };
}
function propertyFunction$1(name2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      delete this[name2];
    else
      this[name2] = v2;
  };
}
function selection_property$1(name2, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove$1 : typeof value === "function" ? propertyFunction$1 : propertyConstant$1)(name2, value)) : this.node()[name2];
}
function classArray$1(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList$1(node) {
  return node.classList || new ClassList$1(node);
}
function ClassList$1(node) {
  this._node = node;
  this._names = classArray$1(node.getAttribute("class") || "");
}
ClassList$1.prototype = {
  add: function(name2) {
    var i = this._names.indexOf(name2);
    if (i < 0) {
      this._names.push(name2);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name2) {
    var i = this._names.indexOf(name2);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name2) {
    return this._names.indexOf(name2) >= 0;
  }
};
function classedAdd$1(node, names) {
  var list = classList$1(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove$1(node, names) {
  var list = classList$1(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue$1(names) {
  return function() {
    classedAdd$1(this, names);
  };
}
function classedFalse$1(names) {
  return function() {
    classedRemove$1(this, names);
  };
}
function classedFunction$1(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd$1 : classedRemove$1)(this, names);
  };
}
function selection_classed$1(name2, value) {
  var names = classArray$1(name2 + "");
  if (arguments.length < 2) {
    var list = classList$1(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction$1 : value ? classedTrue$1 : classedFalse$1)(names, value));
}
function textRemove$1() {
  this.textContent = "";
}
function textConstant$2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$2(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.textContent = v2 == null ? "" : v2;
  };
}
function selection_text$1(value) {
  return arguments.length ? this.each(value == null ? textRemove$1 : (typeof value === "function" ? textFunction$2 : textConstant$2)(value)) : this.node().textContent;
}
function htmlRemove$1() {
  this.innerHTML = "";
}
function htmlConstant$1(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction$1(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.innerHTML = v2 == null ? "" : v2;
  };
}
function selection_html$1(value) {
  return arguments.length ? this.each(value == null ? htmlRemove$1 : (typeof value === "function" ? htmlFunction$1 : htmlConstant$1)(value)) : this.node().innerHTML;
}
function raise$1() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise$1() {
  return this.each(raise$1);
}
function lower$1() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower$1() {
  return this.each(lower$1);
}
function selection_append$1(name2) {
  var create2 = typeof name2 === "function" ? name2 : creator$1(name2);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull$1() {
  return null;
}
function selection_insert$1(name2, before) {
  var create2 = typeof name2 === "function" ? name2 : creator$1(name2), select2 = before == null ? constantNull$1 : typeof before === "function" ? before : selector$1(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove$1() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function selection_remove$1() {
  return this.each(remove$1);
}
function selection_cloneShallow() {
  var clone2 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum$1(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener$1(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames$2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name: name2 };
  });
}
function onRemove$1(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd$1(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener$1(value);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function selection_on$1(typename, value, options) {
  var typenames = parseTypenames$2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd$1 : onRemove$1;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}
function dispatchEvent$1(node, type2, params) {
  var window2 = defaultView$1(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant$1(type2, params) {
  return function() {
    return dispatchEvent$1(this, type2, params);
  };
}
function dispatchFunction$1(type2, params) {
  return function() {
    return dispatchEvent$1(this, type2, params.apply(this, arguments));
  };
}
function selection_dispatch$1(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction$1 : dispatchConstant$1)(type2, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        yield node;
    }
  }
}
var root$1 = [null];
function Selection$2(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection$2([[document.documentElement]], root$1);
}
function selection_selection() {
  return this;
}
Selection$2.prototype = selection.prototype = {
  constructor: Selection$2,
  select: selection_select$1,
  selectAll: selection_selectAll$1,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter$1,
  data: selection_data$1,
  enter: selection_enter$1,
  exit: selection_exit$1,
  join: selection_join,
  merge: selection_merge$1,
  selection: selection_selection,
  order: selection_order$1,
  sort: selection_sort$1,
  call: selection_call$1,
  nodes: selection_nodes$1,
  node: selection_node$1,
  size: selection_size$1,
  empty: selection_empty$1,
  each: selection_each$1,
  attr: selection_attr$1,
  style: selection_style$1,
  property: selection_property$1,
  classed: selection_classed$1,
  text: selection_text$1,
  html: selection_html$1,
  raise: selection_raise$1,
  lower: selection_lower$1,
  append: selection_append$1,
  insert: selection_insert$1,
  remove: selection_remove$1,
  clone: selection_clone,
  datum: selection_datum$1,
  on: selection_on$1,
  dispatch: selection_dispatch$1,
  [Symbol.iterator]: selection_iterator
};
function select$1(selector2) {
  return typeof selector2 === "string" ? new Selection$2([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$2([[selector2]], root$1);
}
function define$1(constructor, factory2, prototype) {
  constructor.prototype = factory2.prototype = prototype;
  prototype.constructor = constructor;
}
function extend$2(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color$1() {
}
var darker$1 = 0.7;
var brighter$1 = 1 / darker$1;
var reI$1 = "\\s*([+-]?\\d+)\\s*", reN$1 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP$1 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex$1 = /^#([0-9a-f]{3,8})$/, reRgbInteger$1 = new RegExp(`^rgb\\(${reI$1},${reI$1},${reI$1}\\)$`), reRgbPercent$1 = new RegExp(`^rgb\\(${reP$1},${reP$1},${reP$1}\\)$`), reRgbaInteger$1 = new RegExp(`^rgba\\(${reI$1},${reI$1},${reI$1},${reN$1}\\)$`), reRgbaPercent$1 = new RegExp(`^rgba\\(${reP$1},${reP$1},${reP$1},${reN$1}\\)$`), reHslPercent$1 = new RegExp(`^hsl\\(${reN$1},${reP$1},${reP$1}\\)$`), reHslaPercent$1 = new RegExp(`^hsla\\(${reN$1},${reP$1},${reP$1},${reN$1}\\)$`);
var named$1 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define$1(Color$1, color$2, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex$1,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex$1,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl$1,
  formatRgb: color_formatRgb$1,
  toString: color_formatRgb$1
});
function color_formatHex$1() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl$1() {
  return hslConvert$1(this).formatHsl();
}
function color_formatRgb$1() {
  return this.rgb().formatRgb();
}
function color$2(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex$1.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn$1(m) : l === 3 ? new Rgb$1(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba$1(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba$1(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger$1.exec(format2)) ? new Rgb$1(m[1], m[2], m[3], 1) : (m = reRgbPercent$1.exec(format2)) ? new Rgb$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger$1.exec(format2)) ? rgba$1(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent$1.exec(format2)) ? rgba$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent$1.exec(format2)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent$1.exec(format2)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, m[4]) : named$1.hasOwnProperty(format2) ? rgbn$1(named$1[format2]) : format2 === "transparent" ? new Rgb$1(NaN, NaN, NaN, 0) : null;
}
function rgbn$1(n) {
  return new Rgb$1(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba$1(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb$1(r, g, b, a);
}
function rgbConvert$1(o) {
  if (!(o instanceof Color$1))
    o = color$2(o);
  if (!o)
    return new Rgb$1();
  o = o.rgb();
  return new Rgb$1(o.r, o.g, o.b, o.opacity);
}
function rgb$2(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert$1(r) : new Rgb$1(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb$1(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define$1(Rgb$1, rgb$2, extend$2(Color$1, {
  brighter(k) {
    k = k == null ? brighter$1 : Math.pow(brighter$1, k);
    return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker$1 : Math.pow(darker$1, k);
    return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb$1(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex$1,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex$1,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb$1,
  toString: rgb_formatRgb$1
}));
function rgb_formatHex$1() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}${hex$1((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb$1() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex$1(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla$1(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl$1(h, s, l, a);
}
function hslConvert$1(o) {
  if (o instanceof Hsl$1)
    return new Hsl$1(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color$1))
    o = color$2(o);
  if (!o)
    return new Hsl$1();
  if (o instanceof Hsl$1)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r === max2)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max2)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl$1(h, s, l, o.opacity);
}
function hsl$1(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert$1(h) : new Hsl$1(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl$1(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define$1(Hsl$1, hsl$1, extend$2(Color$1, {
  brighter(k) {
    k = k == null ? brighter$1 : Math.pow(brighter$1, k);
    return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker$1 : Math.pow(darker$1, k);
    return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb$1(
      hsl2rgb$1(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb$1(h, m1, m2),
      hsl2rgb$1(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl$1(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb$1(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
const radians = Math.PI / 180;
const degrees$1 = 180 / Math.PI;
var A$1 = -0.14861, B$1 = 1.78277, C$1 = -0.29227, D$1 = -0.90649, E$1 = 1.97294, ED$1 = E$1 * D$1, EB$1 = E$1 * B$1, BC_DA$1 = B$1 * C$1 - D$1 * A$1;
function cubehelixConvert$1(o) {
  if (o instanceof Cubehelix$1)
    return new Cubehelix$1(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb$1))
    o = rgbConvert$1(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA$1 * b + ED$1 * r - EB$1 * g) / (BC_DA$1 + ED$1 - EB$1), bl = b - l, k = (E$1 * (g - l) - C$1 * bl) / D$1, s = Math.sqrt(k * k + bl * bl) / (E$1 * l * (1 - l)), h = s ? Math.atan2(k, bl) * degrees$1 - 120 : NaN;
  return new Cubehelix$1(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix$3(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert$1(h) : new Cubehelix$1(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix$1(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define$1(Cubehelix$1, cubehelix$3, extend$2(Color$1, {
  brighter(k) {
    k = k == null ? brighter$1 : Math.pow(brighter$1, k);
    return new Cubehelix$1(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker$1 : Math.pow(darker$1, k);
    return new Cubehelix$1(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb$1(
      255 * (l + a * (A$1 * cosh2 + B$1 * sinh2)),
      255 * (l + a * (C$1 * cosh2 + D$1 * sinh2)),
      255 * (l + a * (E$1 * cosh2)),
      this.opacity
    );
  }
}));
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis$1(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}
const constant$3 = (x) => () => x;
function linear$2(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential$1(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue$1(a, b) {
  var d = b - a;
  return d ? linear$2(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
}
function gamma$1(y) {
  return (y = +y) === 1 ? nogamma$1 : function(a, b) {
    return b - a ? exponential$1(a, b, y) : constant$3(isNaN(a) ? b : a);
  };
}
function nogamma$1(a, b) {
  var d = b - a;
  return d ? linear$2(a, d) : constant$3(isNaN(a) ? b : a);
}
const interpolateRgb = function rgbGamma(y) {
  var color2 = gamma$1(y);
  function rgb2(start2, end) {
    var r = color2((start2 = rgb$2(start2)).r, (end = rgb$2(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma$1(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors2) {
    var n = colors2.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb$2(colors2[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis$1);
function numberArray$1(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c2 = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c2[i] = a[i] * (1 - t) + b[i] * t;
    return c2;
  };
}
function isNumberArray$1(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
function genericArray$1(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x[i] = interpolate$1(a[i], b[i]);
  for (; i < nb; ++i)
    c2[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c2[i] = x[i](t);
    return c2;
  };
}
function date$1(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}
function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}
function object$1(a, b) {
  var i = {}, c2 = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = interpolate$1(a[k], b[k]);
    } else {
      c2[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c2[k] = i[k](t);
    return c2;
  };
}
var reA$1 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB$1 = new RegExp(reA$1.source, "g");
function zero$1(b) {
  return function() {
    return b;
  };
}
function one$1(b) {
  return function(t) {
    return b(t) + "";
  };
}
function interpolateString(a, b) {
  var bi = reA$1.lastIndex = reB$1.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA$1.exec(a)) && (bm = reB$1.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB$1.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one$1(q[0].x) : zero$1(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}
function interpolate$1(a, b) {
  var t = typeof b, c2;
  return b == null || t === "boolean" ? constant$3(b) : (t === "number" ? interpolateNumber : t === "string" ? (c2 = color$2(b)) ? (b = c2, interpolateRgb) : interpolateString : b instanceof color$2 ? interpolateRgb : b instanceof Date ? date$1 : isNumberArray$1(b) ? numberArray$1 : Array.isArray(b) ? genericArray$1 : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1 : interpolateNumber)(a, b);
}
function interpolateRound$1(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}
var degrees = 180 / Math.PI;
var identity$4 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a, b, c2, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c2 + b * d)
    c2 -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c2 * c2 + d * d))
    c2 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c2)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity$4 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null)
    return identity$4;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity$4;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse2(a), b = parse2(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
function cubehelix$2(hue2) {
  return function cubehelixGamma(y) {
    y = +y;
    function cubehelix2(start2, end) {
      var h = hue2((start2 = cubehelix$3(start2)).h, (end = cubehelix$3(end)).h), s = nogamma$1(start2.s, end.s), l = nogamma$1(start2.l, end.l), opacity = nogamma$1(start2.opacity, end.opacity);
      return function(t) {
        start2.h = h(t);
        start2.s = s(t);
        start2.l = l(Math.pow(t, y));
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    cubehelix2.gamma = cubehelixGamma;
    return cubehelix2;
  }(1);
}
cubehelix$2(hue$1);
var cubehelixLong$1 = cubehelix$2(nogamma$1);
var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout$1)
    timeout$1 = clearTimeout(timeout$1);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}
var emptyOn = dispatch$1("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node, name2, id2, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name: name2,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init$1(node, id2) {
  var schedule2 = get$2(node, id2);
  if (schedule2.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule2;
}
function set$1(node, id2) {
  var schedule2 = get$2(node, id2);
  if (schedule2.state > STARTED)
    throw new Error("too late; already running");
  return schedule2;
}
function get$2(node, id2) {
  var schedule2 = node.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2]))
    throw new Error("transition not found");
  return schedule2;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self2.name)
        continue;
      if (o.state === STARTED)
        return timeout(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node.__transition;
  }
}
function interrupt(node, name2) {
  var schedules = node.__transition, schedule2, active2, empty2 = true, i;
  if (!schedules)
    return;
  name2 = name2 == null ? null : name2 + "";
  for (i in schedules) {
    if ((schedule2 = schedules[i]).name !== name2) {
      empty2 = false;
      continue;
    }
    active2 = schedule2.state > STARTING && schedule2.state < ENDING;
    schedule2.state = ENDED;
    schedule2.timer.stop();
    schedule2.on.call(active2 ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
    delete schedules[i];
  }
  if (empty2)
    delete node.__transition;
}
function selection_interrupt(name2) {
  return this.each(function() {
    interrupt(this, name2);
  });
}
function tweenRemove(id2, name2) {
  var tween0, tween1;
  return function() {
    var schedule2 = set$1(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name2) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name2, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule2 = set$1(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name: name2, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name2) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name2, value) {
  var id2 = this._id;
  name2 += "";
  if (arguments.length < 2) {
    var tween = get$2(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name2) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name2, value));
}
function tweenValue(transition, name2, value) {
  var id2 = transition._id;
  transition.each(function() {
    var schedule2 = set$1(this, id2);
    (schedule2.value || (schedule2.value = {}))[name2] = value.apply(this, arguments);
  });
  return function(node) {
    return get$2(node, id2).value[name2];
  };
}
function interpolate(a, b) {
  var c2;
  return (typeof b === "number" ? interpolateNumber : b instanceof color$2 ? interpolateRgb : (c2 = color$2(b)) ? (b = c2, interpolateRgb) : interpolateString)(a, b);
}
function attrRemove$1(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name2, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS$1(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction$1(name2, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name2);
    string0 = this.getAttribute(name2);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS$1(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr(name2, value) {
  var fullname = namespace$1(name2), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name2, typeof value === "function" ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name2, value)) : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname) : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
}
function attrInterpolate(name2, i) {
  return function(t) {
    this.setAttribute(name2, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name2, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolate(name2, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_attrTween(name2, value) {
  var key = "attr." + name2;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace$1(name2);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init$1(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init$1(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get$2(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set$1(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set$1(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get$2(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set$1(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get$2(this.node(), id2).ease;
}
function easeVarying(id2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (typeof v2 !== "function")
      throw new Error();
    set$1(this, id2).ease = v2;
  };
}
function transition_easeVarying(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}
function transition_filter(match) {
  if (typeof match !== "function")
    match = matcher$2(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge3 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge3[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
function start(name2) {
  return (name2 + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name2, listener) {
  var on0, on1, sit = start(name2) ? init$1 : set$1;
  return function() {
    var schedule2 = sit(this, id2), on = schedule2.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name2, listener);
    schedule2.on = on1;
  };
}
function transition_on(name2, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get$2(this.node(), id2).on.on(name2) : this.each(onFunction(id2, name2, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name2 = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selector$1(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name2, id2, i, subgroup, get$2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name2, id2);
}
function transition_selectAll(select2) {
  var name2 = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selectorAll$1(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select2.call(node, node.__data__, i, group), child, inherit2 = get$2(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule(child, name2, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name2, id2);
}
var Selection$1 = selection.prototype.constructor;
function transition_selection() {
  return new Selection$1(this._groups, this._parents);
}
function styleNull(name2, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), string1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove$1(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant$1(name2, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction$1(name2, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name2) {
  var on0, on1, listener0, key = "style." + name2, event = "end." + key, remove2;
  return function() {
    var schedule2 = set$1(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove$1(name2)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style(name2, value, priority) {
  var i = (name2 += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this.styleTween(name2, styleNull(name2, i)).on("end.style." + name2, styleRemove$1(name2)) : typeof value === "function" ? this.styleTween(name2, styleFunction$1(name2, i, tweenValue(this, "style." + name2, value))).each(styleMaybeRemove(this._id, name2)) : this.styleTween(name2, styleConstant$1(name2, i, value), priority).on("end.style." + name2, null);
}
function styleInterpolate(name2, i, priority) {
  return function(t) {
    this.style.setProperty(name2, i.call(this, t), priority);
  };
}
function styleTween(name2, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name2, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function transition_styleTween(name2, value, priority) {
  var key = "style." + (name2 += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name2, value, priority == null ? "" : priority));
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value) {
  return this.tween("text", typeof value === "function" ? textFunction$1(tweenValue(this, "text", value)) : textConstant$1(value == null ? "" : value + ""));
}
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}
function transition_transition() {
  var name2 = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get$2(node, id0);
        schedule(node, name2, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name2, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size2 = that.size();
  return new Promise(function(resolve2, reject2) {
    var cancel = { value: reject2 }, end = { value: function() {
      if (--size2 === 0)
        resolve2();
    } };
    that.each(function() {
      var schedule2 = set$1(this, id2), on = schedule2.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule2.on = on1;
    });
    if (size2 === 0)
      resolve2();
  });
}
var id = 0;
function Transition(groups, parents, name2, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name2;
  this._id = id2;
}
function newId() {
  return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function selection_transition(name2) {
  var id2, timing;
  if (name2 instanceof Transition) {
    id2 = name2._id, name2 = name2._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name2 = name2 == null ? null : name2 + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name2, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name2, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
function formatDecimal$1(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}
function exponent$1(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}
function formatGroup$1(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re$1 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier$1(specifier) {
  if (!(match = re$1.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier$1({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier$1.prototype = FormatSpecifier$1.prototype;
function FormatSpecifier$1(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier$1.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
var prefixExponent$1;
function formatPrefixAuto$1(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent$1 = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}
function formatRounded$1(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes$1 = {
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal$1,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded$1(x * 100, p),
  "r": formatRounded$1,
  "s": formatPrefixAuto$1,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};
function identity$3(x) {
  return x;
}
var map$3 = Array.prototype.map, prefixes$1 = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$1(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$3 : formatGroup$1(map$3.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$3 : formatNumerals(map$3.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier$1(specifier);
    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes$1[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes$1[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix2, valueSuffix = suffix, i, n, c2;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim(value);
        if (valueNegative && +value === 0 && sign3 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes$1[8 + prefixExponent$1 / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier$1(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3, k = Math.pow(10, -e), prefix2 = prefixes$1[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale$1;
var format$5;
var formatPrefix$1;
defaultLocale$1({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  format$5 = locale$1.format;
  formatPrefix$1 = locale$1.formatPrefix;
  return locale$1;
}
function precisionFixed$1(step) {
  return Math.max(0, -exponent$1(Math.abs(step)));
}
function precisionPrefix$1(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
}
function precisionRound$1(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent$1(max2) - exponent$1(step)) + 1;
}
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function")
        this.interpolator(domain);
      else
        this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}
const implicit = Symbol("implicit");
function ordinal() {
  var index = new InternMap(), domain = [], range2 = [], unknown = implicit;
  function scale(d) {
    let i = index.get(d);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index.set(d, i = domain.push(d) - 1);
    }
    return range2[i % range2.length];
  }
  scale.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index = new InternMap();
    for (const value of _) {
      if (index.has(value))
        continue;
      index.set(value, domain.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), scale) : range2.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range2).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}
function identity$2(x) {
  return x;
}
function tickFormat$1(start2, stop, count, specifier) {
  var step = tickStep$1(start2, stop, count), precision;
  specifier = formatSpecifier$1(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix$1(step, value)))
        specifier.precision = precision;
      return formatPrefix$1(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound$1(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed$1(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format$5(specifier);
}
function linearish$1(scale) {
  var domain = scale.domain;
  scale.ticks = function(count) {
    var d = domain();
    return ticks$1(d[0], d[d.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat$1(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };
  scale.nice = function(count) {
    if (count == null)
      count = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function transformer() {
  var x0 = 0, x1 = 1, t0, t1, k10, transform, interpolator = identity$2, clamp2 = false, unknown;
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp2 ? Math.max(0, Math.min(1, x)) : x));
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale) : clamp2;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range2(interpolate2) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }
  scale.range = range2(interpolate$1);
  scale.rangeRound = range2(interpolateRound$1);
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}
function copy$1(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = linearish$1(transformer()(identity$2));
  scale.copy = function() {
    return copy$1(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}
function colors$1(specifier) {
  var n = specifier.length / 6 | 0, colors2 = new Array(n), i = 0;
  while (i < n)
    colors2[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors2;
}
const Dark2 = colors$1("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");
const Paired = colors$1("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
const Set1 = colors$1("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");
const Set2 = colors$1("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");
const Set3 = colors$1("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
const Tableau10 = colors$1("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
const ramp$2 = (scheme2) => rgbBasis(scheme2[scheme2.length - 1]);
var scheme$3 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors$1);
const RdBu = ramp$2(scheme$3);
var scheme$2 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors$1);
const Blues = ramp$2(scheme$2);
var scheme$1 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors$1);
const Greens = ramp$2(scheme$1);
var scheme = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors$1);
const Reds = ramp$2(scheme);
cubehelixLong$1(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.5, 0.8));
cubehelixLong$1(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.5, 0.8));
var c = cubehelix$3();
function rainbow(t) {
  if (t < 0 || t > 1)
    t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c.h = 360 * t - 100;
  c.s = 1.5 - 1.5 * ts;
  c.l = 0.8 - 0.9 * ts;
  return c + "";
}
function turbo(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}
function ramp$1(range2) {
  var n = range2.length;
  return function(t) {
    return range2[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
const viridis = ramp$1(colors$1("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp$1(colors$1("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
ramp$1(colors$1("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp$1(colors$1("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
function Transform$1(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform$1.prototype = {
  constructor: Transform$1,
  scale: function(k) {
    return k === 1 ? this : new Transform$1(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform$1(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
Transform$1.prototype;
function fade(node, { delay = 0, duration = 400, easing = identity$5 } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
function setCustomFontSize(element, size2) {
  if (size2 && size2 !== "lg" && size2 !== "sm" && size2 !== "xs") {
    element.style.fontSize = size2.replace("x", "em");
  } else {
    element.style.fontSize = "";
  }
}
function getTransform(scale, translateX, translateY, rotate, flip, translateTimes = 1, translateUnit = "", rotateUnit = "") {
  let flipX = 1;
  let flipY = 1;
  if (flip) {
    if (flip == "horizontal") {
      flipX = -1;
    } else if (flip == "vertical") {
      flipY = -1;
    } else {
      flipX = flipY = -1;
    }
  }
  if (typeof scale === "string") {
    scale = parseFloat(scale);
  }
  if (typeof translateX === "string") {
    translateX = parseFloat(translateX);
  }
  if (typeof translateY === "string") {
    translateY = parseFloat(translateY);
  }
  const x = `${translateX * translateTimes}${translateUnit}`;
  const y = `${translateY * translateTimes}${translateUnit}`;
  let output = `translate(${x},${y}) scale(${flipX * scale},${flipY * scale})`;
  if (rotate) {
    output += ` rotate(${rotate}${rotateUnit})`;
  }
  return output;
}
function create_if_block$9(ctx) {
  let svg;
  let g1;
  let g0;
  let g1_transform_value;
  let g1_transform_origin_value;
  let svg_class_value;
  let svg_viewBox_value;
  let svg_aria_hidden_value;
  let if_block0 = (
    /*title*/
    ctx[3] && create_if_block_2$6(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (typeof /*i*/
    ctx2[17][4] == "string")
      return create_if_block_1$6;
    return create_else_block$6;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      svg = svg_element("svg");
      if (if_block0)
        if_block0.c();
      g1 = svg_element("g");
      g0 = svg_element("g");
      if_block1.c();
      attr(
        g0,
        "transform",
        /*transform*/
        ctx[16]
      );
      attr(g1, "transform", g1_transform_value = "translate(" + /*i*/
      ctx[17][0] / 2 + " " + /*i*/
      ctx[17][1] / 2 + ")");
      attr(g1, "transform-origin", g1_transform_origin_value = /*i*/
      ctx[17][0] / 4 + " 0");
      attr(
        svg,
        "id",
        /*id*/
        ctx[1]
      );
      attr(svg, "class", svg_class_value = "svelte-fa svelte-fa-base " + /*clazz*/
      ctx[0] + " svelte-bvo74f");
      attr(
        svg,
        "style",
        /*style*/
        ctx[2]
      );
      attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*i*/
      ctx[17][0] + " " + /*i*/
      ctx[17][1]);
      attr(svg, "aria-hidden", svg_aria_hidden_value = /*title*/
      ctx[3] === void 0);
      attr(svg, "role", "img");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      toggle_class(
        svg,
        "pulse",
        /*pulse*/
        ctx[9]
      );
      toggle_class(
        svg,
        "svelte-fa-size-lg",
        /*size*/
        ctx[4] === "lg"
      );
      toggle_class(
        svg,
        "svelte-fa-size-sm",
        /*size*/
        ctx[4] === "sm"
      );
      toggle_class(
        svg,
        "svelte-fa-size-xs",
        /*size*/
        ctx[4] === "xs"
      );
      toggle_class(
        svg,
        "svelte-fa-fw",
        /*fw*/
        ctx[6]
      );
      toggle_class(
        svg,
        "svelte-fa-pull-left",
        /*pull*/
        ctx[7] === "left"
      );
      toggle_class(
        svg,
        "svelte-fa-pull-right",
        /*pull*/
        ctx[7] === "right"
      );
      toggle_class(
        svg,
        "spin",
        /*spin*/
        ctx[8]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      if (if_block0)
        if_block0.m(svg, null);
      append(svg, g1);
      append(g1, g0);
      if_block1.m(g0, null);
      ctx[24](svg);
    },
    p(ctx2, dirty) {
      if (
        /*title*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$6(ctx2);
          if_block0.c();
          if_block0.m(svg, g1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(g0, null);
        }
      }
      if (dirty & /*transform*/
      65536) {
        attr(
          g0,
          "transform",
          /*transform*/
          ctx2[16]
        );
      }
      if (dirty & /*i*/
      131072 && g1_transform_value !== (g1_transform_value = "translate(" + /*i*/
      ctx2[17][0] / 2 + " " + /*i*/
      ctx2[17][1] / 2 + ")")) {
        attr(g1, "transform", g1_transform_value);
      }
      if (dirty & /*i*/
      131072 && g1_transform_origin_value !== (g1_transform_origin_value = /*i*/
      ctx2[17][0] / 4 + " 0")) {
        attr(g1, "transform-origin", g1_transform_origin_value);
      }
      if (dirty & /*id*/
      2) {
        attr(
          svg,
          "id",
          /*id*/
          ctx2[1]
        );
      }
      if (dirty & /*clazz*/
      1 && svg_class_value !== (svg_class_value = "svelte-fa svelte-fa-base " + /*clazz*/
      ctx2[0] + " svelte-bvo74f")) {
        attr(svg, "class", svg_class_value);
      }
      if (dirty & /*style*/
      4) {
        attr(
          svg,
          "style",
          /*style*/
          ctx2[2]
        );
      }
      if (dirty & /*i*/
      131072 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*i*/
      ctx2[17][0] + " " + /*i*/
      ctx2[17][1])) {
        attr(svg, "viewBox", svg_viewBox_value);
      }
      if (dirty & /*title*/
      8 && svg_aria_hidden_value !== (svg_aria_hidden_value = /*title*/
      ctx2[3] === void 0)) {
        attr(svg, "aria-hidden", svg_aria_hidden_value);
      }
      if (dirty & /*clazz, pulse*/
      513) {
        toggle_class(
          svg,
          "pulse",
          /*pulse*/
          ctx2[9]
        );
      }
      if (dirty & /*clazz, size*/
      17) {
        toggle_class(
          svg,
          "svelte-fa-size-lg",
          /*size*/
          ctx2[4] === "lg"
        );
      }
      if (dirty & /*clazz, size*/
      17) {
        toggle_class(
          svg,
          "svelte-fa-size-sm",
          /*size*/
          ctx2[4] === "sm"
        );
      }
      if (dirty & /*clazz, size*/
      17) {
        toggle_class(
          svg,
          "svelte-fa-size-xs",
          /*size*/
          ctx2[4] === "xs"
        );
      }
      if (dirty & /*clazz, fw*/
      65) {
        toggle_class(
          svg,
          "svelte-fa-fw",
          /*fw*/
          ctx2[6]
        );
      }
      if (dirty & /*clazz, pull*/
      129) {
        toggle_class(
          svg,
          "svelte-fa-pull-left",
          /*pull*/
          ctx2[7] === "left"
        );
      }
      if (dirty & /*clazz, pull*/
      129) {
        toggle_class(
          svg,
          "svelte-fa-pull-right",
          /*pull*/
          ctx2[7] === "right"
        );
      }
      if (dirty & /*clazz, spin*/
      257) {
        toggle_class(
          svg,
          "spin",
          /*spin*/
          ctx2[8]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      if (if_block0)
        if_block0.d();
      if_block1.d();
      ctx[24](null);
    }
  };
}
function create_if_block_2$6(ctx) {
  let title_1;
  let t;
  return {
    c() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, title_1, anchor);
      append(title_1, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*title*/
      8)
        set_data(
          t,
          /*title*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(title_1);
      }
    }
  };
}
function create_else_block$6(ctx) {
  let path0;
  let path0_d_value;
  let path0_fill_value;
  let path0_fill_opacity_value;
  let path0_transform_value;
  let path1;
  let path1_d_value;
  let path1_fill_value;
  let path1_fill_opacity_value;
  let path1_transform_value;
  return {
    c() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "d", path0_d_value = /*i*/
      ctx[17][4][0]);
      attr(path0, "fill", path0_fill_value = /*secondaryColor*/
      ctx[11] || /*color*/
      ctx[5] || "currentColor");
      attr(path0, "fill-opacity", path0_fill_opacity_value = /*swapOpacity*/
      ctx[14] != false ? (
        /*primaryOpacity*/
        ctx[12]
      ) : (
        /*secondaryOpacity*/
        ctx[13]
      ));
      attr(path0, "transform", path0_transform_value = "translate(" + /*i*/
      ctx[17][0] / -2 + " " + /*i*/
      ctx[17][1] / -2 + ")");
      attr(path1, "d", path1_d_value = /*i*/
      ctx[17][4][1]);
      attr(path1, "fill", path1_fill_value = /*primaryColor*/
      ctx[10] || /*color*/
      ctx[5] || "currentColor");
      attr(path1, "fill-opacity", path1_fill_opacity_value = /*swapOpacity*/
      ctx[14] != false ? (
        /*secondaryOpacity*/
        ctx[13]
      ) : (
        /*primaryOpacity*/
        ctx[12]
      ));
      attr(path1, "transform", path1_transform_value = "translate(" + /*i*/
      ctx[17][0] / -2 + " " + /*i*/
      ctx[17][1] / -2 + ")");
    },
    m(target, anchor) {
      insert(target, path0, anchor);
      insert(target, path1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*i*/
      131072 && path0_d_value !== (path0_d_value = /*i*/
      ctx2[17][4][0])) {
        attr(path0, "d", path0_d_value);
      }
      if (dirty & /*secondaryColor, color*/
      2080 && path0_fill_value !== (path0_fill_value = /*secondaryColor*/
      ctx2[11] || /*color*/
      ctx2[5] || "currentColor")) {
        attr(path0, "fill", path0_fill_value);
      }
      if (dirty & /*swapOpacity, primaryOpacity, secondaryOpacity*/
      28672 && path0_fill_opacity_value !== (path0_fill_opacity_value = /*swapOpacity*/
      ctx2[14] != false ? (
        /*primaryOpacity*/
        ctx2[12]
      ) : (
        /*secondaryOpacity*/
        ctx2[13]
      ))) {
        attr(path0, "fill-opacity", path0_fill_opacity_value);
      }
      if (dirty & /*i*/
      131072 && path0_transform_value !== (path0_transform_value = "translate(" + /*i*/
      ctx2[17][0] / -2 + " " + /*i*/
      ctx2[17][1] / -2 + ")")) {
        attr(path0, "transform", path0_transform_value);
      }
      if (dirty & /*i*/
      131072 && path1_d_value !== (path1_d_value = /*i*/
      ctx2[17][4][1])) {
        attr(path1, "d", path1_d_value);
      }
      if (dirty & /*primaryColor, color*/
      1056 && path1_fill_value !== (path1_fill_value = /*primaryColor*/
      ctx2[10] || /*color*/
      ctx2[5] || "currentColor")) {
        attr(path1, "fill", path1_fill_value);
      }
      if (dirty & /*swapOpacity, secondaryOpacity, primaryOpacity*/
      28672 && path1_fill_opacity_value !== (path1_fill_opacity_value = /*swapOpacity*/
      ctx2[14] != false ? (
        /*secondaryOpacity*/
        ctx2[13]
      ) : (
        /*primaryOpacity*/
        ctx2[12]
      ))) {
        attr(path1, "fill-opacity", path1_fill_opacity_value);
      }
      if (dirty & /*i*/
      131072 && path1_transform_value !== (path1_transform_value = "translate(" + /*i*/
      ctx2[17][0] / -2 + " " + /*i*/
      ctx2[17][1] / -2 + ")")) {
        attr(path1, "transform", path1_transform_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(path0);
        detach(path1);
      }
    }
  };
}
function create_if_block_1$6(ctx) {
  let path;
  let path_d_value;
  let path_fill_value;
  let path_transform_value;
  return {
    c() {
      path = svg_element("path");
      attr(path, "d", path_d_value = /*i*/
      ctx[17][4]);
      attr(path, "fill", path_fill_value = /*color*/
      ctx[5] || /*primaryColor*/
      ctx[10] || "currentColor");
      attr(path, "transform", path_transform_value = "translate(" + /*i*/
      ctx[17][0] / -2 + " " + /*i*/
      ctx[17][1] / -2 + ")");
    },
    m(target, anchor) {
      insert(target, path, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*i*/
      131072 && path_d_value !== (path_d_value = /*i*/
      ctx2[17][4])) {
        attr(path, "d", path_d_value);
      }
      if (dirty & /*color, primaryColor*/
      1056 && path_fill_value !== (path_fill_value = /*color*/
      ctx2[5] || /*primaryColor*/
      ctx2[10] || "currentColor")) {
        attr(path, "fill", path_fill_value);
      }
      if (dirty & /*i*/
      131072 && path_transform_value !== (path_transform_value = "translate(" + /*i*/
      ctx2[17][0] / -2 + " " + /*i*/
      ctx2[17][1] / -2 + ")")) {
        attr(path, "transform", path_transform_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(path);
      }
    }
  };
}
function create_fragment$j(ctx) {
  let if_block_anchor;
  let if_block = (
    /*i*/
    ctx[17][4] && create_if_block$9(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty$2();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*i*/
        ctx2[17][4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$9(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let i;
  let transform;
  let { class: clazz = void 0 } = $$props;
  let { id: id2 = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { icon } = $$props;
  let { title = void 0 } = $$props;
  let { size: size2 = void 0 } = $$props;
  let { color: color2 = void 0 } = $$props;
  let { fw = false } = $$props;
  let { pull = void 0 } = $$props;
  let { scale = 1 } = $$props;
  let { translateX = 0 } = $$props;
  let { translateY = 0 } = $$props;
  let { rotate = void 0 } = $$props;
  let { flip = void 0 } = $$props;
  let { spin = false } = $$props;
  let { pulse = false } = $$props;
  let { primaryColor = "" } = $$props;
  let { secondaryColor = "" } = $$props;
  let { primaryOpacity = 1 } = $$props;
  let { secondaryOpacity = 0.4 } = $$props;
  let { swapOpacity = false } = $$props;
  let svgElement;
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      svgElement = $$value;
      $$invalidate(15, svgElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, clazz = $$props2.class);
    if ("id" in $$props2)
      $$invalidate(1, id2 = $$props2.id);
    if ("style" in $$props2)
      $$invalidate(2, style = $$props2.style);
    if ("icon" in $$props2)
      $$invalidate(18, icon = $$props2.icon);
    if ("title" in $$props2)
      $$invalidate(3, title = $$props2.title);
    if ("size" in $$props2)
      $$invalidate(4, size2 = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(5, color2 = $$props2.color);
    if ("fw" in $$props2)
      $$invalidate(6, fw = $$props2.fw);
    if ("pull" in $$props2)
      $$invalidate(7, pull = $$props2.pull);
    if ("scale" in $$props2)
      $$invalidate(19, scale = $$props2.scale);
    if ("translateX" in $$props2)
      $$invalidate(20, translateX = $$props2.translateX);
    if ("translateY" in $$props2)
      $$invalidate(21, translateY = $$props2.translateY);
    if ("rotate" in $$props2)
      $$invalidate(22, rotate = $$props2.rotate);
    if ("flip" in $$props2)
      $$invalidate(23, flip = $$props2.flip);
    if ("spin" in $$props2)
      $$invalidate(8, spin = $$props2.spin);
    if ("pulse" in $$props2)
      $$invalidate(9, pulse = $$props2.pulse);
    if ("primaryColor" in $$props2)
      $$invalidate(10, primaryColor = $$props2.primaryColor);
    if ("secondaryColor" in $$props2)
      $$invalidate(11, secondaryColor = $$props2.secondaryColor);
    if ("primaryOpacity" in $$props2)
      $$invalidate(12, primaryOpacity = $$props2.primaryOpacity);
    if ("secondaryOpacity" in $$props2)
      $$invalidate(13, secondaryOpacity = $$props2.secondaryOpacity);
    if ("swapOpacity" in $$props2)
      $$invalidate(14, swapOpacity = $$props2.swapOpacity);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*svgElement, size*/
    32784) {
      if (svgElement && size2) {
        setCustomFontSize(svgElement, size2);
      }
    }
    if ($$self.$$.dirty & /*icon*/
    262144) {
      $$invalidate(17, i = icon && icon.icon || [0, 0, "", [], ""]);
    }
    if ($$self.$$.dirty & /*scale, translateX, translateY, rotate, flip*/
    16252928) {
      $$invalidate(16, transform = getTransform(scale, translateX, translateY, rotate, flip, 512));
    }
  };
  return [
    clazz,
    id2,
    style,
    title,
    size2,
    color2,
    fw,
    pull,
    spin,
    pulse,
    primaryColor,
    secondaryColor,
    primaryOpacity,
    secondaryOpacity,
    swapOpacity,
    svgElement,
    transform,
    i,
    icon,
    scale,
    translateX,
    translateY,
    rotate,
    flip,
    svg_binding
  ];
}
class Fa extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$l, create_fragment$j, safe_not_equal, {
      class: 0,
      id: 1,
      style: 2,
      icon: 18,
      title: 3,
      size: 4,
      color: 5,
      fw: 6,
      pull: 7,
      scale: 19,
      translateX: 20,
      translateY: 21,
      rotate: 22,
      flip: 23,
      spin: 8,
      pulse: 9,
      primaryColor: 10,
      secondaryColor: 11,
      primaryOpacity: 12,
      secondaryOpacity: 13,
      swapOpacity: 14
    });
  }
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var faExclamationTriangle = {};
var faTriangleExclamation = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "triangle-exclamation";
  var width = 512;
  var height = 512;
  var aliases = [9888, "exclamation-triangle", "warning"];
  var unicode = "f071";
  var svgPathData = "M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480L40 480c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24l0 112c0 13.3 10.7 24 24 24s24-10.7 24-24l0-112c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z";
  exports.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      aliases,
      unicode,
      svgPathData
    ]
  };
  exports.faTriangleExclamation = exports.definition;
  exports.prefix = prefix2;
  exports.iconName = iconName;
  exports.width = width;
  exports.height = height;
  exports.ligatures = aliases;
  exports.unicode = unicode;
  exports.svgPathData = svgPathData;
  exports.aliases = aliases;
})(faTriangleExclamation);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var source = faTriangleExclamation;
  exports.definition = {
    prefix: source.prefix,
    iconName: source.iconName,
    icon: [
      source.width,
      source.height,
      source.aliases,
      source.unicode,
      source.svgPathData
    ]
  };
  exports.faExclamationTriangle = exports.definition;
  exports.prefix = source.prefix;
  exports.iconName = source.iconName;
  exports.width = source.width;
  exports.height = source.height;
  exports.ligatures = source.aliases;
  exports.unicode = source.unicode;
  exports.svgPathData = source.svgPathData;
  exports.aliases = source.aliases;
})(faExclamationTriangle);
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      return constructor.resolve(callback()).then(function() {
        return constructor.reject(reason);
      });
    }
  );
}
function allSettled(arr) {
  var P2 = this;
  return new P2(function(resolve2, reject2) {
    if (!(arr && typeof arr.length !== "undefined")) {
      return reject2(
        new TypeError(
          typeof arr + " " + arr + " is not iterable(cannot read property Symbol(Symbol.iterator))"
        )
      );
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return resolve2([]);
    var remaining = args.length;
    function res(i2, val) {
      if (val && (typeof val === "object" || typeof val === "function")) {
        var then = val.then;
        if (typeof then === "function") {
          then.call(
            val,
            function(val2) {
              res(i2, val2);
            },
            function(e) {
              args[i2] = { status: "rejected", reason: e };
              if (--remaining === 0) {
                resolve2(args);
              }
            }
          );
          return;
        }
      }
      args[i2] = { status: "fulfilled", value: val };
      if (--remaining === 0) {
        resolve2(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
}
function AggregateError$1(errors, message) {
  this.name = "AggregateError", this.errors = errors;
  this.message = message || "";
}
AggregateError$1.prototype = Error.prototype;
function any(arr) {
  var P2 = this;
  return new P2(function(resolve2, reject2) {
    if (!(arr && typeof arr.length !== "undefined")) {
      return reject2(new TypeError("Promise.any accepts an array"));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return reject2();
    var rejectionReasons = [];
    for (var i = 0; i < args.length; i++) {
      try {
        P2.resolve(args[i]).then(resolve2).catch(function(error) {
          rejectionReasons.push(error);
          if (rejectionReasons.length === args.length) {
            reject2(
              new AggregateError$1(
                rejectionReasons,
                "All promises were rejected"
              )
            );
          }
        });
      } catch (ex) {
        reject2(ex);
      }
    }
  });
}
var setTimeoutFunc = setTimeout;
function isArray$5(x) {
  return Boolean(x && typeof x.length !== "undefined");
}
function noop$1() {
}
function bind$3(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}
function Promise$1(fn) {
  if (!(this instanceof Promise$1))
    throw new TypeError("Promises must be constructed via new");
  if (typeof fn !== "function")
    throw new TypeError("not a function");
  this._state = 0;
  this._handled = false;
  this._value = void 0;
  this._deferreds = [];
  doResolve(fn, this);
}
function handle(self2, deferred) {
  while (self2._state === 3) {
    self2 = self2._value;
  }
  if (self2._state === 0) {
    self2._deferreds.push(deferred);
    return;
  }
  self2._handled = true;
  Promise$1._immediateFn(function() {
    var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self2._state === 1 ? resolve$1 : reject)(deferred.promise, self2._value);
      return;
    }
    var ret;
    try {
      ret = cb(self2._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve$1(deferred.promise, ret);
  });
}
function resolve$1(self2, newValue) {
  try {
    if (newValue === self2)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
      var then = newValue.then;
      if (newValue instanceof Promise$1) {
        self2._state = 3;
        self2._value = newValue;
        finale(self2);
        return;
      } else if (typeof then === "function") {
        doResolve(bind$3(then, newValue), self2);
        return;
      }
    }
    self2._state = 1;
    self2._value = newValue;
    finale(self2);
  } catch (e) {
    reject(self2, e);
  }
}
function reject(self2, newValue) {
  self2._state = 2;
  self2._value = newValue;
  finale(self2);
}
function finale(self2) {
  if (self2._state === 2 && self2._deferreds.length === 0) {
    Promise$1._immediateFn(function() {
      if (!self2._handled) {
        Promise$1._unhandledRejectionFn(self2._value);
      }
    });
  }
  for (var i = 0, len = self2._deferreds.length; i < len; i++) {
    handle(self2, self2._deferreds[i]);
  }
  self2._deferreds = null;
}
function Handler(onFulfilled, onRejected, promise2) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.promise = promise2;
}
function doResolve(fn, self2) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done)
          return;
        done = true;
        resolve$1(self2, value);
      },
      function(reason) {
        if (done)
          return;
        done = true;
        reject(self2, reason);
      }
    );
  } catch (ex) {
    if (done)
      return;
    done = true;
    reject(self2, ex);
  }
}
Promise$1.prototype["catch"] = function(onRejected) {
  return this.then(null, onRejected);
};
Promise$1.prototype.then = function(onFulfilled, onRejected) {
  var prom = new this.constructor(noop$1);
  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};
Promise$1.prototype["finally"] = finallyConstructor;
Promise$1.all = function(arr) {
  return new Promise$1(function(resolve2, reject2) {
    if (!isArray$5(arr)) {
      return reject2(new TypeError("Promise.all accepts an array"));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return resolve2([]);
    var remaining = args.length;
    function res(i2, val) {
      try {
        if (val && (typeof val === "object" || typeof val === "function")) {
          var then = val.then;
          if (typeof then === "function") {
            then.call(
              val,
              function(val2) {
                res(i2, val2);
              },
              reject2
            );
            return;
          }
        }
        args[i2] = val;
        if (--remaining === 0) {
          resolve2(args);
        }
      } catch (ex) {
        reject2(ex);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};
Promise$1.any = any;
Promise$1.allSettled = allSettled;
Promise$1.resolve = function(value) {
  if (value && typeof value === "object" && value.constructor === Promise$1) {
    return value;
  }
  return new Promise$1(function(resolve2) {
    resolve2(value);
  });
};
Promise$1.reject = function(value) {
  return new Promise$1(function(resolve2, reject2) {
    reject2(value);
  });
};
Promise$1.race = function(arr) {
  return new Promise$1(function(resolve2, reject2) {
    if (!isArray$5(arr)) {
      return reject2(new TypeError("Promise.race accepts an array"));
    }
    for (var i = 0, len = arr.length; i < len; i++) {
      Promise$1.resolve(arr[i]).then(resolve2, reject2);
    }
  });
};
Promise$1._immediateFn = // @ts-ignore
typeof setImmediate === "function" && function(fn) {
  setImmediate(fn);
} || function(fn) {
  setTimeoutFunc(fn, 0);
};
Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== "undefined" && console) {
    console.warn("Possible Unhandled Promise Rejection:", err);
  }
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
      return test2[n];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (hasOwnProperty$1.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
const objectAssign$1 = /* @__PURE__ */ getDefaultExportFromCjs(objectAssign);
/*!
 * @pixi/polyfill - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
if (typeof globalThis === "undefined") {
  if (typeof self !== "undefined") {
    self.globalThis = self;
  } else if (typeof global !== "undefined") {
    global.globalThis = global;
  }
}
if (!globalThis.Promise) {
  globalThis.Promise = Promise$1;
}
if (!Object.assign) {
  Object.assign = objectAssign$1;
}
var ONE_FRAME_TIME = 16;
if (!(Date.now && Date.prototype.getTime)) {
  Date.now = function now2() {
    return (/* @__PURE__ */ new Date()).getTime();
  };
}
if (!(globalThis.performance && globalThis.performance.now)) {
  var startTime_1 = Date.now();
  if (!globalThis.performance) {
    globalThis.performance = {};
  }
  globalThis.performance.now = function() {
    return Date.now() - startTime_1;
  };
}
var lastTime = Date.now();
var vendors = ["ms", "moz", "webkit", "o"];
for (var x = 0; x < vendors.length && !globalThis.requestAnimationFrame; ++x) {
  var p = vendors[x];
  globalThis.requestAnimationFrame = globalThis[p + "RequestAnimationFrame"];
  globalThis.cancelAnimationFrame = globalThis[p + "CancelAnimationFrame"] || globalThis[p + "CancelRequestAnimationFrame"];
}
if (!globalThis.requestAnimationFrame) {
  globalThis.requestAnimationFrame = function(callback) {
    if (typeof callback !== "function") {
      throw new TypeError(callback + "is not a function");
    }
    var currentTime = Date.now();
    var delay = ONE_FRAME_TIME + lastTime - currentTime;
    if (delay < 0) {
      delay = 0;
    }
    lastTime = currentTime;
    return globalThis.self.setTimeout(function() {
      lastTime = Date.now();
      callback(performance.now());
    }, delay);
  };
}
if (!globalThis.cancelAnimationFrame) {
  globalThis.cancelAnimationFrame = function(id2) {
    return clearTimeout(id2);
  };
}
if (!Math.sign) {
  Math.sign = function mathSign(x) {
    x = Number(x);
    if (x === 0 || isNaN(x)) {
      return x;
    }
    return x > 0 ? 1 : -1;
  };
}
if (!Number.isInteger) {
  Number.isInteger = function numberIsInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
}
if (!globalThis.ArrayBuffer) {
  globalThis.ArrayBuffer = Array;
}
if (!globalThis.Float32Array) {
  globalThis.Float32Array = Array;
}
if (!globalThis.Uint32Array) {
  globalThis.Uint32Array = Array;
}
if (!globalThis.Uint16Array) {
  globalThis.Uint16Array = Array;
}
if (!globalThis.Uint8Array) {
  globalThis.Uint8Array = Array;
}
if (!globalThis.Int32Array) {
  globalThis.Int32Array = Array;
}
/*!
 * @pixi/constants - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV || (ENV = {}));
var RENDERER_TYPE;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var BUFFER_BITS;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS || (BUFFER_BITS = {}));
var BLEND_MODES;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES || (BLEND_MODES = {}));
var DRAW_MODES;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES || (DRAW_MODES = {}));
var FORMATS;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS || (FORMATS = {}));
var TARGETS;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS || (TARGETS = {}));
var TYPES;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES || (TYPES = {}));
var SAMPLER_TYPES;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));
var SCALE_MODES;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES || (SCALE_MODES = {}));
var WRAP_MODES;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES || (WRAP_MODES = {}));
var MIPMAP_MODES;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES || (MIPMAP_MODES = {}));
var ALPHA_MODES;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES || (ALPHA_MODES = {}));
var CLEAR_MODES;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES || (CLEAR_MODES = {}));
var GC_MODES;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES || (GC_MODES = {}));
var PRECISION;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION || (PRECISION = {}));
var MASK_TYPES;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
  MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";
})(MASK_TYPES || (MASK_TYPES = {}));
var COLOR_MASK_BITS;
(function(COLOR_MASK_BITS2) {
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["RED"] = 1] = "RED";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["GREEN"] = 2] = "GREEN";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["BLUE"] = 4] = "BLUE";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["ALPHA"] = 8] = "ALPHA";
})(COLOR_MASK_BITS || (COLOR_MASK_BITS = {}));
var MSAA_QUALITY;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY || (MSAA_QUALITY = {}));
var BUFFER_TYPE;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE || (BUFFER_TYPE = {}));
/*!
 * @pixi/settings - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var BrowserAdapter = {
  /**
   * Creates a canvas element of the given size.
   * This canvas is created using the browser's native canvas element.
   * @param width - width of the canvas
   * @param height - height of the canvas
   */
  createCanvas: function(width, height) {
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var _a2;
    return (_a2 = document.baseURI) !== null && _a2 !== void 0 ? _a2 : window.location.href;
  },
  fetch: function(url2, options) {
    return fetch(url2, options);
  }
};
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile$1(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
var isMobile = isMobile$1(globalThis.navigator);
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
function maxRecommendedTextures(max2) {
  var allowMax = true;
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile.android.device) {
      var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max2 : 4;
}
var settings = {
  /**
   * This adapter is used to call methods that are platform dependent.
   * For example `document.createElement` only runs on the web but fails in node environments.
   * This allows us to support more platforms by abstracting away specific implementations per platform.
   *
   * By default the adapter is set to work in the browser. However you can create your own
   * by implementing the `IAdapter` interface. See `IAdapter` for more information.
   * @name ADAPTER
   * @memberof PIXI.settings
   * @type {PIXI.IAdapter}
   * @default PIXI.BrowserAdapter
   */
  ADAPTER: BrowserAdapter,
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: MIPMAP_MODES.POW2,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @type {PIXI.MSAA_QUALITY}
   * @default PIXI.MSAA_QUALITY.NONE
   */
  FILTER_MULTISAMPLE: MSAA_QUALITY.NONE,
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {boolean} [antialias=false] - {@link PIXI.IRendererOptions.antialias}
   * @property {boolean} [autoDensity=false] - {@link PIXI.IRendererOptions.autoDensity}
   * @property {number} [backgroundAlpha=1] - {@link PIXI.IRendererOptions.backgroundAlpha}
   * @property {number} [backgroundColor=0x000000] - {@link PIXI.IRendererOptions.backgroundColor}
   * @property {boolean} [clearBeforeRender=true] - {@link PIXI.IRendererOptions.clearBeforeRender}
   * @property {number} [height=600] - {@link PIXI.IRendererOptions.height}
   * @property {boolean} [preserveDrawingBuffer=false] - {@link PIXI.IRendererOptions.preserveDrawingBuffer}
   * @property {boolean|'notMultiplied'} [useContextAlpha=true] - {@link PIXI.IRendererOptions.useContextAlpha}
   * @property {HTMLCanvasElement} [view=null] - {@link PIXI.IRendererOptions.view}
   * @property {number} [width=800] - {@link PIXI.IRendererOptions.width}
   */
  RENDER_OPTIONS: {
    view: null,
    width: 800,
    height: 600,
    autoDensity: false,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: true,
    clearBeforeRender: true,
    antialias: false,
    preserveDrawingBuffer: false
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: GC_MODES.AUTO,
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: WRAP_MODES.CLAMP,
  /**
   * Default scale mode for textures.
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: SCALE_MODES.LINEAR,
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: PRECISION.HIGH,
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM,
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: false,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: false
};
var eventemitter3 = { exports: {} };
(function(module) {
  var has2 = Object.prototype.hasOwnProperty, prefix2 = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix2 = false;
  }
  function EE(fn, context2, once) {
    this.fn = fn;
    this.context = context2;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context2, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context2 || emitter, once), evt = prefix2 ? prefix2 + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name2;
    if (this._eventsCount === 0)
      return names;
    for (name2 in events = this._events) {
      if (has2.call(events, name2))
        names.push(prefix2 ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context2) {
    return addListener(this, event, fn, context2, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context2) {
    return addListener(this, event, fn, context2, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context2 && listeners[i].context !== context2) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix2 ? prefix2 + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix2;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  var minX, minY, maxX, maxY, x, y, invSize;
  if (hasHoles)
    outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];
    for (var i = dim; i < outerLen; i += dim) {
      x = data[i];
      y = data[i + 1];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start2, end, dim, clockwise) {
  var i, last;
  if (clockwise === signedArea(data, start2, end, dim) > 0) {
    for (i = start2; i < end; i += dim)
      last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start2; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start2, end) {
  if (!start2)
    return start2;
  if (!end)
    end = start2;
  var p = start2, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  var stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a = ear.prev, b = ear, c2 = ear.next;
  if (area(a, b, c2) >= 0)
    return false;
  var ax = a.x, bx = b.x, cx = c2.x, ay = a.y, by = b.y, cy = c2.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var p = c2.next;
  while (p !== a) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev, b = ear, c2 = ear.next;
  if (area(a, b, c2) >= 0)
    return false;
  var ax = a.x, bx = b.x, cx = c2.x, ay = a.y, by = b.y, cy = c2.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  var p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start2, triangles, dim) {
  var p = start2;
  do {
    var a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b.i / dim | 0);
      removeNode(p);
      removeNode(p.next);
      p = start2 = b;
    }
    p = p.next;
  } while (p !== start2);
  return filterPoints(p);
}
function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
  var a = start2;
  do {
    var b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        var c2 = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start2);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [], i, len, start2, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start2 = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start2, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx)
          return m;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m)
    return null;
  var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan2 = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan2;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start2, minX, minY, invSize) {
  var p = start2;
  do {
    if (p.z === 0)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start2);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e;
        else
          list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start2) {
  var p = start2, leftmost = start2;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start2);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  var o1 = sign$4(area(p1, q1, p2));
  var o2 = sign$4(area(p1, q1, q2));
  var o3 = sign$4(area(p2, q2, p1));
  var o4 = sign$4(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign$4(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  var p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  var a2 = new Node$1(a.i, a.x, a.y), b2 = new Node$1(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  var p = new Node$1(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node$1(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i = 0, len = holeIndices.length; i < len; i++) {
      var start2 = holeIndices[i] * dim;
      var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start2, end, dim));
    }
  }
  var trianglesArea = 0;
  for (i = 0; i < triangles.length; i += 3) {
    var a = triangles[i] * dim;
    var b = triangles[i + 1] * dim;
    var c2 = triangles[i + 2] * dim;
    trianglesArea += Math.abs(
      (data[a] - data[c2]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c2 + 1] - data[a + 1])
    );
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start2, end, dim) {
  var sum2 = 0;
  for (var i = start2, j = end - dim; i < end; i += dim) {
    sum2 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum2;
}
earcut.flatten = function(data) {
  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i = 0; i < data.length; i++) {
    for (var j = 0; j < data[i].length; j++) {
      for (var d = 0; d < dim; d++)
        result.vertices.push(data[i][j][d]);
    }
    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcutExports = earcut$2.exports;
const earcut$1 = /* @__PURE__ */ getDefaultExportFromCjs(earcutExports);
var punycode$1 = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
punycode$1.exports;
(function(module, exports) {
  (function(root2) {
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = module && !module.nodeType && module;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
      root2 = freeGlobal;
    }
    var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, baseMinusTMin = base - tMin, floor2 = Math.floor, stringFromCharCode = String.fromCharCode, key;
    function error(type2) {
      throw new RangeError(errors[type2]);
    }
    function map2(array2, fn) {
      var length = array2.length;
      var result = [];
      while (length--) {
        result[length] = fn(array2[length]);
      }
      return result;
    }
    function mapDomain(string2, fn) {
      var parts = string2.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string2 = parts[1];
      }
      string2 = string2.replace(regexSeparators, ".");
      var labels = string2.split(".");
      var encoded = map2(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string2) {
      var output = [], counter = 0, length = string2.length, value, extra;
      while (counter < length) {
        value = string2.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          extra = string2.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function ucs2encode(array2) {
      return map2(array2, function(value) {
        var output = "";
        if (value > 65535) {
          value -= 65536;
          output += stringFromCharCode(value >>> 10 & 1023 | 55296);
          value = 56320 | value & 1023;
        }
        output += stringFromCharCode(value);
        return output;
      }).join("");
    }
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor2(delta / damp) : delta >> 1;
      delta += floor2(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor2(delta / baseMinusTMin);
      }
      return floor2(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    function decode2(input) {
      var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
      basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        for (oldi = i, w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor2((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          baseMinusT = base - t;
          if (w > floor2(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor2(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor2(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return ucs2encode(output);
    }
    function encode3(input) {
      var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
      input = ucs2decode(input);
      inputLength = input.length;
      n = initialN;
      delta = 0;
      bias = initialBias;
      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      handledCPCount = basicLength = output.length;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        for (m = maxInt, j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor2((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue == n) {
            for (q = delta, k = base; ; k += base) {
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              qMinusT = q - t;
              baseMinusT = base - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor2(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function(string2) {
        return regexPunycode.test(string2) ? decode2(string2.slice(4).toLowerCase()) : string2;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function(string2) {
        return regexNonASCII.test(string2) ? "xn--" + encode3(string2) : string2;
      });
    }
    punycode2 = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "1.4.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode2,
      "encode": encode3,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    if (freeExports && freeModule) {
      if (module.exports == freeExports) {
        freeModule.exports = punycode2;
      } else {
        for (key in punycode2) {
          punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
        }
      }
    } else {
      root2.punycode = punycode2;
    }
  })(commonjsGlobal);
})(punycode$1, punycode$1.exports);
var punycodeExports = punycode$1.exports;
var type = TypeError;
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize$1 = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace$1 = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat$1 = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
  return O.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace$1.call(intStr, sepRegex, "$&_") + "." + $replace$1.call($replace$1.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace$1.call(str, sepRegex, "$&_");
}
var utilInspect = require$$0;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var quotes = {
  __proto__: null,
  "double": '"',
  single: "'"
};
var quoteREs = {
  __proto__: null,
  "double": /(["\\])/g,
  single: /(['\\])/g
};
var objectInspect = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has$3(opts, "quoteStyle") && !has$3(quotes, opts.quoteStyle)) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$4(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function" && !isRegExp$2(obj)) {
    var name2 = nameOf(obj);
    var keys = arrObjKeys(obj, inspect2);
    return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace$1.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i = 0; i < attrs.length; i++) {
      s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
    }
    s += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s += "...";
    }
    s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s;
  }
  if (isArray$4(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat$1.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap$1(obj)) {
    var mapParts = [];
    if (mapForEach) {
      mapForEach.call(obj, function(value, key) {
        mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
      });
    }
    return collectionOf("Map", mapSize$1.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    if (setForEach) {
      setForEach.call(obj, function(value) {
        setParts.push(inspect2(value, obj));
      });
    }
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber$1(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean$1(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString$1(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (typeof window !== "undefined" && obj === window) {
    return "{ [object Window] }";
  }
  if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
    return "{ [object globalThis] }";
  }
  if (!isDate$1(obj) && !isRegExp$2(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag2 = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat$1.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag2 + "{}";
    }
    if (indent) {
      return tag2 + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag2 + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s, defaultStyle2, opts) {
  var style = opts.quoteStyle || defaultStyle2;
  var quoteChar = quotes[style];
  return quoteChar + s + quoteChar;
}
function quote(s) {
  return $replace$1.call(String(s), /"/g, "&quot;");
}
function canTrustToString(obj) {
  return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
}
function isArray$4(obj) {
  return toStr(obj) === "[object Array]" && canTrustToString(obj);
}
function isDate$1(obj) {
  return toStr(obj) === "[object Date]" && canTrustToString(obj);
}
function isRegExp$2(obj) {
  return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && canTrustToString(obj);
}
function isString$1(obj) {
  return toStr(obj) === "[object String]" && canTrustToString(obj);
}
function isNumber$1(obj) {
  return toStr(obj) === "[object Number]" && canTrustToString(obj);
}
function isBoolean$1(obj) {
  return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
var hasOwn$1 = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$3(obj, key) {
  return hasOwn$1.call(obj, key);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f) {
  if (f.name) {
    return f.name;
  }
  var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
  if (m) {
    return m[1];
  }
  return null;
}
function indexOf(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) {
      return i;
    }
  }
  return -1;
}
function isMap$1(x) {
  if (!mapSize$1 || !x || typeof x !== "object") {
    return false;
  }
  try {
    mapSize$1.call(x);
    try {
      setSize.call(x);
    } catch (s) {
      return true;
    }
    return x instanceof Map;
  } catch (e) {
  }
  return false;
}
function isWeakMap(x) {
  if (!weakMapHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x, weakMapHas);
    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakMap;
  } catch (e) {
  }
  return false;
}
function isWeakRef(x) {
  if (!weakRefDeref || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {
  }
  return false;
}
function isSet(x) {
  if (!setSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    setSize.call(x);
    try {
      mapSize$1.call(x);
    } catch (m) {
      return true;
    }
    return x instanceof Set;
  } catch (e) {
  }
  return false;
}
function isWeakSet(x) {
  if (!weakSetHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x, weakSetHas);
    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakSet;
  } catch (e) {
  }
  return false;
}
function isElement(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
    return true;
  }
  return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var quoteRE = quoteREs[opts.quoteStyle || "single"];
  quoteRE.lastIndex = 0;
  var s = $replace$1.call($replace$1.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, "single", opts);
}
function lowbyte(c2) {
  var n = c2.charCodeAt(0);
  var x = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n];
  if (x) {
    return "\\" + x;
  }
  return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type2) {
  return type2 + " { ? }";
}
function collectionOf(type2, size2, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type2 + " (" + size2 + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf(xs[i], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$4(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i = 0; i < obj.length; i++) {
      xs[i] = has$3(obj, i) ? inspect2(obj[i], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k = 0; k < syms.length; k++) {
      symMap["$" + syms[k]] = syms[k];
    }
  }
  for (var key in obj) {
    if (!has$3(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
      }
    }
  }
  return xs;
}
var inspect$3 = objectInspect;
var $TypeError$5 = type;
var listGetNode = function(list, key, isDelete) {
  var prev = list;
  var curr;
  for (; (curr = prev.next) != null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      if (!isDelete) {
        curr.next = /** @type {NonNullable<typeof list.next>} */
        list.next;
        list.next = curr;
      }
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  if (!objects) {
    return void 0;
  }
  var node = listGetNode(objects, key);
  return node && node.value;
};
var listSet = function(objects, key, value) {
  var node = listGetNode(objects, key);
  if (node) {
    node.value = value;
  } else {
    objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  if (!objects) {
    return false;
  }
  return !!listGetNode(objects, key);
};
var listDelete = function(objects, key) {
  if (objects) {
    return listGetNode(objects, key, true);
  }
};
var sideChannelList = function getSideChannelList() {
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError$5("Side channel does not contain " + inspect$3(key));
      }
    },
    "delete": function(key) {
      var root2 = $o && $o.next;
      var deletedNode = listDelete($o, key);
      if (deletedNode && root2 && root2 === deletedNode) {
        $o = void 0;
      }
      return !!deletedNode;
    },
    get: function(key) {
      return listGet($o, key);
    },
    has: function(key) {
      return listHas($o, key);
    },
    set: function(key, value) {
      if (!$o) {
        $o = {
          next: void 0
        };
      }
      listSet(
        /** @type {NonNullable<typeof $o>} */
        $o,
        key,
        value
      );
    }
  };
  return channel;
};
var esObjectAtoms = Object;
var esErrors = Error;
var _eval = EvalError;
var range = RangeError;
var ref = ReferenceError;
var syntax = SyntaxError;
var uri = URIError;
var abs$3 = Math.abs;
var floor$2 = Math.floor;
var max$2 = Math.max;
var min$2 = Math.min;
var pow$2 = Math.pow;
var round$3 = Math.round;
var _isNaN = Number.isNaN || function isNaN2(a) {
  return a !== a;
};
var $isNaN = _isNaN;
var sign$3 = function sign(number2) {
  if ($isNaN(number2) || number2 === 0) {
    return number2;
  }
  return number2 < 0 ? -1 : 1;
};
var gOPD = Object.getOwnPropertyDescriptor;
var $gOPD$1 = gOPD;
if ($gOPD$1) {
  try {
    $gOPD$1([], "length");
  } catch (e) {
    $gOPD$1 = null;
  }
}
var gopd = $gOPD$1;
var $defineProperty$1 = Object.defineProperty || false;
if ($defineProperty$1) {
  try {
    $defineProperty$1({}, "a", { value: 1 });
  } catch (e) {
    $defineProperty$1 = false;
  }
}
var esDefineProperty = $defineProperty$1;
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams;
}
var hasSymbols$1;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols$1;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams();
  hasSymbols$1 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols$1;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf)
    return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf)
    return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object2 = esObjectAtoms;
  Object_getPrototypeOf = $Object2.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr2 = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr2.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind)
    return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall)
    return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply)
    return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
var bind$2 = requireFunctionBind();
var $apply$1 = requireFunctionApply();
var $call$2 = requireFunctionCall();
var $reflectApply = reflectApply;
var actualApply = $reflectApply || bind$2.call($call$2, $apply$1);
var bind$1 = requireFunctionBind();
var $TypeError$4 = type;
var $call$1 = requireFunctionCall();
var $actualApply = actualApply;
var callBindApplyHelpers = function callBindBasic(args) {
  if (args.length < 1 || typeof args[0] !== "function") {
    throw new $TypeError$4("a function is required");
  }
  return $actualApply(bind$1, $call$1, args);
};
var get$1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet)
    return get$1;
  hasRequiredGet = 1;
  var callBind = callBindApplyHelpers;
  var gOPD2 = gopd;
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object2 = Object;
  var $getPrototypeOf = $Object2.getPrototypeOf;
  get$1 = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object2(value));
    }
  ) : false;
  return get$1;
}
var getProto$1;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto)
    return getProto$1;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = requireGet();
  getProto$1 = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto$1;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown)
    return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call, $hasOwn);
  return hasown;
}
var undefined$1;
var $Object = esObjectAtoms;
var $Error = esErrors;
var $EvalError = _eval;
var $RangeError = range;
var $ReferenceError = ref;
var $SyntaxError = syntax;
var $TypeError$3 = type;
var $URIError = uri;
var abs$2 = abs$3;
var floor$1 = floor$2;
var max$1 = max$2;
var min$1 = min$2;
var pow$1 = pow$2;
var round$2 = round$3;
var sign$2 = sign$3;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD = gopd;
var $defineProperty = esDefineProperty;
var throwTypeError = function() {
  throw new $TypeError$3();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = requireHasSymbols()();
var getProto = requireGetProto();
var $ObjectGPO = requireObject_getPrototypeOf();
var $ReflectGPO = requireReflect_getPrototypeOf();
var $apply = requireFunctionApply();
var $call = requireFunctionCall();
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply,
  "%Object.defineProperty%": $defineProperty,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs$2,
  "%Math.floor%": floor$1,
  "%Math.max%": max$1,
  "%Math.min%": min$1,
  "%Math.pow%": pow$1,
  "%Math.round%": round$2,
  "%Math.sign%": sign$2,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto) {
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind = requireFunctionBind();
var hasOwn = requireHasown();
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string2) {
  var first = $strSlice(string2, 0, 1);
  var last = $strSlice(string2, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string2, rePropName, function(match, number2, quote2, subString) {
    result[result.length] = quote2 ? $replace(subString, reEscapeChar, "$1") : number2 || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$3("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name2) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$3("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var GetIntrinsic$2 = getIntrinsic;
var callBindBasic2 = callBindApplyHelpers;
var $indexOf = callBindBasic2([GetIntrinsic$2("%String.prototype.indexOf%")]);
var callBound$2 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = (
    /** @type {(this: unknown, ...args: unknown[]) => unknown} */
    GetIntrinsic$2(name2, !!allowMissing)
  );
  if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
    return callBindBasic2(
      /** @type {const} */
      [intrinsic]
    );
  }
  return intrinsic;
};
var GetIntrinsic$1 = getIntrinsic;
var callBound$1 = callBound$2;
var inspect$2 = objectInspect;
var $TypeError$2 = type;
var $Map = GetIntrinsic$1("%Map%", true);
var $mapGet = callBound$1("Map.prototype.get", true);
var $mapSet = callBound$1("Map.prototype.set", true);
var $mapHas = callBound$1("Map.prototype.has", true);
var $mapDelete = callBound$1("Map.prototype.delete", true);
var $mapSize = callBound$1("Map.prototype.size", true);
var sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */
function getSideChannelMap() {
  var $m;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError$2("Side channel does not contain " + inspect$2(key));
      }
    },
    "delete": function(key) {
      if ($m) {
        var result = $mapDelete($m, key);
        if ($mapSize($m) === 0) {
          $m = void 0;
        }
        return result;
      }
      return false;
    },
    get: function(key) {
      if ($m) {
        return $mapGet($m, key);
      }
    },
    has: function(key) {
      if ($m) {
        return $mapHas($m, key);
      }
      return false;
    },
    set: function(key, value) {
      if (!$m) {
        $m = new $Map();
      }
      $mapSet($m, key, value);
    }
  };
  return channel;
};
var GetIntrinsic2 = getIntrinsic;
var callBound = callBound$2;
var inspect$1 = objectInspect;
var getSideChannelMap$1 = sideChannelMap;
var $TypeError$1 = type;
var $WeakMap = GetIntrinsic2("%WeakMap%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
var sideChannelWeakmap = $WeakMap ? (
  /** @type {Exclude<import('.'), false>} */
  function getSideChannelWeakMap() {
    var $wm;
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError$1("Side channel does not contain " + inspect$1(key));
        }
      },
      "delete": function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapDelete($wm, key);
          }
        } else if (getSideChannelMap$1) {
          if ($m) {
            return $m["delete"](key);
          }
        }
        return false;
      },
      get: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        }
        return $m && $m.get(key);
      },
      has: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        }
        return !!$m && $m.has(key);
      },
      set: function(key, value) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm) {
            $wm = new $WeakMap();
          }
          $weakMapSet($wm, key, value);
        } else if (getSideChannelMap$1) {
          if (!$m) {
            $m = getSideChannelMap$1();
          }
          $m.set(key, value);
        }
      }
    };
    return channel;
  }
) : getSideChannelMap$1;
var $TypeError = type;
var inspect = objectInspect;
var getSideChannelList2 = sideChannelList;
var getSideChannelMap2 = sideChannelMap;
var getSideChannelWeakMap2 = sideChannelWeakmap;
var makeChannel = getSideChannelWeakMap2 || getSideChannelMap2 || getSideChannelList2;
var sideChannel = function getSideChannel() {
  var $channelData;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError("Side channel does not contain " + inspect(key));
      }
    },
    "delete": function(key) {
      return !!$channelData && $channelData["delete"](key);
    },
    get: function(key) {
      return $channelData && $channelData.get(key);
    },
    has: function(key) {
      return !!$channelData && $channelData.has(key);
    },
    set: function(key, value) {
      if (!$channelData) {
        $channelData = makeChannel();
      }
      $channelData.set(key, value);
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$4 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$3 = formats$4;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$3 = Array.isArray;
var hexTable = function() {
  var array2 = [];
  for (var i = 0; i < 256; ++i) {
    array2.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array2;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$3(obj)) {
      var compacted = [];
      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== "undefined") {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? { __proto__: null } : {};
  for (var i = 0; i < source.length; ++i) {
    if (typeof source[i] !== "undefined") {
      obj[i] = source[i];
    }
  }
  return obj;
};
var merge = function merge2(target, source, options) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object" && typeof source !== "function") {
    if (isArray$3(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$3(target) && !isArray$3(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$3(target) && isArray$3(source)) {
    source.forEach(function(item, i) {
      if (has$2.call(target, i)) {
        var targetItem = target[i];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i] = merge2(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge2(acc[key], value, options);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign$1 = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode = function(str, defaultDecoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};
var limit = 1024;
var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
  if (str.length === 0) {
    return str;
  }
  var string2 = str;
  if (typeof str === "symbol") {
    string2 = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string2 = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var j = 0; j < string2.length; j += limit) {
    var segment = string2.length >= limit ? string2.slice(j, j + limit) : string2;
    var arr = [];
    for (var i = 0; i < segment.length; ++i) {
      var c2 = segment.charCodeAt(i);
      if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats$3.RFC1738 && (c2 === 40 || c2 === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c2 < 128) {
        arr[arr.length] = hexTable[c2];
        continue;
      }
      if (c2 < 2048) {
        arr[arr.length] = hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
        continue;
      }
      if (c2 < 55296 || c2 >= 57344) {
        arr[arr.length] = hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
        continue;
      }
      i += 1;
      c2 = 65536 + ((c2 & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
    }
    out += arr.join("");
  }
  return out;
};
var compact = function compact2(value) {
  var queue = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i = 0; i < queue.length; ++i) {
    var item = queue[i];
    var obj = item.obj[item.prop];
    var keys = Object.keys(obj);
    for (var j = 0; j < keys.length; ++j) {
      var key = keys[j];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value;
};
var isRegExp$1 = function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a, b) {
  return [].concat(a, b);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$3(val)) {
    var mapped = [];
    for (var i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$2 = {
  arrayToObject,
  assign: assign$1,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp: isRegExp$1,
  maybeMap,
  merge
};
var getSideChannel2 = sideChannel;
var utils$1 = utils$2;
var formats$2 = formats$4;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix2) {
    return prefix2 + "[]";
  },
  comma: "comma",
  indices: function indices(prefix2, key) {
    return prefix2 + "[" + key + "]";
  },
  repeat: function repeat(prefix2) {
    return prefix2;
  }
};
var isArray$2 = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray$2(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$2["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  commaRoundTrip: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  filter: void 0,
  format: defaultFormat,
  formatter: formats$2.formatters[defaultFormat],
  // deprecated
  indices: false,
  serializeDate: function serializeDate(date2) {
    return toISO.call(date2);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
  return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
};
var sentinel = {};
var stringify$1 = function stringify(object2, prefix2, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object2;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos = tmpSc.get(object2);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter2 === "function") {
    obj = filter2(prefix2, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$2(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix2, defaults$1.encoder, charset, "key", format2) : prefix2;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix2 : encoder(prefix2, defaults$1.encoder, charset, "key", format2);
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format2))];
    }
    return [formatter(prefix2) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$2(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = utils$1.maybeMap(obj, encoder);
    }
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$2(filter2)) {
    objKeys = filter2;
  } else {
    var keys = Object.keys(obj);
    objKeys = sort ? keys.sort(sort) : keys;
  }
  var encodedPrefix = encodeDotInKeys ? String(prefix2).replace(/\./g, "%2E") : String(prefix2);
  var adjustedPrefix = commaRoundTrip && isArray$2(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
  if (allowEmptyArrays && isArray$2(obj) && obj.length === 0) {
    return adjustedPrefix + "[]";
  }
  for (var j = 0; j < objKeys.length; ++j) {
    var key = objKeys[j];
    var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
    var keyPrefix2 = isArray$2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
    sideChannel2.set(object2, step);
    var valueSideChannel = getSideChannel2();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify(
      value,
      keyPrefix2,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray$2(obj) ? null : encoder,
      filter2,
      sort,
      allowDots,
      serializeDate2,
      format2,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format2 = formats$2["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$2.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  var formatter = formats$2.formatters[format2];
  var filter2 = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$2(opts.filter)) {
    filter2 = opts.filter;
  }
  var arrayFormat;
  if (opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults$1.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults$1.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$1.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults$1.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter: filter2,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object2, opts) {
  var obj = object2;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter2;
  if (typeof options.filter === "function") {
    filter2 = options.filter;
    obj = filter2("", obj);
  } else if (isArray$2(options.filter)) {
    filter2 = options.filter;
    objKeys = filter2;
  }
  var keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
  var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];
    var value = obj[key];
    if (options.skipNulls && value === null) {
      continue;
    }
    pushToArray(keys, stringify$1(
      value,
      key,
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel2
    ));
  }
  var joined = keys.join(options.delimiter);
  var prefix2 = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix2 += "utf8=%26%2310003%3B&";
    } else {
      prefix2 += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix2 + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var isArray$1 = Array.isArray;
var defaults = {
  allowDots: false,
  allowEmptyArrays: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decodeDotInKeys: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  duplicates: "combine",
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictDepth: false,
  strictNullHandling: false,
  throwOnLimitExceeded: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options, currentArrayLength) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
    throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = { __proto__: null };
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  var limit2 = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(
    options.delimiter,
    options.throwOnLimitExceeded ? limit2 + 1 : limit2
  );
  if (options.throwOnLimitExceeded && parts.length > limit2) {
    throw new RangeError("Parameter limit exceeded. Only " + limit2 + " parameter" + (limit2 === 1 ? "" : "s") + " allowed.");
  }
  var skipIndex = -1;
  var i;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i = 0; i < parts.length; ++i) {
      if (parts[i].indexOf("utf8=") === 0) {
        if (parts[i] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i;
        i = parts.length;
      }
    }
  }
  for (i = 0; i < parts.length; ++i) {
    if (i === skipIndex) {
      continue;
    }
    var part = parts[i];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key;
    var val;
    if (pos === -1) {
      key = options.decoder(part, defaults.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
      val = utils.maybeMap(
        parseArrayValue(
          part.slice(pos + 1),
          options,
          isArray$1(obj[key]) ? obj[key].length : 0
        ),
        function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        }
      );
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(String(val));
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray$1(val) ? [val] : val;
    }
    var existing = has.call(obj, key);
    if (existing && options.duplicates === "combine") {
      obj[key] = utils.combine(obj[key], val);
    } else if (!existing || options.duplicates === "last") {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var currentArrayLength = 0;
  if (chain.length > 0 && chain[chain.length - 1] === "[]") {
    var parentKey = chain.slice(0, -1).join("");
    currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
  }
  var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
  for (var i = chain.length - 1; i >= 0; --i) {
    var obj;
    var root2 = chain[i];
    if (root2 === "[]" && options.parseArrays) {
      obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
    } else {
      obj = options.plainObjects ? { __proto__: null } : {};
      var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
      var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
      var index = parseInt(decodedRoot, 10);
      if (!options.parseArrays && decodedRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index) && root2 !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
        obj = [];
        obj[index] = leaf;
      } else if (decodedRoot !== "__proto__") {
        obj[decodedRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key);
  var parent = segment ? key.slice(0, segment.index) : key;
  var keys = [];
  if (parent) {
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(parent);
  }
  var i = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
    i += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(segment[1]);
  }
  if (segment) {
    if (options.strictDepth === true) {
      throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
    }
    keys.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
    throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
    throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
  }
  var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
  if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
    throw new TypeError("The duplicates option must be either combine, first, or last");
  }
  var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    duplicates,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
    throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
  };
};
var parse$4 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? { __proto__: null } : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? { __proto__: null } : {};
  var keys = Object.keys(tempObj);
  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};
var stringify2 = stringify_1;
var parse$3 = parse$4;
var formats$1 = formats$4;
var lib = {
  formats: formats$1,
  parse: parse$3,
  stringify: stringify2
};
var punycode = punycodeExports;
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, delims = [
  "<",
  ">",
  '"',
  "`",
  " ",
  "\r",
  "\n",
  "	"
], unwise = [
  "{",
  "}",
  "|",
  "\\",
  "^",
  "`"
].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = [
  "%",
  "/",
  "?",
  ";",
  "#"
].concat(autoEscape), hostEndingChars = [
  "/",
  "?",
  "#"
], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  javascript: true,
  "javascript:": true
}, hostlessProtocol = {
  javascript: true,
  "javascript:": true
}, slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
}, querystring = lib;
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && typeof url2 === "object" && url2 instanceof Url) {
    return url2;
  }
  var u = new Url();
  u.parse(url2, parseQueryString, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
  if (typeof url2 !== "string") {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
  }
  var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url2 = uSplit.join(splitter);
  var rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      return this;
    }
  }
  var proto2 = protocolPattern.exec(rest);
  if (proto2) {
    proto2 = proto2[0];
    var lowerProto = proto2.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto2.length);
  }
  if (slashesDenoteHost || proto2 || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto2 && hostlessProtocol[proto2])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto2] && (slashes || proto2 && !slashedProtocol[proto2])) {
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost();
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    } else {
      this.hostname = this.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      this.hostname = punycode.toASCII(this.hostname);
    }
    var p = this.port ? ":" + this.port : "";
    var h = this.hostname || "";
    this.host = h + p;
    this.href += this.host;
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) {
        continue;
      }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash2 = rest.indexOf("#");
  if (hash2 !== -1) {
    this.hash = rest.substr(hash2);
    rest = rest.slice(0, hash2);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    this.search = "";
    this.query = {};
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "/";
  }
  if (this.pathname || this.search) {
    var p = this.pathname || "";
    var s = this.search || "";
    this.path = p + s;
  }
  this.href = this.format();
  return this;
};
function urlFormat(obj) {
  if (typeof obj === "string") {
    obj = urlParse(obj);
  }
  if (!(obj instanceof Url)) {
    return Url.prototype.format.call(obj);
  }
  return obj.format();
}
Url.prototype.format = function() {
  var auth = this.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = this.protocol || "", pathname = this.pathname || "", hash2 = this.hash || "", host = false, query = "";
  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
    if (this.port) {
      host += ":" + this.port;
    }
  }
  if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: "repeat",
      addQueryPrefix: false
    });
  }
  var search = this.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":") {
    protocol += ":";
  }
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/") {
      pathname = "/" + pathname;
    }
  } else if (!host) {
    host = "";
  }
  if (hash2 && hash2.charAt(0) !== "#") {
    hash2 = "#" + hash2;
  }
  if (search && search.charAt(0) !== "?") {
    search = "?" + search;
  }
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash2;
};
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
Url.prototype.resolveObject = function(relative) {
  if (typeof relative === "string") {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }
  result.hash = relative.hash;
  if (relative.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative.slashes && !relative.protocol) {
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== "protocol") {
        result[rkey] = relative[rkey];
      }
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = "/";
      result.path = result.pathname;
    }
    result.href = result.format();
    return result;
  }
  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v2 = 0; v2 < keys.length; v2++) {
        var k = keys[v2];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift())) {
      }
      if (!relative.host) {
        relative.host = "";
      }
      if (!relative.hostname) {
        relative.hostname = "";
      }
      if (relPath[0] !== "") {
        relPath.unshift("");
      }
      if (relPath.length < 2) {
        relPath.unshift("");
      }
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p = result.pathname || "";
      var s = result.search || "";
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "") {
        srcPath[0] = result.host;
      } else {
        srcPath.unshift(result.host);
      }
    }
    result.host = "";
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === "") {
          relPath[0] = relative.host;
        } else {
          relPath.unshift(relative.host);
        }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  if (isRelAbs) {
    result.host = relative.host || relative.host === "" ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath) {
      srcPath = [];
    }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === ".") {
      srcPath.splice(i, 1);
    } else if (last === "..") {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
    result.host = result.hostname;
    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift("");
  }
  if (srcPath.length > 0) {
    result.pathname = srcPath.join("/");
  } else {
    result.pathname = null;
    result.path = null;
  }
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse$2 = urlParse;
var resolve = urlResolve;
var format$4 = urlFormat;
/*!
 * @pixi/utils - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var url = {
  parse: parse$2,
  format: format$4,
  resolve
};
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
var saidHello = false;
var VERSION = "6.5.10";
function sayHello(type2) {
  var _a2;
  if (saidHello) {
    return;
  }
  if (settings.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
    var args = [
      "\n %c %c %c PixiJS " + VERSION + " - ✰ " + type2 + " ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n",
      "background: #ff66a5; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff66a5; background: #030307; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "background: #ffc3dc; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;"
    ];
    (_a2 = globalThis.console).log.apply(_a2, args);
  } else if (globalThis.console) {
    globalThis.console.log("PixiJS " + VERSION + " - " + type2 + " - http://www.pixijs.com/");
  }
  saidHello = true;
}
var supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      var contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!settings.ADAPTER.getWebGLRenderingContext()) {
          return false;
        }
        var canvas = settings.ADAPTER.createCanvas();
        var gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        var success = !!(gl && gl.getContextAttributes().stencil);
        if (gl) {
          var loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e) {
        return false;
      }
    }();
  }
  return supported;
}
var aliceblue = "#f0f8ff";
var antiquewhite = "#faebd7";
var aqua = "#00ffff";
var aquamarine = "#7fffd4";
var azure = "#f0ffff";
var beige = "#f5f5dc";
var bisque = "#ffe4c4";
var black = "#000000";
var blanchedalmond = "#ffebcd";
var blue = "#0000ff";
var blueviolet = "#8a2be2";
var brown = "#a52a2a";
var burlywood = "#deb887";
var cadetblue = "#5f9ea0";
var chartreuse = "#7fff00";
var chocolate = "#d2691e";
var coral = "#ff7f50";
var cornflowerblue = "#6495ed";
var cornsilk = "#fff8dc";
var crimson = "#dc143c";
var cyan = "#00ffff";
var darkblue = "#00008b";
var darkcyan = "#008b8b";
var darkgoldenrod = "#b8860b";
var darkgray = "#a9a9a9";
var darkgreen = "#006400";
var darkgrey = "#a9a9a9";
var darkkhaki = "#bdb76b";
var darkmagenta = "#8b008b";
var darkolivegreen = "#556b2f";
var darkorange = "#ff8c00";
var darkorchid = "#9932cc";
var darkred = "#8b0000";
var darksalmon = "#e9967a";
var darkseagreen = "#8fbc8f";
var darkslateblue = "#483d8b";
var darkslategray = "#2f4f4f";
var darkslategrey = "#2f4f4f";
var darkturquoise = "#00ced1";
var darkviolet = "#9400d3";
var deeppink = "#ff1493";
var deepskyblue = "#00bfff";
var dimgray = "#696969";
var dimgrey = "#696969";
var dodgerblue = "#1e90ff";
var firebrick = "#b22222";
var floralwhite = "#fffaf0";
var forestgreen = "#228b22";
var fuchsia = "#ff00ff";
var gainsboro = "#dcdcdc";
var ghostwhite = "#f8f8ff";
var goldenrod = "#daa520";
var gold = "#ffd700";
var gray = "#808080";
var green = "#008000";
var greenyellow = "#adff2f";
var grey = "#808080";
var honeydew = "#f0fff0";
var hotpink = "#ff69b4";
var indianred = "#cd5c5c";
var indigo = "#4b0082";
var ivory = "#fffff0";
var khaki = "#f0e68c";
var lavenderblush = "#fff0f5";
var lavender = "#e6e6fa";
var lawngreen = "#7cfc00";
var lemonchiffon = "#fffacd";
var lightblue = "#add8e6";
var lightcoral = "#f08080";
var lightcyan = "#e0ffff";
var lightgoldenrodyellow = "#fafad2";
var lightgray = "#d3d3d3";
var lightgreen = "#90ee90";
var lightgrey = "#d3d3d3";
var lightpink = "#ffb6c1";
var lightsalmon = "#ffa07a";
var lightseagreen = "#20b2aa";
var lightskyblue = "#87cefa";
var lightslategray = "#778899";
var lightslategrey = "#778899";
var lightsteelblue = "#b0c4de";
var lightyellow = "#ffffe0";
var lime = "#00ff00";
var limegreen = "#32cd32";
var linen = "#faf0e6";
var magenta = "#ff00ff";
var maroon = "#800000";
var mediumaquamarine = "#66cdaa";
var mediumblue = "#0000cd";
var mediumorchid = "#ba55d3";
var mediumpurple = "#9370db";
var mediumseagreen = "#3cb371";
var mediumslateblue = "#7b68ee";
var mediumspringgreen = "#00fa9a";
var mediumturquoise = "#48d1cc";
var mediumvioletred = "#c71585";
var midnightblue = "#191970";
var mintcream = "#f5fffa";
var mistyrose = "#ffe4e1";
var moccasin = "#ffe4b5";
var navajowhite = "#ffdead";
var navy = "#000080";
var oldlace = "#fdf5e6";
var olive = "#808000";
var olivedrab = "#6b8e23";
var orange = "#ffa500";
var orangered = "#ff4500";
var orchid = "#da70d6";
var palegoldenrod = "#eee8aa";
var palegreen = "#98fb98";
var paleturquoise = "#afeeee";
var palevioletred = "#db7093";
var papayawhip = "#ffefd5";
var peachpuff = "#ffdab9";
var peru = "#cd853f";
var pink = "#ffc0cb";
var plum = "#dda0dd";
var powderblue = "#b0e0e6";
var purple = "#800080";
var rebeccapurple = "#663399";
var red = "#ff0000";
var rosybrown = "#bc8f8f";
var royalblue = "#4169e1";
var saddlebrown = "#8b4513";
var salmon = "#fa8072";
var sandybrown = "#f4a460";
var seagreen = "#2e8b57";
var seashell = "#fff5ee";
var sienna = "#a0522d";
var silver = "#c0c0c0";
var skyblue = "#87ceeb";
var slateblue = "#6a5acd";
var slategray = "#708090";
var slategrey = "#708090";
var snow = "#fffafa";
var springgreen = "#00ff7f";
var steelblue = "#4682b4";
var tan$1 = "#d2b48c";
var teal = "#008080";
var thistle = "#d8bfd8";
var tomato = "#ff6347";
var turquoise = "#40e0d0";
var violet = "#ee82ee";
var wheat = "#f5deb3";
var white = "#ffffff";
var whitesmoke = "#f5f5f5";
var yellow = "#ffff00";
var yellowgreen = "#9acd32";
var cssColorNames = {
  aliceblue,
  antiquewhite,
  aqua,
  aquamarine,
  azure,
  beige,
  bisque,
  black,
  blanchedalmond,
  blue,
  blueviolet,
  brown,
  burlywood,
  cadetblue,
  chartreuse,
  chocolate,
  coral,
  cornflowerblue,
  cornsilk,
  crimson,
  cyan,
  darkblue,
  darkcyan,
  darkgoldenrod,
  darkgray,
  darkgreen,
  darkgrey,
  darkkhaki,
  darkmagenta,
  darkolivegreen,
  darkorange,
  darkorchid,
  darkred,
  darksalmon,
  darkseagreen,
  darkslateblue,
  darkslategray,
  darkslategrey,
  darkturquoise,
  darkviolet,
  deeppink,
  deepskyblue,
  dimgray,
  dimgrey,
  dodgerblue,
  firebrick,
  floralwhite,
  forestgreen,
  fuchsia,
  gainsboro,
  ghostwhite,
  goldenrod,
  gold,
  gray,
  green,
  greenyellow,
  grey,
  honeydew,
  hotpink,
  indianred,
  indigo,
  ivory,
  khaki,
  lavenderblush,
  lavender,
  lawngreen,
  lemonchiffon,
  lightblue,
  lightcoral,
  lightcyan,
  lightgoldenrodyellow,
  lightgray,
  lightgreen,
  lightgrey,
  lightpink,
  lightsalmon,
  lightseagreen,
  lightskyblue,
  lightslategray,
  lightslategrey,
  lightsteelblue,
  lightyellow,
  lime,
  limegreen,
  linen,
  magenta,
  maroon,
  mediumaquamarine,
  mediumblue,
  mediumorchid,
  mediumpurple,
  mediumseagreen,
  mediumslateblue,
  mediumspringgreen,
  mediumturquoise,
  mediumvioletred,
  midnightblue,
  mintcream,
  mistyrose,
  moccasin,
  navajowhite,
  navy,
  oldlace,
  olive,
  olivedrab,
  orange,
  orangered,
  orchid,
  palegoldenrod,
  palegreen,
  paleturquoise,
  palevioletred,
  papayawhip,
  peachpuff,
  peru,
  pink,
  plum,
  powderblue,
  purple,
  rebeccapurple,
  red,
  rosybrown,
  royalblue,
  saddlebrown,
  salmon,
  sandybrown,
  seagreen,
  seashell,
  sienna,
  silver,
  skyblue,
  slateblue,
  slategray,
  slategrey,
  snow,
  springgreen,
  steelblue,
  tan: tan$1,
  teal,
  thistle,
  tomato,
  turquoise,
  violet,
  wheat,
  white,
  whitesmoke,
  yellow,
  yellowgreen
};
function hex2rgb(hex2, out) {
  if (out === void 0) {
    out = [];
  }
  out[0] = (hex2 >> 16 & 255) / 255;
  out[1] = (hex2 >> 8 & 255) / 255;
  out[2] = (hex2 & 255) / 255;
  return out;
}
function hex2string(hex2) {
  var hexString = hex2.toString(16);
  hexString = "000000".substring(0, 6 - hexString.length) + hexString;
  return "#" + hexString;
}
function string2hex(string2) {
  if (typeof string2 === "string") {
    string2 = cssColorNames[string2.toLowerCase()] || string2;
    if (string2[0] === "#") {
      string2 = string2.slice(1);
    }
  }
  return parseInt(string2, 16);
}
function mapPremultipliedBlendModes() {
  var pm = [];
  var npm = [];
  for (var i = 0; i < 32; i++) {
    pm[i] = i;
    npm[i] = i;
  }
  pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;
  pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;
  pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;
  npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;
  npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;
  npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  var array2 = [];
  array2.push(npm);
  array2.push(pm);
  return array2;
}
var premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb2, alpha, out, premultiply) {
  out = out || new Float32Array(4);
  if (premultiply || premultiply === void 0) {
    out[0] = rgb2[0] * alpha;
    out[1] = rgb2[1] * alpha;
    out[2] = rgb2[2] * alpha;
  } else {
    out[0] = rgb2[0];
    out[1] = rgb2[1];
    out[2] = rgb2[2];
  }
  out[3] = alpha;
  return out;
}
function premultiplyTint(tint, alpha) {
  if (alpha === 1) {
    return (alpha * 255 << 24) + tint;
  }
  if (alpha === 0) {
    return 0;
  }
  var R = tint >> 16 & 255;
  var G = tint >> 8 & 255;
  var B2 = tint & 255;
  R = R * alpha + 0.5 | 0;
  G = G * alpha + 0.5 | 0;
  B2 = B2 * alpha + 0.5 | 0;
  return (alpha * 255 << 24) + (R << 16) + (G << 8) + B2;
}
function premultiplyTintToRgba(tint, alpha, out, premultiply) {
  out = out || new Float32Array(4);
  out[0] = (tint >> 16 & 255) / 255;
  out[1] = (tint >> 8 & 255) / 255;
  out[2] = (tint & 255) / 255;
  if (premultiply || premultiply === void 0) {
    out[0] *= alpha;
    out[1] *= alpha;
    out[2] *= alpha;
  }
  out[3] = alpha;
  return out;
}
function createIndicesForQuads(size2, outBuffer) {
  if (outBuffer === void 0) {
    outBuffer = null;
  }
  var totalIndices = size2 * 6;
  outBuffer = outBuffer || new Uint16Array(totalIndices);
  if (outBuffer.length !== totalIndices) {
    throw new Error("Out buffer length is incorrect, got " + outBuffer.length + " and expected " + totalIndices);
  }
  for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
    outBuffer[i + 0] = j + 0;
    outBuffer[i + 1] = j + 1;
    outBuffer[i + 2] = j + 2;
    outBuffer[i + 3] = j + 0;
    outBuffer[i + 4] = j + 2;
    outBuffer[i + 5] = j + 3;
  }
  return outBuffer;
}
function getBufferType(array2) {
  if (array2.BYTES_PER_ELEMENT === 4) {
    if (array2 instanceof Float32Array) {
      return "Float32Array";
    } else if (array2 instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array2.BYTES_PER_ELEMENT === 2) {
    if (array2 instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array2.BYTES_PER_ELEMENT === 1) {
    if (array2 instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}
function nextPow2(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
function isPow2(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
function log2$1(v2) {
  var r = (v2 > 65535 ? 1 : 0) << 4;
  v2 >>>= r;
  var shift = (v2 > 255 ? 1 : 0) << 3;
  v2 >>>= shift;
  r |= shift;
  shift = (v2 > 15 ? 1 : 0) << 2;
  v2 >>>= shift;
  r |= shift;
  shift = (v2 > 3 ? 1 : 0) << 1;
  v2 >>>= shift;
  r |= shift;
  return r | v2 >> 1;
}
function removeItems(arr, startIdx, removeCount) {
  var length = arr.length;
  var i;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  var len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
}
function sign$1(n) {
  if (n === 0) {
    return 0;
  }
  return n < 0 ? -1 : 1;
}
var nextUid = 0;
function uid() {
  return ++nextUid;
}
var warnings = {};
function deprecation(version, message, ignoreDepth) {
  if (ignoreDepth === void 0) {
    ignoreDepth = 3;
  }
  if (warnings[message]) {
    return;
  }
  var stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", message + "\nDeprecated since v" + version);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
var ProgramCache = {};
var TextureCache = /* @__PURE__ */ Object.create(null);
var BaseTextureCache = /* @__PURE__ */ Object.create(null);
var CanvasRenderTarget = (
  /** @class */
  function() {
    function CanvasRenderTarget2(width, height, resolution) {
      this.canvas = settings.ADAPTER.createCanvas();
      this.context = this.canvas.getContext("2d");
      this.resolution = resolution || settings.RESOLUTION;
      this.resize(width, height);
    }
    CanvasRenderTarget2.prototype.clear = function() {
      this.context.setTransform(1, 0, 0, 1, 0, 0);
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };
    CanvasRenderTarget2.prototype.resize = function(desiredWidth, desiredHeight) {
      this.canvas.width = Math.round(desiredWidth * this.resolution);
      this.canvas.height = Math.round(desiredHeight * this.resolution);
    };
    CanvasRenderTarget2.prototype.destroy = function() {
      this.context = null;
      this.canvas = null;
    };
    Object.defineProperty(CanvasRenderTarget2.prototype, "width", {
      /**
       * The width of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.width;
      },
      set: function(val) {
        this.canvas.width = Math.round(val);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CanvasRenderTarget2.prototype, "height", {
      /**
       * The height of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.height;
      },
      set: function(val) {
        this.canvas.height = Math.round(val);
      },
      enumerable: false,
      configurable: true
    });
    return CanvasRenderTarget2;
  }()
);
function trimCanvas(canvas) {
  var width = canvas.width;
  var height = canvas.height;
  var context2 = canvas.getContext("2d", {
    willReadFrequently: true
  });
  var imageData = context2.getImageData(0, 0, width, height);
  var pixels = imageData.data;
  var len = pixels.length;
  var bound = {
    top: null,
    left: null,
    right: null,
    bottom: null
  };
  var data = null;
  var i;
  var x;
  var y;
  for (i = 0; i < len; i += 4) {
    if (pixels[i + 3] !== 0) {
      x = i / 4 % width;
      y = ~~(i / 4 / width);
      if (bound.top === null) {
        bound.top = y;
      }
      if (bound.left === null) {
        bound.left = x;
      } else if (x < bound.left) {
        bound.left = x;
      }
      if (bound.right === null) {
        bound.right = x + 1;
      } else if (bound.right < x) {
        bound.right = x + 1;
      }
      if (bound.bottom === null) {
        bound.bottom = y;
      } else if (bound.bottom < y) {
        bound.bottom = y;
      }
    }
  }
  if (bound.top !== null) {
    width = bound.right - bound.left;
    height = bound.bottom - bound.top + 1;
    data = context2.getImageData(bound.left, bound.top, width, height);
  }
  return {
    height,
    width,
    data
  };
}
var tempAnchor$1;
function determineCrossOrigin(url$1, loc) {
  if (loc === void 0) {
    loc = globalThis.location;
  }
  if (url$1.indexOf("data:") === 0) {
    return "";
  }
  loc = loc || globalThis.location;
  if (!tempAnchor$1) {
    tempAnchor$1 = document.createElement("a");
  }
  tempAnchor$1.href = url$1;
  var parsedUrl = url.parse(tempAnchor$1.href);
  var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
function getResolutionOfUrl(url2, defaultValue2) {
  var resolution = settings.RETINA_PREFIX.exec(url2);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue2 !== void 0 ? defaultValue2 : 1;
}
/*!
 * @pixi/math - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var PI_2 = Math.PI * 2;
var RAD_TO_DEG = 180 / Math.PI;
var DEG_TO_RAD = Math.PI / 180;
var SHAPES;
(function(SHAPES2) {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
})(SHAPES || (SHAPES = {}));
var Point = (
  /** @class */
  function() {
    function Point2(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      this.x = 0;
      this.y = 0;
      this.x = x;
      this.y = y;
    }
    Point2.prototype.clone = function() {
      return new Point2(this.x, this.y);
    };
    Point2.prototype.copyFrom = function(p) {
      this.set(p.x, p.y);
      return this;
    };
    Point2.prototype.copyTo = function(p) {
      p.set(this.x, this.y);
      return p;
    };
    Point2.prototype.equals = function(p) {
      return p.x === this.x && p.y === this.y;
    };
    Point2.prototype.set = function(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = x;
      }
      this.x = x;
      this.y = y;
      return this;
    };
    Point2.prototype.toString = function() {
      return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
    };
    return Point2;
  }()
);
var tempPoints$1 = [new Point(), new Point(), new Point(), new Point()];
var Rectangle = (
  /** @class */
  function() {
    function Rectangle2(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = Number(x);
      this.y = Number(y);
      this.width = Number(width);
      this.height = Number(height);
      this.type = SHAPES.RECT;
    }
    Object.defineProperty(Rectangle2.prototype, "left", {
      /** Returns the left edge of the rectangle. */
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "right", {
      /** Returns the right edge of the rectangle. */
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "top", {
      /** Returns the top edge of the rectangle. */
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "bottom", {
      /** Returns the bottom edge of the rectangle. */
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle2, "EMPTY", {
      /** A constant empty rectangle. */
      get: function() {
        return new Rectangle2(0, 0, 0, 0);
      },
      enumerable: false,
      configurable: true
    });
    Rectangle2.prototype.clone = function() {
      return new Rectangle2(this.x, this.y, this.width, this.height);
    };
    Rectangle2.prototype.copyFrom = function(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    };
    Rectangle2.prototype.copyTo = function(rectangle) {
      rectangle.x = this.x;
      rectangle.y = this.y;
      rectangle.width = this.width;
      rectangle.height = this.height;
      return rectangle;
    };
    Rectangle2.prototype.contains = function(x, y) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x >= this.x && x < this.x + this.width) {
        if (y >= this.y && y < this.y + this.height) {
          return true;
        }
      }
      return false;
    };
    Rectangle2.prototype.intersects = function(other, transform) {
      if (!transform) {
        var x0_1 = this.x < other.x ? other.x : this.x;
        var x1_1 = this.right > other.right ? other.right : this.right;
        if (x1_1 <= x0_1) {
          return false;
        }
        var y0_1 = this.y < other.y ? other.y : this.y;
        var y1_1 = this.bottom > other.bottom ? other.bottom : this.bottom;
        return y1_1 > y0_1;
      }
      var x0 = this.left;
      var x1 = this.right;
      var y0 = this.top;
      var y1 = this.bottom;
      if (x1 <= x0 || y1 <= y0) {
        return false;
      }
      var lt = tempPoints$1[0].set(other.left, other.top);
      var lb = tempPoints$1[1].set(other.left, other.bottom);
      var rt = tempPoints$1[2].set(other.right, other.top);
      var rb = tempPoints$1[3].set(other.right, other.bottom);
      if (rt.x <= lt.x || lb.y <= lt.y) {
        return false;
      }
      var s = Math.sign(transform.a * transform.d - transform.b * transform.c);
      if (s === 0) {
        return false;
      }
      transform.apply(lt, lt);
      transform.apply(lb, lb);
      transform.apply(rt, rt);
      transform.apply(rb, rb);
      if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
        return false;
      }
      var nx = s * (lb.y - lt.y);
      var ny = s * (lt.x - lb.x);
      var n00 = nx * x0 + ny * y0;
      var n10 = nx * x1 + ny * y0;
      var n01 = nx * x0 + ny * y1;
      var n11 = nx * x1 + ny * y1;
      if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
        return false;
      }
      var mx = s * (lt.y - rt.y);
      var my = s * (rt.x - lt.x);
      var m00 = mx * x0 + my * y0;
      var m10 = mx * x1 + my * y0;
      var m01 = mx * x0 + my * y1;
      var m11 = mx * x1 + my * y1;
      if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
        return false;
      }
      return true;
    };
    Rectangle2.prototype.pad = function(paddingX, paddingY) {
      if (paddingX === void 0) {
        paddingX = 0;
      }
      if (paddingY === void 0) {
        paddingY = paddingX;
      }
      this.x -= paddingX;
      this.y -= paddingY;
      this.width += paddingX * 2;
      this.height += paddingY * 2;
      return this;
    };
    Rectangle2.prototype.fit = function(rectangle) {
      var x1 = Math.max(this.x, rectangle.x);
      var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
      var y1 = Math.max(this.y, rectangle.y);
      var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = Math.max(x2 - x1, 0);
      this.y = y1;
      this.height = Math.max(y2 - y1, 0);
      return this;
    };
    Rectangle2.prototype.ceil = function(resolution, eps) {
      if (resolution === void 0) {
        resolution = 1;
      }
      if (eps === void 0) {
        eps = 1e-3;
      }
      var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
      var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
      this.x = Math.floor((this.x + eps) * resolution) / resolution;
      this.y = Math.floor((this.y + eps) * resolution) / resolution;
      this.width = x2 - this.x;
      this.height = y2 - this.y;
      return this;
    };
    Rectangle2.prototype.enlarge = function(rectangle) {
      var x1 = Math.min(this.x, rectangle.x);
      var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
      var y1 = Math.min(this.y, rectangle.y);
      var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = x2 - x1;
      this.y = y1;
      this.height = y2 - y1;
      return this;
    };
    Rectangle2.prototype.toString = function() {
      return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    };
    return Rectangle2;
  }()
);
var Circle = (
  /** @class */
  function() {
    function Circle2(x, y, radius) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (radius === void 0) {
        radius = 0;
      }
      this.x = x;
      this.y = y;
      this.radius = radius;
      this.type = SHAPES.CIRC;
    }
    Circle2.prototype.clone = function() {
      return new Circle2(this.x, this.y, this.radius);
    };
    Circle2.prototype.contains = function(x, y) {
      if (this.radius <= 0) {
        return false;
      }
      var r2 = this.radius * this.radius;
      var dx = this.x - x;
      var dy = this.y - y;
      dx *= dx;
      dy *= dy;
      return dx + dy <= r2;
    };
    Circle2.prototype.getBounds = function() {
      return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    };
    Circle2.prototype.toString = function() {
      return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
    };
    return Circle2;
  }()
);
var Ellipse = (
  /** @class */
  function() {
    function Ellipse2(x, y, halfWidth, halfHeight) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (halfWidth === void 0) {
        halfWidth = 0;
      }
      if (halfHeight === void 0) {
        halfHeight = 0;
      }
      this.x = x;
      this.y = y;
      this.width = halfWidth;
      this.height = halfHeight;
      this.type = SHAPES.ELIP;
    }
    Ellipse2.prototype.clone = function() {
      return new Ellipse2(this.x, this.y, this.width, this.height);
    };
    Ellipse2.prototype.contains = function(x, y) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      var normx = (x - this.x) / this.width;
      var normy = (y - this.y) / this.height;
      normx *= normx;
      normy *= normy;
      return normx + normy <= 1;
    };
    Ellipse2.prototype.getBounds = function() {
      return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    };
    Ellipse2.prototype.toString = function() {
      return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    };
    return Ellipse2;
  }()
);
var Polygon = (
  /** @class */
  function() {
    function Polygon2() {
      var arguments$1 = arguments;
      var points = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        points[_i] = arguments$1[_i];
      }
      var flat = Array.isArray(points[0]) ? points[0] : points;
      if (typeof flat[0] !== "number") {
        var p = [];
        for (var i = 0, il = flat.length; i < il; i++) {
          p.push(flat[i].x, flat[i].y);
        }
        flat = p;
      }
      this.points = flat;
      this.type = SHAPES.POLY;
      this.closeStroke = true;
    }
    Polygon2.prototype.clone = function() {
      var points = this.points.slice();
      var polygon = new Polygon2(points);
      polygon.closeStroke = this.closeStroke;
      return polygon;
    };
    Polygon2.prototype.contains = function(x, y) {
      var inside = false;
      var length = this.points.length / 2;
      for (var i = 0, j = length - 1; i < length; j = i++) {
        var xi = this.points[i * 2];
        var yi = this.points[i * 2 + 1];
        var xj = this.points[j * 2];
        var yj = this.points[j * 2 + 1];
        var intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
        if (intersect) {
          inside = !inside;
        }
      }
      return inside;
    };
    Polygon2.prototype.toString = function() {
      return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(pointsDesc, currentPoint) {
        return pointsDesc + ", " + currentPoint;
      }, "") + "]");
    };
    return Polygon2;
  }()
);
var RoundedRectangle = (
  /** @class */
  function() {
    function RoundedRectangle2(x, y, width, height, radius) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      if (radius === void 0) {
        radius = 20;
      }
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.radius = radius;
      this.type = SHAPES.RREC;
    }
    RoundedRectangle2.prototype.clone = function() {
      return new RoundedRectangle2(this.x, this.y, this.width, this.height, this.radius);
    };
    RoundedRectangle2.prototype.contains = function(x, y) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x >= this.x && x <= this.x + this.width) {
        if (y >= this.y && y <= this.y + this.height) {
          var radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
          if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
            return true;
          }
          var dx = x - (this.x + radius);
          var dy = y - (this.y + radius);
          var radius2 = radius * radius;
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x - (this.x + this.width - radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dy = y - (this.y + this.height - radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x - (this.x + radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
        }
      }
      return false;
    };
    RoundedRectangle2.prototype.toString = function() {
      return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
    };
    return RoundedRectangle2;
  }()
);
var ObservablePoint = (
  /** @class */
  function() {
    function ObservablePoint2(cb, scope, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      this._x = x;
      this._y = y;
      this.cb = cb;
      this.scope = scope;
    }
    ObservablePoint2.prototype.clone = function(cb, scope) {
      if (cb === void 0) {
        cb = this.cb;
      }
      if (scope === void 0) {
        scope = this.scope;
      }
      return new ObservablePoint2(cb, scope, this._x, this._y);
    };
    ObservablePoint2.prototype.set = function(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = x;
      }
      if (this._x !== x || this._y !== y) {
        this._x = x;
        this._y = y;
        this.cb.call(this.scope);
      }
      return this;
    };
    ObservablePoint2.prototype.copyFrom = function(p) {
      if (this._x !== p.x || this._y !== p.y) {
        this._x = p.x;
        this._y = p.y;
        this.cb.call(this.scope);
      }
      return this;
    };
    ObservablePoint2.prototype.copyTo = function(p) {
      p.set(this._x, this._y);
      return p;
    };
    ObservablePoint2.prototype.equals = function(p) {
      return p.x === this._x && p.y === this._y;
    };
    ObservablePoint2.prototype.toString = function() {
      return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
    };
    Object.defineProperty(ObservablePoint2.prototype, "x", {
      /** Position of the observable point on the x axis. */
      get: function() {
        return this._x;
      },
      set: function(value) {
        if (this._x !== value) {
          this._x = value;
          this.cb.call(this.scope);
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ObservablePoint2.prototype, "y", {
      /** Position of the observable point on the y axis. */
      get: function() {
        return this._y;
      },
      set: function(value) {
        if (this._y !== value) {
          this._y = value;
          this.cb.call(this.scope);
        }
      },
      enumerable: false,
      configurable: true
    });
    return ObservablePoint2;
  }()
);
var Matrix$1 = (
  /** @class */
  function() {
    function Matrix2(a, b, c2, d, tx, ty) {
      if (a === void 0) {
        a = 1;
      }
      if (b === void 0) {
        b = 0;
      }
      if (c2 === void 0) {
        c2 = 0;
      }
      if (d === void 0) {
        d = 1;
      }
      if (tx === void 0) {
        tx = 0;
      }
      if (ty === void 0) {
        ty = 0;
      }
      this.array = null;
      this.a = a;
      this.b = b;
      this.c = c2;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
    }
    Matrix2.prototype.fromArray = function(array2) {
      this.a = array2[0];
      this.b = array2[1];
      this.c = array2[3];
      this.d = array2[4];
      this.tx = array2[2];
      this.ty = array2[5];
    };
    Matrix2.prototype.set = function(a, b, c2, d, tx, ty) {
      this.a = a;
      this.b = b;
      this.c = c2;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
      return this;
    };
    Matrix2.prototype.toArray = function(transpose, out) {
      if (!this.array) {
        this.array = new Float32Array(9);
      }
      var array2 = out || this.array;
      if (transpose) {
        array2[0] = this.a;
        array2[1] = this.b;
        array2[2] = 0;
        array2[3] = this.c;
        array2[4] = this.d;
        array2[5] = 0;
        array2[6] = this.tx;
        array2[7] = this.ty;
        array2[8] = 1;
      } else {
        array2[0] = this.a;
        array2[1] = this.c;
        array2[2] = this.tx;
        array2[3] = this.b;
        array2[4] = this.d;
        array2[5] = this.ty;
        array2[6] = 0;
        array2[7] = 0;
        array2[8] = 1;
      }
      return array2;
    };
    Matrix2.prototype.apply = function(pos, newPos) {
      newPos = newPos || new Point();
      var x = pos.x;
      var y = pos.y;
      newPos.x = this.a * x + this.c * y + this.tx;
      newPos.y = this.b * x + this.d * y + this.ty;
      return newPos;
    };
    Matrix2.prototype.applyInverse = function(pos, newPos) {
      newPos = newPos || new Point();
      var id2 = 1 / (this.a * this.d + this.c * -this.b);
      var x = pos.x;
      var y = pos.y;
      newPos.x = this.d * id2 * x + -this.c * id2 * y + (this.ty * this.c - this.tx * this.d) * id2;
      newPos.y = this.a * id2 * y + -this.b * id2 * x + (-this.ty * this.a + this.tx * this.b) * id2;
      return newPos;
    };
    Matrix2.prototype.translate = function(x, y) {
      this.tx += x;
      this.ty += y;
      return this;
    };
    Matrix2.prototype.scale = function(x, y) {
      this.a *= x;
      this.d *= y;
      this.c *= x;
      this.b *= y;
      this.tx *= x;
      this.ty *= y;
      return this;
    };
    Matrix2.prototype.rotate = function(angle) {
      var cos2 = Math.cos(angle);
      var sin2 = Math.sin(angle);
      var a1 = this.a;
      var c1 = this.c;
      var tx1 = this.tx;
      this.a = a1 * cos2 - this.b * sin2;
      this.b = a1 * sin2 + this.b * cos2;
      this.c = c1 * cos2 - this.d * sin2;
      this.d = c1 * sin2 + this.d * cos2;
      this.tx = tx1 * cos2 - this.ty * sin2;
      this.ty = tx1 * sin2 + this.ty * cos2;
      return this;
    };
    Matrix2.prototype.append = function(matrix2) {
      var a1 = this.a;
      var b1 = this.b;
      var c1 = this.c;
      var d1 = this.d;
      this.a = matrix2.a * a1 + matrix2.b * c1;
      this.b = matrix2.a * b1 + matrix2.b * d1;
      this.c = matrix2.c * a1 + matrix2.d * c1;
      this.d = matrix2.c * b1 + matrix2.d * d1;
      this.tx = matrix2.tx * a1 + matrix2.ty * c1 + this.tx;
      this.ty = matrix2.tx * b1 + matrix2.ty * d1 + this.ty;
      return this;
    };
    Matrix2.prototype.setTransform = function(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
      this.a = Math.cos(rotation + skewY) * scaleX;
      this.b = Math.sin(rotation + skewY) * scaleX;
      this.c = -Math.sin(rotation - skewX) * scaleY;
      this.d = Math.cos(rotation - skewX) * scaleY;
      this.tx = x - (pivotX * this.a + pivotY * this.c);
      this.ty = y - (pivotX * this.b + pivotY * this.d);
      return this;
    };
    Matrix2.prototype.prepend = function(matrix2) {
      var tx1 = this.tx;
      if (matrix2.a !== 1 || matrix2.b !== 0 || matrix2.c !== 0 || matrix2.d !== 1) {
        var a1 = this.a;
        var c1 = this.c;
        this.a = a1 * matrix2.a + this.b * matrix2.c;
        this.b = a1 * matrix2.b + this.b * matrix2.d;
        this.c = c1 * matrix2.a + this.d * matrix2.c;
        this.d = c1 * matrix2.b + this.d * matrix2.d;
      }
      this.tx = tx1 * matrix2.a + this.ty * matrix2.c + matrix2.tx;
      this.ty = tx1 * matrix2.b + this.ty * matrix2.d + matrix2.ty;
      return this;
    };
    Matrix2.prototype.decompose = function(transform) {
      var a = this.a;
      var b = this.b;
      var c2 = this.c;
      var d = this.d;
      var pivot = transform.pivot;
      var skewX = -Math.atan2(-c2, d);
      var skewY = Math.atan2(b, a);
      var delta = Math.abs(skewX + skewY);
      if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
        transform.rotation = skewY;
        transform.skew.x = transform.skew.y = 0;
      } else {
        transform.rotation = 0;
        transform.skew.x = skewX;
        transform.skew.y = skewY;
      }
      transform.scale.x = Math.sqrt(a * a + b * b);
      transform.scale.y = Math.sqrt(c2 * c2 + d * d);
      transform.position.x = this.tx + (pivot.x * a + pivot.y * c2);
      transform.position.y = this.ty + (pivot.x * b + pivot.y * d);
      return transform;
    };
    Matrix2.prototype.invert = function() {
      var a1 = this.a;
      var b1 = this.b;
      var c1 = this.c;
      var d1 = this.d;
      var tx1 = this.tx;
      var n = a1 * d1 - b1 * c1;
      this.a = d1 / n;
      this.b = -b1 / n;
      this.c = -c1 / n;
      this.d = a1 / n;
      this.tx = (c1 * this.ty - d1 * tx1) / n;
      this.ty = -(a1 * this.ty - b1 * tx1) / n;
      return this;
    };
    Matrix2.prototype.identity = function() {
      this.a = 1;
      this.b = 0;
      this.c = 0;
      this.d = 1;
      this.tx = 0;
      this.ty = 0;
      return this;
    };
    Matrix2.prototype.clone = function() {
      var matrix2 = new Matrix2();
      matrix2.a = this.a;
      matrix2.b = this.b;
      matrix2.c = this.c;
      matrix2.d = this.d;
      matrix2.tx = this.tx;
      matrix2.ty = this.ty;
      return matrix2;
    };
    Matrix2.prototype.copyTo = function(matrix2) {
      matrix2.a = this.a;
      matrix2.b = this.b;
      matrix2.c = this.c;
      matrix2.d = this.d;
      matrix2.tx = this.tx;
      matrix2.ty = this.ty;
      return matrix2;
    };
    Matrix2.prototype.copyFrom = function(matrix2) {
      this.a = matrix2.a;
      this.b = matrix2.b;
      this.c = matrix2.c;
      this.d = matrix2.d;
      this.tx = matrix2.tx;
      this.ty = matrix2.ty;
      return this;
    };
    Matrix2.prototype.toString = function() {
      return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
    };
    Object.defineProperty(Matrix2, "IDENTITY", {
      /**
       * A default (identity) matrix
       * @readonly
       */
      get: function() {
        return new Matrix2();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Matrix2, "TEMP_MATRIX", {
      /**
       * A temp matrix
       * @readonly
       */
      get: function() {
        return new Matrix2();
      },
      enumerable: false,
      configurable: true
    });
    return Matrix2;
  }()
);
var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
var rotationCayley = [];
var rotationMatrices = [];
var signum = Math.sign;
function init() {
  for (var i = 0; i < 16; i++) {
    var row = [];
    rotationCayley.push(row);
    for (var j = 0; j < 16; j++) {
      var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
      var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
      var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
      var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
      for (var k = 0; k < 16; k++) {
        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
          row.push(k);
          break;
        }
      }
    }
  }
  for (var i = 0; i < 16; i++) {
    var mat = new Matrix$1();
    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
var groupD8 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: function(ind) {
    return ux[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: function(ind) {
    return uy[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: function(ind) {
    return vx[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: function(ind) {
    return vy[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: function(rotation) {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: function(rotationSecond, rotationFirst) {
    return rotationCayley[rotationSecond][rotationFirst];
  },
  /**
   * Reverse of `add`.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: function(rotationSecond, rotationFirst) {
    return rotationCayley[rotationSecond][groupD8.inv(rotationFirst)];
  },
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof PIXI.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: function(rotation) {
    return rotation ^ 4;
  },
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: function(rotation) {
    return (rotation & 3) === 2;
  },
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof PIXI.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: function(dx, dy) {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof PIXI.groupD8
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: function(matrix2, rotation, tx, ty) {
    if (tx === void 0) {
      tx = 0;
    }
    if (ty === void 0) {
      ty = 0;
    }
    var mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix2.append(mat);
  }
};
var Transform = (
  /** @class */
  function() {
    function Transform2() {
      this.worldTransform = new Matrix$1();
      this.localTransform = new Matrix$1();
      this.position = new ObservablePoint(this.onChange, this, 0, 0);
      this.scale = new ObservablePoint(this.onChange, this, 1, 1);
      this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
      this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
      this._rotation = 0;
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
      this._localID = 0;
      this._currentLocalID = 0;
      this._worldID = 0;
      this._parentID = 0;
    }
    Transform2.prototype.onChange = function() {
      this._localID++;
    };
    Transform2.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y);
      this._sx = Math.sin(this._rotation + this.skew.y);
      this._cy = -Math.sin(this._rotation - this.skew.x);
      this._sy = Math.cos(this._rotation - this.skew.x);
      this._localID++;
    };
    Transform2.prototype.toString = function() {
      return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
    };
    Transform2.prototype.updateLocalTransform = function() {
      var lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
    };
    Transform2.prototype.updateTransform = function(parentTransform) {
      var lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
      if (this._parentID !== parentTransform._worldID) {
        var pt = parentTransform.worldTransform;
        var wt = this.worldTransform;
        wt.a = lt.a * pt.a + lt.b * pt.c;
        wt.b = lt.a * pt.b + lt.b * pt.d;
        wt.c = lt.c * pt.a + lt.d * pt.c;
        wt.d = lt.c * pt.b + lt.d * pt.d;
        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
        this._parentID = parentTransform._worldID;
        this._worldID++;
      }
    };
    Transform2.prototype.setFromMatrix = function(matrix2) {
      matrix2.decompose(this);
      this._localID++;
    };
    Object.defineProperty(Transform2.prototype, "rotation", {
      /** The rotation of the object in radians. */
      get: function() {
        return this._rotation;
      },
      set: function(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this.updateSkew();
        }
      },
      enumerable: false,
      configurable: true
    });
    Transform2.IDENTITY = new Transform2();
    return Transform2;
  }()
);
/*!
 * @pixi/display - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.SORTABLE_CHILDREN = false;
var Bounds = (
  /** @class */
  function() {
    function Bounds2() {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
      this.rect = null;
      this.updateID = -1;
    }
    Bounds2.prototype.isEmpty = function() {
      return this.minX > this.maxX || this.minY > this.maxY;
    };
    Bounds2.prototype.clear = function() {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
    };
    Bounds2.prototype.getRectangle = function(rect) {
      if (this.minX > this.maxX || this.minY > this.maxY) {
        return Rectangle.EMPTY;
      }
      rect = rect || new Rectangle(0, 0, 1, 1);
      rect.x = this.minX;
      rect.y = this.minY;
      rect.width = this.maxX - this.minX;
      rect.height = this.maxY - this.minY;
      return rect;
    };
    Bounds2.prototype.addPoint = function(point) {
      this.minX = Math.min(this.minX, point.x);
      this.maxX = Math.max(this.maxX, point.x);
      this.minY = Math.min(this.minY, point.y);
      this.maxY = Math.max(this.maxY, point.y);
    };
    Bounds2.prototype.addPointMatrix = function(matrix2, point) {
      var a = matrix2.a, b = matrix2.b, c2 = matrix2.c, d = matrix2.d, tx = matrix2.tx, ty = matrix2.ty;
      var x = a * point.x + c2 * point.y + tx;
      var y = b * point.x + d * point.y + ty;
      this.minX = Math.min(this.minX, x);
      this.maxX = Math.max(this.maxX, x);
      this.minY = Math.min(this.minY, y);
      this.maxY = Math.max(this.maxY, y);
    };
    Bounds2.prototype.addQuad = function(vertices) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      var x = vertices[0];
      var y = vertices[1];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = vertices[2];
      y = vertices[3];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = vertices[4];
      y = vertices[5];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = vertices[6];
      y = vertices[7];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    Bounds2.prototype.addFrame = function(transform, x0, y0, x1, y1) {
      this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
    };
    Bounds2.prototype.addFrameMatrix = function(matrix2, x0, y0, x1, y1) {
      var a = matrix2.a;
      var b = matrix2.b;
      var c2 = matrix2.c;
      var d = matrix2.d;
      var tx = matrix2.tx;
      var ty = matrix2.ty;
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      var x = a * x0 + c2 * y0 + tx;
      var y = b * x0 + d * y0 + ty;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = a * x1 + c2 * y0 + tx;
      y = b * x1 + d * y0 + ty;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = a * x0 + c2 * y1 + tx;
      y = b * x0 + d * y1 + ty;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = a * x1 + c2 * y1 + tx;
      y = b * x1 + d * y1 + ty;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    Bounds2.prototype.addVertexData = function(vertexData, beginOffset, endOffset) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      for (var i = beginOffset; i < endOffset; i += 2) {
        var x = vertexData[i];
        var y = vertexData[i + 1];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    Bounds2.prototype.addVertices = function(transform, vertices, beginOffset, endOffset) {
      this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
    };
    Bounds2.prototype.addVerticesMatrix = function(matrix2, vertices, beginOffset, endOffset, padX, padY) {
      if (padX === void 0) {
        padX = 0;
      }
      if (padY === void 0) {
        padY = padX;
      }
      var a = matrix2.a;
      var b = matrix2.b;
      var c2 = matrix2.c;
      var d = matrix2.d;
      var tx = matrix2.tx;
      var ty = matrix2.ty;
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      for (var i = beginOffset; i < endOffset; i += 2) {
        var rawX = vertices[i];
        var rawY = vertices[i + 1];
        var x = a * rawX + c2 * rawY + tx;
        var y = d * rawY + b * rawX + ty;
        minX = Math.min(minX, x - padX);
        maxX = Math.max(maxX, x + padX);
        minY = Math.min(minY, y - padY);
        maxY = Math.max(maxY, y + padY);
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    Bounds2.prototype.addBounds = function(bounds) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.minX = bounds.minX < minX ? bounds.minX : minX;
      this.minY = bounds.minY < minY ? bounds.minY : minY;
      this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
      this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
    };
    Bounds2.prototype.addBoundsMask = function(bounds, mask) {
      var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
      var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
      var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
      var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
      if (_minX <= _maxX && _minY <= _maxY) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = _minX < minX ? _minX : minX;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = _maxY > maxY ? _maxY : maxY;
      }
    };
    Bounds2.prototype.addBoundsMatrix = function(bounds, matrix2) {
      this.addFrameMatrix(matrix2, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
    };
    Bounds2.prototype.addBoundsArea = function(bounds, area2) {
      var _minX = bounds.minX > area2.x ? bounds.minX : area2.x;
      var _minY = bounds.minY > area2.y ? bounds.minY : area2.y;
      var _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width;
      var _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;
      if (_minX <= _maxX && _minY <= _maxY) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = _minX < minX ? _minX : minX;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = _maxY > maxY ? _maxY : maxY;
      }
    };
    Bounds2.prototype.pad = function(paddingX, paddingY) {
      if (paddingX === void 0) {
        paddingX = 0;
      }
      if (paddingY === void 0) {
        paddingY = paddingX;
      }
      if (!this.isEmpty()) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
      }
    };
    Bounds2.prototype.addFramePad = function(x0, y0, x1, y1, padX, padY) {
      x0 -= padX;
      y0 -= padY;
      x1 += padX;
      y1 += padY;
      this.minX = this.minX < x0 ? this.minX : x0;
      this.maxX = this.maxX > x1 ? this.maxX : x1;
      this.minY = this.minY < y0 ? this.minY : y0;
      this.maxY = this.maxY > y1 ? this.maxY : y1;
    };
    return Bounds2;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$j = function(d, b) {
  extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$j(d, b);
};
function __extends$j(d, b) {
  extendStatics$j(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var DisplayObject = (
  /** @class */
  function(_super) {
    __extends$j(DisplayObject2, _super);
    function DisplayObject2() {
      var _this = _super.call(this) || this;
      _this.tempDisplayObjectParent = null;
      _this.transform = new Transform();
      _this.alpha = 1;
      _this.visible = true;
      _this.renderable = true;
      _this.cullable = false;
      _this.cullArea = null;
      _this.parent = null;
      _this.worldAlpha = 1;
      _this._lastSortedIndex = 0;
      _this._zIndex = 0;
      _this.filterArea = null;
      _this.filters = null;
      _this._enabledFilters = null;
      _this._bounds = new Bounds();
      _this._localBounds = null;
      _this._boundsID = 0;
      _this._boundsRect = null;
      _this._localBoundsRect = null;
      _this._mask = null;
      _this._maskRefCount = 0;
      _this._destroyed = false;
      _this.isSprite = false;
      _this.isMask = false;
      return _this;
    }
    DisplayObject2.mixin = function(source) {
      var keys = Object.keys(source);
      for (var i = 0; i < keys.length; ++i) {
        var propertyName = keys[i];
        Object.defineProperty(DisplayObject2.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
      }
    };
    Object.defineProperty(DisplayObject2.prototype, "destroyed", {
      /**
       * Fired when this DisplayObject is added to a Container.
       * @instance
       * @event added
       * @param {PIXI.Container} container - The container added to.
       */
      /**
       * Fired when this DisplayObject is removed from a Container.
       * @instance
       * @event removed
       * @param {PIXI.Container} container - The container removed from.
       */
      /**
       * Fired when this DisplayObject is destroyed. This event is emitted once
       * destroy is finished.
       * @instance
       * @event destroyed
       */
      /** Readonly flag for destroyed display objects. */
      get: function() {
        return this._destroyed;
      },
      enumerable: false,
      configurable: true
    });
    DisplayObject2.prototype._recursivePostUpdateTransform = function() {
      if (this.parent) {
        this.parent._recursivePostUpdateTransform();
        this.transform.updateTransform(this.parent.transform);
      } else {
        this.transform.updateTransform(this._tempDisplayObjectParent.transform);
      }
    };
    DisplayObject2.prototype.updateTransform = function() {
      this._boundsID++;
      this.transform.updateTransform(this.parent.transform);
      this.worldAlpha = this.alpha * this.parent.worldAlpha;
    };
    DisplayObject2.prototype.getBounds = function(skipUpdate, rect) {
      if (!skipUpdate) {
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.updateTransform();
          this.parent = null;
        } else {
          this._recursivePostUpdateTransform();
          this.updateTransform();
        }
      }
      if (this._bounds.updateID !== this._boundsID) {
        this.calculateBounds();
        this._bounds.updateID = this._boundsID;
      }
      if (!rect) {
        if (!this._boundsRect) {
          this._boundsRect = new Rectangle();
        }
        rect = this._boundsRect;
      }
      return this._bounds.getRectangle(rect);
    };
    DisplayObject2.prototype.getLocalBounds = function(rect) {
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      if (!this._localBounds) {
        this._localBounds = new Bounds();
      }
      var transformRef = this.transform;
      var parentRef = this.parent;
      this.parent = null;
      this.transform = this._tempDisplayObjectParent.transform;
      var worldBounds = this._bounds;
      var worldBoundsID = this._boundsID;
      this._bounds = this._localBounds;
      var bounds = this.getBounds(false, rect);
      this.parent = parentRef;
      this.transform = transformRef;
      this._bounds = worldBounds;
      this._bounds.updateID += this._boundsID - worldBoundsID;
      return bounds;
    };
    DisplayObject2.prototype.toGlobal = function(position, point, skipUpdate) {
      if (skipUpdate === void 0) {
        skipUpdate = false;
      }
      if (!skipUpdate) {
        this._recursivePostUpdateTransform();
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.displayObjectUpdateTransform();
          this.parent = null;
        } else {
          this.displayObjectUpdateTransform();
        }
      }
      return this.worldTransform.apply(position, point);
    };
    DisplayObject2.prototype.toLocal = function(position, from, point, skipUpdate) {
      if (from) {
        position = from.toGlobal(position, point, skipUpdate);
      }
      if (!skipUpdate) {
        this._recursivePostUpdateTransform();
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.displayObjectUpdateTransform();
          this.parent = null;
        } else {
          this.displayObjectUpdateTransform();
        }
      }
      return this.worldTransform.applyInverse(position, point);
    };
    DisplayObject2.prototype.setParent = function(container) {
      if (!container || !container.addChild) {
        throw new Error("setParent: Argument must be a Container");
      }
      container.addChild(this);
      return container;
    };
    DisplayObject2.prototype.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (scaleX === void 0) {
        scaleX = 1;
      }
      if (scaleY === void 0) {
        scaleY = 1;
      }
      if (rotation === void 0) {
        rotation = 0;
      }
      if (skewX === void 0) {
        skewX = 0;
      }
      if (skewY === void 0) {
        skewY = 0;
      }
      if (pivotX === void 0) {
        pivotX = 0;
      }
      if (pivotY === void 0) {
        pivotY = 0;
      }
      this.position.x = x;
      this.position.y = y;
      this.scale.x = !scaleX ? 1 : scaleX;
      this.scale.y = !scaleY ? 1 : scaleY;
      this.rotation = rotation;
      this.skew.x = skewX;
      this.skew.y = skewY;
      this.pivot.x = pivotX;
      this.pivot.y = pivotY;
      return this;
    };
    DisplayObject2.prototype.destroy = function(_options) {
      if (this.parent) {
        this.parent.removeChild(this);
      }
      this._destroyed = true;
      this.transform = null;
      this.parent = null;
      this._bounds = null;
      this.mask = null;
      this.cullArea = null;
      this.filters = null;
      this.filterArea = null;
      this.hitArea = null;
      this.interactive = false;
      this.interactiveChildren = false;
      this.emit("destroyed");
      this.removeAllListeners();
    };
    Object.defineProperty(DisplayObject2.prototype, "_tempDisplayObjectParent", {
      /**
       * @protected
       * @member {PIXI.Container}
       */
      get: function() {
        if (this.tempDisplayObjectParent === null) {
          this.tempDisplayObjectParent = new TemporaryDisplayObject();
        }
        return this.tempDisplayObjectParent;
      },
      enumerable: false,
      configurable: true
    });
    DisplayObject2.prototype.enableTempParent = function() {
      var myParent = this.parent;
      this.parent = this._tempDisplayObjectParent;
      return myParent;
    };
    DisplayObject2.prototype.disableTempParent = function(cacheParent) {
      this.parent = cacheParent;
    };
    Object.defineProperty(DisplayObject2.prototype, "x", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get: function() {
        return this.position.x;
      },
      set: function(value) {
        this.transform.position.x = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "y", {
      /**
       * The position of the displayObject on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get: function() {
        return this.position.y;
      },
      set: function(value) {
        this.transform.position.y = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "worldTransform", {
      /**
       * Current transform of the object based on world (parent) factors.
       * @readonly
       */
      get: function() {
        return this.transform.worldTransform;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "localTransform", {
      /**
       * Current transform of the object based on local factors: position, scale, other stuff.
       * @readonly
       */
      get: function() {
        return this.transform.localTransform;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "position", {
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.position;
      },
      set: function(value) {
        this.transform.position.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "scale", {
      /**
       * The scale factors of this object along the local coordinate axes.
       *
       * The default scale is (1, 1).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.scale;
      },
      set: function(value) {
        this.transform.scale.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "pivot", {
      /**
       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
       * is the projection of `pivot` in the parent's local space.
       *
       * By default, the pivot is the origin (0, 0).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.pivot;
      },
      set: function(value) {
        this.transform.pivot.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "skew", {
      /**
       * The skew factor for the object in radians.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.skew;
      },
      set: function(value) {
        this.transform.skew.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "rotation", {
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation;
      },
      set: function(value) {
        this.transform.rotation = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "angle", {
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation * RAD_TO_DEG;
      },
      set: function(value) {
        this.transform.rotation = value * DEG_TO_RAD;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "zIndex", {
      /**
       * The zIndex of the displayObject.
       *
       * If a container has the sortableChildren property set to true, children will be automatically
       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
       * and thus rendered on top of other display objects within the same container.
       * @see PIXI.Container#sortableChildren
       */
      get: function() {
        return this._zIndex;
      },
      set: function(value) {
        this._zIndex = value;
        if (this.parent) {
          this.parent.sortDirty = true;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "worldVisible", {
      /**
       * Indicates if the object is globally visible.
       * @readonly
       */
      get: function() {
        var item = this;
        do {
          if (!item.visible) {
            return false;
          }
          item = item.parent;
        } while (item);
        return true;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "mask", {
      /**
       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
       * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
       * To remove a mask, set this property to `null`.
       *
       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
       * @example
       * const graphics = new PIXI.Graphics();
       * graphics.beginFill(0xFF3300);
       * graphics.drawRect(50, 250, 100, 100);
       * graphics.endFill();
       *
       * const sprite = new PIXI.Sprite(texture);
       * sprite.mask = graphics;
       * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
       */
      get: function() {
        return this._mask;
      },
      set: function(value) {
        if (this._mask === value) {
          return;
        }
        if (this._mask) {
          var maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
          if (maskObject) {
            maskObject._maskRefCount--;
            if (maskObject._maskRefCount === 0) {
              maskObject.renderable = true;
              maskObject.isMask = false;
            }
          }
        }
        this._mask = value;
        if (this._mask) {
          var maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
          if (maskObject) {
            if (maskObject._maskRefCount === 0) {
              maskObject.renderable = false;
              maskObject.isMask = true;
            }
            maskObject._maskRefCount++;
          }
        }
      },
      enumerable: false,
      configurable: true
    });
    return DisplayObject2;
  }(EventEmitter)
);
var TemporaryDisplayObject = (
  /** @class */
  function(_super) {
    __extends$j(TemporaryDisplayObject2, _super);
    function TemporaryDisplayObject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.sortDirty = null;
      return _this;
    }
    return TemporaryDisplayObject2;
  }(DisplayObject)
);
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
function sortChildren(a, b) {
  if (a.zIndex === b.zIndex) {
    return a._lastSortedIndex - b._lastSortedIndex;
  }
  return a.zIndex - b.zIndex;
}
var Container = (
  /** @class */
  function(_super) {
    __extends$j(Container2, _super);
    function Container2() {
      var _this = _super.call(this) || this;
      _this.children = [];
      _this.sortableChildren = settings.SORTABLE_CHILDREN;
      _this.sortDirty = false;
      return _this;
    }
    Container2.prototype.onChildrenChange = function(_length) {
    };
    Container2.prototype.addChild = function() {
      var arguments$1 = arguments;
      var children2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        children2[_i] = arguments$1[_i];
      }
      if (children2.length > 1) {
        for (var i = 0; i < children2.length; i++) {
          this.addChild(children2[i]);
        }
      } else {
        var child = children2[0];
        if (child.parent) {
          child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        child.transform._parentID = -1;
        this.children.push(child);
        this._boundsID++;
        this.onChildrenChange(this.children.length - 1);
        this.emit("childAdded", child, this, this.children.length - 1);
        child.emit("added", this);
      }
      return children2[0];
    };
    Container2.prototype.addChildAt = function(child, index) {
      if (index < 0 || index > this.children.length) {
        throw new Error(child + "addChildAt: The index " + index + " supplied is out of bounds " + this.children.length);
      }
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.splice(index, 0, child);
      this._boundsID++;
      this.onChildrenChange(index);
      child.emit("added", this);
      this.emit("childAdded", child, this, index);
      return child;
    };
    Container2.prototype.swapChildren = function(child, child2) {
      if (child === child2) {
        return;
      }
      var index1 = this.getChildIndex(child);
      var index2 = this.getChildIndex(child2);
      this.children[index1] = child2;
      this.children[index2] = child;
      this.onChildrenChange(index1 < index2 ? index1 : index2);
    };
    Container2.prototype.getChildIndex = function(child) {
      var index = this.children.indexOf(child);
      if (index === -1) {
        throw new Error("The supplied DisplayObject must be a child of the caller");
      }
      return index;
    };
    Container2.prototype.setChildIndex = function(child, index) {
      if (index < 0 || index >= this.children.length) {
        throw new Error("The index " + index + " supplied is out of bounds " + this.children.length);
      }
      var currentIndex = this.getChildIndex(child);
      removeItems(this.children, currentIndex, 1);
      this.children.splice(index, 0, child);
      this.onChildrenChange(index);
    };
    Container2.prototype.getChildAt = function(index) {
      if (index < 0 || index >= this.children.length) {
        throw new Error("getChildAt: Index (" + index + ") does not exist.");
      }
      return this.children[index];
    };
    Container2.prototype.removeChild = function() {
      var arguments$1 = arguments;
      var children2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        children2[_i] = arguments$1[_i];
      }
      if (children2.length > 1) {
        for (var i = 0; i < children2.length; i++) {
          this.removeChild(children2[i]);
        }
      } else {
        var child = children2[0];
        var index = this.children.indexOf(child);
        if (index === -1) {
          return null;
        }
        child.parent = null;
        child.transform._parentID = -1;
        removeItems(this.children, index, 1);
        this._boundsID++;
        this.onChildrenChange(index);
        child.emit("removed", this);
        this.emit("childRemoved", child, this, index);
      }
      return children2[0];
    };
    Container2.prototype.removeChildAt = function(index) {
      var child = this.getChildAt(index);
      child.parent = null;
      child.transform._parentID = -1;
      removeItems(this.children, index, 1);
      this._boundsID++;
      this.onChildrenChange(index);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index);
      return child;
    };
    Container2.prototype.removeChildren = function(beginIndex, endIndex) {
      if (beginIndex === void 0) {
        beginIndex = 0;
      }
      if (endIndex === void 0) {
        endIndex = this.children.length;
      }
      var begin = beginIndex;
      var end = endIndex;
      var range2 = end - begin;
      var removed;
      if (range2 > 0 && range2 <= end) {
        removed = this.children.splice(begin, range2);
        for (var i = 0; i < removed.length; ++i) {
          removed[i].parent = null;
          if (removed[i].transform) {
            removed[i].transform._parentID = -1;
          }
        }
        this._boundsID++;
        this.onChildrenChange(beginIndex);
        for (var i = 0; i < removed.length; ++i) {
          removed[i].emit("removed", this);
          this.emit("childRemoved", removed[i], this, i);
        }
        return removed;
      } else if (range2 === 0 && this.children.length === 0) {
        return [];
      }
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    };
    Container2.prototype.sortChildren = function() {
      var sortRequired = false;
      for (var i = 0, j = this.children.length; i < j; ++i) {
        var child = this.children[i];
        child._lastSortedIndex = i;
        if (!sortRequired && child.zIndex !== 0) {
          sortRequired = true;
        }
      }
      if (sortRequired && this.children.length > 1) {
        this.children.sort(sortChildren);
      }
      this.sortDirty = false;
    };
    Container2.prototype.updateTransform = function() {
      if (this.sortableChildren && this.sortDirty) {
        this.sortChildren();
      }
      this._boundsID++;
      this.transform.updateTransform(this.parent.transform);
      this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var i = 0, j = this.children.length; i < j; ++i) {
        var child = this.children[i];
        if (child.visible) {
          child.updateTransform();
        }
      }
    };
    Container2.prototype.calculateBounds = function() {
      this._bounds.clear();
      this._calculateBounds();
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        if (!child.visible || !child.renderable) {
          continue;
        }
        child.calculateBounds();
        if (child._mask) {
          var maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
          if (maskObject) {
            maskObject.calculateBounds();
            this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
          } else {
            this._bounds.addBounds(child._bounds);
          }
        } else if (child.filterArea) {
          this._bounds.addBoundsArea(child._bounds, child.filterArea);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      }
      this._bounds.updateID = this._boundsID;
    };
    Container2.prototype.getLocalBounds = function(rect, skipChildrenUpdate) {
      if (skipChildrenUpdate === void 0) {
        skipChildrenUpdate = false;
      }
      var result = _super.prototype.getLocalBounds.call(this, rect);
      if (!skipChildrenUpdate) {
        for (var i = 0, j = this.children.length; i < j; ++i) {
          var child = this.children[i];
          if (child.visible) {
            child.updateTransform();
          }
        }
      }
      return result;
    };
    Container2.prototype._calculateBounds = function() {
    };
    Container2.prototype._renderWithCulling = function(renderer) {
      var sourceFrame = renderer.renderTexture.sourceFrame;
      if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
        return;
      }
      var bounds;
      var transform;
      if (this.cullArea) {
        bounds = this.cullArea;
        transform = this.worldTransform;
      } else if (this._render !== Container2.prototype._render) {
        bounds = this.getBounds(true);
      }
      if (bounds && sourceFrame.intersects(bounds, transform)) {
        this._render(renderer);
      } else if (this.cullArea) {
        return;
      }
      for (var i = 0, j = this.children.length; i < j; ++i) {
        var child = this.children[i];
        var childCullable = child.cullable;
        child.cullable = childCullable || !this.cullArea;
        child.render(renderer);
        child.cullable = childCullable;
      }
    };
    Container2.prototype.render = function(renderer) {
      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
      }
      if (this._mask || this.filters && this.filters.length) {
        this.renderAdvanced(renderer);
      } else if (this.cullable) {
        this._renderWithCulling(renderer);
      } else {
        this._render(renderer);
        for (var i = 0, j = this.children.length; i < j; ++i) {
          this.children[i].render(renderer);
        }
      }
    };
    Container2.prototype.renderAdvanced = function(renderer) {
      var filters = this.filters;
      var mask = this._mask;
      if (filters) {
        if (!this._enabledFilters) {
          this._enabledFilters = [];
        }
        this._enabledFilters.length = 0;
        for (var i = 0; i < filters.length; i++) {
          if (filters[i].enabled) {
            this._enabledFilters.push(filters[i]);
          }
        }
      }
      var flush2 = filters && this._enabledFilters && this._enabledFilters.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE));
      if (flush2) {
        renderer.batch.flush();
      }
      if (filters && this._enabledFilters && this._enabledFilters.length) {
        renderer.filter.push(this, this._enabledFilters);
      }
      if (mask) {
        renderer.mask.push(this, this._mask);
      }
      if (this.cullable) {
        this._renderWithCulling(renderer);
      } else {
        this._render(renderer);
        for (var i = 0, j = this.children.length; i < j; ++i) {
          this.children[i].render(renderer);
        }
      }
      if (flush2) {
        renderer.batch.flush();
      }
      if (mask) {
        renderer.mask.pop(this);
      }
      if (filters && this._enabledFilters && this._enabledFilters.length) {
        renderer.filter.pop();
      }
    };
    Container2.prototype._render = function(_renderer) {
    };
    Container2.prototype.destroy = function(options) {
      _super.prototype.destroy.call(this);
      this.sortDirty = false;
      var destroyChildren = typeof options === "boolean" ? options : options && options.children;
      var oldChildren = this.removeChildren(0, this.children.length);
      if (destroyChildren) {
        for (var i = 0; i < oldChildren.length; ++i) {
          oldChildren[i].destroy(options);
        }
      }
    };
    Object.defineProperty(Container2.prototype, "width", {
      /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.x * this.getLocalBounds().width;
      },
      set: function(value) {
        var width = this.getLocalBounds().width;
        if (width !== 0) {
          this.scale.x = value / width;
        } else {
          this.scale.x = 1;
        }
        this._width = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "height", {
      /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.y * this.getLocalBounds().height;
      },
      set: function(value) {
        var height = this.getLocalBounds().height;
        if (height !== 0) {
          this.scale.y = value / height;
        } else {
          this.scale.y = 1;
        }
        this._height = value;
      },
      enumerable: false,
      configurable: true
    });
    return Container2;
  }(DisplayObject)
);
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
/*!
 * @pixi/extensions - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/extensions is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t) {
    var arguments$1 = arguments;
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments$1[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) {
          t[p] = s[p];
        }
      }
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var ExtensionType;
(function(ExtensionType2) {
  ExtensionType2["Application"] = "application";
  ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";
  ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";
  ExtensionType2["Loader"] = "loader";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
})(ExtensionType || (ExtensionType = {}));
var normalizeExtension = function(ext) {
  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
    if (!ext.extension) {
      throw new Error("Extension class must have an extension object");
    }
    var metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
    ext = __assign$1(__assign$1({}, metadata), { ref: ext });
  }
  if (typeof ext === "object") {
    ext = __assign$1({}, ext);
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext.type === "string") {
    ext.type = [ext.type];
  }
  return ext;
};
var extensions = {
  /** @ignore */
  _addHandlers: null,
  /** @ignore */
  _removeHandlers: null,
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {PIXI.extensions} For chaining.
   */
  remove: function() {
    var arguments$1 = arguments;
    var _this = this;
    var extensions2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      extensions2[_i] = arguments$1[_i];
    }
    extensions2.map(normalizeExtension).forEach(function(ext) {
      ext.type.forEach(function(type2) {
        var _a2, _b2;
        return (_b2 = (_a2 = _this._removeHandlers)[type2]) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, ext);
      });
    });
    return this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {PIXI.extensions} For chaining.
   */
  add: function() {
    var arguments$1 = arguments;
    var _this = this;
    var extensions2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      extensions2[_i] = arguments$1[_i];
    }
    extensions2.map(normalizeExtension).forEach(function(ext) {
      ext.type.forEach(function(type2) {
        var handlers = _this._addHandlers;
        var queue = _this._queue;
        if (!handlers[type2]) {
          queue[type2] = queue[type2] || [];
          queue[type2].push(ext);
        } else {
          handlers[type2](ext);
        }
      });
    });
    return this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.
   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.
   * @returns {PIXI.extensions} For chaining.
   */
  handle: function(type2, onAdd2, onRemove2) {
    var addHandlers = this._addHandlers = this._addHandlers || {};
    var removeHandlers = this._removeHandlers = this._removeHandlers || {};
    if (addHandlers[type2] || removeHandlers[type2]) {
      throw new Error("Extension type " + type2 + " already has a handler");
    }
    addHandlers[type2] = onAdd2;
    removeHandlers[type2] = onRemove2;
    var queue = this._queue;
    if (queue[type2]) {
      queue[type2].forEach(function(ext) {
        return onAdd2(ext);
      });
      delete queue[type2];
    }
    return this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByMap: function(type2, map2) {
    return this.handle(type2, function(extension) {
      map2[extension.name] = extension.ref;
    }, function(extension) {
      delete map2[extension.name];
    });
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByList: function(type2, list) {
    return this.handle(type2, function(extension) {
      var _a2, _b2;
      if (list.includes(extension.ref)) {
        return;
      }
      list.push(extension.ref);
      if (type2 === ExtensionType.Loader) {
        (_b2 = (_a2 = extension.ref).add) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
    }, function(extension) {
      var index = list.indexOf(extension.ref);
      if (index !== -1) {
        list.splice(index, 1);
      }
    });
  }
};
/*!
 * @pixi/runner - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Runner = (
  /** @class */
  function() {
    function Runner2(name2) {
      this.items = [];
      this._name = name2;
      this._aliasCount = 0;
    }
    Runner2.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {
      if (arguments.length > 8) {
        throw new Error("max arguments reached");
      }
      var _a2 = this, name2 = _a2.name, items = _a2.items;
      this._aliasCount++;
      for (var i = 0, len = items.length; i < len; i++) {
        items[i][name2](a0, a1, a2, a3, a4, a5, a6, a7);
      }
      if (items === this.items) {
        this._aliasCount--;
      }
      return this;
    };
    Runner2.prototype.ensureNonAliasedItems = function() {
      if (this._aliasCount > 0 && this.items.length > 1) {
        this._aliasCount = 0;
        this.items = this.items.slice(0);
      }
    };
    Runner2.prototype.add = function(item) {
      if (item[this._name]) {
        this.ensureNonAliasedItems();
        this.remove(item);
        this.items.push(item);
      }
      return this;
    };
    Runner2.prototype.remove = function(item) {
      var index = this.items.indexOf(item);
      if (index !== -1) {
        this.ensureNonAliasedItems();
        this.items.splice(index, 1);
      }
      return this;
    };
    Runner2.prototype.contains = function(item) {
      return this.items.indexOf(item) !== -1;
    };
    Runner2.prototype.removeAll = function() {
      this.ensureNonAliasedItems();
      this.items.length = 0;
      return this;
    };
    Runner2.prototype.destroy = function() {
      this.removeAll();
      this.items = null;
      this._name = null;
    };
    Object.defineProperty(Runner2.prototype, "empty", {
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get: function() {
        return this.items.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Runner2.prototype, "name", {
      /**
       * The name of the runner.
       * @readonly
       */
      get: function() {
        return this._name;
      },
      enumerable: false,
      configurable: true
    });
    return Runner2;
  }()
);
Object.defineProperties(Runner.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Runner.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Runner.prototype.emit }
});
/*!
 * @pixi/ticker - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY;
(function(UPDATE_PRIORITY2) {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
var TickerListener = (
  /** @class */
  function() {
    function TickerListener2(fn, context2, priority, once) {
      if (context2 === void 0) {
        context2 = null;
      }
      if (priority === void 0) {
        priority = 0;
      }
      if (once === void 0) {
        once = false;
      }
      this.next = null;
      this.previous = null;
      this._destroyed = false;
      this.fn = fn;
      this.context = context2;
      this.priority = priority;
      this.once = once;
    }
    TickerListener2.prototype.match = function(fn, context2) {
      if (context2 === void 0) {
        context2 = null;
      }
      return this.fn === fn && this.context === context2;
    };
    TickerListener2.prototype.emit = function(deltaTime) {
      if (this.fn) {
        if (this.context) {
          this.fn.call(this.context, deltaTime);
        } else {
          this.fn(deltaTime);
        }
      }
      var redirect = this.next;
      if (this.once) {
        this.destroy(true);
      }
      if (this._destroyed) {
        this.next = null;
      }
      return redirect;
    };
    TickerListener2.prototype.connect = function(previous) {
      this.previous = previous;
      if (previous.next) {
        previous.next.previous = this;
      }
      this.next = previous.next;
      previous.next = this;
    };
    TickerListener2.prototype.destroy = function(hard) {
      if (hard === void 0) {
        hard = false;
      }
      this._destroyed = true;
      this.fn = null;
      this.context = null;
      if (this.previous) {
        this.previous.next = this.next;
      }
      if (this.next) {
        this.next.previous = this.previous;
      }
      var redirect = this.next;
      this.next = hard ? null : redirect;
      this.previous = null;
      return redirect;
    };
    return TickerListener2;
  }()
);
var Ticker = (
  /** @class */
  function() {
    function Ticker2() {
      var _this = this;
      this.autoStart = false;
      this.deltaTime = 1;
      this.lastTime = -1;
      this.speed = 1;
      this.started = false;
      this._requestId = null;
      this._maxElapsedMS = 100;
      this._minElapsedMS = 0;
      this._protected = false;
      this._lastFrame = -1;
      this._head = new TickerListener(null, null, Infinity);
      this.deltaMS = 1 / settings.TARGET_FPMS;
      this.elapsedMS = 1 / settings.TARGET_FPMS;
      this._tick = function(time) {
        _this._requestId = null;
        if (_this.started) {
          _this.update(time);
          if (_this.started && _this._requestId === null && _this._head.next) {
            _this._requestId = requestAnimationFrame(_this._tick);
          }
        }
      };
    }
    Ticker2.prototype._requestIfNeeded = function() {
      if (this._requestId === null && this._head.next) {
        this.lastTime = performance.now();
        this._lastFrame = this.lastTime;
        this._requestId = requestAnimationFrame(this._tick);
      }
    };
    Ticker2.prototype._cancelIfNeeded = function() {
      if (this._requestId !== null) {
        cancelAnimationFrame(this._requestId);
        this._requestId = null;
      }
    };
    Ticker2.prototype._startIfPossible = function() {
      if (this.started) {
        this._requestIfNeeded();
      } else if (this.autoStart) {
        this.start();
      }
    };
    Ticker2.prototype.add = function(fn, context2, priority) {
      if (priority === void 0) {
        priority = UPDATE_PRIORITY.NORMAL;
      }
      return this._addListener(new TickerListener(fn, context2, priority));
    };
    Ticker2.prototype.addOnce = function(fn, context2, priority) {
      if (priority === void 0) {
        priority = UPDATE_PRIORITY.NORMAL;
      }
      return this._addListener(new TickerListener(fn, context2, priority, true));
    };
    Ticker2.prototype._addListener = function(listener) {
      var current = this._head.next;
      var previous = this._head;
      if (!current) {
        listener.connect(previous);
      } else {
        while (current) {
          if (listener.priority > current.priority) {
            listener.connect(previous);
            break;
          }
          previous = current;
          current = current.next;
        }
        if (!listener.previous) {
          listener.connect(previous);
        }
      }
      this._startIfPossible();
      return this;
    };
    Ticker2.prototype.remove = function(fn, context2) {
      var listener = this._head.next;
      while (listener) {
        if (listener.match(fn, context2)) {
          listener = listener.destroy();
        } else {
          listener = listener.next;
        }
      }
      if (!this._head.next) {
        this._cancelIfNeeded();
      }
      return this;
    };
    Object.defineProperty(Ticker2.prototype, "count", {
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get: function() {
        if (!this._head) {
          return 0;
        }
        var count = 0;
        var current = this._head;
        while (current = current.next) {
          count++;
        }
        return count;
      },
      enumerable: false,
      configurable: true
    });
    Ticker2.prototype.start = function() {
      if (!this.started) {
        this.started = true;
        this._requestIfNeeded();
      }
    };
    Ticker2.prototype.stop = function() {
      if (this.started) {
        this.started = false;
        this._cancelIfNeeded();
      }
    };
    Ticker2.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        var listener = this._head.next;
        while (listener) {
          listener = listener.destroy(true);
        }
        this._head.destroy();
        this._head = null;
      }
    };
    Ticker2.prototype.update = function(currentTime) {
      if (currentTime === void 0) {
        currentTime = performance.now();
      }
      var elapsedMS;
      if (currentTime > this.lastTime) {
        elapsedMS = this.elapsedMS = currentTime - this.lastTime;
        if (elapsedMS > this._maxElapsedMS) {
          elapsedMS = this._maxElapsedMS;
        }
        elapsedMS *= this.speed;
        if (this._minElapsedMS) {
          var delta = currentTime - this._lastFrame | 0;
          if (delta < this._minElapsedMS) {
            return;
          }
          this._lastFrame = currentTime - delta % this._minElapsedMS;
        }
        this.deltaMS = elapsedMS;
        this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
        var head = this._head;
        var listener = head.next;
        while (listener) {
          listener = listener.emit(this.deltaTime);
        }
        if (!head.next) {
          this._cancelIfNeeded();
        }
      } else {
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      }
      this.lastTime = currentTime;
    };
    Object.defineProperty(Ticker2.prototype, "FPS", {
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link PIXI.Ticker#speed}, which is specific
       * to scaling {@link PIXI.Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get: function() {
        return 1e3 / this.elapsedMS;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker2.prototype, "minFPS", {
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This value is used to cap {@link PIXI.Ticker#deltaTime},
       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get: function() {
        return 1e3 / this._maxElapsedMS;
      },
      set: function(fps) {
        var minFPS = Math.min(this.maxFPS, fps);
        var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS);
        this._maxElapsedMS = 1 / minFPMS;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker2.prototype, "maxFPS", {
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This will effect the measured value of {@link PIXI.Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get: function() {
        if (this._minElapsedMS) {
          return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
      },
      set: function(fps) {
        if (fps === 0) {
          this._minElapsedMS = 0;
        } else {
          var maxFPS = Math.max(this.minFPS, fps);
          this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker2, "shared", {
      /**
       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
       * {@link PIXI.VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * let ticker = PIXI.Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.Ticker.shared instance.
       * ticker.autoStart = false;
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * // You may use the shared ticker to render...
       * let renderer = PIXI.autoDetectRenderer();
       * let stage = new PIXI.Container();
       * document.body.appendChild(renderer.view);
       * ticker.add(function (time) {
       *     renderer.render(stage);
       * });
       * @example
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * function animate(time) {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * }
       * animate(performance.now());
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!Ticker2._shared) {
          var shared = Ticker2._shared = new Ticker2();
          shared.autoStart = true;
          shared._protected = true;
        }
        return Ticker2._shared;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker2, "system", {
      /**
       * The system ticker instance used by {@link PIXI.InteractionManager} and by
       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!Ticker2._system) {
          var system = Ticker2._system = new Ticker2();
          system.autoStart = true;
          system._protected = true;
        }
        return Ticker2._system;
      },
      enumerable: false,
      configurable: true
    });
    return Ticker2;
  }()
);
var TickerPlugin = (
  /** @class */
  function() {
    function TickerPlugin2() {
    }
    TickerPlugin2.init = function(options) {
      var _this = this;
      options = Object.assign({
        autoStart: true,
        sharedTicker: false
      }, options);
      Object.defineProperty(this, "ticker", {
        set: function(ticker) {
          if (this._ticker) {
            this._ticker.remove(this.render, this);
          }
          this._ticker = ticker;
          if (ticker) {
            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
          }
        },
        get: function() {
          return this._ticker;
        }
      });
      this.stop = function() {
        _this._ticker.stop();
      };
      this.start = function() {
        _this._ticker.start();
      };
      this._ticker = null;
      this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
      if (options.autoStart) {
        this.start();
      }
    };
    TickerPlugin2.destroy = function() {
      if (this._ticker) {
        var oldTicker = this._ticker;
        this.ticker = null;
        oldTicker.destroy();
      }
    };
    TickerPlugin2.extension = ExtensionType.Application;
    return TickerPlugin2;
  }()
);
/*!
 * @pixi/core - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.PREFER_ENV = isMobile.any ? ENV.WEBGL : ENV.WEBGL2;
settings.STRICT_TEXTURE_CACHE = false;
var INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source) {
    return null;
  }
  var extension = "";
  if (typeof source === "string") {
    var result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (var i = INSTALLED.length - 1; i >= 0; --i) {
    var ResourcePlugin = INSTALLED[i];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$i = function(d, b) {
  extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$i(d, b);
};
function __extends$i(d, b) {
  extendStatics$i(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    var arguments$1 = arguments;
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments$1[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) {
          t[p] = s[p];
        }
      }
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) {
      t[p] = s[p];
    }
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) {
        t[p[i]] = s[p[i]];
      }
    }
  }
  return t;
}
var Resource = (
  /** @class */
  function() {
    function Resource2(width, height) {
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this._width = width;
      this._height = height;
      this.destroyed = false;
      this.internal = false;
      this.onResize = new Runner("setRealSize");
      this.onUpdate = new Runner("update");
      this.onError = new Runner("onError");
    }
    Resource2.prototype.bind = function(baseTexture) {
      this.onResize.add(baseTexture);
      this.onUpdate.add(baseTexture);
      this.onError.add(baseTexture);
      if (this._width || this._height) {
        this.onResize.emit(this._width, this._height);
      }
    };
    Resource2.prototype.unbind = function(baseTexture) {
      this.onResize.remove(baseTexture);
      this.onUpdate.remove(baseTexture);
      this.onError.remove(baseTexture);
    };
    Resource2.prototype.resize = function(width, height) {
      if (width !== this._width || height !== this._height) {
        this._width = width;
        this._height = height;
        this.onResize.emit(width, height);
      }
    };
    Object.defineProperty(Resource2.prototype, "valid", {
      /**
       * Has been validated
       * @readonly
       */
      get: function() {
        return !!this._width && !!this._height;
      },
      enumerable: false,
      configurable: true
    });
    Resource2.prototype.update = function() {
      if (!this.destroyed) {
        this.onUpdate.emit();
      }
    };
    Resource2.prototype.load = function() {
      return Promise.resolve(this);
    };
    Object.defineProperty(Resource2.prototype, "width", {
      /**
       * The width of the resource.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resource2.prototype, "height", {
      /**
       * The height of the resource.
       * @readonly
       */
      get: function() {
        return this._height;
      },
      enumerable: false,
      configurable: true
    });
    Resource2.prototype.style = function(_renderer, _baseTexture, _glTexture) {
      return false;
    };
    Resource2.prototype.dispose = function() {
    };
    Resource2.prototype.destroy = function() {
      if (!this.destroyed) {
        this.destroyed = true;
        this.dispose();
        this.onError.removeAll();
        this.onError = null;
        this.onResize.removeAll();
        this.onResize = null;
        this.onUpdate.removeAll();
        this.onUpdate = null;
      }
    };
    Resource2.test = function(_source, _extension) {
      return false;
    };
    return Resource2;
  }()
);
var BufferResource = (
  /** @class */
  function(_super) {
    __extends$i(BufferResource2, _super);
    function BufferResource2(source, options) {
      var _this = this;
      var _a2 = options || {}, width = _a2.width, height = _a2.height;
      if (!width || !height) {
        throw new Error("BufferResource width or height invalid");
      }
      _this = _super.call(this, width, height) || this;
      _this.data = source;
      return _this;
    }
    BufferResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
      var gl = renderer.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
      var width = baseTexture.realWidth;
      var height = baseTexture.realHeight;
      if (glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
      }
      return true;
    };
    BufferResource2.prototype.dispose = function() {
      this.data = null;
    };
    BufferResource2.test = function(source) {
      return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
    };
    return BufferResource2;
  }(Resource)
);
var defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  format: FORMATS.RGBA,
  alphaMode: ALPHA_MODES.NPM
};
var BaseTexture = (
  /** @class */
  function(_super) {
    __extends$i(BaseTexture2, _super);
    function BaseTexture2(resource, options) {
      if (resource === void 0) {
        resource = null;
      }
      if (options === void 0) {
        options = null;
      }
      var _this = _super.call(this) || this;
      options = options || {};
      var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width = options.width, height = options.height, wrapMode = options.wrapMode, format2 = options.format, type2 = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
      if (resource && !(resource instanceof Resource)) {
        resource = autoDetectResource(resource, resourceOptions);
        resource.internal = true;
      }
      _this.resolution = resolution || settings.RESOLUTION;
      _this.width = Math.round((width || 0) * _this.resolution) / _this.resolution;
      _this.height = Math.round((height || 0) * _this.resolution) / _this.resolution;
      _this._mipmap = mipmap !== void 0 ? mipmap : settings.MIPMAP_TEXTURES;
      _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings.ANISOTROPIC_LEVEL;
      _this._wrapMode = wrapMode || settings.WRAP_MODE;
      _this._scaleMode = scaleMode !== void 0 ? scaleMode : settings.SCALE_MODE;
      _this.format = format2 || FORMATS.RGBA;
      _this.type = type2 || TYPES.UNSIGNED_BYTE;
      _this.target = target || TARGETS.TEXTURE_2D;
      _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES.UNPACK;
      _this.uid = uid();
      _this.touched = 0;
      _this.isPowerOfTwo = false;
      _this._refreshPOT();
      _this._glTextures = {};
      _this.dirtyId = 0;
      _this.dirtyStyleId = 0;
      _this.cacheId = null;
      _this.valid = width > 0 && height > 0;
      _this.textureCacheIds = [];
      _this.destroyed = false;
      _this.resource = null;
      _this._batchEnabled = 0;
      _this._batchLocation = 0;
      _this.parentTextureArray = null;
      _this.setResource(resource);
      return _this;
    }
    Object.defineProperty(BaseTexture2.prototype, "realWidth", {
      /**
       * Pixel width of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.width * this.resolution);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseTexture2.prototype, "realHeight", {
      /**
       * Pixel height of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.height * this.resolution);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseTexture2.prototype, "mipmap", {
      /**
       * Mipmap mode of the texture, affects downscaled images
       * @default PIXI.settings.MIPMAP_TEXTURES
       */
      get: function() {
        return this._mipmap;
      },
      set: function(value) {
        if (this._mipmap !== value) {
          this._mipmap = value;
          this.dirtyStyleId++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseTexture2.prototype, "scaleMode", {
      /**
       * The scale mode to apply when scaling this texture
       * @default PIXI.settings.SCALE_MODE
       */
      get: function() {
        return this._scaleMode;
      },
      set: function(value) {
        if (this._scaleMode !== value) {
          this._scaleMode = value;
          this.dirtyStyleId++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseTexture2.prototype, "wrapMode", {
      /**
       * How the texture wraps
       * @default PIXI.settings.WRAP_MODE
       */
      get: function() {
        return this._wrapMode;
      },
      set: function(value) {
        if (this._wrapMode !== value) {
          this._wrapMode = value;
          this.dirtyStyleId++;
        }
      },
      enumerable: false,
      configurable: true
    });
    BaseTexture2.prototype.setStyle = function(scaleMode, mipmap) {
      var dirty;
      if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
        this.scaleMode = scaleMode;
        dirty = true;
      }
      if (mipmap !== void 0 && mipmap !== this.mipmap) {
        this.mipmap = mipmap;
        dirty = true;
      }
      if (dirty) {
        this.dirtyStyleId++;
      }
      return this;
    };
    BaseTexture2.prototype.setSize = function(desiredWidth, desiredHeight, resolution) {
      resolution = resolution || this.resolution;
      return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
    };
    BaseTexture2.prototype.setRealSize = function(realWidth, realHeight, resolution) {
      this.resolution = resolution || this.resolution;
      this.width = Math.round(realWidth) / this.resolution;
      this.height = Math.round(realHeight) / this.resolution;
      this._refreshPOT();
      this.update();
      return this;
    };
    BaseTexture2.prototype._refreshPOT = function() {
      this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
    };
    BaseTexture2.prototype.setResolution = function(resolution) {
      var oldResolution = this.resolution;
      if (oldResolution === resolution) {
        return this;
      }
      this.resolution = resolution;
      if (this.valid) {
        this.width = Math.round(this.width * oldResolution) / resolution;
        this.height = Math.round(this.height * oldResolution) / resolution;
        this.emit("update", this);
      }
      this._refreshPOT();
      return this;
    };
    BaseTexture2.prototype.setResource = function(resource) {
      if (this.resource === resource) {
        return this;
      }
      if (this.resource) {
        throw new Error("Resource can be set only once");
      }
      resource.bind(this);
      this.resource = resource;
      return this;
    };
    BaseTexture2.prototype.update = function() {
      if (!this.valid) {
        if (this.width > 0 && this.height > 0) {
          this.valid = true;
          this.emit("loaded", this);
          this.emit("update", this);
        }
      } else {
        this.dirtyId++;
        this.dirtyStyleId++;
        this.emit("update", this);
      }
    };
    BaseTexture2.prototype.onError = function(event) {
      this.emit("error", this, event);
    };
    BaseTexture2.prototype.destroy = function() {
      if (this.resource) {
        this.resource.unbind(this);
        if (this.resource.internal) {
          this.resource.destroy();
        }
        this.resource = null;
      }
      if (this.cacheId) {
        delete BaseTextureCache[this.cacheId];
        delete TextureCache[this.cacheId];
        this.cacheId = null;
      }
      this.dispose();
      BaseTexture2.removeFromCache(this);
      this.textureCacheIds = null;
      this.destroyed = true;
    };
    BaseTexture2.prototype.dispose = function() {
      this.emit("dispose", this);
    };
    BaseTexture2.prototype.castToBaseTexture = function() {
      return this;
    };
    BaseTexture2.from = function(source, options, strict) {
      if (strict === void 0) {
        strict = settings.STRICT_TEXTURE_CACHE;
      }
      var isFrame = typeof source === "string";
      var cacheId = null;
      if (isFrame) {
        cacheId = source;
      } else {
        if (!source._pixiId) {
          var prefix2 = options && options.pixiIdPrefix || "pixiid";
          source._pixiId = prefix2 + "_" + uid();
        }
        cacheId = source._pixiId;
      }
      var baseTexture = BaseTextureCache[cacheId];
      if (isFrame && strict && !baseTexture) {
        throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
      }
      if (!baseTexture) {
        baseTexture = new BaseTexture2(source, options);
        baseTexture.cacheId = cacheId;
        BaseTexture2.addToCache(baseTexture, cacheId);
      }
      return baseTexture;
    };
    BaseTexture2.fromBuffer = function(buffer, width, height, options) {
      buffer = buffer || new Float32Array(width * height * 4);
      var resource = new BufferResource(buffer, { width, height });
      var type2 = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
      return new BaseTexture2(resource, Object.assign({}, defaultBufferOptions, options || { width, height, type: type2 }));
    };
    BaseTexture2.addToCache = function(baseTexture, id2) {
      if (id2) {
        if (baseTexture.textureCacheIds.indexOf(id2) === -1) {
          baseTexture.textureCacheIds.push(id2);
        }
        if (BaseTextureCache[id2]) {
          console.warn("BaseTexture added to the cache with an id [" + id2 + "] that already had an entry");
        }
        BaseTextureCache[id2] = baseTexture;
      }
    };
    BaseTexture2.removeFromCache = function(baseTexture) {
      if (typeof baseTexture === "string") {
        var baseTextureFromCache = BaseTextureCache[baseTexture];
        if (baseTextureFromCache) {
          var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
          if (index > -1) {
            baseTextureFromCache.textureCacheIds.splice(index, 1);
          }
          delete BaseTextureCache[baseTexture];
          return baseTextureFromCache;
        }
      } else if (baseTexture && baseTexture.textureCacheIds) {
        for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
          delete BaseTextureCache[baseTexture.textureCacheIds[i]];
        }
        baseTexture.textureCacheIds.length = 0;
        return baseTexture;
      }
      return null;
    };
    BaseTexture2._globalBatch = 0;
    return BaseTexture2;
  }(EventEmitter)
);
var AbstractMultiResource = (
  /** @class */
  function(_super) {
    __extends$i(AbstractMultiResource2, _super);
    function AbstractMultiResource2(length, options) {
      var _this = this;
      var _a2 = options || {}, width = _a2.width, height = _a2.height;
      _this = _super.call(this, width, height) || this;
      _this.items = [];
      _this.itemDirtyIds = [];
      for (var i = 0; i < length; i++) {
        var partTexture = new BaseTexture();
        _this.items.push(partTexture);
        _this.itemDirtyIds.push(-2);
      }
      _this.length = length;
      _this._load = null;
      _this.baseTexture = null;
      return _this;
    }
    AbstractMultiResource2.prototype.initFromArray = function(resources, options) {
      for (var i = 0; i < this.length; i++) {
        if (!resources[i]) {
          continue;
        }
        if (resources[i].castToBaseTexture) {
          this.addBaseTextureAt(resources[i].castToBaseTexture(), i);
        } else if (resources[i] instanceof Resource) {
          this.addResourceAt(resources[i], i);
        } else {
          this.addResourceAt(autoDetectResource(resources[i], options), i);
        }
      }
    };
    AbstractMultiResource2.prototype.dispose = function() {
      for (var i = 0, len = this.length; i < len; i++) {
        this.items[i].destroy();
      }
      this.items = null;
      this.itemDirtyIds = null;
      this._load = null;
    };
    AbstractMultiResource2.prototype.addResourceAt = function(resource, index) {
      if (!this.items[index]) {
        throw new Error("Index " + index + " is out of bounds");
      }
      if (resource.valid && !this.valid) {
        this.resize(resource.width, resource.height);
      }
      this.items[index].setResource(resource);
      return this;
    };
    AbstractMultiResource2.prototype.bind = function(baseTexture) {
      if (this.baseTexture !== null) {
        throw new Error("Only one base texture per TextureArray is allowed");
      }
      _super.prototype.bind.call(this, baseTexture);
      for (var i = 0; i < this.length; i++) {
        this.items[i].parentTextureArray = baseTexture;
        this.items[i].on("update", baseTexture.update, baseTexture);
      }
    };
    AbstractMultiResource2.prototype.unbind = function(baseTexture) {
      _super.prototype.unbind.call(this, baseTexture);
      for (var i = 0; i < this.length; i++) {
        this.items[i].parentTextureArray = null;
        this.items[i].off("update", baseTexture.update, baseTexture);
      }
    };
    AbstractMultiResource2.prototype.load = function() {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      var resources = this.items.map(function(item) {
        return item.resource;
      }).filter(function(item) {
        return item;
      });
      var promises = resources.map(function(item) {
        return item.load();
      });
      this._load = Promise.all(promises).then(function() {
        var _a2 = _this.items[0], realWidth = _a2.realWidth, realHeight = _a2.realHeight;
        _this.resize(realWidth, realHeight);
        return Promise.resolve(_this);
      });
      return this._load;
    };
    return AbstractMultiResource2;
  }(Resource)
);
var ArrayResource = (
  /** @class */
  function(_super) {
    __extends$i(ArrayResource2, _super);
    function ArrayResource2(source, options) {
      var _this = this;
      var _a2 = options || {}, width = _a2.width, height = _a2.height;
      var urls;
      var length;
      if (Array.isArray(source)) {
        urls = source;
        length = source.length;
      } else {
        length = source;
      }
      _this = _super.call(this, length, { width, height }) || this;
      if (urls) {
        _this.initFromArray(urls, options);
      }
      return _this;
    }
    ArrayResource2.prototype.addBaseTextureAt = function(baseTexture, index) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index);
      } else {
        throw new Error("ArrayResource does not support RenderTexture");
      }
      return this;
    };
    ArrayResource2.prototype.bind = function(baseTexture) {
      _super.prototype.bind.call(this, baseTexture);
      baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
    };
    ArrayResource2.prototype.upload = function(renderer, texture, glTexture) {
      var _a2 = this, length = _a2.length, itemDirtyIds = _a2.itemDirtyIds, items = _a2.items;
      var gl = renderer.gl;
      if (glTexture.dirtyId < 0) {
        gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
      }
      for (var i = 0; i < length; i++) {
        var item = items[i];
        if (itemDirtyIds[i] < item.dirtyId) {
          itemDirtyIds[i] = item.dirtyId;
          if (item.valid) {
            gl.texSubImage3D(
              gl.TEXTURE_2D_ARRAY,
              0,
              0,
              // xoffset
              0,
              // yoffset
              i,
              // zoffset
              item.resource.width,
              item.resource.height,
              1,
              texture.format,
              glTexture.type,
              item.resource.source
            );
          }
        }
      }
      return true;
    };
    return ArrayResource2;
  }(AbstractMultiResource)
);
var BaseImageResource = (
  /** @class */
  function(_super) {
    __extends$i(BaseImageResource2, _super);
    function BaseImageResource2(source) {
      var _this = this;
      var sourceAny = source;
      var width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
      var height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
      _this = _super.call(this, width, height) || this;
      _this.source = source;
      _this.noSubImage = false;
      return _this;
    }
    BaseImageResource2.crossOrigin = function(element, url2, crossorigin) {
      if (crossorigin === void 0 && url2.indexOf("data:") !== 0) {
        element.crossOrigin = determineCrossOrigin(url2);
      } else if (crossorigin !== false) {
        element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
      }
    };
    BaseImageResource2.prototype.upload = function(renderer, baseTexture, glTexture, source) {
      var gl = renderer.gl;
      var width = baseTexture.realWidth;
      var height = baseTexture.realHeight;
      source = source || this.source;
      if (source instanceof HTMLImageElement) {
        if (!source.complete || source.naturalWidth === 0) {
          return false;
        }
      } else if (source instanceof HTMLVideoElement) {
        if (source.readyState <= 1) {
          return false;
        }
      }
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
      if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
      }
      return true;
    };
    BaseImageResource2.prototype.update = function() {
      if (this.destroyed) {
        return;
      }
      var source = this.source;
      var width = source.naturalWidth || source.videoWidth || source.width;
      var height = source.naturalHeight || source.videoHeight || source.height;
      this.resize(width, height);
      _super.prototype.update.call(this);
    };
    BaseImageResource2.prototype.dispose = function() {
      this.source = null;
    };
    return BaseImageResource2;
  }(Resource)
);
var CanvasResource = (
  /** @class */
  function(_super) {
    __extends$i(CanvasResource2, _super);
    function CanvasResource2(source) {
      return _super.call(this, source) || this;
    }
    CanvasResource2.test = function(source) {
      var OffscreenCanvas2 = globalThis.OffscreenCanvas;
      if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
        return true;
      }
      return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
    };
    return CanvasResource2;
  }(BaseImageResource)
);
var CubeResource = (
  /** @class */
  function(_super) {
    __extends$i(CubeResource2, _super);
    function CubeResource2(source, options) {
      var _this = this;
      var _a2 = options || {}, width = _a2.width, height = _a2.height, autoLoad = _a2.autoLoad, linkBaseTexture = _a2.linkBaseTexture;
      if (source && source.length !== CubeResource2.SIDES) {
        throw new Error("Invalid length. Got " + source.length + ", expected 6");
      }
      _this = _super.call(this, 6, { width, height }) || this;
      for (var i = 0; i < CubeResource2.SIDES; i++) {
        _this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
      }
      _this.linkBaseTexture = linkBaseTexture !== false;
      if (source) {
        _this.initFromArray(source, options);
      }
      if (autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    CubeResource2.prototype.bind = function(baseTexture) {
      _super.prototype.bind.call(this, baseTexture);
      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
    };
    CubeResource2.prototype.addBaseTextureAt = function(baseTexture, index, linkBaseTexture) {
      if (!this.items[index]) {
        throw new Error("Index " + index + " is out of bounds");
      }
      if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
        if (baseTexture.resource) {
          this.addResourceAt(baseTexture.resource, index);
        } else {
          throw new Error("CubeResource does not support copying of renderTexture.");
        }
      } else {
        baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;
        baseTexture.parentTextureArray = this.baseTexture;
        this.items[index] = baseTexture;
      }
      if (baseTexture.valid && !this.valid) {
        this.resize(baseTexture.realWidth, baseTexture.realHeight);
      }
      this.items[index] = baseTexture;
      return this;
    };
    CubeResource2.prototype.upload = function(renderer, _baseTexture, glTexture) {
      var dirty = this.itemDirtyIds;
      for (var i = 0; i < CubeResource2.SIDES; i++) {
        var side = this.items[i];
        if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {
          if (side.valid && side.resource) {
            side.resource.upload(renderer, side, glTexture);
            dirty[i] = side.dirtyId;
          } else if (dirty[i] < -1) {
            renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
            dirty[i] = -1;
          }
        }
      }
      return true;
    };
    CubeResource2.test = function(source) {
      return Array.isArray(source) && source.length === CubeResource2.SIDES;
    };
    CubeResource2.SIDES = 6;
    return CubeResource2;
  }(AbstractMultiResource)
);
var ImageResource = (
  /** @class */
  function(_super) {
    __extends$i(ImageResource2, _super);
    function ImageResource2(source, options) {
      var _this = this;
      options = options || {};
      if (!(source instanceof HTMLImageElement)) {
        var imageElement = new Image();
        BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
        imageElement.src = source;
        source = imageElement;
      }
      _this = _super.call(this, source) || this;
      if (!source.complete && !!_this._width && !!_this._height) {
        _this._width = 0;
        _this._height = 0;
      }
      _this.url = source.src;
      _this._process = null;
      _this.preserveBitmap = false;
      _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
      _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
      _this.bitmap = null;
      _this._load = null;
      if (options.autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    ImageResource2.prototype.load = function(createBitmap) {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      if (createBitmap !== void 0) {
        this.createBitmap = createBitmap;
      }
      this._load = new Promise(function(resolve2, reject2) {
        var source = _this.source;
        _this.url = source.src;
        var completed = function() {
          if (_this.destroyed) {
            return;
          }
          source.onload = null;
          source.onerror = null;
          _this.resize(source.width, source.height);
          _this._load = null;
          if (_this.createBitmap) {
            resolve2(_this.process());
          } else {
            resolve2(_this);
          }
        };
        if (source.complete && source.src) {
          completed();
        } else {
          source.onload = completed;
          source.onerror = function(event) {
            reject2(event);
            _this.onError.emit(event);
          };
        }
      });
      return this._load;
    };
    ImageResource2.prototype.process = function() {
      var _this = this;
      var source = this.source;
      if (this._process !== null) {
        return this._process;
      }
      if (this.bitmap !== null || !globalThis.createImageBitmap) {
        return Promise.resolve(this);
      }
      var createImageBitmap = globalThis.createImageBitmap;
      var cors = !source.crossOrigin || source.crossOrigin === "anonymous";
      this._process = fetch(source.src, {
        mode: cors ? "cors" : "no-cors"
      }).then(function(r) {
        return r.blob();
      }).then(function(blob) {
        return createImageBitmap(blob, 0, 0, source.width, source.height, {
          premultiplyAlpha: _this.alphaMode === null || _this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
      }).then(function(bitmap) {
        if (_this.destroyed) {
          return Promise.reject();
        }
        _this.bitmap = bitmap;
        _this.update();
        _this._process = null;
        return Promise.resolve(_this);
      });
      return this._process;
    };
    ImageResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
      if (typeof this.alphaMode === "number") {
        baseTexture.alphaMode = this.alphaMode;
      }
      if (!this.createBitmap) {
        return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);
      }
      if (!this.bitmap) {
        this.process();
        if (!this.bitmap) {
          return false;
        }
      }
      _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);
      if (!this.preserveBitmap) {
        var flag = true;
        var glTextures = baseTexture._glTextures;
        for (var key in glTextures) {
          var otherTex = glTextures[key];
          if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
            flag = false;
            break;
          }
        }
        if (flag) {
          if (this.bitmap.close) {
            this.bitmap.close();
          }
          this.bitmap = null;
        }
      }
      return true;
    };
    ImageResource2.prototype.dispose = function() {
      this.source.onload = null;
      this.source.onerror = null;
      _super.prototype.dispose.call(this);
      if (this.bitmap) {
        this.bitmap.close();
        this.bitmap = null;
      }
      this._process = null;
      this._load = null;
    };
    ImageResource2.test = function(source) {
      return typeof source === "string" || source instanceof HTMLImageElement;
    };
    return ImageResource2;
  }(BaseImageResource)
);
var SVGResource = (
  /** @class */
  function(_super) {
    __extends$i(SVGResource2, _super);
    function SVGResource2(sourceBase64, options) {
      var _this = this;
      options = options || {};
      _this = _super.call(this, settings.ADAPTER.createCanvas()) || this;
      _this._width = 0;
      _this._height = 0;
      _this.svg = sourceBase64;
      _this.scale = options.scale || 1;
      _this._overrideWidth = options.width;
      _this._overrideHeight = options.height;
      _this._resolve = null;
      _this._crossorigin = options.crossorigin;
      _this._load = null;
      if (options.autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    SVGResource2.prototype.load = function() {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      this._load = new Promise(function(resolve2) {
        _this._resolve = function() {
          _this.resize(_this.source.width, _this.source.height);
          resolve2(_this);
        };
        if (SVGResource2.SVG_XML.test(_this.svg.trim())) {
          if (!btoa) {
            throw new Error("Your browser doesn't support base64 conversions.");
          }
          _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
        }
        _this._loadSvg();
      });
      return this._load;
    };
    SVGResource2.prototype._loadSvg = function() {
      var _this = this;
      var tempImage = new Image();
      BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
      tempImage.src = this.svg;
      tempImage.onerror = function(event) {
        if (!_this._resolve) {
          return;
        }
        tempImage.onerror = null;
        _this.onError.emit(event);
      };
      tempImage.onload = function() {
        if (!_this._resolve) {
          return;
        }
        var svgWidth = tempImage.width;
        var svgHeight = tempImage.height;
        if (!svgWidth || !svgHeight) {
          throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
        }
        var width = svgWidth * _this.scale;
        var height = svgHeight * _this.scale;
        if (_this._overrideWidth || _this._overrideHeight) {
          width = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
          height = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
        }
        width = Math.round(width);
        height = Math.round(height);
        var canvas = _this.source;
        canvas.width = width;
        canvas.height = height;
        canvas._pixiId = "canvas_" + uid();
        canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
        _this._resolve();
        _this._resolve = null;
      };
    };
    SVGResource2.getSize = function(svgString) {
      var sizeMatch = SVGResource2.SVG_SIZE.exec(svgString);
      var size2 = {};
      if (sizeMatch) {
        size2[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
        size2[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
      }
      return size2;
    };
    SVGResource2.prototype.dispose = function() {
      _super.prototype.dispose.call(this);
      this._resolve = null;
      this._crossorigin = null;
    };
    SVGResource2.test = function(source, extension) {
      return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && SVGResource2.SVG_XML.test(source);
    };
    SVGResource2.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
    SVGResource2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
    return SVGResource2;
  }(BaseImageResource)
);
var VideoResource = (
  /** @class */
  function(_super) {
    __extends$i(VideoResource2, _super);
    function VideoResource2(source, options) {
      var _this = this;
      options = options || {};
      if (!(source instanceof HTMLVideoElement)) {
        var videoElement = document.createElement("video");
        videoElement.setAttribute("preload", "auto");
        videoElement.setAttribute("webkit-playsinline", "");
        videoElement.setAttribute("playsinline", "");
        if (typeof source === "string") {
          source = [source];
        }
        var firstSrc = source[0].src || source[0];
        BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
        for (var i = 0; i < source.length; ++i) {
          var sourceElement = document.createElement("source");
          var _a2 = source[i], src = _a2.src, mime = _a2.mime;
          src = src || source[i];
          var baseSrc = src.split("?").shift().toLowerCase();
          var ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
          mime = mime || VideoResource2.MIME_TYPES[ext] || "video/" + ext;
          sourceElement.src = src;
          sourceElement.type = mime;
          videoElement.appendChild(sourceElement);
        }
        source = videoElement;
      }
      _this = _super.call(this, source) || this;
      _this.noSubImage = true;
      _this._autoUpdate = true;
      _this._isConnectedToTicker = false;
      _this._updateFPS = options.updateFPS || 0;
      _this._msToNextUpdate = 0;
      _this.autoPlay = options.autoPlay !== false;
      _this._load = null;
      _this._resolve = null;
      _this._onCanPlay = _this._onCanPlay.bind(_this);
      _this._onError = _this._onError.bind(_this);
      if (options.autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    VideoResource2.prototype.update = function(_deltaTime) {
      if (!this.destroyed) {
        var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
        if (!this._updateFPS || this._msToNextUpdate <= 0) {
          _super.prototype.update.call(this);
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
      }
    };
    VideoResource2.prototype.load = function() {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      var source = this.source;
      if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
        source.complete = true;
      }
      source.addEventListener("play", this._onPlayStart.bind(this));
      source.addEventListener("pause", this._onPlayStop.bind(this));
      if (!this._isSourceReady()) {
        source.addEventListener("canplay", this._onCanPlay);
        source.addEventListener("canplaythrough", this._onCanPlay);
        source.addEventListener("error", this._onError, true);
      } else {
        this._onCanPlay();
      }
      this._load = new Promise(function(resolve2) {
        if (_this.valid) {
          resolve2(_this);
        } else {
          _this._resolve = resolve2;
          source.load();
        }
      });
      return this._load;
    };
    VideoResource2.prototype._onError = function(event) {
      this.source.removeEventListener("error", this._onError, true);
      this.onError.emit(event);
    };
    VideoResource2.prototype._isSourcePlaying = function() {
      var source = this.source;
      return !source.paused && !source.ended && this._isSourceReady();
    };
    VideoResource2.prototype._isSourceReady = function() {
      var source = this.source;
      return source.readyState > 2;
    };
    VideoResource2.prototype._onPlayStart = function() {
      if (!this.valid) {
        this._onCanPlay();
      }
      if (this.autoUpdate && !this._isConnectedToTicker) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    };
    VideoResource2.prototype._onPlayStop = function() {
      if (this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
    };
    VideoResource2.prototype._onCanPlay = function() {
      var source = this.source;
      source.removeEventListener("canplay", this._onCanPlay);
      source.removeEventListener("canplaythrough", this._onCanPlay);
      var valid = this.valid;
      this.resize(source.videoWidth, source.videoHeight);
      if (!valid && this._resolve) {
        this._resolve(this);
        this._resolve = null;
      }
      if (this._isSourcePlaying()) {
        this._onPlayStart();
      } else if (this.autoPlay) {
        source.play();
      }
    };
    VideoResource2.prototype.dispose = function() {
      if (this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
      var source = this.source;
      if (source) {
        source.removeEventListener("error", this._onError, true);
        source.pause();
        source.src = "";
        source.load();
      }
      _super.prototype.dispose.call(this);
    };
    Object.defineProperty(VideoResource2.prototype, "autoUpdate", {
      /** Should the base texture automatically update itself, set to true by default. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          if (!this._autoUpdate && this._isConnectedToTicker) {
            Ticker.shared.remove(this.update, this);
            this._isConnectedToTicker = false;
          } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
            Ticker.shared.add(this.update, this);
            this._isConnectedToTicker = true;
          }
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(VideoResource2.prototype, "updateFPS", {
      /**
       * How many times a second to update the texture from the video. Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get: function() {
        return this._updateFPS;
      },
      set: function(value) {
        if (value !== this._updateFPS) {
          this._updateFPS = value;
        }
      },
      enumerable: false,
      configurable: true
    });
    VideoResource2.test = function(source, extension) {
      return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || VideoResource2.TYPES.indexOf(extension) > -1;
    };
    VideoResource2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
    VideoResource2.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    };
    return VideoResource2;
  }(BaseImageResource)
);
var ImageBitmapResource = (
  /** @class */
  function(_super) {
    __extends$i(ImageBitmapResource2, _super);
    function ImageBitmapResource2(source) {
      return _super.call(this, source) || this;
    }
    ImageBitmapResource2.test = function(source) {
      return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && source instanceof ImageBitmap;
    };
    return ImageBitmapResource2;
  }(BaseImageResource)
);
INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
var DepthResource = (
  /** @class */
  function(_super) {
    __extends$i(DepthResource2, _super);
    function DepthResource2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DepthResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
      var gl = renderer.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
      var width = baseTexture.realWidth;
      var height = baseTexture.realHeight;
      if (glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
      }
      return true;
    };
    return DepthResource2;
  }(BufferResource)
);
var Framebuffer = (
  /** @class */
  function() {
    function Framebuffer2(width, height) {
      this.width = Math.round(width || 100);
      this.height = Math.round(height || 100);
      this.stencil = false;
      this.depth = false;
      this.dirtyId = 0;
      this.dirtyFormat = 0;
      this.dirtySize = 0;
      this.depthTexture = null;
      this.colorTextures = [];
      this.glFramebuffers = {};
      this.disposeRunner = new Runner("disposeFramebuffer");
      this.multisample = MSAA_QUALITY.NONE;
    }
    Object.defineProperty(Framebuffer2.prototype, "colorTexture", {
      /**
       * Reference to the colorTexture.
       * @readonly
       */
      get: function() {
        return this.colorTextures[0];
      },
      enumerable: false,
      configurable: true
    });
    Framebuffer2.prototype.addColorTexture = function(index, texture) {
      if (index === void 0) {
        index = 0;
      }
      this.colorTextures[index] = texture || new BaseTexture(null, {
        scaleMode: SCALE_MODES.NEAREST,
        resolution: 1,
        mipmap: MIPMAP_MODES.OFF,
        width: this.width,
        height: this.height
      });
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer2.prototype.addDepthTexture = function(texture) {
      this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
        scaleMode: SCALE_MODES.NEAREST,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: MIPMAP_MODES.OFF,
        format: FORMATS.DEPTH_COMPONENT,
        type: TYPES.UNSIGNED_SHORT
      });
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer2.prototype.enableDepth = function() {
      this.depth = true;
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer2.prototype.enableStencil = function() {
      this.stencil = true;
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer2.prototype.resize = function(width, height) {
      width = Math.round(width);
      height = Math.round(height);
      if (width === this.width && height === this.height) {
        return;
      }
      this.width = width;
      this.height = height;
      this.dirtyId++;
      this.dirtySize++;
      for (var i = 0; i < this.colorTextures.length; i++) {
        var texture = this.colorTextures[i];
        var resolution = texture.resolution;
        texture.setSize(width / resolution, height / resolution);
      }
      if (this.depthTexture) {
        var resolution = this.depthTexture.resolution;
        this.depthTexture.setSize(width / resolution, height / resolution);
      }
    };
    Framebuffer2.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    };
    Framebuffer2.prototype.destroyDepthTexture = function() {
      if (this.depthTexture) {
        this.depthTexture.destroy();
        this.depthTexture = null;
        ++this.dirtyId;
        ++this.dirtyFormat;
      }
    };
    return Framebuffer2;
  }()
);
var BaseRenderTexture = (
  /** @class */
  function(_super) {
    __extends$i(BaseRenderTexture2, _super);
    function BaseRenderTexture2(options) {
      if (options === void 0) {
        options = {};
      }
      var _this = this;
      if (typeof options === "number") {
        var width = arguments[0];
        var height = arguments[1];
        var scaleMode = arguments[2];
        var resolution = arguments[3];
        options = { width, height, scaleMode, resolution };
      }
      options.width = options.width || 100;
      options.height = options.height || 100;
      options.multisample = options.multisample !== void 0 ? options.multisample : MSAA_QUALITY.NONE;
      _this = _super.call(this, null, options) || this;
      _this.mipmap = MIPMAP_MODES.OFF;
      _this.valid = true;
      _this.clearColor = [0, 0, 0, 0];
      _this.framebuffer = new Framebuffer(_this.realWidth, _this.realHeight).addColorTexture(0, _this);
      _this.framebuffer.multisample = options.multisample;
      _this.maskStack = [];
      _this.filterStack = [{}];
      return _this;
    }
    BaseRenderTexture2.prototype.resize = function(desiredWidth, desiredHeight) {
      this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
      this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    };
    BaseRenderTexture2.prototype.dispose = function() {
      this.framebuffer.dispose();
      _super.prototype.dispose.call(this);
    };
    BaseRenderTexture2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.framebuffer.destroyDepthTexture();
      this.framebuffer = null;
    };
    return BaseRenderTexture2;
  }(BaseTexture)
);
var TextureUvs = (
  /** @class */
  function() {
    function TextureUvs2() {
      this.x0 = 0;
      this.y0 = 0;
      this.x1 = 1;
      this.y1 = 0;
      this.x2 = 1;
      this.y2 = 1;
      this.x3 = 0;
      this.y3 = 1;
      this.uvsFloat32 = new Float32Array(8);
    }
    TextureUvs2.prototype.set = function(frame2, baseFrame, rotate) {
      var tw = baseFrame.width;
      var th = baseFrame.height;
      if (rotate) {
        var w2 = frame2.width / 2 / tw;
        var h2 = frame2.height / 2 / th;
        var cX = frame2.x / tw + w2;
        var cY = frame2.y / th + h2;
        rotate = groupD8.add(rotate, groupD8.NW);
        this.x0 = cX + w2 * groupD8.uX(rotate);
        this.y0 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x1 = cX + w2 * groupD8.uX(rotate);
        this.y1 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x2 = cX + w2 * groupD8.uX(rotate);
        this.y2 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x3 = cX + w2 * groupD8.uX(rotate);
        this.y3 = cY + h2 * groupD8.uY(rotate);
      } else {
        this.x0 = frame2.x / tw;
        this.y0 = frame2.y / th;
        this.x1 = (frame2.x + frame2.width) / tw;
        this.y1 = frame2.y / th;
        this.x2 = (frame2.x + frame2.width) / tw;
        this.y2 = (frame2.y + frame2.height) / th;
        this.x3 = frame2.x / tw;
        this.y3 = (frame2.y + frame2.height) / th;
      }
      this.uvsFloat32[0] = this.x0;
      this.uvsFloat32[1] = this.y0;
      this.uvsFloat32[2] = this.x1;
      this.uvsFloat32[3] = this.y1;
      this.uvsFloat32[4] = this.x2;
      this.uvsFloat32[5] = this.y2;
      this.uvsFloat32[6] = this.x3;
      this.uvsFloat32[7] = this.y3;
    };
    TextureUvs2.prototype.toString = function() {
      return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
    };
    return TextureUvs2;
  }()
);
var DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
var Texture = (
  /** @class */
  function(_super) {
    __extends$i(Texture2, _super);
    function Texture2(baseTexture, frame2, orig, trim, rotate, anchor) {
      var _this = _super.call(this) || this;
      _this.noFrame = false;
      if (!frame2) {
        _this.noFrame = true;
        frame2 = new Rectangle(0, 0, 1, 1);
      }
      if (baseTexture instanceof Texture2) {
        baseTexture = baseTexture.baseTexture;
      }
      _this.baseTexture = baseTexture;
      _this._frame = frame2;
      _this.trim = trim;
      _this.valid = false;
      _this._uvs = DEFAULT_UVS;
      _this.uvMatrix = null;
      _this.orig = orig || frame2;
      _this._rotate = Number(rotate || 0);
      if (rotate === true) {
        _this._rotate = 2;
      } else if (_this._rotate % 2 !== 0) {
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      }
      _this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
      _this._updateID = 0;
      _this.textureCacheIds = [];
      if (!baseTexture.valid) {
        baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
      } else if (_this.noFrame) {
        if (baseTexture.valid) {
          _this.onBaseTextureUpdated(baseTexture);
        }
      } else {
        _this.frame = frame2;
      }
      if (_this.noFrame) {
        baseTexture.on("update", _this.onBaseTextureUpdated, _this);
      }
      return _this;
    }
    Texture2.prototype.update = function() {
      if (this.baseTexture.resource) {
        this.baseTexture.resource.update();
      }
    };
    Texture2.prototype.onBaseTextureUpdated = function(baseTexture) {
      if (this.noFrame) {
        if (!this.baseTexture.valid) {
          return;
        }
        this._frame.width = baseTexture.width;
        this._frame.height = baseTexture.height;
        this.valid = true;
        this.updateUvs();
      } else {
        this.frame = this._frame;
      }
      this.emit("update", this);
    };
    Texture2.prototype.destroy = function(destroyBase) {
      if (this.baseTexture) {
        if (destroyBase) {
          var resource = this.baseTexture.resource;
          if (resource && resource.url && TextureCache[resource.url]) {
            Texture2.removeFromCache(resource.url);
          }
          this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
        this.baseTexture.off("update", this.onBaseTextureUpdated, this);
        this.baseTexture = null;
      }
      this._frame = null;
      this._uvs = null;
      this.trim = null;
      this.orig = null;
      this.valid = false;
      Texture2.removeFromCache(this);
      this.textureCacheIds = null;
    };
    Texture2.prototype.clone = function() {
      var clonedFrame = this._frame.clone();
      var clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
      var clonedTexture = new Texture2(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
      if (this.noFrame) {
        clonedTexture._frame = clonedFrame;
      }
      return clonedTexture;
    };
    Texture2.prototype.updateUvs = function() {
      if (this._uvs === DEFAULT_UVS) {
        this._uvs = new TextureUvs();
      }
      this._uvs.set(this._frame, this.baseTexture, this.rotate);
      this._updateID++;
    };
    Texture2.from = function(source, options, strict) {
      if (options === void 0) {
        options = {};
      }
      if (strict === void 0) {
        strict = settings.STRICT_TEXTURE_CACHE;
      }
      var isFrame = typeof source === "string";
      var cacheId = null;
      if (isFrame) {
        cacheId = source;
      } else if (source instanceof BaseTexture) {
        if (!source.cacheId) {
          var prefix2 = options && options.pixiIdPrefix || "pixiid";
          source.cacheId = prefix2 + "-" + uid();
          BaseTexture.addToCache(source, source.cacheId);
        }
        cacheId = source.cacheId;
      } else {
        if (!source._pixiId) {
          var prefix2 = options && options.pixiIdPrefix || "pixiid";
          source._pixiId = prefix2 + "_" + uid();
        }
        cacheId = source._pixiId;
      }
      var texture = TextureCache[cacheId];
      if (isFrame && strict && !texture) {
        throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
      }
      if (!texture && !(source instanceof BaseTexture)) {
        if (!options.resolution) {
          options.resolution = getResolutionOfUrl(source);
        }
        texture = new Texture2(new BaseTexture(source, options));
        texture.baseTexture.cacheId = cacheId;
        BaseTexture.addToCache(texture.baseTexture, cacheId);
        Texture2.addToCache(texture, cacheId);
      } else if (!texture && source instanceof BaseTexture) {
        texture = new Texture2(source);
        Texture2.addToCache(texture, cacheId);
      }
      return texture;
    };
    Texture2.fromURL = function(url2, options) {
      var resourceOptions = Object.assign({ autoLoad: false }, options === null || options === void 0 ? void 0 : options.resourceOptions);
      var texture = Texture2.from(url2, Object.assign({ resourceOptions }, options), false);
      var resource = texture.baseTexture.resource;
      if (texture.baseTexture.valid) {
        return Promise.resolve(texture);
      }
      return resource.load().then(function() {
        return Promise.resolve(texture);
      });
    };
    Texture2.fromBuffer = function(buffer, width, height, options) {
      return new Texture2(BaseTexture.fromBuffer(buffer, width, height, options));
    };
    Texture2.fromLoader = function(source, imageUrl, name2, options) {
      var baseTexture = new BaseTexture(source, Object.assign({
        scaleMode: settings.SCALE_MODE,
        resolution: getResolutionOfUrl(imageUrl)
      }, options));
      var resource = baseTexture.resource;
      if (resource instanceof ImageResource) {
        resource.url = imageUrl;
      }
      var texture = new Texture2(baseTexture);
      if (!name2) {
        name2 = imageUrl;
      }
      BaseTexture.addToCache(texture.baseTexture, name2);
      Texture2.addToCache(texture, name2);
      if (name2 !== imageUrl) {
        BaseTexture.addToCache(texture.baseTexture, imageUrl);
        Texture2.addToCache(texture, imageUrl);
      }
      if (texture.baseTexture.valid) {
        return Promise.resolve(texture);
      }
      return new Promise(function(resolve2) {
        texture.baseTexture.once("loaded", function() {
          return resolve2(texture);
        });
      });
    };
    Texture2.addToCache = function(texture, id2) {
      if (id2) {
        if (texture.textureCacheIds.indexOf(id2) === -1) {
          texture.textureCacheIds.push(id2);
        }
        if (TextureCache[id2]) {
          console.warn("Texture added to the cache with an id [" + id2 + "] that already had an entry");
        }
        TextureCache[id2] = texture;
      }
    };
    Texture2.removeFromCache = function(texture) {
      if (typeof texture === "string") {
        var textureFromCache = TextureCache[texture];
        if (textureFromCache) {
          var index = textureFromCache.textureCacheIds.indexOf(texture);
          if (index > -1) {
            textureFromCache.textureCacheIds.splice(index, 1);
          }
          delete TextureCache[texture];
          return textureFromCache;
        }
      } else if (texture && texture.textureCacheIds) {
        for (var i = 0; i < texture.textureCacheIds.length; ++i) {
          if (TextureCache[texture.textureCacheIds[i]] === texture) {
            delete TextureCache[texture.textureCacheIds[i]];
          }
        }
        texture.textureCacheIds.length = 0;
        return texture;
      }
      return null;
    };
    Object.defineProperty(Texture2.prototype, "resolution", {
      /**
       * Returns resolution of baseTexture
       * @readonly
       */
      get: function() {
        return this.baseTexture.resolution;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture2.prototype, "frame", {
      /**
       * The frame specifies the region of the base texture that this texture uses.
       * Please call `updateUvs()` after you change coordinates of `frame` manually.
       */
      get: function() {
        return this._frame;
      },
      set: function(frame2) {
        this._frame = frame2;
        this.noFrame = false;
        var x = frame2.x, y = frame2.y, width = frame2.width, height = frame2.height;
        var xNotFit = x + width > this.baseTexture.width;
        var yNotFit = y + height > this.baseTexture.height;
        if (xNotFit || yNotFit) {
          var relationship = xNotFit && yNotFit ? "and" : "or";
          var errorX = "X: " + x + " + " + width + " = " + (x + width) + " > " + this.baseTexture.width;
          var errorY = "Y: " + y + " + " + height + " = " + (y + height) + " > " + this.baseTexture.height;
          throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
        }
        this.valid = width && height && this.baseTexture.valid;
        if (!this.trim && !this.rotate) {
          this.orig = frame2;
        }
        if (this.valid) {
          this.updateUvs();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture2.prototype, "rotate", {
      /**
       * Indicates whether the texture is rotated inside the atlas
       * set to 2 to compensate for texture packer rotation
       * set to 6 to compensate for spine packer rotation
       * can be used to rotate or mirror sprites
       * See {@link PIXI.groupD8} for explanation
       */
      get: function() {
        return this._rotate;
      },
      set: function(rotate) {
        this._rotate = rotate;
        if (this.valid) {
          this.updateUvs();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture2.prototype, "width", {
      /** The width of the Texture in pixels. */
      get: function() {
        return this.orig.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture2.prototype, "height", {
      /** The height of the Texture in pixels. */
      get: function() {
        return this.orig.height;
      },
      enumerable: false,
      configurable: true
    });
    Texture2.prototype.castToBaseTexture = function() {
      return this.baseTexture;
    };
    Object.defineProperty(Texture2, "EMPTY", {
      /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
      get: function() {
        if (!Texture2._EMPTY) {
          Texture2._EMPTY = new Texture2(new BaseTexture());
          removeAllHandlers(Texture2._EMPTY);
          removeAllHandlers(Texture2._EMPTY.baseTexture);
        }
        return Texture2._EMPTY;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture2, "WHITE", {
      /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
      get: function() {
        if (!Texture2._WHITE) {
          var canvas = settings.ADAPTER.createCanvas(16, 16);
          var context2 = canvas.getContext("2d");
          canvas.width = 16;
          canvas.height = 16;
          context2.fillStyle = "white";
          context2.fillRect(0, 0, 16, 16);
          Texture2._WHITE = new Texture2(BaseTexture.from(canvas));
          removeAllHandlers(Texture2._WHITE);
          removeAllHandlers(Texture2._WHITE.baseTexture);
        }
        return Texture2._WHITE;
      },
      enumerable: false,
      configurable: true
    });
    return Texture2;
  }(EventEmitter)
);
var RenderTexture = (
  /** @class */
  function(_super) {
    __extends$i(RenderTexture2, _super);
    function RenderTexture2(baseRenderTexture, frame2) {
      var _this = _super.call(this, baseRenderTexture, frame2) || this;
      _this.valid = true;
      _this.filterFrame = null;
      _this.filterPoolKey = null;
      _this.updateUvs();
      return _this;
    }
    Object.defineProperty(RenderTexture2.prototype, "framebuffer", {
      /**
       * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
       * @readonly
       */
      get: function() {
        return this.baseTexture.framebuffer;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RenderTexture2.prototype, "multisample", {
      /**
       * Shortcut to `this.framebuffer.multisample`.
       * @default PIXI.MSAA_QUALITY.NONE
       */
      get: function() {
        return this.framebuffer.multisample;
      },
      set: function(value) {
        this.framebuffer.multisample = value;
      },
      enumerable: false,
      configurable: true
    });
    RenderTexture2.prototype.resize = function(desiredWidth, desiredHeight, resizeBaseTexture) {
      if (resizeBaseTexture === void 0) {
        resizeBaseTexture = true;
      }
      var resolution = this.baseTexture.resolution;
      var width = Math.round(desiredWidth * resolution) / resolution;
      var height = Math.round(desiredHeight * resolution) / resolution;
      this.valid = width > 0 && height > 0;
      this._frame.width = this.orig.width = width;
      this._frame.height = this.orig.height = height;
      if (resizeBaseTexture) {
        this.baseTexture.resize(width, height);
      }
      this.updateUvs();
    };
    RenderTexture2.prototype.setResolution = function(resolution) {
      var baseTexture = this.baseTexture;
      if (baseTexture.resolution === resolution) {
        return;
      }
      baseTexture.setResolution(resolution);
      this.resize(baseTexture.width, baseTexture.height, false);
    };
    RenderTexture2.create = function(options) {
      var arguments$1 = arguments;
      var rest = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        rest[_i - 1] = arguments$1[_i];
      }
      if (typeof options === "number") {
        deprecation("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated.");
        options = {
          width: options,
          height: rest[0],
          scaleMode: rest[1],
          resolution: rest[2]
        };
      }
      return new RenderTexture2(new BaseRenderTexture(options));
    };
    return RenderTexture2;
  }(Texture)
);
var RenderTexturePool = (
  /** @class */
  function() {
    function RenderTexturePool2(textureOptions) {
      this.texturePool = {};
      this.textureOptions = textureOptions || {};
      this.enableFullScreen = false;
      this._pixelsWidth = 0;
      this._pixelsHeight = 0;
    }
    RenderTexturePool2.prototype.createTexture = function(realWidth, realHeight, multisample) {
      if (multisample === void 0) {
        multisample = MSAA_QUALITY.NONE;
      }
      var baseRenderTexture = new BaseRenderTexture(Object.assign({
        width: realWidth,
        height: realHeight,
        resolution: 1,
        multisample
      }, this.textureOptions));
      return new RenderTexture(baseRenderTexture);
    };
    RenderTexturePool2.prototype.getOptimalTexture = function(minWidth, minHeight, resolution, multisample) {
      if (resolution === void 0) {
        resolution = 1;
      }
      if (multisample === void 0) {
        multisample = MSAA_QUALITY.NONE;
      }
      var key;
      minWidth = Math.ceil(minWidth * resolution - 1e-6);
      minHeight = Math.ceil(minHeight * resolution - 1e-6);
      if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
        minWidth = nextPow2(minWidth);
        minHeight = nextPow2(minHeight);
        key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
        if (multisample > 1) {
          key += multisample * 4294967296;
        }
      } else {
        key = multisample > 1 ? -multisample : -1;
      }
      if (!this.texturePool[key]) {
        this.texturePool[key] = [];
      }
      var renderTexture = this.texturePool[key].pop();
      if (!renderTexture) {
        renderTexture = this.createTexture(minWidth, minHeight, multisample);
      }
      renderTexture.filterPoolKey = key;
      renderTexture.setResolution(resolution);
      return renderTexture;
    };
    RenderTexturePool2.prototype.getFilterTexture = function(input, resolution, multisample) {
      var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
      filterTexture.filterFrame = input.filterFrame;
      return filterTexture;
    };
    RenderTexturePool2.prototype.returnTexture = function(renderTexture) {
      var key = renderTexture.filterPoolKey;
      renderTexture.filterFrame = null;
      this.texturePool[key].push(renderTexture);
    };
    RenderTexturePool2.prototype.returnFilterTexture = function(renderTexture) {
      this.returnTexture(renderTexture);
    };
    RenderTexturePool2.prototype.clear = function(destroyTextures) {
      destroyTextures = destroyTextures !== false;
      if (destroyTextures) {
        for (var i in this.texturePool) {
          var textures = this.texturePool[i];
          if (textures) {
            for (var j = 0; j < textures.length; j++) {
              textures[j].destroy(true);
            }
          }
        }
      }
      this.texturePool = {};
    };
    RenderTexturePool2.prototype.setScreenSize = function(size2) {
      if (size2.width === this._pixelsWidth && size2.height === this._pixelsHeight) {
        return;
      }
      this.enableFullScreen = size2.width > 0 && size2.height > 0;
      for (var i in this.texturePool) {
        if (!(Number(i) < 0)) {
          continue;
        }
        var textures = this.texturePool[i];
        if (textures) {
          for (var j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
        this.texturePool[i] = [];
      }
      this._pixelsWidth = size2.width;
      this._pixelsHeight = size2.height;
    };
    RenderTexturePool2.SCREEN_KEY = -1;
    return RenderTexturePool2;
  }()
);
var Attribute$1 = (
  /** @class */
  function() {
    function Attribute2(buffer, size2, normalized, type2, stride, start2, instance2) {
      if (size2 === void 0) {
        size2 = 0;
      }
      if (normalized === void 0) {
        normalized = false;
      }
      if (type2 === void 0) {
        type2 = TYPES.FLOAT;
      }
      this.buffer = buffer;
      this.size = size2;
      this.normalized = normalized;
      this.type = type2;
      this.stride = stride;
      this.start = start2;
      this.instance = instance2;
    }
    Attribute2.prototype.destroy = function() {
      this.buffer = null;
    };
    Attribute2.from = function(buffer, size2, normalized, type2, stride) {
      return new Attribute2(buffer, size2, normalized, type2, stride);
    };
    return Attribute2;
  }()
);
var UID$4 = 0;
var Buffer2 = (
  /** @class */
  function() {
    function Buffer3(data, _static, index) {
      if (_static === void 0) {
        _static = true;
      }
      if (index === void 0) {
        index = false;
      }
      this.data = data || new Float32Array(1);
      this._glBuffers = {};
      this._updateID = 0;
      this.index = index;
      this.static = _static;
      this.id = UID$4++;
      this.disposeRunner = new Runner("disposeBuffer");
    }
    Buffer3.prototype.update = function(data) {
      if (data instanceof Array) {
        data = new Float32Array(data);
      }
      this.data = data || this.data;
      this._updateID++;
    };
    Buffer3.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    };
    Buffer3.prototype.destroy = function() {
      this.dispose();
      this.data = null;
    };
    Object.defineProperty(Buffer3.prototype, "index", {
      get: function() {
        return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      },
      /**
       * Flags whether this is an index buffer.
       *
       * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
       * the buffer of type `ARRAY_BUFFER`.
       *
       * For backwards compatibility.
       */
      set: function(value) {
        this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
      },
      enumerable: false,
      configurable: true
    });
    Buffer3.from = function(data) {
      if (data instanceof Array) {
        data = new Float32Array(data);
      }
      return new Buffer3(data);
    };
    return Buffer3;
  }()
);
var map$1$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  var outSize = 0;
  var stride = 0;
  var views = {};
  for (var i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  var buffer = new ArrayBuffer(outSize * 4);
  var out = null;
  var littleOffset = 0;
  for (var i = 0; i < arrays.length; i++) {
    var size2 = sizes[i];
    var array2 = arrays[i];
    var type2 = getBufferType(array2);
    if (!views[type2]) {
      views[type2] = new map$1$1[type2](buffer);
    }
    out = views[type2];
    for (var j = 0; j < array2.length; j++) {
      var indexStart = (j / size2 | 0) * stride + littleOffset;
      var index = j % size2;
      out[indexStart + index] = array2[j];
    }
    littleOffset += size2;
  }
  return new Float32Array(buffer);
}
var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
var UID$3 = 0;
var map$2 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
var Geometry = (
  /** @class */
  function() {
    function Geometry2(buffers, attributes) {
      if (buffers === void 0) {
        buffers = [];
      }
      if (attributes === void 0) {
        attributes = {};
      }
      this.buffers = buffers;
      this.indexBuffer = null;
      this.attributes = attributes;
      this.glVertexArrayObjects = {};
      this.id = UID$3++;
      this.instanced = false;
      this.instanceCount = 1;
      this.disposeRunner = new Runner("disposeGeometry");
      this.refCount = 0;
    }
    Geometry2.prototype.addAttribute = function(id2, buffer, size2, normalized, type2, stride, start2, instance2) {
      if (size2 === void 0) {
        size2 = 0;
      }
      if (normalized === void 0) {
        normalized = false;
      }
      if (instance2 === void 0) {
        instance2 = false;
      }
      if (!buffer) {
        throw new Error("You must pass a buffer when creating an attribute");
      }
      if (!(buffer instanceof Buffer2)) {
        if (buffer instanceof Array) {
          buffer = new Float32Array(buffer);
        }
        buffer = new Buffer2(buffer);
      }
      var ids = id2.split("|");
      if (ids.length > 1) {
        for (var i = 0; i < ids.length; i++) {
          this.addAttribute(ids[i], buffer, size2, normalized, type2);
        }
        return this;
      }
      var bufferIndex = this.buffers.indexOf(buffer);
      if (bufferIndex === -1) {
        this.buffers.push(buffer);
        bufferIndex = this.buffers.length - 1;
      }
      this.attributes[id2] = new Attribute$1(bufferIndex, size2, normalized, type2, stride, start2, instance2);
      this.instanced = this.instanced || instance2;
      return this;
    };
    Geometry2.prototype.getAttribute = function(id2) {
      return this.attributes[id2];
    };
    Geometry2.prototype.getBuffer = function(id2) {
      return this.buffers[this.getAttribute(id2).buffer];
    };
    Geometry2.prototype.addIndex = function(buffer) {
      if (!(buffer instanceof Buffer2)) {
        if (buffer instanceof Array) {
          buffer = new Uint16Array(buffer);
        }
        buffer = new Buffer2(buffer);
      }
      buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      this.indexBuffer = buffer;
      if (this.buffers.indexOf(buffer) === -1) {
        this.buffers.push(buffer);
      }
      return this;
    };
    Geometry2.prototype.getIndex = function() {
      return this.indexBuffer;
    };
    Geometry2.prototype.interleave = function() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
        return this;
      }
      var arrays = [];
      var sizes = [];
      var interleavedBuffer = new Buffer2();
      var i;
      for (i in this.attributes) {
        var attribute = this.attributes[i];
        var buffer = this.buffers[attribute.buffer];
        arrays.push(buffer.data);
        sizes.push(attribute.size * byteSizeMap$1[attribute.type] / 4);
        attribute.buffer = 0;
      }
      interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
      for (i = 0; i < this.buffers.length; i++) {
        if (this.buffers[i] !== this.indexBuffer) {
          this.buffers[i].destroy();
        }
      }
      this.buffers = [interleavedBuffer];
      if (this.indexBuffer) {
        this.buffers.push(this.indexBuffer);
      }
      return this;
    };
    Geometry2.prototype.getSize = function() {
      for (var i in this.attributes) {
        var attribute = this.attributes[i];
        var buffer = this.buffers[attribute.buffer];
        return buffer.data.length / (attribute.stride / 4 || attribute.size);
      }
      return 0;
    };
    Geometry2.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    };
    Geometry2.prototype.destroy = function() {
      this.dispose();
      this.buffers = null;
      this.indexBuffer = null;
      this.attributes = null;
    };
    Geometry2.prototype.clone = function() {
      var geometry = new Geometry2();
      for (var i = 0; i < this.buffers.length; i++) {
        geometry.buffers[i] = new Buffer2(this.buffers[i].data.slice(0));
      }
      for (var i in this.attributes) {
        var attrib = this.attributes[i];
        geometry.attributes[i] = new Attribute$1(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
      }
      if (this.indexBuffer) {
        geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
        geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      }
      return geometry;
    };
    Geometry2.merge = function(geometries) {
      var geometryOut = new Geometry2();
      var arrays = [];
      var sizes = [];
      var offsets = [];
      var geometry;
      for (var i = 0; i < geometries.length; i++) {
        geometry = geometries[i];
        for (var j = 0; j < geometry.buffers.length; j++) {
          sizes[j] = sizes[j] || 0;
          sizes[j] += geometry.buffers[j].data.length;
          offsets[j] = 0;
        }
      }
      for (var i = 0; i < geometry.buffers.length; i++) {
        arrays[i] = new map$2[getBufferType(geometry.buffers[i].data)](sizes[i]);
        geometryOut.buffers[i] = new Buffer2(arrays[i]);
      }
      for (var i = 0; i < geometries.length; i++) {
        geometry = geometries[i];
        for (var j = 0; j < geometry.buffers.length; j++) {
          arrays[j].set(geometry.buffers[j].data, offsets[j]);
          offsets[j] += geometry.buffers[j].data.length;
        }
      }
      geometryOut.attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
        geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        var offset = 0;
        var stride = 0;
        var offset2 = 0;
        var bufferIndexToCount = 0;
        for (var i = 0; i < geometry.buffers.length; i++) {
          if (geometry.buffers[i] !== geometry.indexBuffer) {
            bufferIndexToCount = i;
            break;
          }
        }
        for (var i in geometry.attributes) {
          var attribute = geometry.attributes[i];
          if ((attribute.buffer | 0) === bufferIndexToCount) {
            stride += attribute.size * byteSizeMap$1[attribute.type] / 4;
          }
        }
        for (var i = 0; i < geometries.length; i++) {
          var indexBufferData = geometries[i].indexBuffer.data;
          for (var j = 0; j < indexBufferData.length; j++) {
            geometryOut.indexBuffer.data[j + offset2] += offset;
          }
          offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;
          offset2 += indexBufferData.length;
        }
      }
      return geometryOut;
    };
    return Geometry2;
  }()
);
var Quad = (
  /** @class */
  function(_super) {
    __extends$i(Quad2, _super);
    function Quad2() {
      var _this = _super.call(this) || this;
      _this.addAttribute("aVertexPosition", new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ])).addIndex([0, 1, 3, 2]);
      return _this;
    }
    return Quad2;
  }(Geometry)
);
var QuadUv = (
  /** @class */
  function(_super) {
    __extends$i(QuadUv2, _super);
    function QuadUv2() {
      var _this = _super.call(this) || this;
      _this.vertices = new Float32Array([
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]);
      _this.uvs = new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]);
      _this.vertexBuffer = new Buffer2(_this.vertices);
      _this.uvBuffer = new Buffer2(_this.uvs);
      _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
      return _this;
    }
    QuadUv2.prototype.map = function(targetTextureFrame, destinationFrame) {
      var x = 0;
      var y = 0;
      this.uvs[0] = x;
      this.uvs[1] = y;
      this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
      this.uvs[3] = y;
      this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
      this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;
      this.uvs[6] = x;
      this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;
      x = destinationFrame.x;
      y = destinationFrame.y;
      this.vertices[0] = x;
      this.vertices[1] = y;
      this.vertices[2] = x + destinationFrame.width;
      this.vertices[3] = y;
      this.vertices[4] = x + destinationFrame.width;
      this.vertices[5] = y + destinationFrame.height;
      this.vertices[6] = x;
      this.vertices[7] = y + destinationFrame.height;
      this.invalidate();
      return this;
    };
    QuadUv2.prototype.invalidate = function() {
      this.vertexBuffer._updateID++;
      this.uvBuffer._updateID++;
      return this;
    };
    return QuadUv2;
  }(Geometry)
);
var UID$2 = 0;
var UniformGroup = (
  /** @class */
  function() {
    function UniformGroup2(uniforms, isStatic, isUbo) {
      this.group = true;
      this.syncUniforms = {};
      this.dirtyId = 0;
      this.id = UID$2++;
      this.static = !!isStatic;
      this.ubo = !!isUbo;
      if (uniforms instanceof Buffer2) {
        this.buffer = uniforms;
        this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
        this.autoManage = false;
        this.ubo = true;
      } else {
        this.uniforms = uniforms;
        if (this.ubo) {
          this.buffer = new Buffer2(new Float32Array(1));
          this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
          this.autoManage = true;
        }
      }
    }
    UniformGroup2.prototype.update = function() {
      this.dirtyId++;
      if (!this.autoManage && this.buffer) {
        this.buffer.update();
      }
    };
    UniformGroup2.prototype.add = function(name2, uniforms, _static) {
      if (!this.ubo) {
        this.uniforms[name2] = new UniformGroup2(uniforms, _static);
      } else {
        throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
      }
    };
    UniformGroup2.from = function(uniforms, _static, _ubo) {
      return new UniformGroup2(uniforms, _static, _ubo);
    };
    UniformGroup2.uboFrom = function(uniforms, _static) {
      return new UniformGroup2(uniforms, _static !== null && _static !== void 0 ? _static : true, true);
    };
    return UniformGroup2;
  }()
);
var FilterState = (
  /** @class */
  function() {
    function FilterState2() {
      this.renderTexture = null;
      this.target = null;
      this.legacy = false;
      this.resolution = 1;
      this.multisample = MSAA_QUALITY.NONE;
      this.sourceFrame = new Rectangle();
      this.destinationFrame = new Rectangle();
      this.bindingSourceFrame = new Rectangle();
      this.bindingDestinationFrame = new Rectangle();
      this.filters = [];
      this.transform = null;
    }
    FilterState2.prototype.clear = function() {
      this.target = null;
      this.filters = null;
      this.renderTexture = null;
    };
    return FilterState2;
  }()
);
var tempPoints = [new Point(), new Point(), new Point(), new Point()];
var tempMatrix$2 = new Matrix$1();
var FilterSystem = (
  /** @class */
  function() {
    function FilterSystem2(renderer) {
      this.renderer = renderer;
      this.defaultFilterStack = [{}];
      this.texturePool = new RenderTexturePool();
      this.texturePool.setScreenSize(renderer.view);
      this.statePool = [];
      this.quad = new Quad();
      this.quadUv = new QuadUv();
      this.tempRect = new Rectangle();
      this.activeState = {};
      this.globalUniforms = new UniformGroup({
        outputFrame: new Rectangle(),
        inputSize: new Float32Array(4),
        inputPixel: new Float32Array(4),
        inputClamp: new Float32Array(4),
        resolution: 1,
        // legacy variables
        filterArea: new Float32Array(4),
        filterClamp: new Float32Array(4)
      }, true);
      this.forceClear = false;
      this.useMaxPadding = false;
    }
    FilterSystem2.prototype.push = function(target, filters) {
      var _a2, _b2;
      var renderer = this.renderer;
      var filterStack = this.defaultFilterStack;
      var state = this.statePool.pop() || new FilterState();
      var renderTextureSystem = this.renderer.renderTexture;
      var resolution = filters[0].resolution;
      var multisample = filters[0].multisample;
      var padding = filters[0].padding;
      var autoFit = filters[0].autoFit;
      var legacy = (_a2 = filters[0].legacy) !== null && _a2 !== void 0 ? _a2 : true;
      for (var i = 1; i < filters.length; i++) {
        var filter2 = filters[i];
        resolution = Math.min(resolution, filter2.resolution);
        multisample = Math.min(multisample, filter2.multisample);
        padding = this.useMaxPadding ? Math.max(padding, filter2.padding) : padding + filter2.padding;
        autoFit = autoFit && filter2.autoFit;
        legacy = legacy || ((_b2 = filter2.legacy) !== null && _b2 !== void 0 ? _b2 : true);
      }
      if (filterStack.length === 1) {
        this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
      }
      filterStack.push(state);
      state.resolution = resolution;
      state.multisample = multisample;
      state.legacy = legacy;
      state.target = target;
      state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
      state.sourceFrame.pad(padding);
      var sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
      if (renderer.projection.transform) {
        this.transformAABB(tempMatrix$2.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
      }
      if (autoFit) {
        state.sourceFrame.fit(sourceFrameProjected);
        if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
          state.sourceFrame.width = 0;
          state.sourceFrame.height = 0;
        }
      } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
      this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
      state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
      state.filters = filters;
      state.destinationFrame.width = state.renderTexture.width;
      state.destinationFrame.height = state.renderTexture.height;
      var destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = state.sourceFrame.width;
      destinationFrame.height = state.sourceFrame.height;
      state.renderTexture.filterFrame = state.sourceFrame;
      state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
      state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
      state.transform = renderer.projection.transform;
      renderer.projection.transform = null;
      renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
      renderer.framebuffer.clear(0, 0, 0, 0);
    };
    FilterSystem2.prototype.pop = function() {
      var filterStack = this.defaultFilterStack;
      var state = filterStack.pop();
      var filters = state.filters;
      this.activeState = state;
      var globalUniforms = this.globalUniforms.uniforms;
      globalUniforms.outputFrame = state.sourceFrame;
      globalUniforms.resolution = state.resolution;
      var inputSize = globalUniforms.inputSize;
      var inputPixel = globalUniforms.inputPixel;
      var inputClamp = globalUniforms.inputClamp;
      inputSize[0] = state.destinationFrame.width;
      inputSize[1] = state.destinationFrame.height;
      inputSize[2] = 1 / inputSize[0];
      inputSize[3] = 1 / inputSize[1];
      inputPixel[0] = Math.round(inputSize[0] * state.resolution);
      inputPixel[1] = Math.round(inputSize[1] * state.resolution);
      inputPixel[2] = 1 / inputPixel[0];
      inputPixel[3] = 1 / inputPixel[1];
      inputClamp[0] = 0.5 * inputPixel[2];
      inputClamp[1] = 0.5 * inputPixel[3];
      inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
      inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
      if (state.legacy) {
        var filterArea = globalUniforms.filterArea;
        filterArea[0] = state.destinationFrame.width;
        filterArea[1] = state.destinationFrame.height;
        filterArea[2] = state.sourceFrame.x;
        filterArea[3] = state.sourceFrame.y;
        globalUniforms.filterClamp = globalUniforms.inputClamp;
      }
      this.globalUniforms.update();
      var lastState = filterStack[filterStack.length - 1];
      this.renderer.framebuffer.blit();
      if (filters.length === 1) {
        filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);
        this.returnFilterTexture(state.renderTexture);
      } else {
        var flip = state.renderTexture;
        var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
        flop.filterFrame = flip.filterFrame;
        var i = 0;
        for (i = 0; i < filters.length - 1; ++i) {
          if (i === 1 && state.multisample > 1) {
            flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
            flop.filterFrame = flip.filterFrame;
          }
          filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
          var t = flip;
          flip = flop;
          flop = t;
        }
        filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);
        if (i > 1 && state.multisample > 1) {
          this.returnFilterTexture(state.renderTexture);
        }
        this.returnFilterTexture(flip);
        this.returnFilterTexture(flop);
      }
      state.clear();
      this.statePool.push(state);
    };
    FilterSystem2.prototype.bindAndClear = function(filterTexture, clearMode) {
      if (clearMode === void 0) {
        clearMode = CLEAR_MODES.CLEAR;
      }
      var _a2 = this.renderer, renderTextureSystem = _a2.renderTexture, stateSystem = _a2.state;
      if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
        this.renderer.projection.transform = this.activeState.transform;
      } else {
        this.renderer.projection.transform = null;
      }
      if (filterTexture && filterTexture.filterFrame) {
        var destinationFrame = this.tempRect;
        destinationFrame.x = 0;
        destinationFrame.y = 0;
        destinationFrame.width = filterTexture.filterFrame.width;
        destinationFrame.height = filterTexture.filterFrame.height;
        renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
      } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
        renderTextureSystem.bind(filterTexture);
      } else {
        this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      }
      var autoClear = stateSystem.stateId & 1 || this.forceClear;
      if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {
        this.renderer.framebuffer.clear(0, 0, 0, 0);
      }
    };
    FilterSystem2.prototype.applyFilter = function(filter2, input, output, clearMode) {
      var renderer = this.renderer;
      renderer.state.set(filter2.state);
      this.bindAndClear(output, clearMode);
      filter2.uniforms.uSampler = input;
      filter2.uniforms.filterGlobals = this.globalUniforms;
      renderer.shader.bind(filter2);
      filter2.legacy = !!filter2.program.attributeData.aTextureCoord;
      if (filter2.legacy) {
        this.quadUv.map(input._frame, input.filterFrame);
        renderer.geometry.bind(this.quadUv);
        renderer.geometry.draw(DRAW_MODES.TRIANGLES);
      } else {
        renderer.geometry.bind(this.quad);
        renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);
      }
    };
    FilterSystem2.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
      var _a2 = this.activeState, sourceFrame = _a2.sourceFrame, destinationFrame = _a2.destinationFrame;
      var orig = sprite._texture.orig;
      var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
      var worldTransform = sprite.worldTransform.copyTo(Matrix$1.TEMP_MATRIX);
      worldTransform.invert();
      mappedMatrix.prepend(worldTransform);
      mappedMatrix.scale(1 / orig.width, 1 / orig.height);
      mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
      return mappedMatrix;
    };
    FilterSystem2.prototype.destroy = function() {
      this.renderer = null;
      this.texturePool.clear(false);
    };
    FilterSystem2.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution, multisample) {
      if (resolution === void 0) {
        resolution = 1;
      }
      if (multisample === void 0) {
        multisample = MSAA_QUALITY.NONE;
      }
      return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
    };
    FilterSystem2.prototype.getFilterTexture = function(input, resolution, multisample) {
      if (typeof input === "number") {
        var swap = input;
        input = resolution;
        resolution = swap;
      }
      input = input || this.activeState.renderTexture;
      var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
      filterTexture.filterFrame = input.filterFrame;
      return filterTexture;
    };
    FilterSystem2.prototype.returnFilterTexture = function(renderTexture) {
      this.texturePool.returnTexture(renderTexture);
    };
    FilterSystem2.prototype.emptyPool = function() {
      this.texturePool.clear(true);
    };
    FilterSystem2.prototype.resize = function() {
      this.texturePool.setScreenSize(this.renderer.view);
    };
    FilterSystem2.prototype.transformAABB = function(matrix2, rect) {
      var lt = tempPoints[0];
      var lb = tempPoints[1];
      var rt = tempPoints[2];
      var rb = tempPoints[3];
      lt.set(rect.left, rect.top);
      lb.set(rect.left, rect.bottom);
      rt.set(rect.right, rect.top);
      rb.set(rect.right, rect.bottom);
      matrix2.apply(lt, lt);
      matrix2.apply(lb, lb);
      matrix2.apply(rt, rt);
      matrix2.apply(rb, rb);
      var x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
      var y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
      var x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
      var y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
      rect.x = x0;
      rect.y = y0;
      rect.width = x1 - x0;
      rect.height = y1 - y0;
    };
    FilterSystem2.prototype.roundFrame = function(frame2, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
      if (frame2.width <= 0 || frame2.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
        return;
      }
      if (transform) {
        var a = transform.a, b = transform.b, c2 = transform.c, d = transform.d;
        if ((Math.abs(b) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {
          return;
        }
      }
      transform = transform ? tempMatrix$2.copyFrom(transform) : tempMatrix$2.identity();
      transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
      this.transformAABB(transform, frame2);
      frame2.ceil(resolution);
      this.transformAABB(transform.invert(), frame2);
    };
    return FilterSystem2;
  }()
);
var ObjectRenderer = (
  /** @class */
  function() {
    function ObjectRenderer2(renderer) {
      this.renderer = renderer;
    }
    ObjectRenderer2.prototype.flush = function() {
    };
    ObjectRenderer2.prototype.destroy = function() {
      this.renderer = null;
    };
    ObjectRenderer2.prototype.start = function() {
    };
    ObjectRenderer2.prototype.stop = function() {
      this.flush();
    };
    ObjectRenderer2.prototype.render = function(_object) {
    };
    return ObjectRenderer2;
  }()
);
var BatchSystem = (
  /** @class */
  function() {
    function BatchSystem2(renderer) {
      this.renderer = renderer;
      this.emptyRenderer = new ObjectRenderer(renderer);
      this.currentRenderer = this.emptyRenderer;
    }
    BatchSystem2.prototype.setObjectRenderer = function(objectRenderer) {
      if (this.currentRenderer === objectRenderer) {
        return;
      }
      this.currentRenderer.stop();
      this.currentRenderer = objectRenderer;
      this.currentRenderer.start();
    };
    BatchSystem2.prototype.flush = function() {
      this.setObjectRenderer(this.emptyRenderer);
    };
    BatchSystem2.prototype.reset = function() {
      this.setObjectRenderer(this.emptyRenderer);
    };
    BatchSystem2.prototype.copyBoundTextures = function(arr, maxTextures) {
      var boundTextures = this.renderer.texture.boundTextures;
      for (var i = maxTextures - 1; i >= 0; --i) {
        arr[i] = boundTextures[i] || null;
        if (arr[i]) {
          arr[i]._batchLocation = i;
        }
      }
    };
    BatchSystem2.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
      var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
      var j = 0;
      for (var i = 0; i < count; i++) {
        var tex = elements[i];
        var loc = tex._batchLocation;
        if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
          ids[i] = loc;
          continue;
        }
        while (j < maxTextures) {
          var bound = boundTextures[j];
          if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
            j++;
            continue;
          }
          ids[i] = j;
          tex._batchLocation = j;
          boundTextures[j] = tex;
          break;
        }
      }
    };
    BatchSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return BatchSystem2;
  }()
);
var CONTEXT_UID_COUNTER = 0;
var ContextSystem = (
  /** @class */
  function() {
    function ContextSystem2(renderer) {
      this.renderer = renderer;
      this.webGLVersion = 1;
      this.extensions = {};
      this.supports = {
        uint32Indices: false
      };
      this.handleContextLost = this.handleContextLost.bind(this);
      this.handleContextRestored = this.handleContextRestored.bind(this);
      renderer.view.addEventListener("webglcontextlost", this.handleContextLost, false);
      renderer.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
    Object.defineProperty(ContextSystem2.prototype, "isLost", {
      /**
       * `true` if the context is lost
       * @readonly
       */
      get: function() {
        return !this.gl || this.gl.isContextLost();
      },
      enumerable: false,
      configurable: true
    });
    ContextSystem2.prototype.contextChange = function(gl) {
      this.gl = gl;
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    };
    ContextSystem2.prototype.initFromContext = function(gl) {
      this.gl = gl;
      this.validateContext(gl);
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
      this.renderer.runners.contextChange.emit(gl);
    };
    ContextSystem2.prototype.initFromOptions = function(options) {
      var gl = this.createContext(this.renderer.view, options);
      this.initFromContext(gl);
    };
    ContextSystem2.prototype.createContext = function(canvas, options) {
      var gl;
      if (settings.PREFER_ENV >= ENV.WEBGL2) {
        gl = canvas.getContext("webgl2", options);
      }
      if (gl) {
        this.webGLVersion = 2;
      } else {
        this.webGLVersion = 1;
        gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
        if (!gl) {
          throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        }
      }
      this.gl = gl;
      this.getExtensions();
      return this.gl;
    };
    ContextSystem2.prototype.getExtensions = function() {
      var gl = this.gl;
      var common = {
        loseContext: gl.getExtension("WEBGL_lose_context"),
        anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: gl.getExtension("WEBGL_compressed_texture_etc"),
        etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: gl.getExtension("WEBGL_compressed_texture_atc"),
        astc: gl.getExtension("WEBGL_compressed_texture_astc")
      };
      if (this.webGLVersion === 1) {
        Object.assign(this.extensions, common, {
          drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
          depthTexture: gl.getExtension("WEBGL_depth_texture"),
          vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
          uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
          // Floats and half-floats
          floatTexture: gl.getExtension("OES_texture_float"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          textureHalfFloat: gl.getExtension("OES_texture_half_float"),
          textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
        });
      } else if (this.webGLVersion === 2) {
        Object.assign(this.extensions, common, {
          // Floats and half-floats
          colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
        });
      }
    };
    ContextSystem2.prototype.handleContextLost = function(event) {
      var _this = this;
      event.preventDefault();
      setTimeout(function() {
        if (_this.gl.isContextLost() && _this.extensions.loseContext) {
          _this.extensions.loseContext.restoreContext();
        }
      }, 0);
    };
    ContextSystem2.prototype.handleContextRestored = function() {
      this.renderer.runners.contextChange.emit(this.gl);
    };
    ContextSystem2.prototype.destroy = function() {
      var view = this.renderer.view;
      this.renderer = null;
      view.removeEventListener("webglcontextlost", this.handleContextLost);
      view.removeEventListener("webglcontextrestored", this.handleContextRestored);
      this.gl.useProgram(null);
      if (this.extensions.loseContext) {
        this.extensions.loseContext.loseContext();
      }
    };
    ContextSystem2.prototype.postrender = function() {
      if (this.renderer.renderingToScreen) {
        this.gl.flush();
      }
    };
    ContextSystem2.prototype.validateContext = function(gl) {
      var attributes = gl.getContextAttributes();
      var isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
      if (isWebGl2) {
        this.webGLVersion = 2;
      }
      if (attributes && !attributes.stencil) {
        console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      }
      var hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = hasuint32;
      if (!hasuint32) {
        console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
      }
    };
    return ContextSystem2;
  }()
);
var GLFramebuffer = (
  /** @class */
  /* @__PURE__ */ function() {
    function GLFramebuffer2(framebuffer) {
      this.framebuffer = framebuffer;
      this.stencil = null;
      this.dirtyId = -1;
      this.dirtyFormat = -1;
      this.dirtySize = -1;
      this.multisample = MSAA_QUALITY.NONE;
      this.msaaBuffer = null;
      this.blitFramebuffer = null;
      this.mipLevel = 0;
    }
    return GLFramebuffer2;
  }()
);
var tempRectangle = new Rectangle();
var FramebufferSystem = (
  /** @class */
  function() {
    function FramebufferSystem2(renderer) {
      this.renderer = renderer;
      this.managedFramebuffers = [];
      this.unknownFramebuffer = new Framebuffer(10, 10);
      this.msaaSamples = null;
    }
    FramebufferSystem2.prototype.contextChange = function() {
      this.disposeAll(true);
      var gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.current = this.unknownFramebuffer;
      this.viewport = new Rectangle();
      this.hasMRT = true;
      this.writeDepthTexture = true;
      if (this.renderer.context.webGLVersion === 1) {
        var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
        var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
          nativeDrawBuffersExtension_1 = null;
          nativeDepthTextureExtension = null;
        }
        if (nativeDrawBuffersExtension_1) {
          gl.drawBuffers = function(activeTextures) {
            return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
          };
        } else {
          this.hasMRT = false;
          gl.drawBuffers = function() {
          };
        }
        if (!nativeDepthTextureExtension) {
          this.writeDepthTexture = false;
        }
      } else {
        this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
      }
    };
    FramebufferSystem2.prototype.bind = function(framebuffer, frame2, mipLevel) {
      if (mipLevel === void 0) {
        mipLevel = 0;
      }
      var gl = this.gl;
      if (framebuffer) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
        if (this.current !== framebuffer) {
          this.current = framebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
        }
        if (fbo.mipLevel !== mipLevel) {
          framebuffer.dirtyId++;
          framebuffer.dirtyFormat++;
          fbo.mipLevel = mipLevel;
        }
        if (fbo.dirtyId !== framebuffer.dirtyId) {
          fbo.dirtyId = framebuffer.dirtyId;
          if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
            fbo.dirtyFormat = framebuffer.dirtyFormat;
            fbo.dirtySize = framebuffer.dirtySize;
            this.updateFramebuffer(framebuffer, mipLevel);
          } else if (fbo.dirtySize !== framebuffer.dirtySize) {
            fbo.dirtySize = framebuffer.dirtySize;
            this.resizeFramebuffer(framebuffer);
          }
        }
        for (var i = 0; i < framebuffer.colorTextures.length; i++) {
          var tex = framebuffer.colorTextures[i];
          this.renderer.texture.unbind(tex.parentTextureArray || tex);
        }
        if (framebuffer.depthTexture) {
          this.renderer.texture.unbind(framebuffer.depthTexture);
        }
        if (frame2) {
          var mipWidth = frame2.width >> mipLevel;
          var mipHeight = frame2.height >> mipLevel;
          var scale = mipWidth / frame2.width;
          this.setViewport(frame2.x * scale, frame2.y * scale, mipWidth, mipHeight);
        } else {
          var mipWidth = framebuffer.width >> mipLevel;
          var mipHeight = framebuffer.height >> mipLevel;
          this.setViewport(0, 0, mipWidth, mipHeight);
        }
      } else {
        if (this.current) {
          this.current = null;
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        if (frame2) {
          this.setViewport(frame2.x, frame2.y, frame2.width, frame2.height);
        } else {
          this.setViewport(0, 0, this.renderer.width, this.renderer.height);
        }
      }
    };
    FramebufferSystem2.prototype.setViewport = function(x, y, width, height) {
      var v2 = this.viewport;
      x = Math.round(x);
      y = Math.round(y);
      width = Math.round(width);
      height = Math.round(height);
      if (v2.width !== width || v2.height !== height || v2.x !== x || v2.y !== y) {
        v2.x = x;
        v2.y = y;
        v2.width = width;
        v2.height = height;
        this.gl.viewport(x, y, width, height);
      }
    };
    Object.defineProperty(FramebufferSystem2.prototype, "size", {
      /**
       * Get the size of the current width and height. Returns object with `width` and `height` values.
       * @readonly
       */
      get: function() {
        if (this.current) {
          return { x: 0, y: 0, width: this.current.width, height: this.current.height };
        }
        return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
      },
      enumerable: false,
      configurable: true
    });
    FramebufferSystem2.prototype.clear = function(r, g, b, a, mask) {
      if (mask === void 0) {
        mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH;
      }
      var gl = this.gl;
      gl.clearColor(r, g, b, a);
      gl.clear(mask);
    };
    FramebufferSystem2.prototype.initFramebuffer = function(framebuffer) {
      var gl = this.gl;
      var fbo = new GLFramebuffer(gl.createFramebuffer());
      fbo.multisample = this.detectSamples(framebuffer.multisample);
      framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
      this.managedFramebuffers.push(framebuffer);
      framebuffer.disposeRunner.add(this);
      return fbo;
    };
    FramebufferSystem2.prototype.resizeFramebuffer = function(framebuffer) {
      var gl = this.gl;
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
      }
      if (fbo.stencil) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        if (fbo.msaaBuffer) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
      }
      var colorTextures = framebuffer.colorTextures;
      var count = colorTextures.length;
      if (!gl.drawBuffers) {
        count = Math.min(count, 1);
      }
      for (var i = 0; i < count; i++) {
        var texture = colorTextures[i];
        var parentTexture = texture.parentTextureArray || texture;
        this.renderer.texture.bind(parentTexture, 0);
      }
      if (framebuffer.depthTexture && this.writeDepthTexture) {
        this.renderer.texture.bind(framebuffer.depthTexture, 0);
      }
    };
    FramebufferSystem2.prototype.updateFramebuffer = function(framebuffer, mipLevel) {
      var gl = this.gl;
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      var colorTextures = framebuffer.colorTextures;
      var count = colorTextures.length;
      if (!gl.drawBuffers) {
        count = Math.min(count, 1);
      }
      if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
        fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
      } else if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
        fbo.msaaBuffer = null;
        if (fbo.blitFramebuffer) {
          fbo.blitFramebuffer.dispose();
          fbo.blitFramebuffer = null;
        }
      }
      var activeTextures = [];
      for (var i = 0; i < count; i++) {
        var texture = colorTextures[i];
        var parentTexture = texture.parentTextureArray || texture;
        this.renderer.texture.bind(parentTexture, 0);
        if (i === 0 && fbo.msaaBuffer) {
          continue;
        }
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
      }
      if (activeTextures.length > 1) {
        gl.drawBuffers(activeTextures);
      }
      if (framebuffer.depthTexture) {
        var writeDepthTexture = this.writeDepthTexture;
        if (writeDepthTexture) {
          var depthTexture = framebuffer.depthTexture;
          this.renderer.texture.bind(depthTexture, 0);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        }
      }
      if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
        fbo.stencil = fbo.stencil || gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        if (fbo.msaaBuffer) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
      } else if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
        fbo.stencil = null;
      }
    };
    FramebufferSystem2.prototype.canMultisampleFramebuffer = function(framebuffer) {
      return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
    };
    FramebufferSystem2.prototype.detectSamples = function(samples) {
      var msaaSamples = this.msaaSamples;
      var res = MSAA_QUALITY.NONE;
      if (samples <= 1 || msaaSamples === null) {
        return res;
      }
      for (var i = 0; i < msaaSamples.length; i++) {
        if (msaaSamples[i] <= samples) {
          res = msaaSamples[i];
          break;
        }
      }
      if (res === 1) {
        res = MSAA_QUALITY.NONE;
      }
      return res;
    };
    FramebufferSystem2.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
      var _a2 = this, current = _a2.current, renderer = _a2.renderer, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
      if (renderer.context.webGLVersion !== 2) {
        return;
      }
      if (!current) {
        return;
      }
      var fbo = current.glFramebuffers[CONTEXT_UID];
      if (!fbo) {
        return;
      }
      if (!framebuffer) {
        if (!fbo.msaaBuffer) {
          return;
        }
        var colorTexture = current.colorTextures[0];
        if (!colorTexture) {
          return;
        }
        if (!fbo.blitFramebuffer) {
          fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
          fbo.blitFramebuffer.addColorTexture(0, colorTexture);
        }
        framebuffer = fbo.blitFramebuffer;
        if (framebuffer.colorTextures[0] !== colorTexture) {
          framebuffer.colorTextures[0] = colorTexture;
          framebuffer.dirtyId++;
          framebuffer.dirtyFormat++;
        }
        if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
          framebuffer.width = current.width;
          framebuffer.height = current.height;
          framebuffer.dirtyId++;
          framebuffer.dirtySize++;
        }
      }
      if (!sourcePixels) {
        sourcePixels = tempRectangle;
        sourcePixels.width = current.width;
        sourcePixels.height = current.height;
      }
      if (!destPixels) {
        destPixels = sourcePixels;
      }
      var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
      this.bind(framebuffer);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
      gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    };
    FramebufferSystem2.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      var gl = this.gl;
      if (!fbo) {
        return;
      }
      delete framebuffer.glFramebuffers[this.CONTEXT_UID];
      var index = this.managedFramebuffers.indexOf(framebuffer);
      if (index >= 0) {
        this.managedFramebuffers.splice(index, 1);
      }
      framebuffer.disposeRunner.remove(this);
      if (!contextLost) {
        gl.deleteFramebuffer(fbo.framebuffer);
        if (fbo.msaaBuffer) {
          gl.deleteRenderbuffer(fbo.msaaBuffer);
        }
        if (fbo.stencil) {
          gl.deleteRenderbuffer(fbo.stencil);
        }
      }
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
      }
    };
    FramebufferSystem2.prototype.disposeAll = function(contextLost) {
      var list = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (var i = 0; i < list.length; i++) {
        this.disposeFramebuffer(list[i], contextLost);
      }
    };
    FramebufferSystem2.prototype.forceStencil = function() {
      var framebuffer = this.current;
      if (!framebuffer) {
        return;
      }
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (!fbo || fbo.stencil) {
        return;
      }
      framebuffer.stencil = true;
      var w = framebuffer.width;
      var h = framebuffer.height;
      var gl = this.gl;
      var stencil = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
      }
      fbo.stencil = stencil;
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
    };
    FramebufferSystem2.prototype.reset = function() {
      this.current = this.unknownFramebuffer;
      this.viewport = new Rectangle();
    };
    FramebufferSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return FramebufferSystem2;
  }()
);
var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
var GeometrySystem = (
  /** @class */
  function() {
    function GeometrySystem2(renderer) {
      this.renderer = renderer;
      this._activeGeometry = null;
      this._activeVao = null;
      this.hasVao = true;
      this.hasInstance = true;
      this.canUseUInt32ElementIndex = false;
      this.managedGeometries = {};
    }
    GeometrySystem2.prototype.contextChange = function() {
      this.disposeAll(true);
      var gl = this.gl = this.renderer.gl;
      var context2 = this.renderer.context;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      if (context2.webGLVersion !== 2) {
        var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
          nativeVaoExtension_1 = null;
        }
        if (nativeVaoExtension_1) {
          gl.createVertexArray = function() {
            return nativeVaoExtension_1.createVertexArrayOES();
          };
          gl.bindVertexArray = function(vao) {
            return nativeVaoExtension_1.bindVertexArrayOES(vao);
          };
          gl.deleteVertexArray = function(vao) {
            return nativeVaoExtension_1.deleteVertexArrayOES(vao);
          };
        } else {
          this.hasVao = false;
          gl.createVertexArray = function() {
            return null;
          };
          gl.bindVertexArray = function() {
            return null;
          };
          gl.deleteVertexArray = function() {
            return null;
          };
        }
      }
      if (context2.webGLVersion !== 2) {
        var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
        if (instanceExt_1) {
          gl.vertexAttribDivisor = function(a, b) {
            return instanceExt_1.vertexAttribDivisorANGLE(a, b);
          };
          gl.drawElementsInstanced = function(a, b, c2, d, e) {
            return instanceExt_1.drawElementsInstancedANGLE(a, b, c2, d, e);
          };
          gl.drawArraysInstanced = function(a, b, c2, d) {
            return instanceExt_1.drawArraysInstancedANGLE(a, b, c2, d);
          };
        } else {
          this.hasInstance = false;
        }
      }
      this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
    };
    GeometrySystem2.prototype.bind = function(geometry, shader) {
      shader = shader || this.renderer.shader.shader;
      var gl = this.gl;
      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var incRefCount = false;
      if (!vaos) {
        this.managedGeometries[geometry.id] = geometry;
        geometry.disposeRunner.add(this);
        geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
        incRefCount = true;
      }
      var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
      this._activeGeometry = geometry;
      if (this._activeVao !== vao) {
        this._activeVao = vao;
        if (this.hasVao) {
          gl.bindVertexArray(vao);
        } else {
          this.activateVao(geometry, shader.program);
        }
      }
      this.updateBuffers();
    };
    GeometrySystem2.prototype.reset = function() {
      this.unbind();
    };
    GeometrySystem2.prototype.updateBuffers = function() {
      var geometry = this._activeGeometry;
      var bufferSystem = this.renderer.buffer;
      for (var i = 0; i < geometry.buffers.length; i++) {
        var buffer = geometry.buffers[i];
        bufferSystem.update(buffer);
      }
    };
    GeometrySystem2.prototype.checkCompatibility = function(geometry, program) {
      var geometryAttributes = geometry.attributes;
      var shaderAttributes = program.attributeData;
      for (var j in shaderAttributes) {
        if (!geometryAttributes[j]) {
          throw new Error('shader and geometry incompatible, geometry missing the "' + j + '" attribute');
        }
      }
    };
    GeometrySystem2.prototype.getSignature = function(geometry, program) {
      var attribs = geometry.attributes;
      var shaderAttributes = program.attributeData;
      var strings = ["g", geometry.id];
      for (var i in attribs) {
        if (shaderAttributes[i]) {
          strings.push(i, shaderAttributes[i].location);
        }
      }
      return strings.join("-");
    };
    GeometrySystem2.prototype.initGeometryVao = function(geometry, shader, incRefCount) {
      if (incRefCount === void 0) {
        incRefCount = true;
      }
      var gl = this.gl;
      var CONTEXT_UID = this.CONTEXT_UID;
      var bufferSystem = this.renderer.buffer;
      var program = shader.program;
      if (!program.glPrograms[CONTEXT_UID]) {
        this.renderer.shader.generateProgram(shader);
      }
      this.checkCompatibility(geometry, program);
      var signature = this.getSignature(geometry, program);
      var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var vao = vaoObjectHash[signature];
      if (vao) {
        vaoObjectHash[program.id] = vao;
        return vao;
      }
      var buffers = geometry.buffers;
      var attributes = geometry.attributes;
      var tempStride = {};
      var tempStart = {};
      for (var j in buffers) {
        tempStride[j] = 0;
        tempStart[j] = 0;
      }
      for (var j in attributes) {
        if (!attributes[j].size && program.attributeData[j]) {
          attributes[j].size = program.attributeData[j].size;
        } else if (!attributes[j].size) {
          console.warn("PIXI Geometry attribute '" + j + "' size cannot be determined (likely the bound shader does not have the attribute)");
        }
        tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];
      }
      for (var j in attributes) {
        var attribute = attributes[j];
        var attribSize = attribute.size;
        if (attribute.stride === void 0) {
          if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {
            attribute.stride = 0;
          } else {
            attribute.stride = tempStride[attribute.buffer];
          }
        }
        if (attribute.start === void 0) {
          attribute.start = tempStart[attribute.buffer];
          tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];
        }
      }
      vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      for (var i = 0; i < buffers.length; i++) {
        var buffer = buffers[i];
        bufferSystem.bind(buffer);
        if (incRefCount) {
          buffer._glBuffers[CONTEXT_UID].refCount++;
        }
      }
      this.activateVao(geometry, program);
      this._activeVao = vao;
      vaoObjectHash[program.id] = vao;
      vaoObjectHash[signature] = vao;
      return vao;
    };
    GeometrySystem2.prototype.disposeGeometry = function(geometry, contextLost) {
      var _a2;
      if (!this.managedGeometries[geometry.id]) {
        return;
      }
      delete this.managedGeometries[geometry.id];
      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var gl = this.gl;
      var buffers = geometry.buffers;
      var bufferSystem = (_a2 = this.renderer) === null || _a2 === void 0 ? void 0 : _a2.buffer;
      geometry.disposeRunner.remove(this);
      if (!vaos) {
        return;
      }
      if (bufferSystem) {
        for (var i = 0; i < buffers.length; i++) {
          var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
          if (buf) {
            buf.refCount--;
            if (buf.refCount === 0 && !contextLost) {
              bufferSystem.dispose(buffers[i], contextLost);
            }
          }
        }
      }
      if (!contextLost) {
        for (var vaoId in vaos) {
          if (vaoId[0] === "g") {
            var vao = vaos[vaoId];
            if (this._activeVao === vao) {
              this.unbind();
            }
            gl.deleteVertexArray(vao);
          }
        }
      }
      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    };
    GeometrySystem2.prototype.disposeAll = function(contextLost) {
      var all = Object.keys(this.managedGeometries);
      for (var i = 0; i < all.length; i++) {
        this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
      }
    };
    GeometrySystem2.prototype.activateVao = function(geometry, program) {
      var gl = this.gl;
      var CONTEXT_UID = this.CONTEXT_UID;
      var bufferSystem = this.renderer.buffer;
      var buffers = geometry.buffers;
      var attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        bufferSystem.bind(geometry.indexBuffer);
      }
      var lastBuffer = null;
      for (var j in attributes) {
        var attribute = attributes[j];
        var buffer = buffers[attribute.buffer];
        var glBuffer = buffer._glBuffers[CONTEXT_UID];
        if (program.attributeData[j]) {
          if (lastBuffer !== glBuffer) {
            bufferSystem.bind(buffer);
            lastBuffer = glBuffer;
          }
          var location = program.attributeData[j].location;
          gl.enableVertexAttribArray(location);
          gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
          if (attribute.instance) {
            if (this.hasInstance) {
              gl.vertexAttribDivisor(location, 1);
            } else {
              throw new Error("geometry error, GPU Instancing is not supported on this device");
            }
          }
        }
      }
    };
    GeometrySystem2.prototype.draw = function(type2, size2, start2, instanceCount) {
      var gl = this.gl;
      var geometry = this._activeGeometry;
      if (geometry.indexBuffer) {
        var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
        var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
        if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
          if (geometry.instanced) {
            gl.drawElementsInstanced(type2, size2 || geometry.indexBuffer.data.length, glType, (start2 || 0) * byteSize, instanceCount || 1);
          } else {
            gl.drawElements(type2, size2 || geometry.indexBuffer.data.length, glType, (start2 || 0) * byteSize);
          }
        } else {
          console.warn("unsupported index buffer type: uint32");
        }
      } else if (geometry.instanced) {
        gl.drawArraysInstanced(type2, start2, size2 || geometry.getSize(), instanceCount || 1);
      } else {
        gl.drawArrays(type2, start2, size2 || geometry.getSize());
      }
      return this;
    };
    GeometrySystem2.prototype.unbind = function() {
      this.gl.bindVertexArray(null);
      this._activeVao = null;
      this._activeGeometry = null;
    };
    GeometrySystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return GeometrySystem2;
  }()
);
var MaskData = (
  /** @class */
  function() {
    function MaskData2(maskObject) {
      if (maskObject === void 0) {
        maskObject = null;
      }
      this.type = MASK_TYPES.NONE;
      this.autoDetect = true;
      this.maskObject = maskObject || null;
      this.pooled = false;
      this.isMaskData = true;
      this.resolution = null;
      this.multisample = settings.FILTER_MULTISAMPLE;
      this.enabled = true;
      this.colorMask = 15;
      this._filters = null;
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
      this._scissorRectLocal = null;
      this._colorMask = 15;
      this._target = null;
    }
    Object.defineProperty(MaskData2.prototype, "filter", {
      /**
       * The sprite mask filter.
       * If set to `null`, the default sprite mask filter is used.
       * @default null
       */
      get: function() {
        return this._filters ? this._filters[0] : null;
      },
      set: function(value) {
        if (value) {
          if (this._filters) {
            this._filters[0] = value;
          } else {
            this._filters = [value];
          }
        } else {
          this._filters = null;
        }
      },
      enumerable: false,
      configurable: true
    });
    MaskData2.prototype.reset = function() {
      if (this.pooled) {
        this.maskObject = null;
        this.type = MASK_TYPES.NONE;
        this.autoDetect = true;
      }
      this._target = null;
      this._scissorRectLocal = null;
    };
    MaskData2.prototype.copyCountersOrReset = function(maskAbove) {
      if (maskAbove) {
        this._stencilCounter = maskAbove._stencilCounter;
        this._scissorCounter = maskAbove._scissorCounter;
        this._scissorRect = maskAbove._scissorRect;
      } else {
        this._stencilCounter = 0;
        this._scissorCounter = 0;
        this._scissorRect = null;
      }
    };
    return MaskData2;
  }()
);
function compileShader(gl, type2, src) {
  var shader = gl.createShader(type2);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
function logPrettyShaderError(gl, shader) {
  var shaderSrc = gl.getShaderSource(shader).split("\n").map(function(line, index) {
    return index + ": " + line;
  });
  var shaderLog = gl.getShaderInfoLog(shader);
  var splitShader = shaderLog.split("\n");
  var dedupe = {};
  var lineNumbers = splitShader.map(function(line) {
    return parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(n) {
    if (n && !dedupe[n]) {
      dedupe[n] = true;
      return true;
    }
    return false;
  });
  var logArgs = [""];
  lineNumbers.forEach(function(number2) {
    shaderSrc[number2 - 1] = "%c" + shaderSrc[number2 - 1] + "%c";
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn.apply(console, logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
function booleanArray(size2) {
  var array2 = new Array(size2);
  for (var i = 0; i < array2.length; i++) {
    array2[i] = false;
  }
  return array2;
}
function defaultValue(type2, size2) {
  switch (type2) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size2);
    case "vec3":
      return new Float32Array(3 * size2);
    case "vec4":
      return new Float32Array(4 * size2);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size2);
    case "ivec3":
      return new Int32Array(3 * size2);
    case "ivec4":
      return new Int32Array(4 * size2);
    case "uvec2":
      return new Uint32Array(2 * size2);
    case "uvec3":
      return new Uint32Array(3 * size2);
    case "uvec4":
      return new Uint32Array(4 * size2);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size2);
    case "bvec3":
      return booleanArray(3 * size2);
    case "bvec4":
      return booleanArray(4 * size2);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext = {};
var context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context && context.isContextLost()) {
    var canvas = settings.ADAPTER.createCanvas();
    var gl = void 0;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}
var maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION.MEDIUM;
    var gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}
function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    var precision = requestedPrecision;
    if (requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH) {
      precision = PRECISION.MEDIUM;
    }
    return "precision " + precision + " float;\n" + src;
  } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type2) {
  return GLSL_TO_SIZE[type2];
}
var GL_TABLE = null;
var GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type2) {
  if (!GL_TABLE) {
    var typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var i = 0; i < typeNames.length; ++i) {
      var tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type2];
}
var uniformParsers = [
  // a float cache layer
  {
    test: function(data) {
      return data.type === "float" && data.size === 1 && !data.isArray;
    },
    code: function(name2) {
      return '\n            if(uv["' + name2 + '"] !== ud["' + name2 + '"].value)\n            {\n                ud["' + name2 + '"].value = uv["' + name2 + '"]\n                gl.uniform1f(ud["' + name2 + '"].location, uv["' + name2 + '"])\n            }\n            ';
    }
  },
  // handling samplers
  {
    test: function(data, uniform) {
      return (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0);
    },
    code: function(name2) {
      return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name2 + '"], t);\n\n            if(ud["' + name2 + '"].value !== t)\n            {\n                ud["' + name2 + '"].value = t;\n                gl.uniform1i(ud["' + name2 + '"].location, t);\n; // eslint-disable-line max-len\n            }';
    }
  },
  // uploading pixi matrix object to mat3
  {
    test: function(data, uniform) {
      return data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0;
    },
    code: function(name2) {
      return '\n            gl.uniformMatrix3fv(ud["' + name2 + '"].location, false, uv["' + name2 + '"].toArray(true));\n            ';
    },
    codeUbo: function(name2) {
      return "\n                var " + name2 + "_matrix = uv." + name2 + ".toArray(true);\n\n                data[offset] = " + name2 + "_matrix[0];\n                data[offset+1] = " + name2 + "_matrix[1];\n                data[offset+2] = " + name2 + "_matrix[2];\n        \n                data[offset + 4] = " + name2 + "_matrix[3];\n                data[offset + 5] = " + name2 + "_matrix[4];\n                data[offset + 6] = " + name2 + "_matrix[5];\n        \n                data[offset + 8] = " + name2 + "_matrix[6];\n                data[offset + 9] = " + name2 + "_matrix[7];\n                data[offset + 10] = " + name2 + "_matrix[8];\n            ";
    }
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: function(data, uniform) {
      return data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0;
    },
    code: function(name2) {
      return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name2 + '"].location, v.x, v.y);\n                }';
    },
    codeUbo: function(name2) {
      return "\n                v = uv." + name2 + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
    }
  },
  // caching layer for a vec2
  {
    test: function(data) {
      return data.type === "vec2" && data.size === 1 && !data.isArray;
    },
    code: function(name2) {
      return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name2 + '"].location, v[0], v[1]);\n                }\n            ';
    }
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: function(data, uniform) {
      return data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0;
    },
    code: function(name2) {
      return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name2 + '"].location, v.x, v.y, v.width, v.height)\n                }';
    },
    codeUbo: function(name2) {
      return "\n                    v = uv." + name2 + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
    }
  },
  // a caching layer for vec4 uploading
  {
    test: function(data) {
      return data.type === "vec4" && data.size === 1 && !data.isArray;
    },
    code: function(name2) {
      return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name2 + '"].location, v[0], v[1], v[2], v[3])\n                }';
    }
  }
];
var GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
  vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
  vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
  vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
  int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
  ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
  ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
  ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
  uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
  uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
  uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
  uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
  bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
  bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
  bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
  bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
  samplerCube: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
  sampler2DArray: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }"
};
var GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  var _a2;
  var funcFragments = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
  for (var i in group.uniforms) {
    var data = uniformData[i];
    if (!data) {
      if ((_a2 = group.uniforms[i]) === null || _a2 === void 0 ? void 0 : _a2.group) {
        if (group.uniforms[i].ubo) {
          funcFragments.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + i + ", '" + i + "');\n                    ");
        } else {
          funcFragments.push("\n                        renderer.shader.syncUniformGroup(uv." + i + ", syncData);\n                    ");
        }
      }
      continue;
    }
    var uniform = group.uniforms[i];
    var parsed = false;
    for (var j = 0; j < uniformParsers.length; j++) {
      if (uniformParsers[j].test(data, uniform)) {
        funcFragments.push(uniformParsers[j].code(i, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      var templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      var template = templateType[data.type].replace("location", 'ud["' + i + '"].location');
      funcFragments.push('\n            cu = ud["' + i + '"];\n            cv = cu.value;\n            v = uv["' + i + '"];\n            ' + template + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  var src = "";
  for (var i = 0; i < maxIfs; ++i) {
    if (i > 0) {
      src += "\nelse ";
    }
    if (i < maxIfs - 1) {
      src += "if(test == " + i + ".0){}";
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  var shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    var fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}
var unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    var func2 = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func2({ a: "b" }, "a", "b") === true;
  } catch (e) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var defaultFragment$2 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
var defaultVertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
var UID$1 = 0;
var nameCache = {};
var Program = (
  /** @class */
  function() {
    function Program2(vertexSrc, fragmentSrc, name2) {
      if (name2 === void 0) {
        name2 = "pixi-shader";
      }
      this.id = UID$1++;
      this.vertexSrc = vertexSrc || Program2.defaultVertexSrc;
      this.fragmentSrc = fragmentSrc || Program2.defaultFragmentSrc;
      this.vertexSrc = this.vertexSrc.trim();
      this.fragmentSrc = this.fragmentSrc.trim();
      if (this.vertexSrc.substring(0, 8) !== "#version") {
        name2 = name2.replace(/\s+/g, "-");
        if (nameCache[name2]) {
          nameCache[name2]++;
          name2 += "-" + nameCache[name2];
        } else {
          nameCache[name2] = 1;
        }
        this.vertexSrc = "#define SHADER_NAME " + name2 + "\n" + this.vertexSrc;
        this.fragmentSrc = "#define SHADER_NAME " + name2 + "\n" + this.fragmentSrc;
        this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH);
        this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());
      }
      this.glPrograms = {};
      this.syncUniforms = null;
    }
    Object.defineProperty(Program2, "defaultVertexSrc", {
      /**
       * The default vertex shader source.
       * @constant
       */
      get: function() {
        return defaultVertex$3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Program2, "defaultFragmentSrc", {
      /**
       * The default fragment shader source.
       * @constant
       */
      get: function() {
        return defaultFragment$2;
      },
      enumerable: false,
      configurable: true
    });
    Program2.from = function(vertexSrc, fragmentSrc, name2) {
      var key = vertexSrc + fragmentSrc;
      var program = ProgramCache[key];
      if (!program) {
        ProgramCache[key] = program = new Program2(vertexSrc, fragmentSrc, name2);
      }
      return program;
    };
    return Program2;
  }()
);
var Shader = (
  /** @class */
  function() {
    function Shader2(program, uniforms) {
      this.uniformBindCount = 0;
      this.program = program;
      if (uniforms) {
        if (uniforms instanceof UniformGroup) {
          this.uniformGroup = uniforms;
        } else {
          this.uniformGroup = new UniformGroup(uniforms);
        }
      } else {
        this.uniformGroup = new UniformGroup({});
      }
      this.disposeRunner = new Runner("disposeShader");
    }
    Shader2.prototype.checkUniformExists = function(name2, group) {
      if (group.uniforms[name2]) {
        return true;
      }
      for (var i in group.uniforms) {
        var uniform = group.uniforms[i];
        if (uniform.group) {
          if (this.checkUniformExists(name2, uniform)) {
            return true;
          }
        }
      }
      return false;
    };
    Shader2.prototype.destroy = function() {
      this.uniformGroup = null;
      this.disposeRunner.emit(this);
      this.disposeRunner.destroy();
    };
    Object.defineProperty(Shader2.prototype, "uniforms", {
      /**
       * Shader uniform values, shortcut for `uniformGroup.uniforms`.
       * @readonly
       */
      get: function() {
        return this.uniformGroup.uniforms;
      },
      enumerable: false,
      configurable: true
    });
    Shader2.from = function(vertexSrc, fragmentSrc, uniforms) {
      var program = Program.from(vertexSrc, fragmentSrc);
      return new Shader2(program, uniforms);
    };
    return Shader2;
  }()
);
var BLEND$1 = 0;
var OFFSET$1 = 1;
var CULLING$1 = 2;
var DEPTH_TEST$1 = 3;
var WINDING$1 = 4;
var DEPTH_MASK$1 = 5;
var State = (
  /** @class */
  function() {
    function State2() {
      this.data = 0;
      this.blendMode = BLEND_MODES.NORMAL;
      this.polygonOffset = 0;
      this.blend = true;
      this.depthMask = true;
    }
    Object.defineProperty(State2.prototype, "blend", {
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << BLEND$1);
      },
      set: function(value) {
        if (!!(this.data & 1 << BLEND$1) !== value) {
          this.data ^= 1 << BLEND$1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "offsets", {
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << OFFSET$1);
      },
      set: function(value) {
        if (!!(this.data & 1 << OFFSET$1) !== value) {
          this.data ^= 1 << OFFSET$1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "culling", {
      /**
       * Activates culling of polygons.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << CULLING$1);
      },
      set: function(value) {
        if (!!(this.data & 1 << CULLING$1) !== value) {
          this.data ^= 1 << CULLING$1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "depthTest", {
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << DEPTH_TEST$1);
      },
      set: function(value) {
        if (!!(this.data & 1 << DEPTH_TEST$1) !== value) {
          this.data ^= 1 << DEPTH_TEST$1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "depthMask", {
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << DEPTH_MASK$1);
      },
      set: function(value) {
        if (!!(this.data & 1 << DEPTH_MASK$1) !== value) {
          this.data ^= 1 << DEPTH_MASK$1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "clockwiseFrontFace", {
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << WINDING$1);
      },
      set: function(value) {
        if (!!(this.data & 1 << WINDING$1) !== value) {
          this.data ^= 1 << WINDING$1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "blendMode", {
      /**
       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this._blendMode;
      },
      set: function(value) {
        this.blend = value !== BLEND_MODES.NONE;
        this._blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "polygonOffset", {
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get: function() {
        return this._polygonOffset;
      },
      set: function(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
      },
      enumerable: false,
      configurable: true
    });
    State2.prototype.toString = function() {
      return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
    };
    State2.for2d = function() {
      var state = new State2();
      state.depthTest = false;
      state.blend = true;
      return state;
    };
    return State2;
  }()
);
var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
var defaultVertex$2 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var Filter = (
  /** @class */
  function(_super) {
    __extends$i(Filter2, _super);
    function Filter2(vertexSrc, fragmentSrc, uniforms) {
      var _this = this;
      var program = Program.from(vertexSrc || Filter2.defaultVertexSrc, fragmentSrc || Filter2.defaultFragmentSrc);
      _this = _super.call(this, program, uniforms) || this;
      _this.padding = 0;
      _this.resolution = settings.FILTER_RESOLUTION;
      _this.multisample = settings.FILTER_MULTISAMPLE;
      _this.enabled = true;
      _this.autoFit = true;
      _this.state = new State();
      return _this;
    }
    Filter2.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {
      filterManager.applyFilter(this, input, output, clearMode);
    };
    Object.defineProperty(Filter2.prototype, "blendMode", {
      /**
       * Sets the blend mode of the filter.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this.state.blendMode;
      },
      set: function(value) {
        this.state.blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Filter2.prototype, "resolution", {
      /**
       * The resolution of the filter. Setting this to be lower will lower the quality but
       * increase the performance of the filter.
       */
      get: function() {
        return this._resolution;
      },
      set: function(value) {
        this._resolution = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Filter2, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @constant
       */
      get: function() {
        return defaultVertex$2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Filter2, "defaultFragmentSrc", {
      /**
       * The default fragment shader source
       * @constant
       */
      get: function() {
        return defaultFragment$1;
      },
      enumerable: false,
      configurable: true
    });
    return Filter2;
  }(Shader)
);
var vertex$4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
var fragment$7 = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
var tempMat$1 = new Matrix$1();
var TextureMatrix = (
  /** @class */
  function() {
    function TextureMatrix2(texture, clampMargin) {
      this._texture = texture;
      this.mapCoord = new Matrix$1();
      this.uClampFrame = new Float32Array(4);
      this.uClampOffset = new Float32Array(2);
      this._textureID = -1;
      this._updateID = 0;
      this.clampOffset = 0;
      this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
      this.isSimple = false;
    }
    Object.defineProperty(TextureMatrix2.prototype, "texture", {
      /** Texture property. */
      get: function() {
        return this._texture;
      },
      set: function(value) {
        this._texture = value;
        this._textureID = -1;
      },
      enumerable: false,
      configurable: true
    });
    TextureMatrix2.prototype.multiplyUvs = function(uvs, out) {
      if (out === void 0) {
        out = uvs;
      }
      var mat = this.mapCoord;
      for (var i = 0; i < uvs.length; i += 2) {
        var x = uvs[i];
        var y = uvs[i + 1];
        out[i] = x * mat.a + y * mat.c + mat.tx;
        out[i + 1] = x * mat.b + y * mat.d + mat.ty;
      }
      return out;
    };
    TextureMatrix2.prototype.update = function(forceUpdate) {
      var tex = this._texture;
      if (!tex || !tex.valid) {
        return false;
      }
      if (!forceUpdate && this._textureID === tex._updateID) {
        return false;
      }
      this._textureID = tex._updateID;
      this._updateID++;
      var uvs = tex._uvs;
      this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
      var orig = tex.orig;
      var trim = tex.trim;
      if (trim) {
        tempMat$1.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
        this.mapCoord.append(tempMat$1);
      }
      var texBase = tex.baseTexture;
      var frame2 = this.uClampFrame;
      var margin2 = this.clampMargin / texBase.resolution;
      var offset = this.clampOffset;
      frame2[0] = (tex._frame.x + margin2 + offset) / texBase.width;
      frame2[1] = (tex._frame.y + margin2 + offset) / texBase.height;
      frame2[2] = (tex._frame.x + tex._frame.width - margin2 + offset) / texBase.width;
      frame2[3] = (tex._frame.y + tex._frame.height - margin2 + offset) / texBase.height;
      this.uClampOffset[0] = offset / texBase.realWidth;
      this.uClampOffset[1] = offset / texBase.realHeight;
      this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
      return true;
    };
    return TextureMatrix2;
  }()
);
var SpriteMaskFilter = (
  /** @class */
  function(_super) {
    __extends$i(SpriteMaskFilter2, _super);
    function SpriteMaskFilter2(vertexSrc, fragmentSrc, uniforms) {
      var _this = this;
      var sprite = null;
      if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
        sprite = vertexSrc;
        vertexSrc = void 0;
        fragmentSrc = void 0;
        uniforms = void 0;
      }
      _this = _super.call(this, vertexSrc || vertex$4, fragmentSrc || fragment$7, uniforms) || this;
      _this.maskSprite = sprite;
      _this.maskMatrix = new Matrix$1();
      return _this;
    }
    Object.defineProperty(SpriteMaskFilter2.prototype, "maskSprite", {
      /**
       * Sprite mask
       * @type {PIXI.DisplayObject}
       */
      get: function() {
        return this._maskSprite;
      },
      set: function(value) {
        this._maskSprite = value;
        if (this._maskSprite) {
          this._maskSprite.renderable = false;
        }
      },
      enumerable: false,
      configurable: true
    });
    SpriteMaskFilter2.prototype.apply = function(filterManager, input, output, clearMode) {
      var maskSprite = this._maskSprite;
      var tex = maskSprite._texture;
      if (!tex.valid) {
        return;
      }
      if (!tex.uvMatrix) {
        tex.uvMatrix = new TextureMatrix(tex, 0);
      }
      tex.uvMatrix.update();
      this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
      this.uniforms.mask = tex;
      this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
      this.uniforms.alpha = maskSprite.worldAlpha;
      this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
      filterManager.applyFilter(this, input, output, clearMode);
    };
    return SpriteMaskFilter2;
  }(Filter)
);
var MaskSystem = (
  /** @class */
  function() {
    function MaskSystem2(renderer) {
      this.renderer = renderer;
      this.enableScissor = true;
      this.alphaMaskPool = [];
      this.maskDataPool = [];
      this.maskStack = [];
      this.alphaMaskIndex = 0;
    }
    MaskSystem2.prototype.setMaskStack = function(maskStack) {
      this.maskStack = maskStack;
      this.renderer.scissor.setMaskStack(maskStack);
      this.renderer.stencil.setMaskStack(maskStack);
    };
    MaskSystem2.prototype.push = function(target, maskDataOrTarget) {
      var maskData = maskDataOrTarget;
      if (!maskData.isMaskData) {
        var d = this.maskDataPool.pop() || new MaskData();
        d.pooled = true;
        d.maskObject = maskDataOrTarget;
        maskData = d;
      }
      var maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      maskData.copyCountersOrReset(maskAbove);
      maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;
      if (maskData.autoDetect) {
        this.detect(maskData);
      }
      maskData._target = target;
      if (maskData.type !== MASK_TYPES.SPRITE) {
        this.maskStack.push(maskData);
      }
      if (maskData.enabled) {
        switch (maskData.type) {
          case MASK_TYPES.SCISSOR:
            this.renderer.scissor.push(maskData);
            break;
          case MASK_TYPES.STENCIL:
            this.renderer.stencil.push(maskData);
            break;
          case MASK_TYPES.SPRITE:
            maskData.copyCountersOrReset(null);
            this.pushSpriteMask(maskData);
            break;
          case MASK_TYPES.COLOR:
            this.pushColorMask(maskData);
            break;
        }
      }
      if (maskData.type === MASK_TYPES.SPRITE) {
        this.maskStack.push(maskData);
      }
    };
    MaskSystem2.prototype.pop = function(target) {
      var maskData = this.maskStack.pop();
      if (!maskData || maskData._target !== target) {
        return;
      }
      if (maskData.enabled) {
        switch (maskData.type) {
          case MASK_TYPES.SCISSOR:
            this.renderer.scissor.pop(maskData);
            break;
          case MASK_TYPES.STENCIL:
            this.renderer.stencil.pop(maskData.maskObject);
            break;
          case MASK_TYPES.SPRITE:
            this.popSpriteMask(maskData);
            break;
          case MASK_TYPES.COLOR:
            this.popColorMask(maskData);
            break;
        }
      }
      maskData.reset();
      if (maskData.pooled) {
        this.maskDataPool.push(maskData);
      }
      if (this.maskStack.length !== 0) {
        var maskCurrent = this.maskStack[this.maskStack.length - 1];
        if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {
          maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
        }
      }
    };
    MaskSystem2.prototype.detect = function(maskData) {
      var maskObject = maskData.maskObject;
      if (!maskObject) {
        maskData.type = MASK_TYPES.COLOR;
      } else if (maskObject.isSprite) {
        maskData.type = MASK_TYPES.SPRITE;
      } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
        maskData.type = MASK_TYPES.SCISSOR;
      } else {
        maskData.type = MASK_TYPES.STENCIL;
      }
    };
    MaskSystem2.prototype.pushSpriteMask = function(maskData) {
      var _a2, _b2;
      var maskObject = maskData.maskObject;
      var target = maskData._target;
      var alphaMaskFilter = maskData._filters;
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
        if (!alphaMaskFilter) {
          alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];
        }
      }
      var renderer = this.renderer;
      var renderTextureSystem = renderer.renderTexture;
      var resolution;
      var multisample;
      if (renderTextureSystem.current) {
        var renderTexture = renderTextureSystem.current;
        resolution = maskData.resolution || renderTexture.resolution;
        multisample = (_a2 = maskData.multisample) !== null && _a2 !== void 0 ? _a2 : renderTexture.multisample;
      } else {
        resolution = maskData.resolution || renderer.resolution;
        multisample = (_b2 = maskData.multisample) !== null && _b2 !== void 0 ? _b2 : renderer.multisample;
      }
      alphaMaskFilter[0].resolution = resolution;
      alphaMaskFilter[0].multisample = multisample;
      alphaMaskFilter[0].maskSprite = maskObject;
      var stashFilterArea = target.filterArea;
      target.filterArea = maskObject.getBounds(true);
      renderer.filter.push(target, alphaMaskFilter);
      target.filterArea = stashFilterArea;
      if (!maskData._filters) {
        this.alphaMaskIndex++;
      }
    };
    MaskSystem2.prototype.popSpriteMask = function(maskData) {
      this.renderer.filter.pop();
      if (maskData._filters) {
        maskData._filters[0].maskSprite = null;
      } else {
        this.alphaMaskIndex--;
        this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
      }
    };
    MaskSystem2.prototype.pushColorMask = function(maskData) {
      var currColorMask = maskData._colorMask;
      var nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
      if (nextColorMask !== currColorMask) {
        this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
      }
    };
    MaskSystem2.prototype.popColorMask = function(maskData) {
      var currColorMask = maskData._colorMask;
      var nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
      if (nextColorMask !== currColorMask) {
        this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
      }
    };
    MaskSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return MaskSystem2;
  }()
);
var AbstractMaskSystem = (
  /** @class */
  function() {
    function AbstractMaskSystem2(renderer) {
      this.renderer = renderer;
      this.maskStack = [];
      this.glConst = 0;
    }
    AbstractMaskSystem2.prototype.getStackLength = function() {
      return this.maskStack.length;
    };
    AbstractMaskSystem2.prototype.setMaskStack = function(maskStack) {
      var gl = this.renderer.gl;
      var curStackLen = this.getStackLength();
      this.maskStack = maskStack;
      var newStackLen = this.getStackLength();
      if (newStackLen !== curStackLen) {
        if (newStackLen === 0) {
          gl.disable(this.glConst);
        } else {
          gl.enable(this.glConst);
          this._useCurrent();
        }
      }
    };
    AbstractMaskSystem2.prototype._useCurrent = function() {
    };
    AbstractMaskSystem2.prototype.destroy = function() {
      this.renderer = null;
      this.maskStack = null;
    };
    return AbstractMaskSystem2;
  }()
);
var tempMatrix$1 = new Matrix$1();
var rectPool = [];
var ScissorSystem = (
  /** @class */
  function(_super) {
    __extends$i(ScissorSystem2, _super);
    function ScissorSystem2(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
      return _this;
    }
    ScissorSystem2.prototype.getStackLength = function() {
      var maskData = this.maskStack[this.maskStack.length - 1];
      if (maskData) {
        return maskData._scissorCounter;
      }
      return 0;
    };
    ScissorSystem2.prototype.calcScissorRect = function(maskData) {
      var _a2;
      if (maskData._scissorRectLocal) {
        return;
      }
      var prevData = maskData._scissorRect;
      var maskObject = maskData.maskObject;
      var renderer = this.renderer;
      var renderTextureSystem = renderer.renderTexture;
      var rect = maskObject.getBounds(true, (_a2 = rectPool.pop()) !== null && _a2 !== void 0 ? _a2 : new Rectangle());
      this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
      if (prevData) {
        rect.fit(prevData);
      }
      maskData._scissorRectLocal = rect;
    };
    ScissorSystem2.isMatrixRotated = function(matrix2) {
      if (!matrix2) {
        return false;
      }
      var a = matrix2.a, b = matrix2.b, c2 = matrix2.c, d = matrix2.d;
      return (Math.abs(b) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);
    };
    ScissorSystem2.prototype.testScissor = function(maskData) {
      var maskObject = maskData.maskObject;
      if (!maskObject.isFastRect || !maskObject.isFastRect()) {
        return false;
      }
      if (ScissorSystem2.isMatrixRotated(maskObject.worldTransform)) {
        return false;
      }
      if (ScissorSystem2.isMatrixRotated(this.renderer.projection.transform)) {
        return false;
      }
      this.calcScissorRect(maskData);
      var rect = maskData._scissorRectLocal;
      return rect.width > 0 && rect.height > 0;
    };
    ScissorSystem2.prototype.roundFrameToPixels = function(frame2, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
      if (ScissorSystem2.isMatrixRotated(transform)) {
        return;
      }
      transform = transform ? tempMatrix$1.copyFrom(transform) : tempMatrix$1.identity();
      transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
      this.renderer.filter.transformAABB(transform, frame2);
      frame2.fit(bindingDestinationFrame);
      frame2.x = Math.round(frame2.x * resolution);
      frame2.y = Math.round(frame2.y * resolution);
      frame2.width = Math.round(frame2.width * resolution);
      frame2.height = Math.round(frame2.height * resolution);
    };
    ScissorSystem2.prototype.push = function(maskData) {
      if (!maskData._scissorRectLocal) {
        this.calcScissorRect(maskData);
      }
      var gl = this.renderer.gl;
      if (!maskData._scissorRect) {
        gl.enable(gl.SCISSOR_TEST);
      }
      maskData._scissorCounter++;
      maskData._scissorRect = maskData._scissorRectLocal;
      this._useCurrent();
    };
    ScissorSystem2.prototype.pop = function(maskData) {
      var gl = this.renderer.gl;
      if (maskData) {
        rectPool.push(maskData._scissorRectLocal);
      }
      if (this.getStackLength() > 0) {
        this._useCurrent();
      } else {
        gl.disable(gl.SCISSOR_TEST);
      }
    };
    ScissorSystem2.prototype._useCurrent = function() {
      var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
      var y;
      if (this.renderer.renderTexture.current) {
        y = rect.y;
      } else {
        y = this.renderer.height - rect.height - rect.y;
      }
      this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);
    };
    return ScissorSystem2;
  }(AbstractMaskSystem)
);
var StencilSystem = (
  /** @class */
  function(_super) {
    __extends$i(StencilSystem2, _super);
    function StencilSystem2(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
      return _this;
    }
    StencilSystem2.prototype.getStackLength = function() {
      var maskData = this.maskStack[this.maskStack.length - 1];
      if (maskData) {
        return maskData._stencilCounter;
      }
      return 0;
    };
    StencilSystem2.prototype.push = function(maskData) {
      var maskObject = maskData.maskObject;
      var gl = this.renderer.gl;
      var prevMaskCount = maskData._stencilCounter;
      if (prevMaskCount === 0) {
        this.renderer.framebuffer.forceStencil();
        gl.clearStencil(0);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        gl.enable(gl.STENCIL_TEST);
      }
      maskData._stencilCounter++;
      var colorMask = maskData._colorMask;
      if (colorMask !== 0) {
        maskData._colorMask = 0;
        gl.colorMask(false, false, false, false);
      }
      gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      if (colorMask !== 0) {
        maskData._colorMask = colorMask;
        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
      }
      this._useCurrent();
    };
    StencilSystem2.prototype.pop = function(maskObject) {
      var gl = this.renderer.gl;
      if (this.getStackLength() === 0) {
        gl.disable(gl.STENCIL_TEST);
      } else {
        var maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        var colorMask = maskData ? maskData._colorMask : 15;
        if (colorMask !== 0) {
          maskData._colorMask = 0;
          gl.colorMask(false, false, false, false);
        }
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
        maskObject.renderable = true;
        maskObject.render(this.renderer);
        this.renderer.batch.flush();
        maskObject.renderable = false;
        if (colorMask !== 0) {
          maskData._colorMask = colorMask;
          gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
        }
        this._useCurrent();
      }
    };
    StencilSystem2.prototype._useCurrent = function() {
      var gl = this.renderer.gl;
      gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    };
    return StencilSystem2;
  }(AbstractMaskSystem)
);
var ProjectionSystem = (
  /** @class */
  function() {
    function ProjectionSystem2(renderer) {
      this.renderer = renderer;
      this.destinationFrame = null;
      this.sourceFrame = null;
      this.defaultFrame = null;
      this.projectionMatrix = new Matrix$1();
      this.transform = null;
    }
    ProjectionSystem2.prototype.update = function(destinationFrame, sourceFrame, resolution, root2) {
      this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
      this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
      this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root2);
      if (this.transform) {
        this.projectionMatrix.append(this.transform);
      }
      var renderer = this.renderer;
      renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
      renderer.globalUniforms.update();
      if (renderer.shader.shader) {
        renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
      }
    };
    ProjectionSystem2.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root2) {
      var pm = this.projectionMatrix;
      var sign3 = !root2 ? 1 : -1;
      pm.identity();
      pm.a = 1 / sourceFrame.width * 2;
      pm.d = sign3 * (1 / sourceFrame.height * 2);
      pm.tx = -1 - sourceFrame.x * pm.a;
      pm.ty = -sign3 - sourceFrame.y * pm.d;
    };
    ProjectionSystem2.prototype.setTransform = function(_matrix) {
    };
    ProjectionSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return ProjectionSystem2;
  }()
);
var tempRect = new Rectangle();
var tempRect2 = new Rectangle();
var RenderTextureSystem = (
  /** @class */
  function() {
    function RenderTextureSystem2(renderer) {
      this.renderer = renderer;
      this.clearColor = renderer._backgroundColorRgba;
      this.defaultMaskStack = [];
      this.current = null;
      this.sourceFrame = new Rectangle();
      this.destinationFrame = new Rectangle();
      this.viewportFrame = new Rectangle();
    }
    RenderTextureSystem2.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
      if (renderTexture === void 0) {
        renderTexture = null;
      }
      var renderer = this.renderer;
      this.current = renderTexture;
      var baseTexture;
      var framebuffer;
      var resolution;
      if (renderTexture) {
        baseTexture = renderTexture.baseTexture;
        resolution = baseTexture.resolution;
        if (!sourceFrame) {
          tempRect.width = renderTexture.frame.width;
          tempRect.height = renderTexture.frame.height;
          sourceFrame = tempRect;
        }
        if (!destinationFrame) {
          tempRect2.x = renderTexture.frame.x;
          tempRect2.y = renderTexture.frame.y;
          tempRect2.width = sourceFrame.width;
          tempRect2.height = sourceFrame.height;
          destinationFrame = tempRect2;
        }
        framebuffer = baseTexture.framebuffer;
      } else {
        resolution = renderer.resolution;
        if (!sourceFrame) {
          tempRect.width = renderer.screen.width;
          tempRect.height = renderer.screen.height;
          sourceFrame = tempRect;
        }
        if (!destinationFrame) {
          destinationFrame = tempRect;
          destinationFrame.width = sourceFrame.width;
          destinationFrame.height = sourceFrame.height;
        }
      }
      var viewportFrame = this.viewportFrame;
      viewportFrame.x = destinationFrame.x * resolution;
      viewportFrame.y = destinationFrame.y * resolution;
      viewportFrame.width = destinationFrame.width * resolution;
      viewportFrame.height = destinationFrame.height * resolution;
      if (!renderTexture) {
        viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
      }
      viewportFrame.ceil();
      this.renderer.framebuffer.bind(framebuffer, viewportFrame);
      this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
      if (renderTexture) {
        this.renderer.mask.setMaskStack(baseTexture.maskStack);
      } else {
        this.renderer.mask.setMaskStack(this.defaultMaskStack);
      }
      this.sourceFrame.copyFrom(sourceFrame);
      this.destinationFrame.copyFrom(destinationFrame);
    };
    RenderTextureSystem2.prototype.clear = function(clearColor, mask) {
      if (this.current) {
        clearColor = clearColor || this.current.baseTexture.clearColor;
      } else {
        clearColor = clearColor || this.clearColor;
      }
      var destinationFrame = this.destinationFrame;
      var baseFrame = this.current ? this.current.baseTexture : this.renderer.screen;
      var clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
      if (clearMask) {
        var _a2 = this.viewportFrame, x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
        x = Math.round(x);
        y = Math.round(y);
        width = Math.round(width);
        height = Math.round(height);
        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
        this.renderer.gl.scissor(x, y, width, height);
      }
      this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
      if (clearMask) {
        this.renderer.scissor.pop();
      }
    };
    RenderTextureSystem2.prototype.resize = function() {
      this.bind(null);
    };
    RenderTextureSystem2.prototype.reset = function() {
      this.bind(null);
    };
    RenderTextureSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return RenderTextureSystem2;
  }()
);
function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
  _renderer.buffer.update(buffer);
}
var UBO_TO_SINGLE_SETTERS = {
  float: "\n        data[offset] = v;\n    ",
  vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
  vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
  vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
  mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
  mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
  mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "
};
var GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  var uboElements = uniformData.map(function(data) {
    return {
      data,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  });
  var size2 = 0;
  var chunkSize = 0;
  var offset = 0;
  for (var i = 0; i < uboElements.length; i++) {
    var uboElement = uboElements[i];
    size2 = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size2 = Math.max(size2, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size2;
    if (chunkSize % size2 !== 0 && chunkSize < 16) {
      var lineUpValue = chunkSize % size2 % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size2 > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size2;
      chunkSize = size2;
    } else {
      uboElement.offset = offset;
      chunkSize += size2;
      offset += size2;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  var usedUniformDatas = [];
  for (var i in uniforms) {
    if (uniformData[i]) {
      usedUniformDatas.push(uniformData[i]);
    }
  }
  usedUniformDatas.sort(function(a, b) {
    return a.index - b.index;
  });
  return usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage) {
    return { size: 0, syncFunc: uboUpdate };
  }
  var usedUniformDatas = getUBOData(group.uniforms, uniformData);
  var _a2 = createUBOElements(usedUniformDatas), uboElements = _a2.uboElements, size2 = _a2.size;
  var funcFragments = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "];
  for (var i = 0; i < uboElements.length; i++) {
    var uboElement = uboElements[i];
    var uniform = group.uniforms[uboElement.data.name];
    var name2 = uboElement.data.name;
    var parsed = false;
    for (var j = 0; j < uniformParsers.length; j++) {
      var uniformParser = uniformParsers[j];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push("offset = " + uboElement.offset / 4 + ";", uniformParsers[j].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        var size_1 = mapSize(uboElement.data.type);
        var rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        var elementSize = size_1 / rowSize;
        var remainder = (4 - elementSize % 4) % 4;
        funcFragments.push("\n                cv = ud." + name2 + ".value;\n                v = uv." + name2 + ";\n                offset = " + uboElement.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + uboElement.data.size * rowSize + "; i++)\n                {\n                    for(var j = 0; j < " + elementSize + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + remainder + ";\n                }\n\n                ");
      } else {
        var template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push("\n                cv = ud." + name2 + ".value;\n                v = uv." + name2 + ";\n                offset = " + uboElement.offset / 4 + ";\n                " + template + ";\n                ");
      }
    }
  }
  funcFragments.push("\n       renderer.buffer.update(buffer);\n    ");
  return {
    size: size2,
    // eslint-disable-next-line no-new-func
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
}
var GLProgram = (
  /** @class */
  function() {
    function GLProgram2(program, uniformData) {
      this.program = program;
      this.uniformData = uniformData;
      this.uniformGroups = {};
      this.uniformDirtyGroups = {};
      this.uniformBufferBindings = {};
    }
    GLProgram2.prototype.destroy = function() {
      this.uniformData = null;
      this.uniformGroups = null;
      this.uniformDirtyGroups = null;
      this.uniformBufferBindings = null;
      this.program = null;
    };
    return GLProgram2;
  }()
);
function getAttributeData(program, gl) {
  var attributes = {};
  var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < totalAttributes; i++) {
    var attribData = gl.getActiveAttrib(program, i);
    if (attribData.name.indexOf("gl_") === 0) {
      continue;
    }
    var type2 = mapType(gl, attribData.type);
    var data = {
      type: type2,
      name: attribData.name,
      size: mapSize(type2),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}
function getUniformData(program, gl) {
  var uniforms = {};
  var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (var i = 0; i < totalUniforms; i++) {
    var uniformData = gl.getActiveUniform(program, i);
    var name2 = uniformData.name.replace(/\[.*?\]$/, "");
    var isArray2 = !!uniformData.name.match(/\[.*?\]$/);
    var type2 = mapType(gl, uniformData.type);
    uniforms[name2] = {
      name: name2,
      index: i,
      type: type2,
      size: uniformData.size,
      isArray: isArray2,
      value: defaultValue(type2, uniformData.size)
    };
  }
  return uniforms;
}
function generateProgram(gl, program) {
  var glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
  var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  var webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    var keys = Object.keys(program.attributeData);
    keys.sort(function(a, b) {
      return a > b ? 1 : -1;
    });
    for (var i = 0; i < keys.length; i++) {
      program.attributeData[keys[i]].location = i;
      gl.bindAttribLocation(webGLProgram, i, keys[i]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  var uniformData = {};
  for (var i in program.uniformData) {
    var data = program.uniformData[i];
    uniformData[i] = {
      location: gl.getUniformLocation(webGLProgram, i),
      value: defaultValue(data.type, data.size)
    };
  }
  var glProgram = new GLProgram(webGLProgram, uniformData);
  return glProgram;
}
var UID = 0;
var defaultSyncData = { textureCount: 0, uboCount: 0 };
var ShaderSystem = (
  /** @class */
  function() {
    function ShaderSystem2(renderer) {
      this.destroyed = false;
      this.renderer = renderer;
      this.systemCheck();
      this.gl = null;
      this.shader = null;
      this.program = null;
      this.cache = {};
      this._uboCache = {};
      this.id = UID++;
    }
    ShaderSystem2.prototype.systemCheck = function() {
      if (!unsafeEvalSupported()) {
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
      }
    };
    ShaderSystem2.prototype.contextChange = function(gl) {
      this.gl = gl;
      this.reset();
    };
    ShaderSystem2.prototype.bind = function(shader, dontSync) {
      shader.disposeRunner.add(this);
      shader.uniforms.globals = this.renderer.globalUniforms;
      var program = shader.program;
      var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
      this.shader = shader;
      if (this.program !== program) {
        this.program = program;
        this.gl.useProgram(glProgram.program);
      }
      if (!dontSync) {
        defaultSyncData.textureCount = 0;
        defaultSyncData.uboCount = 0;
        this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
      }
      return glProgram;
    };
    ShaderSystem2.prototype.setUniforms = function(uniforms) {
      var shader = this.shader.program;
      var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
      shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
    };
    ShaderSystem2.prototype.syncUniformGroup = function(group, syncData) {
      var glProgram = this.getGlProgram();
      if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
        glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
        this.syncUniforms(group, glProgram, syncData);
      }
    };
    ShaderSystem2.prototype.syncUniforms = function(group, glProgram, syncData) {
      var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
    };
    ShaderSystem2.prototype.createSyncGroups = function(group) {
      var id2 = this.getSignature(group, this.shader.program.uniformData, "u");
      if (!this.cache[id2]) {
        this.cache[id2] = generateUniformsSync(group, this.shader.program.uniformData);
      }
      group.syncUniforms[this.shader.program.id] = this.cache[id2];
      return group.syncUniforms[this.shader.program.id];
    };
    ShaderSystem2.prototype.syncUniformBufferGroup = function(group, name2) {
      var glProgram = this.getGlProgram();
      if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
        group.dirtyId = 0;
        var syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name2);
        group.buffer.update();
        syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
      }
      this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name2]);
    };
    ShaderSystem2.prototype.createSyncBufferGroup = function(group, glProgram, name2) {
      var gl = this.renderer.gl;
      this.renderer.buffer.bind(group.buffer);
      var uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name2);
      glProgram.uniformBufferBindings[name2] = this.shader.uniformBindCount;
      gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
      this.shader.uniformBindCount++;
      var id2 = this.getSignature(group, this.shader.program.uniformData, "ubo");
      var uboData = this._uboCache[id2];
      if (!uboData) {
        uboData = this._uboCache[id2] = generateUniformBufferSync(group, this.shader.program.uniformData);
      }
      if (group.autoManage) {
        var data = new Float32Array(uboData.size / 4);
        group.buffer.update(data);
      }
      glProgram.uniformGroups[group.id] = uboData.syncFunc;
      return glProgram.uniformGroups[group.id];
    };
    ShaderSystem2.prototype.getSignature = function(group, uniformData, preFix) {
      var uniforms = group.uniforms;
      var strings = [preFix + "-"];
      for (var i in uniforms) {
        strings.push(i);
        if (uniformData[i]) {
          strings.push(uniformData[i].type);
        }
      }
      return strings.join("-");
    };
    ShaderSystem2.prototype.getGlProgram = function() {
      if (this.shader) {
        return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
      }
      return null;
    };
    ShaderSystem2.prototype.generateProgram = function(shader) {
      var gl = this.gl;
      var program = shader.program;
      var glProgram = generateProgram(gl, program);
      program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
      return glProgram;
    };
    ShaderSystem2.prototype.reset = function() {
      this.program = null;
      this.shader = null;
    };
    ShaderSystem2.prototype.disposeShader = function(shader) {
      if (this.shader === shader) {
        this.shader = null;
      }
    };
    ShaderSystem2.prototype.destroy = function() {
      this.renderer = null;
      this.destroyed = true;
    };
    return ShaderSystem2;
  }()
);
function mapWebGLBlendModesToPixi(gl, array2) {
  if (array2 === void 0) {
    array2 = [];
  }
  array2[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
  array2[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.NONE] = [0, 0];
  array2[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array2[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array2[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array2[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array2[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array2[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array2[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array2;
}
var BLEND = 0;
var OFFSET = 1;
var CULLING = 2;
var DEPTH_TEST = 3;
var WINDING = 4;
var DEPTH_MASK = 5;
var StateSystem = (
  /** @class */
  function() {
    function StateSystem2() {
      this.gl = null;
      this.stateId = 0;
      this.polygonOffset = 0;
      this.blendMode = BLEND_MODES.NONE;
      this._blendEq = false;
      this.map = [];
      this.map[BLEND] = this.setBlend;
      this.map[OFFSET] = this.setOffset;
      this.map[CULLING] = this.setCullFace;
      this.map[DEPTH_TEST] = this.setDepthTest;
      this.map[WINDING] = this.setFrontFace;
      this.map[DEPTH_MASK] = this.setDepthMask;
      this.checks = [];
      this.defaultState = new State();
      this.defaultState.blend = true;
    }
    StateSystem2.prototype.contextChange = function(gl) {
      this.gl = gl;
      this.blendModes = mapWebGLBlendModesToPixi(gl);
      this.set(this.defaultState);
      this.reset();
    };
    StateSystem2.prototype.set = function(state) {
      state = state || this.defaultState;
      if (this.stateId !== state.data) {
        var diff = this.stateId ^ state.data;
        var i = 0;
        while (diff) {
          if (diff & 1) {
            this.map[i].call(this, !!(state.data & 1 << i));
          }
          diff = diff >> 1;
          i++;
        }
        this.stateId = state.data;
      }
      for (var i = 0; i < this.checks.length; i++) {
        this.checks[i](this, state);
      }
    };
    StateSystem2.prototype.forceState = function(state) {
      state = state || this.defaultState;
      for (var i = 0; i < this.map.length; i++) {
        this.map[i].call(this, !!(state.data & 1 << i));
      }
      for (var i = 0; i < this.checks.length; i++) {
        this.checks[i](this, state);
      }
      this.stateId = state.data;
    };
    StateSystem2.prototype.setBlend = function(value) {
      this.updateCheck(StateSystem2.checkBlendMode, value);
      this.gl[value ? "enable" : "disable"](this.gl.BLEND);
    };
    StateSystem2.prototype.setOffset = function(value) {
      this.updateCheck(StateSystem2.checkPolygonOffset, value);
      this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    };
    StateSystem2.prototype.setDepthTest = function(value) {
      this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
    };
    StateSystem2.prototype.setDepthMask = function(value) {
      this.gl.depthMask(value);
    };
    StateSystem2.prototype.setCullFace = function(value) {
      this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
    };
    StateSystem2.prototype.setFrontFace = function(value) {
      this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
    };
    StateSystem2.prototype.setBlendMode = function(value) {
      if (value === this.blendMode) {
        return;
      }
      this.blendMode = value;
      var mode = this.blendModes[value];
      var gl = this.gl;
      if (mode.length === 2) {
        gl.blendFunc(mode[0], mode[1]);
      } else {
        gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
      }
      if (mode.length === 6) {
        this._blendEq = true;
        gl.blendEquationSeparate(mode[4], mode[5]);
      } else if (this._blendEq) {
        this._blendEq = false;
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      }
    };
    StateSystem2.prototype.setPolygonOffset = function(value, scale) {
      this.gl.polygonOffset(value, scale);
    };
    StateSystem2.prototype.reset = function() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
      this.forceState(this.defaultState);
      this._blendEq = true;
      this.blendMode = -1;
      this.setBlendMode(0);
    };
    StateSystem2.prototype.updateCheck = function(func2, value) {
      var index = this.checks.indexOf(func2);
      if (value && index === -1) {
        this.checks.push(func2);
      } else if (!value && index !== -1) {
        this.checks.splice(index, 1);
      }
    };
    StateSystem2.checkBlendMode = function(system, state) {
      system.setBlendMode(state.blendMode);
    };
    StateSystem2.checkPolygonOffset = function(system, state) {
      system.setPolygonOffset(1, state.polygonOffset);
    };
    StateSystem2.prototype.destroy = function() {
      this.gl = null;
    };
    return StateSystem2;
  }()
);
var TextureGCSystem = (
  /** @class */
  function() {
    function TextureGCSystem2(renderer) {
      this.renderer = renderer;
      this.count = 0;
      this.checkCount = 0;
      this.maxIdle = settings.GC_MAX_IDLE;
      this.checkCountMax = settings.GC_MAX_CHECK_COUNT;
      this.mode = settings.GC_MODE;
    }
    TextureGCSystem2.prototype.postrender = function() {
      if (!this.renderer.renderingToScreen) {
        return;
      }
      this.count++;
      if (this.mode === GC_MODES.MANUAL) {
        return;
      }
      this.checkCount++;
      if (this.checkCount > this.checkCountMax) {
        this.checkCount = 0;
        this.run();
      }
    };
    TextureGCSystem2.prototype.run = function() {
      var tm = this.renderer.texture;
      var managedTextures = tm.managedTextures;
      var wasRemoved = false;
      for (var i = 0; i < managedTextures.length; i++) {
        var texture = managedTextures[i];
        if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
          tm.destroyTexture(texture, true);
          managedTextures[i] = null;
          wasRemoved = true;
        }
      }
      if (wasRemoved) {
        var j = 0;
        for (var i = 0; i < managedTextures.length; i++) {
          if (managedTextures[i] !== null) {
            managedTextures[j++] = managedTextures[i];
          }
        }
        managedTextures.length = j;
      }
    };
    TextureGCSystem2.prototype.unload = function(displayObject) {
      var tm = this.renderer.texture;
      var texture = displayObject._texture;
      if (texture && !texture.framebuffer) {
        tm.destroyTexture(texture);
      }
      for (var i = displayObject.children.length - 1; i >= 0; i--) {
        this.unload(displayObject.children[i]);
      }
    };
    TextureGCSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return TextureGCSystem2;
  }()
);
function mapTypeAndFormatToInternalFormat(gl) {
  var _a2, _b2, _c2, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
  var table;
  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
    table = (_a2 = {}, _a2[TYPES.UNSIGNED_BYTE] = (_b2 = {}, _b2[FORMATS.RGBA] = gl.RGBA8, _b2[FORMATS.RGB] = gl.RGB8, _b2[FORMATS.RG] = gl.RG8, _b2[FORMATS.RED] = gl.R8, _b2[FORMATS.RGBA_INTEGER] = gl.RGBA8UI, _b2[FORMATS.RGB_INTEGER] = gl.RGB8UI, _b2[FORMATS.RG_INTEGER] = gl.RG8UI, _b2[FORMATS.RED_INTEGER] = gl.R8UI, _b2[FORMATS.ALPHA] = gl.ALPHA, _b2[FORMATS.LUMINANCE] = gl.LUMINANCE, _b2[FORMATS.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _b2), _a2[TYPES.BYTE] = (_c2 = {}, _c2[FORMATS.RGBA] = gl.RGBA8_SNORM, _c2[FORMATS.RGB] = gl.RGB8_SNORM, _c2[FORMATS.RG] = gl.RG8_SNORM, _c2[FORMATS.RED] = gl.R8_SNORM, _c2[FORMATS.RGBA_INTEGER] = gl.RGBA8I, _c2[FORMATS.RGB_INTEGER] = gl.RGB8I, _c2[FORMATS.RG_INTEGER] = gl.RG8I, _c2[FORMATS.RED_INTEGER] = gl.R8I, _c2), _a2[TYPES.UNSIGNED_SHORT] = (_d = {}, _d[FORMATS.RGBA_INTEGER] = gl.RGBA16UI, _d[FORMATS.RGB_INTEGER] = gl.RGB16UI, _d[FORMATS.RG_INTEGER] = gl.RG16UI, _d[FORMATS.RED_INTEGER] = gl.R16UI, _d[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT16, _d), _a2[TYPES.SHORT] = (_e = {}, _e[FORMATS.RGBA_INTEGER] = gl.RGBA16I, _e[FORMATS.RGB_INTEGER] = gl.RGB16I, _e[FORMATS.RG_INTEGER] = gl.RG16I, _e[FORMATS.RED_INTEGER] = gl.R16I, _e), _a2[TYPES.UNSIGNED_INT] = (_f = {}, _f[FORMATS.RGBA_INTEGER] = gl.RGBA32UI, _f[FORMATS.RGB_INTEGER] = gl.RGB32UI, _f[FORMATS.RG_INTEGER] = gl.RG32UI, _f[FORMATS.RED_INTEGER] = gl.R32UI, _f[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT24, _f), _a2[TYPES.INT] = (_g = {}, _g[FORMATS.RGBA_INTEGER] = gl.RGBA32I, _g[FORMATS.RGB_INTEGER] = gl.RGB32I, _g[FORMATS.RG_INTEGER] = gl.RG32I, _g[FORMATS.RED_INTEGER] = gl.R32I, _g), _a2[TYPES.FLOAT] = (_h = {}, _h[FORMATS.RGBA] = gl.RGBA32F, _h[FORMATS.RGB] = gl.RGB32F, _h[FORMATS.RG] = gl.RG32F, _h[FORMATS.RED] = gl.R32F, _h[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT32F, _h), _a2[TYPES.HALF_FLOAT] = (_j = {}, _j[FORMATS.RGBA] = gl.RGBA16F, _j[FORMATS.RGB] = gl.RGB16F, _j[FORMATS.RG] = gl.RG16F, _j[FORMATS.RED] = gl.R16F, _j), _a2[TYPES.UNSIGNED_SHORT_5_6_5] = (_k = {}, _k[FORMATS.RGB] = gl.RGB565, _k), _a2[TYPES.UNSIGNED_SHORT_4_4_4_4] = (_l = {}, _l[FORMATS.RGBA] = gl.RGBA4, _l), _a2[TYPES.UNSIGNED_SHORT_5_5_5_1] = (_m = {}, _m[FORMATS.RGBA] = gl.RGB5_A1, _m), _a2[TYPES.UNSIGNED_INT_2_10_10_10_REV] = (_o = {}, _o[FORMATS.RGBA] = gl.RGB10_A2, _o[FORMATS.RGBA_INTEGER] = gl.RGB10_A2UI, _o), _a2[TYPES.UNSIGNED_INT_10F_11F_11F_REV] = (_p = {}, _p[FORMATS.RGB] = gl.R11F_G11F_B10F, _p), _a2[TYPES.UNSIGNED_INT_5_9_9_9_REV] = (_q = {}, _q[FORMATS.RGB] = gl.RGB9_E5, _q), _a2[TYPES.UNSIGNED_INT_24_8] = (_r = {}, _r[FORMATS.DEPTH_STENCIL] = gl.DEPTH24_STENCIL8, _r), _a2[TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV] = (_s = {}, _s[FORMATS.DEPTH_STENCIL] = gl.DEPTH32F_STENCIL8, _s), _a2);
  } else {
    table = (_t = {}, _t[TYPES.UNSIGNED_BYTE] = (_u = {}, _u[FORMATS.RGBA] = gl.RGBA, _u[FORMATS.RGB] = gl.RGB, _u[FORMATS.ALPHA] = gl.ALPHA, _u[FORMATS.LUMINANCE] = gl.LUMINANCE, _u[FORMATS.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _u), _t[TYPES.UNSIGNED_SHORT_5_6_5] = (_v = {}, _v[FORMATS.RGB] = gl.RGB, _v), _t[TYPES.UNSIGNED_SHORT_4_4_4_4] = (_w = {}, _w[FORMATS.RGBA] = gl.RGBA, _w), _t[TYPES.UNSIGNED_SHORT_5_5_5_1] = (_x = {}, _x[FORMATS.RGBA] = gl.RGBA, _x), _t);
  }
  return table;
}
var GLTexture = (
  /** @class */
  /* @__PURE__ */ function() {
    function GLTexture2(texture) {
      this.texture = texture;
      this.width = -1;
      this.height = -1;
      this.dirtyId = -1;
      this.dirtyStyleId = -1;
      this.mipmap = false;
      this.wrapMode = 33071;
      this.type = TYPES.UNSIGNED_BYTE;
      this.internalFormat = FORMATS.RGBA;
      this.samplerType = 0;
    }
    return GLTexture2;
  }()
);
var TextureSystem = (
  /** @class */
  function() {
    function TextureSystem2(renderer) {
      this.renderer = renderer;
      this.boundTextures = [];
      this.currentLocation = -1;
      this.managedTextures = [];
      this._unknownBoundTextures = false;
      this.unknownTexture = new BaseTexture();
      this.hasIntegerTextures = false;
    }
    TextureSystem2.prototype.contextChange = function() {
      var gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.webGLVersion = this.renderer.context.webGLVersion;
      this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
      var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = maxTextures;
      for (var i = 0; i < maxTextures; i++) {
        this.boundTextures[i] = null;
      }
      this.emptyTextures = {};
      var emptyTexture2D = new GLTexture(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
      this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
      this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
      for (var i = 0; i < 6; i++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      for (var i = 0; i < this.boundTextures.length; i++) {
        this.bind(null, i);
      }
    };
    TextureSystem2.prototype.bind = function(texture, location) {
      if (location === void 0) {
        location = 0;
      }
      var gl = this.gl;
      texture = texture === null || texture === void 0 ? void 0 : texture.castToBaseTexture();
      if (texture && texture.valid && !texture.parentTextureArray) {
        texture.touched = this.renderer.textureGC.count;
        var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
        if (this.boundTextures[location] !== texture) {
          if (this.currentLocation !== location) {
            this.currentLocation = location;
            gl.activeTexture(gl.TEXTURE0 + location);
          }
          gl.bindTexture(texture.target, glTexture.texture);
        }
        if (glTexture.dirtyId !== texture.dirtyId) {
          if (this.currentLocation !== location) {
            this.currentLocation = location;
            gl.activeTexture(gl.TEXTURE0 + location);
          }
          this.updateTexture(texture);
        } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {
          this.updateTextureStyle(texture);
        }
        this.boundTextures[location] = texture;
      } else {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
        this.boundTextures[location] = null;
      }
    };
    TextureSystem2.prototype.reset = function() {
      this._unknownBoundTextures = true;
      this.hasIntegerTextures = false;
      this.currentLocation = -1;
      for (var i = 0; i < this.boundTextures.length; i++) {
        this.boundTextures[i] = this.unknownTexture;
      }
    };
    TextureSystem2.prototype.unbind = function(texture) {
      var _a2 = this, gl = _a2.gl, boundTextures = _a2.boundTextures;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = false;
        for (var i = 0; i < boundTextures.length; i++) {
          if (boundTextures[i] === this.unknownTexture) {
            this.bind(null, i);
          }
        }
      }
      for (var i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === texture) {
          if (this.currentLocation !== i) {
            gl.activeTexture(gl.TEXTURE0 + i);
            this.currentLocation = i;
          }
          gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
          boundTextures[i] = null;
        }
      }
    };
    TextureSystem2.prototype.ensureSamplerType = function(maxTextures) {
      var _a2 = this, boundTextures = _a2.boundTextures, hasIntegerTextures = _a2.hasIntegerTextures, CONTEXT_UID = _a2.CONTEXT_UID;
      if (!hasIntegerTextures) {
        return;
      }
      for (var i = maxTextures - 1; i >= 0; --i) {
        var tex = boundTextures[i];
        if (tex) {
          var glTexture = tex._glTextures[CONTEXT_UID];
          if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
            this.renderer.texture.unbind(tex);
          }
        }
      }
    };
    TextureSystem2.prototype.initTexture = function(texture) {
      var glTexture = new GLTexture(this.gl.createTexture());
      glTexture.dirtyId = -1;
      texture._glTextures[this.CONTEXT_UID] = glTexture;
      this.managedTextures.push(texture);
      texture.on("dispose", this.destroyTexture, this);
      return glTexture;
    };
    TextureSystem2.prototype.initTextureType = function(texture, glTexture) {
      var _a2, _b2;
      glTexture.internalFormat = (_b2 = (_a2 = this.internalFormats[texture.type]) === null || _a2 === void 0 ? void 0 : _a2[texture.format]) !== null && _b2 !== void 0 ? _b2 : texture.format;
      if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {
        glTexture.type = this.gl.HALF_FLOAT;
      } else {
        glTexture.type = texture.type;
      }
    };
    TextureSystem2.prototype.updateTexture = function(texture) {
      var glTexture = texture._glTextures[this.CONTEXT_UID];
      if (!glTexture) {
        return;
      }
      var renderer = this.renderer;
      this.initTextureType(texture, glTexture);
      if (texture.resource && texture.resource.upload(renderer, texture, glTexture)) {
        if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
          this.hasIntegerTextures = true;
        }
      } else {
        var width = texture.realWidth;
        var height = texture.realHeight;
        var gl = renderer.gl;
        if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
        }
      }
      if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      glTexture.dirtyId = texture.dirtyId;
    };
    TextureSystem2.prototype.destroyTexture = function(texture, skipRemove) {
      var gl = this.gl;
      texture = texture.castToBaseTexture();
      if (texture._glTextures[this.CONTEXT_UID]) {
        this.unbind(texture);
        gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
        texture.off("dispose", this.destroyTexture, this);
        delete texture._glTextures[this.CONTEXT_UID];
        if (!skipRemove) {
          var i = this.managedTextures.indexOf(texture);
          if (i !== -1) {
            removeItems(this.managedTextures, i, 1);
          }
        }
      }
    };
    TextureSystem2.prototype.updateTextureStyle = function(texture) {
      var glTexture = texture._glTextures[this.CONTEXT_UID];
      if (!glTexture) {
        return;
      }
      if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
        glTexture.mipmap = false;
      } else {
        glTexture.mipmap = texture.mipmap >= 1;
      }
      if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
        glTexture.wrapMode = WRAP_MODES.CLAMP;
      } else {
        glTexture.wrapMode = texture.wrapMode;
      }
      if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
        ;
      else {
        this.setStyle(texture, glTexture);
      }
      glTexture.dirtyStyleId = texture.dirtyStyleId;
    };
    TextureSystem2.prototype.setStyle = function(texture, glTexture) {
      var gl = this.gl;
      if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {
        gl.generateMipmap(texture.target);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
      if (glTexture.mipmap) {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
        if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
          var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
        }
      } else {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    };
    TextureSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return TextureSystem2;
  }()
);
var tempMatrix = new Matrix$1();
var AbstractRenderer = (
  /** @class */
  function(_super) {
    __extends$i(AbstractRenderer2, _super);
    function AbstractRenderer2(type2, options) {
      if (type2 === void 0) {
        type2 = RENDERER_TYPE.UNKNOWN;
      }
      var _this = _super.call(this) || this;
      options = Object.assign({}, settings.RENDER_OPTIONS, options);
      _this.options = options;
      _this.type = type2;
      _this.screen = new Rectangle(0, 0, options.width, options.height);
      _this.view = options.view || settings.ADAPTER.createCanvas();
      _this.resolution = options.resolution || settings.RESOLUTION;
      _this.useContextAlpha = options.useContextAlpha;
      _this.autoDensity = !!options.autoDensity;
      _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
      _this.clearBeforeRender = options.clearBeforeRender;
      _this._backgroundColor = 0;
      _this._backgroundColorRgba = [0, 0, 0, 1];
      _this._backgroundColorString = "#000000";
      _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
      _this.backgroundAlpha = options.backgroundAlpha;
      if (options.transparent !== void 0) {
        deprecation("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead.");
        _this.useContextAlpha = options.transparent;
        _this.backgroundAlpha = options.transparent ? 0 : 1;
      }
      _this._lastObjectRendered = null;
      _this.plugins = {};
      return _this;
    }
    AbstractRenderer2.prototype.initPlugins = function(staticMap) {
      for (var o in staticMap) {
        this.plugins[o] = new staticMap[o](this);
      }
    };
    Object.defineProperty(AbstractRenderer2.prototype, "width", {
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @member {number}
       * @readonly
       * @default 800
       */
      get: function() {
        return this.view.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AbstractRenderer2.prototype, "height", {
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @member {number}
       * @readonly
       * @default 600
       */
      get: function() {
        return this.view.height;
      },
      enumerable: false,
      configurable: true
    });
    AbstractRenderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
      this.view.width = Math.round(desiredScreenWidth * this.resolution);
      this.view.height = Math.round(desiredScreenHeight * this.resolution);
      var screenWidth = this.view.width / this.resolution;
      var screenHeight = this.view.height / this.resolution;
      this.screen.width = screenWidth;
      this.screen.height = screenHeight;
      if (this.autoDensity) {
        this.view.style.width = screenWidth + "px";
        this.view.style.height = screenHeight + "px";
      }
      this.emit("resize", screenWidth, screenHeight);
    };
    AbstractRenderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
      if (options === void 0) {
        options = {};
      }
      if (typeof options === "number") {
        deprecation("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options.");
        options = { scaleMode: options, resolution, region };
      }
      var manualRegion = options.region, textureOptions = __rest(options, ["region"]);
      region = manualRegion || displayObject.getLocalBounds(null, true);
      if (region.width === 0) {
        region.width = 1;
      }
      if (region.height === 0) {
        region.height = 1;
      }
      var renderTexture = RenderTexture.create(__assign({ width: region.width, height: region.height }, textureOptions));
      tempMatrix.tx = -region.x;
      tempMatrix.ty = -region.y;
      this.render(displayObject, {
        renderTexture,
        clear: false,
        transform: tempMatrix,
        skipUpdateTransform: !!displayObject.parent
      });
      return renderTexture;
    };
    AbstractRenderer2.prototype.destroy = function(removeView) {
      for (var o in this.plugins) {
        this.plugins[o].destroy();
        this.plugins[o] = null;
      }
      if (removeView && this.view.parentNode) {
        this.view.parentNode.removeChild(this.view);
      }
      var thisAny = this;
      thisAny.plugins = null;
      thisAny.type = RENDERER_TYPE.UNKNOWN;
      thisAny.view = null;
      thisAny.screen = null;
      thisAny._tempDisplayObjectParent = null;
      thisAny.options = null;
      this._backgroundColorRgba = null;
      this._backgroundColorString = null;
      this._lastObjectRendered = null;
    };
    Object.defineProperty(AbstractRenderer2.prototype, "backgroundColor", {
      /**
       * The background color to fill if not transparent
       * @member {number}
       */
      get: function() {
        return this._backgroundColor;
      },
      set: function(value) {
        this._backgroundColor = value;
        this._backgroundColorString = hex2string(value);
        hex2rgb(value, this._backgroundColorRgba);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AbstractRenderer2.prototype, "backgroundAlpha", {
      /**
       * The background color alpha. Setting this to 0 will make the canvas transparent.
       * @member {number}
       */
      get: function() {
        return this._backgroundColorRgba[3];
      },
      set: function(value) {
        this._backgroundColorRgba[3] = value;
      },
      enumerable: false,
      configurable: true
    });
    return AbstractRenderer2;
  }(EventEmitter)
);
var GLBuffer = (
  /** @class */
  /* @__PURE__ */ function() {
    function GLBuffer2(buffer) {
      this.buffer = buffer || null;
      this.updateID = -1;
      this.byteLength = -1;
      this.refCount = 0;
    }
    return GLBuffer2;
  }()
);
var BufferSystem = (
  /** @class */
  function() {
    function BufferSystem2(renderer) {
      this.renderer = renderer;
      this.managedBuffers = {};
      this.boundBufferBases = {};
    }
    BufferSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    BufferSystem2.prototype.contextChange = function() {
      this.disposeAll(true);
      this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    };
    BufferSystem2.prototype.bind = function(buffer) {
      var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
      var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      gl.bindBuffer(buffer.type, glBuffer.buffer);
    };
    BufferSystem2.prototype.bindBufferBase = function(buffer, index) {
      var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
      if (this.boundBufferBases[index] !== buffer) {
        var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
        this.boundBufferBases[index] = buffer;
        gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
      }
    };
    BufferSystem2.prototype.bindBufferRange = function(buffer, index, offset) {
      var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
      offset = offset || 0;
      var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
    };
    BufferSystem2.prototype.update = function(buffer) {
      var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
      var glBuffer = buffer._glBuffers[CONTEXT_UID];
      if (buffer._updateID === glBuffer.updateID) {
        return;
      }
      glBuffer.updateID = buffer._updateID;
      gl.bindBuffer(buffer.type, glBuffer.buffer);
      if (glBuffer.byteLength >= buffer.data.byteLength) {
        gl.bufferSubData(buffer.type, 0, buffer.data);
      } else {
        var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
        glBuffer.byteLength = buffer.data.byteLength;
        gl.bufferData(buffer.type, buffer.data, drawType);
      }
    };
    BufferSystem2.prototype.dispose = function(buffer, contextLost) {
      if (!this.managedBuffers[buffer.id]) {
        return;
      }
      delete this.managedBuffers[buffer.id];
      var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
      var gl = this.gl;
      buffer.disposeRunner.remove(this);
      if (!glBuffer) {
        return;
      }
      if (!contextLost) {
        gl.deleteBuffer(glBuffer.buffer);
      }
      delete buffer._glBuffers[this.CONTEXT_UID];
    };
    BufferSystem2.prototype.disposeAll = function(contextLost) {
      var all = Object.keys(this.managedBuffers);
      for (var i = 0; i < all.length; i++) {
        this.dispose(this.managedBuffers[all[i]], contextLost);
      }
    };
    BufferSystem2.prototype.createGLBuffer = function(buffer) {
      var _a2 = this, CONTEXT_UID = _a2.CONTEXT_UID, gl = _a2.gl;
      buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
      this.managedBuffers[buffer.id] = buffer;
      buffer.disposeRunner.add(this);
      return buffer._glBuffers[CONTEXT_UID];
    };
    return BufferSystem2;
  }()
);
var Renderer = (
  /** @class */
  function(_super) {
    __extends$i(Renderer2, _super);
    function Renderer2(options) {
      var _this = _super.call(this, RENDERER_TYPE.WEBGL, options) || this;
      options = _this.options;
      _this.gl = null;
      _this.CONTEXT_UID = 0;
      _this.runners = {
        destroy: new Runner("destroy"),
        contextChange: new Runner("contextChange"),
        reset: new Runner("reset"),
        update: new Runner("update"),
        postrender: new Runner("postrender"),
        prerender: new Runner("prerender"),
        resize: new Runner("resize")
      };
      _this.runners.contextChange.add(_this);
      _this.globalUniforms = new UniformGroup({
        projectionMatrix: new Matrix$1()
      }, true);
      _this.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(BufferSystem, "buffer").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch");
      _this.initPlugins(Renderer2.__plugins);
      _this.multisample = void 0;
      if (options.context) {
        _this.context.initFromContext(options.context);
      } else {
        _this.context.initFromOptions({
          alpha: !!_this.useContextAlpha,
          antialias: options.antialias,
          premultipliedAlpha: _this.useContextAlpha && _this.useContextAlpha !== "notMultiplied",
          stencil: true,
          preserveDrawingBuffer: options.preserveDrawingBuffer,
          powerPreference: _this.options.powerPreference
        });
      }
      _this.renderingToScreen = true;
      sayHello(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
      _this.resize(_this.options.width, _this.options.height);
      return _this;
    }
    Renderer2.create = function(options) {
      if (isWebGLSupported()) {
        return new Renderer2(options);
      }
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    };
    Renderer2.prototype.contextChange = function() {
      var gl = this.gl;
      var samples;
      if (this.context.webGLVersion === 1) {
        var framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        samples = gl.getParameter(gl.SAMPLES);
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      } else {
        var framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        samples = gl.getParameter(gl.SAMPLES);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
      }
      if (samples >= MSAA_QUALITY.HIGH) {
        this.multisample = MSAA_QUALITY.HIGH;
      } else if (samples >= MSAA_QUALITY.MEDIUM) {
        this.multisample = MSAA_QUALITY.MEDIUM;
      } else if (samples >= MSAA_QUALITY.LOW) {
        this.multisample = MSAA_QUALITY.LOW;
      } else {
        this.multisample = MSAA_QUALITY.NONE;
      }
    };
    Renderer2.prototype.addSystem = function(ClassRef, name2) {
      var system = new ClassRef(this);
      if (this[name2]) {
        throw new Error('Whoops! The name "' + name2 + '" is already in use');
      }
      this[name2] = system;
      for (var i in this.runners) {
        this.runners[i].add(system);
      }
      return this;
    };
    Renderer2.prototype.render = function(displayObject, options) {
      var renderTexture;
      var clear;
      var transform;
      var skipUpdateTransform;
      if (options) {
        if (options instanceof RenderTexture) {
          deprecation("6.0.0", "Renderer#render arguments changed, use options instead.");
          renderTexture = options;
          clear = arguments[2];
          transform = arguments[3];
          skipUpdateTransform = arguments[4];
        } else {
          renderTexture = options.renderTexture;
          clear = options.clear;
          transform = options.transform;
          skipUpdateTransform = options.skipUpdateTransform;
        }
      }
      this.renderingToScreen = !renderTexture;
      this.runners.prerender.emit();
      this.emit("prerender");
      this.projection.transform = transform;
      if (this.context.isLost) {
        return;
      }
      if (!renderTexture) {
        this._lastObjectRendered = displayObject;
      }
      if (!skipUpdateTransform) {
        var cacheParent = displayObject.enableTempParent();
        displayObject.updateTransform();
        displayObject.disableTempParent(cacheParent);
      }
      this.renderTexture.bind(renderTexture);
      this.batch.currentRenderer.start();
      if (clear !== void 0 ? clear : this.clearBeforeRender) {
        this.renderTexture.clear();
      }
      displayObject.render(this);
      this.batch.currentRenderer.flush();
      if (renderTexture) {
        renderTexture.baseTexture.update();
      }
      this.runners.postrender.emit();
      this.projection.transform = null;
      this.emit("postrender");
    };
    Renderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
      if (options === void 0) {
        options = {};
      }
      var renderTexture = _super.prototype.generateTexture.call(this, displayObject, options, resolution, region);
      this.framebuffer.blit();
      return renderTexture;
    };
    Renderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
      _super.prototype.resize.call(this, desiredScreenWidth, desiredScreenHeight);
      this.runners.resize.emit(this.screen.height, this.screen.width);
    };
    Renderer2.prototype.reset = function() {
      this.runners.reset.emit();
      return this;
    };
    Renderer2.prototype.clear = function() {
      this.renderTexture.bind();
      this.renderTexture.clear();
    };
    Renderer2.prototype.destroy = function(removeView) {
      this.runners.destroy.emit();
      for (var r in this.runners) {
        this.runners[r].destroy();
      }
      _super.prototype.destroy.call(this, removeView);
      this.gl = null;
    };
    Object.defineProperty(Renderer2.prototype, "extract", {
      /**
       * Please use `plugins.extract` instead.
       * @member {PIXI.Extract} extract
       * @deprecated since 6.0.0
       * @readonly
       */
      get: function() {
        deprecation("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.");
        return this.plugins.extract;
      },
      enumerable: false,
      configurable: true
    });
    Renderer2.registerPlugin = function(pluginName, ctor) {
      deprecation("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead.");
      extensions.add({
        name: pluginName,
        type: ExtensionType.RendererPlugin,
        ref: ctor
      });
    };
    Renderer2.__plugins = {};
    return Renderer2;
  }(AbstractRenderer)
);
extensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
function autoDetectRenderer(options) {
  return Renderer.create(options);
}
var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var defaultVertex$1 = $defaultVertex;
var defaultFilterVertex = $defaultFilterVertex;
var BatchDrawCall = (
  /** @class */
  /* @__PURE__ */ function() {
    function BatchDrawCall2() {
      this.texArray = null;
      this.blend = 0;
      this.type = DRAW_MODES.TRIANGLES;
      this.start = 0;
      this.size = 0;
      this.data = null;
    }
    return BatchDrawCall2;
  }()
);
var BatchTextureArray = (
  /** @class */
  function() {
    function BatchTextureArray2() {
      this.elements = [];
      this.ids = [];
      this.count = 0;
    }
    BatchTextureArray2.prototype.clear = function() {
      for (var i = 0; i < this.count; i++) {
        this.elements[i] = null;
      }
      this.count = 0;
    };
    return BatchTextureArray2;
  }()
);
var ViewableBuffer = (
  /** @class */
  function() {
    function ViewableBuffer2(sizeOrBuffer) {
      if (typeof sizeOrBuffer === "number") {
        this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
      } else if (sizeOrBuffer instanceof Uint8Array) {
        this.rawBinaryData = sizeOrBuffer.buffer;
      } else {
        this.rawBinaryData = sizeOrBuffer;
      }
      this.uint32View = new Uint32Array(this.rawBinaryData);
      this.float32View = new Float32Array(this.rawBinaryData);
    }
    Object.defineProperty(ViewableBuffer2.prototype, "int8View", {
      /** View on the raw binary data as a `Int8Array`. */
      get: function() {
        if (!this._int8View) {
          this._int8View = new Int8Array(this.rawBinaryData);
        }
        return this._int8View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer2.prototype, "uint8View", {
      /** View on the raw binary data as a `Uint8Array`. */
      get: function() {
        if (!this._uint8View) {
          this._uint8View = new Uint8Array(this.rawBinaryData);
        }
        return this._uint8View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer2.prototype, "int16View", {
      /**  View on the raw binary data as a `Int16Array`. */
      get: function() {
        if (!this._int16View) {
          this._int16View = new Int16Array(this.rawBinaryData);
        }
        return this._int16View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer2.prototype, "uint16View", {
      /** View on the raw binary data as a `Uint16Array`. */
      get: function() {
        if (!this._uint16View) {
          this._uint16View = new Uint16Array(this.rawBinaryData);
        }
        return this._uint16View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer2.prototype, "int32View", {
      /** View on the raw binary data as a `Int32Array`. */
      get: function() {
        if (!this._int32View) {
          this._int32View = new Int32Array(this.rawBinaryData);
        }
        return this._int32View;
      },
      enumerable: false,
      configurable: true
    });
    ViewableBuffer2.prototype.view = function(type2) {
      return this[type2 + "View"];
    };
    ViewableBuffer2.prototype.destroy = function() {
      this.rawBinaryData = null;
      this._int8View = null;
      this._uint8View = null;
      this._int16View = null;
      this._uint16View = null;
      this._int32View = null;
      this.uint32View = null;
      this.float32View = null;
    };
    ViewableBuffer2.sizeOf = function(type2) {
      switch (type2) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(type2 + " isn't a valid view type");
      }
    };
    return ViewableBuffer2;
  }()
);
var AbstractBatchRenderer = (
  /** @class */
  function(_super) {
    __extends$i(AbstractBatchRenderer2, _super);
    function AbstractBatchRenderer2(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.shaderGenerator = null;
      _this.geometryClass = null;
      _this.vertexSize = null;
      _this.state = State.for2d();
      _this.size = settings.SPRITE_BATCH_SIZE * 4;
      _this._vertexCount = 0;
      _this._indexCount = 0;
      _this._bufferedElements = [];
      _this._bufferedTextures = [];
      _this._bufferSize = 0;
      _this._shader = null;
      _this._packedGeometries = [];
      _this._packedGeometryPoolSize = 2;
      _this._flushId = 0;
      _this._aBuffers = {};
      _this._iBuffers = {};
      _this.MAX_TEXTURES = 1;
      _this.renderer.on("prerender", _this.onPrerender, _this);
      renderer.runners.contextChange.add(_this);
      _this._dcIndex = 0;
      _this._aIndex = 0;
      _this._iIndex = 0;
      _this._attributeBuffer = null;
      _this._indexBuffer = null;
      _this._tempBoundTextures = [];
      return _this;
    }
    AbstractBatchRenderer2.prototype.contextChange = function() {
      var gl = this.renderer.gl;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        this.MAX_TEXTURES = 1;
      } else {
        this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);
        this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
      }
      this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (var i = 0; i < this._packedGeometryPoolSize; i++) {
        this._packedGeometries[i] = new this.geometryClass();
      }
      this.initFlushBuffers();
    };
    AbstractBatchRenderer2.prototype.initFlushBuffers = function() {
      var _drawCallPool = AbstractBatchRenderer2._drawCallPool, _textureArrayPool = AbstractBatchRenderer2._textureArrayPool;
      var MAX_SPRITES = this.size / 4;
      var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
      while (_drawCallPool.length < MAX_SPRITES) {
        _drawCallPool.push(new BatchDrawCall());
      }
      while (_textureArrayPool.length < MAX_TA) {
        _textureArrayPool.push(new BatchTextureArray());
      }
      for (var i = 0; i < this.MAX_TEXTURES; i++) {
        this._tempBoundTextures[i] = null;
      }
    };
    AbstractBatchRenderer2.prototype.onPrerender = function() {
      this._flushId = 0;
    };
    AbstractBatchRenderer2.prototype.render = function(element) {
      if (!element._texture.valid) {
        return;
      }
      if (this._vertexCount + element.vertexData.length / 2 > this.size) {
        this.flush();
      }
      this._vertexCount += element.vertexData.length / 2;
      this._indexCount += element.indices.length;
      this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
      this._bufferedElements[this._bufferSize++] = element;
    };
    AbstractBatchRenderer2.prototype.buildTexturesAndDrawCalls = function() {
      var _a2 = this, textures = _a2._bufferedTextures, MAX_TEXTURES = _a2.MAX_TEXTURES;
      var textureArrays = AbstractBatchRenderer2._textureArrayPool;
      var batch = this.renderer.batch;
      var boundTextures = this._tempBoundTextures;
      var touch = this.renderer.textureGC.count;
      var TICK = ++BaseTexture._globalBatch;
      var countTexArrays = 0;
      var texArray = textureArrays[0];
      var start2 = 0;
      batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
      for (var i = 0; i < this._bufferSize; ++i) {
        var tex = textures[i];
        textures[i] = null;
        if (tex._batchEnabled === TICK) {
          continue;
        }
        if (texArray.count >= MAX_TEXTURES) {
          batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
          this.buildDrawCalls(texArray, start2, i);
          start2 = i;
          texArray = textureArrays[++countTexArrays];
          ++TICK;
        }
        tex._batchEnabled = TICK;
        tex.touched = touch;
        texArray.elements[texArray.count++] = tex;
      }
      if (texArray.count > 0) {
        batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
        this.buildDrawCalls(texArray, start2, this._bufferSize);
        ++countTexArrays;
        ++TICK;
      }
      for (var i = 0; i < boundTextures.length; i++) {
        boundTextures[i] = null;
      }
      BaseTexture._globalBatch = TICK;
    };
    AbstractBatchRenderer2.prototype.buildDrawCalls = function(texArray, start2, finish) {
      var _a2 = this, elements = _a2._bufferedElements, _attributeBuffer = _a2._attributeBuffer, _indexBuffer = _a2._indexBuffer, vertexSize = _a2.vertexSize;
      var drawCalls = AbstractBatchRenderer2._drawCallPool;
      var dcIndex = this._dcIndex;
      var aIndex = this._aIndex;
      var iIndex = this._iIndex;
      var drawCall = drawCalls[dcIndex];
      drawCall.start = this._iIndex;
      drawCall.texArray = texArray;
      for (var i = start2; i < finish; ++i) {
        var sprite = elements[i];
        var tex = sprite._texture.baseTexture;
        var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
        elements[i] = null;
        if (start2 < i && drawCall.blend !== spriteBlendMode) {
          drawCall.size = iIndex - drawCall.start;
          start2 = i;
          drawCall = drawCalls[++dcIndex];
          drawCall.texArray = texArray;
          drawCall.start = iIndex;
        }
        this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
        aIndex += sprite.vertexData.length / 2 * vertexSize;
        iIndex += sprite.indices.length;
        drawCall.blend = spriteBlendMode;
      }
      if (start2 < finish) {
        drawCall.size = iIndex - drawCall.start;
        ++dcIndex;
      }
      this._dcIndex = dcIndex;
      this._aIndex = aIndex;
      this._iIndex = iIndex;
    };
    AbstractBatchRenderer2.prototype.bindAndClearTexArray = function(texArray) {
      var textureSystem = this.renderer.texture;
      for (var j = 0; j < texArray.count; j++) {
        textureSystem.bind(texArray.elements[j], texArray.ids[j]);
        texArray.elements[j] = null;
      }
      texArray.count = 0;
    };
    AbstractBatchRenderer2.prototype.updateGeometry = function() {
      var _a2 = this, packedGeometries = _a2._packedGeometries, attributeBuffer = _a2._attributeBuffer, indexBuffer = _a2._indexBuffer;
      if (!settings.CAN_UPLOAD_SAME_BUFFER) {
        if (this._packedGeometryPoolSize <= this._flushId) {
          this._packedGeometryPoolSize++;
          packedGeometries[this._flushId] = new this.geometryClass();
        }
        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
        this.renderer.geometry.bind(packedGeometries[this._flushId]);
        this.renderer.geometry.updateBuffers();
        this._flushId++;
      } else {
        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
        this.renderer.geometry.updateBuffers();
      }
    };
    AbstractBatchRenderer2.prototype.drawBatches = function() {
      var dcCount = this._dcIndex;
      var _a2 = this.renderer, gl = _a2.gl, stateSystem = _a2.state;
      var drawCalls = AbstractBatchRenderer2._drawCallPool;
      var curTexArray = null;
      for (var i = 0; i < dcCount; i++) {
        var _b2 = drawCalls[i], texArray = _b2.texArray, type2 = _b2.type, size2 = _b2.size, start2 = _b2.start, blend = _b2.blend;
        if (curTexArray !== texArray) {
          curTexArray = texArray;
          this.bindAndClearTexArray(texArray);
        }
        this.state.blendMode = blend;
        stateSystem.set(this.state);
        gl.drawElements(type2, size2, gl.UNSIGNED_SHORT, start2 * 2);
      }
    };
    AbstractBatchRenderer2.prototype.flush = function() {
      if (this._vertexCount === 0) {
        return;
      }
      this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
      this._indexBuffer = this.getIndexBuffer(this._indexCount);
      this._aIndex = 0;
      this._iIndex = 0;
      this._dcIndex = 0;
      this.buildTexturesAndDrawCalls();
      this.updateGeometry();
      this.drawBatches();
      this._bufferSize = 0;
      this._vertexCount = 0;
      this._indexCount = 0;
    };
    AbstractBatchRenderer2.prototype.start = function() {
      this.renderer.state.set(this.state);
      this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);
      this.renderer.shader.bind(this._shader);
      if (settings.CAN_UPLOAD_SAME_BUFFER) {
        this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
      }
    };
    AbstractBatchRenderer2.prototype.stop = function() {
      this.flush();
    };
    AbstractBatchRenderer2.prototype.destroy = function() {
      for (var i = 0; i < this._packedGeometryPoolSize; i++) {
        if (this._packedGeometries[i]) {
          this._packedGeometries[i].destroy();
        }
      }
      this.renderer.off("prerender", this.onPrerender, this);
      this._aBuffers = null;
      this._iBuffers = null;
      this._packedGeometries = null;
      this._attributeBuffer = null;
      this._indexBuffer = null;
      if (this._shader) {
        this._shader.destroy();
        this._shader = null;
      }
      _super.prototype.destroy.call(this);
    };
    AbstractBatchRenderer2.prototype.getAttributeBuffer = function(size2) {
      var roundedP2 = nextPow2(Math.ceil(size2 / 8));
      var roundedSizeIndex = log2$1(roundedP2);
      var roundedSize = roundedP2 * 8;
      if (this._aBuffers.length <= roundedSizeIndex) {
        this._iBuffers.length = roundedSizeIndex + 1;
      }
      var buffer = this._aBuffers[roundedSize];
      if (!buffer) {
        this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
      }
      return buffer;
    };
    AbstractBatchRenderer2.prototype.getIndexBuffer = function(size2) {
      var roundedP2 = nextPow2(Math.ceil(size2 / 12));
      var roundedSizeIndex = log2$1(roundedP2);
      var roundedSize = roundedP2 * 12;
      if (this._iBuffers.length <= roundedSizeIndex) {
        this._iBuffers.length = roundedSizeIndex + 1;
      }
      var buffer = this._iBuffers[roundedSizeIndex];
      if (!buffer) {
        this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
      }
      return buffer;
    };
    AbstractBatchRenderer2.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
      var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
      var packedVertices = aIndex / this.vertexSize;
      var uvs = element.uvs;
      var indicies = element.indices;
      var vertexData = element.vertexData;
      var textureId = element._texture.baseTexture._batchLocation;
      var alpha = Math.min(element.worldAlpha, 1);
      var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
      for (var i = 0; i < vertexData.length; i += 2) {
        float32View[aIndex++] = vertexData[i];
        float32View[aIndex++] = vertexData[i + 1];
        float32View[aIndex++] = uvs[i];
        float32View[aIndex++] = uvs[i + 1];
        uint32View[aIndex++] = argb;
        float32View[aIndex++] = textureId;
      }
      for (var i = 0; i < indicies.length; i++) {
        indexBuffer[iIndex++] = packedVertices + indicies[i];
      }
    };
    AbstractBatchRenderer2._drawCallPool = [];
    AbstractBatchRenderer2._textureArrayPool = [];
    return AbstractBatchRenderer2;
  }(ObjectRenderer)
);
var BatchShaderGenerator = (
  /** @class */
  function() {
    function BatchShaderGenerator2(vertexSrc, fragTemplate2) {
      this.vertexSrc = vertexSrc;
      this.fragTemplate = fragTemplate2;
      this.programCache = {};
      this.defaultGroupCache = {};
      if (fragTemplate2.indexOf("%count%") < 0) {
        throw new Error('Fragment template must contain "%count%".');
      }
      if (fragTemplate2.indexOf("%forloop%") < 0) {
        throw new Error('Fragment template must contain "%forloop%".');
      }
    }
    BatchShaderGenerator2.prototype.generateShader = function(maxTextures) {
      if (!this.programCache[maxTextures]) {
        var sampleValues = new Int32Array(maxTextures);
        for (var i = 0; i < maxTextures; i++) {
          sampleValues[i] = i;
        }
        this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
        var fragmentSrc = this.fragTemplate;
        fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
        fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
        this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
      }
      var uniforms = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new Matrix$1(),
        default: this.defaultGroupCache[maxTextures]
      };
      return new Shader(this.programCache[maxTextures], uniforms);
    };
    BatchShaderGenerator2.prototype.generateSampleSrc = function(maxTextures) {
      var src = "";
      src += "\n";
      src += "\n";
      for (var i = 0; i < maxTextures; i++) {
        if (i > 0) {
          src += "\nelse ";
        }
        if (i < maxTextures - 1) {
          src += "if(vTextureId < " + i + ".5)";
        }
        src += "\n{";
        src += "\n	color = texture2D(uSamplers[" + i + "], vTextureCoord);";
        src += "\n}";
      }
      src += "\n";
      src += "\n";
      return src;
    };
    return BatchShaderGenerator2;
  }()
);
var BatchGeometry = (
  /** @class */
  function(_super) {
    __extends$i(BatchGeometry2, _super);
    function BatchGeometry2(_static) {
      if (_static === void 0) {
        _static = false;
      }
      var _this = _super.call(this) || this;
      _this._buffer = new Buffer2(null, _static, false);
      _this._indexBuffer = new Buffer2(null, _static, true);
      _this.addAttribute("aVertexPosition", _this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", _this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, TYPES.FLOAT).addIndex(_this._indexBuffer);
      return _this;
    }
    return BatchGeometry2;
  }(Geometry)
);
var defaultVertex = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
var defaultFragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
var BatchPluginFactory = (
  /** @class */
  function() {
    function BatchPluginFactory2() {
    }
    BatchPluginFactory2.create = function(options) {
      var _a2 = Object.assign({
        vertex: defaultVertex,
        fragment: defaultFragment,
        geometryClass: BatchGeometry,
        vertexSize: 6
      }, options), vertex2 = _a2.vertex, fragment2 = _a2.fragment, vertexSize = _a2.vertexSize, geometryClass = _a2.geometryClass;
      return (
        /** @class */
        function(_super) {
          __extends$i(BatchPlugin, _super);
          function BatchPlugin(renderer) {
            var _this = _super.call(this, renderer) || this;
            _this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
            _this.geometryClass = geometryClass;
            _this.vertexSize = vertexSize;
            return _this;
          }
          return BatchPlugin;
        }(AbstractBatchRenderer)
      );
    };
    Object.defineProperty(BatchPluginFactory2, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @readonly
       */
      get: function() {
        return defaultVertex;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BatchPluginFactory2, "defaultFragmentTemplate", {
      /**
       * The default fragment shader source
       * @readonly
       */
      get: function() {
        return defaultFragment;
      },
      enumerable: false,
      configurable: true
    });
    return BatchPluginFactory2;
  }()
);
var BatchRenderer = BatchPluginFactory.create();
Object.assign(BatchRenderer, {
  extension: {
    name: "batch",
    type: ExtensionType.RendererPlugin
  }
});
/*!
 * @pixi/accessibility - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var accessibleTarget = {
  /**
   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
   *   shadow div with attributes set
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  accessible: false,
  /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
   * @member {?string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleTitle: null,
  /**
   * Sets the aria-label attribute of the shadow div
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleHint: null,
  /**
   * @member {number}
   * @memberof PIXI.DisplayObject#
   * @private
   * @todo Needs docs.
   */
  tabIndex: 0,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleActive: false,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleDiv: null,
  /**
   * Specify the type of div the accessible layer is. Screen readers treat the element differently
   * depending on this type. Defaults to button.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'button'
   */
  accessibleType: "button",
  /**
   * Specify the pointer-events the accessible div will use
   * Defaults to auto.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'auto'
   */
  accessiblePointerEvents: "auto",
  /**
   * Setting to false will prevent any children inside this container to
   * be accessible. Defaults to true.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @default true
   */
  accessibleChildren: true,
  renderId: -1
};
DisplayObject.mixin(accessibleTarget);
var KEY_CODE_TAB = 9;
var DIV_TOUCH_SIZE = 100;
var DIV_TOUCH_POS_X = 0;
var DIV_TOUCH_POS_Y = 0;
var DIV_TOUCH_ZINDEX = 2;
var DIV_HOOK_SIZE = 1;
var DIV_HOOK_POS_X = -1e3;
var DIV_HOOK_POS_Y = -1e3;
var DIV_HOOK_ZINDEX = 2;
var AccessibilityManager = (
  /** @class */
  function() {
    function AccessibilityManager2(renderer) {
      this.debug = false;
      this._isActive = false;
      this._isMobileAccessibility = false;
      this.pool = [];
      this.renderId = 0;
      this.children = [];
      this.androidUpdateCount = 0;
      this.androidUpdateFrequency = 500;
      this._hookDiv = null;
      if (isMobile.tablet || isMobile.phone) {
        this.createTouchHook();
      }
      var div2 = document.createElement("div");
      div2.style.width = DIV_TOUCH_SIZE + "px";
      div2.style.height = DIV_TOUCH_SIZE + "px";
      div2.style.position = "absolute";
      div2.style.top = DIV_TOUCH_POS_X + "px";
      div2.style.left = DIV_TOUCH_POS_Y + "px";
      div2.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      this.div = div2;
      this.renderer = renderer;
      this._onKeyDown = this._onKeyDown.bind(this);
      this._onMouseMove = this._onMouseMove.bind(this);
      globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    Object.defineProperty(AccessibilityManager2.prototype, "isActive", {
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isActive;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AccessibilityManager2.prototype, "isMobileAccessibility", {
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isMobileAccessibility;
      },
      enumerable: false,
      configurable: true
    });
    AccessibilityManager2.prototype.createTouchHook = function() {
      var _this = this;
      var hookDiv = document.createElement("button");
      hookDiv.style.width = DIV_HOOK_SIZE + "px";
      hookDiv.style.height = DIV_HOOK_SIZE + "px";
      hookDiv.style.position = "absolute";
      hookDiv.style.top = DIV_HOOK_POS_X + "px";
      hookDiv.style.left = DIV_HOOK_POS_Y + "px";
      hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
      hookDiv.style.backgroundColor = "#FF0000";
      hookDiv.title = "select to enable accessibility for this content";
      hookDiv.addEventListener("focus", function() {
        _this._isMobileAccessibility = true;
        _this.activate();
        _this.destroyTouchHook();
      });
      document.body.appendChild(hookDiv);
      this._hookDiv = hookDiv;
    };
    AccessibilityManager2.prototype.destroyTouchHook = function() {
      if (!this._hookDiv) {
        return;
      }
      document.body.removeChild(this._hookDiv);
      this._hookDiv = null;
    };
    AccessibilityManager2.prototype.activate = function() {
      var _a2;
      if (this._isActive) {
        return;
      }
      this._isActive = true;
      globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
      globalThis.removeEventListener("keydown", this._onKeyDown, false);
      this.renderer.on("postrender", this.update, this);
      (_a2 = this.renderer.view.parentNode) === null || _a2 === void 0 ? void 0 : _a2.appendChild(this.div);
    };
    AccessibilityManager2.prototype.deactivate = function() {
      var _a2;
      if (!this._isActive || this._isMobileAccessibility) {
        return;
      }
      this._isActive = false;
      globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
      globalThis.addEventListener("keydown", this._onKeyDown, false);
      this.renderer.off("postrender", this.update);
      (_a2 = this.div.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.div);
    };
    AccessibilityManager2.prototype.updateAccessibleObjects = function(displayObject) {
      if (!displayObject.visible || !displayObject.accessibleChildren) {
        return;
      }
      if (displayObject.accessible && displayObject.interactive) {
        if (!displayObject._accessibleActive) {
          this.addChild(displayObject);
        }
        displayObject.renderId = this.renderId;
      }
      var children2 = displayObject.children;
      if (children2) {
        for (var i = 0; i < children2.length; i++) {
          this.updateAccessibleObjects(children2[i]);
        }
      }
    };
    AccessibilityManager2.prototype.update = function() {
      var now2 = performance.now();
      if (isMobile.android.device && now2 < this.androidUpdateCount) {
        return;
      }
      this.androidUpdateCount = now2 + this.androidUpdateFrequency;
      if (!this.renderer.renderingToScreen) {
        return;
      }
      if (this.renderer._lastObjectRendered) {
        this.updateAccessibleObjects(this.renderer._lastObjectRendered);
      }
      var _a2 = this.renderer.view.getBoundingClientRect(), left = _a2.left, top = _a2.top, width = _a2.width, height = _a2.height;
      var _b2 = this.renderer, viewWidth = _b2.width, viewHeight = _b2.height, resolution = _b2.resolution;
      var sx = width / viewWidth * resolution;
      var sy = height / viewHeight * resolution;
      var div2 = this.div;
      div2.style.left = left + "px";
      div2.style.top = top + "px";
      div2.style.width = viewWidth + "px";
      div2.style.height = viewHeight + "px";
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        if (child.renderId !== this.renderId) {
          child._accessibleActive = false;
          removeItems(this.children, i, 1);
          this.div.removeChild(child._accessibleDiv);
          this.pool.push(child._accessibleDiv);
          child._accessibleDiv = null;
          i--;
        } else {
          div2 = child._accessibleDiv;
          var hitArea = child.hitArea;
          var wt = child.worldTransform;
          if (child.hitArea) {
            div2.style.left = (wt.tx + hitArea.x * wt.a) * sx + "px";
            div2.style.top = (wt.ty + hitArea.y * wt.d) * sy + "px";
            div2.style.width = hitArea.width * wt.a * sx + "px";
            div2.style.height = hitArea.height * wt.d * sy + "px";
          } else {
            hitArea = child.getBounds();
            this.capHitArea(hitArea);
            div2.style.left = hitArea.x * sx + "px";
            div2.style.top = hitArea.y * sy + "px";
            div2.style.width = hitArea.width * sx + "px";
            div2.style.height = hitArea.height * sy + "px";
            if (div2.title !== child.accessibleTitle && child.accessibleTitle !== null) {
              div2.title = child.accessibleTitle;
            }
            if (div2.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
              div2.setAttribute("aria-label", child.accessibleHint);
            }
          }
          if (child.accessibleTitle !== div2.title || child.tabIndex !== div2.tabIndex) {
            div2.title = child.accessibleTitle;
            div2.tabIndex = child.tabIndex;
            if (this.debug) {
              this.updateDebugHTML(div2);
            }
          }
        }
      }
      this.renderId++;
    };
    AccessibilityManager2.prototype.updateDebugHTML = function(div2) {
      div2.innerHTML = "type: " + div2.type + "</br> title : " + div2.title + "</br> tabIndex: " + div2.tabIndex;
    };
    AccessibilityManager2.prototype.capHitArea = function(hitArea) {
      if (hitArea.x < 0) {
        hitArea.width += hitArea.x;
        hitArea.x = 0;
      }
      if (hitArea.y < 0) {
        hitArea.height += hitArea.y;
        hitArea.y = 0;
      }
      var _a2 = this.renderer, viewWidth = _a2.width, viewHeight = _a2.height;
      if (hitArea.x + hitArea.width > viewWidth) {
        hitArea.width = viewWidth - hitArea.x;
      }
      if (hitArea.y + hitArea.height > viewHeight) {
        hitArea.height = viewHeight - hitArea.y;
      }
    };
    AccessibilityManager2.prototype.addChild = function(displayObject) {
      var div2 = this.pool.pop();
      if (!div2) {
        div2 = document.createElement("button");
        div2.style.width = DIV_TOUCH_SIZE + "px";
        div2.style.height = DIV_TOUCH_SIZE + "px";
        div2.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
        div2.style.position = "absolute";
        div2.style.zIndex = DIV_TOUCH_ZINDEX.toString();
        div2.style.borderStyle = "none";
        if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
          div2.setAttribute("aria-live", "off");
        } else {
          div2.setAttribute("aria-live", "polite");
        }
        if (navigator.userAgent.match(/rv:.*Gecko\//)) {
          div2.setAttribute("aria-relevant", "additions");
        } else {
          div2.setAttribute("aria-relevant", "text");
        }
        div2.addEventListener("click", this._onClick.bind(this));
        div2.addEventListener("focus", this._onFocus.bind(this));
        div2.addEventListener("focusout", this._onFocusOut.bind(this));
      }
      div2.style.pointerEvents = displayObject.accessiblePointerEvents;
      div2.type = displayObject.accessibleType;
      if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
        div2.title = displayObject.accessibleTitle;
      } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
        div2.title = "displayObject " + displayObject.tabIndex;
      }
      if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
        div2.setAttribute("aria-label", displayObject.accessibleHint);
      }
      if (this.debug) {
        this.updateDebugHTML(div2);
      }
      displayObject._accessibleActive = true;
      displayObject._accessibleDiv = div2;
      div2.displayObject = displayObject;
      this.children.push(displayObject);
      this.div.appendChild(displayObject._accessibleDiv);
      displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
    };
    AccessibilityManager2.prototype._onClick = function(e) {
      var interactionManager = this.renderer.plugins.interaction;
      var displayObject = e.target.displayObject;
      var eventData = interactionManager.eventData;
      interactionManager.dispatchEvent(displayObject, "click", eventData);
      interactionManager.dispatchEvent(displayObject, "pointertap", eventData);
      interactionManager.dispatchEvent(displayObject, "tap", eventData);
    };
    AccessibilityManager2.prototype._onFocus = function(e) {
      if (!e.target.getAttribute("aria-live")) {
        e.target.setAttribute("aria-live", "assertive");
      }
      var interactionManager = this.renderer.plugins.interaction;
      var displayObject = e.target.displayObject;
      var eventData = interactionManager.eventData;
      interactionManager.dispatchEvent(displayObject, "mouseover", eventData);
    };
    AccessibilityManager2.prototype._onFocusOut = function(e) {
      if (!e.target.getAttribute("aria-live")) {
        e.target.setAttribute("aria-live", "polite");
      }
      var interactionManager = this.renderer.plugins.interaction;
      var displayObject = e.target.displayObject;
      var eventData = interactionManager.eventData;
      interactionManager.dispatchEvent(displayObject, "mouseout", eventData);
    };
    AccessibilityManager2.prototype._onKeyDown = function(e) {
      if (e.keyCode !== KEY_CODE_TAB) {
        return;
      }
      this.activate();
    };
    AccessibilityManager2.prototype._onMouseMove = function(e) {
      if (e.movementX === 0 && e.movementY === 0) {
        return;
      }
      this.deactivate();
    };
    AccessibilityManager2.prototype.destroy = function() {
      this.destroyTouchHook();
      this.div = null;
      globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
      globalThis.removeEventListener("keydown", this._onKeyDown);
      this.pool = null;
      this.children = null;
      this.renderer = null;
    };
    AccessibilityManager2.extension = {
      name: "accessibility",
      type: [
        ExtensionType.RendererPlugin,
        ExtensionType.CanvasRendererPlugin
      ]
    };
    return AccessibilityManager2;
  }()
);
/*!
 * @pixi/interaction - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var InteractionData = (
  /** @class */
  function() {
    function InteractionData2() {
      this.pressure = 0;
      this.rotationAngle = 0;
      this.twist = 0;
      this.tangentialPressure = 0;
      this.global = new Point();
      this.target = null;
      this.originalEvent = null;
      this.identifier = null;
      this.isPrimary = false;
      this.button = 0;
      this.buttons = 0;
      this.width = 0;
      this.height = 0;
      this.tiltX = 0;
      this.tiltY = 0;
      this.pointerType = null;
      this.pressure = 0;
      this.rotationAngle = 0;
      this.twist = 0;
      this.tangentialPressure = 0;
    }
    Object.defineProperty(InteractionData2.prototype, "pointerId", {
      /**
       * The unique identifier of the pointer. It will be the same as `identifier`.
       * @readonly
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
       */
      get: function() {
        return this.identifier;
      },
      enumerable: false,
      configurable: true
    });
    InteractionData2.prototype.getLocalPosition = function(displayObject, point, globalPos) {
      return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
    };
    InteractionData2.prototype.copyEvent = function(event) {
      if ("isPrimary" in event && event.isPrimary) {
        this.isPrimary = true;
      }
      this.button = "button" in event && event.button;
      var buttons = "buttons" in event && event.buttons;
      this.buttons = Number.isInteger(buttons) ? buttons : "which" in event && event.which;
      this.width = "width" in event && event.width;
      this.height = "height" in event && event.height;
      this.tiltX = "tiltX" in event && event.tiltX;
      this.tiltY = "tiltY" in event && event.tiltY;
      this.pointerType = "pointerType" in event && event.pointerType;
      this.pressure = "pressure" in event && event.pressure;
      this.rotationAngle = "rotationAngle" in event && event.rotationAngle;
      this.twist = "twist" in event && event.twist || 0;
      this.tangentialPressure = "tangentialPressure" in event && event.tangentialPressure || 0;
    };
    InteractionData2.prototype.reset = function() {
      this.isPrimary = false;
    };
    return InteractionData2;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$h = function(d, b) {
  extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$h(d, b);
};
function __extends$h(d, b) {
  extendStatics$h(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var InteractionEvent = (
  /** @class */
  function() {
    function InteractionEvent2() {
      this.stopped = false;
      this.stopsPropagatingAt = null;
      this.stopPropagationHint = false;
      this.target = null;
      this.currentTarget = null;
      this.type = null;
      this.data = null;
    }
    InteractionEvent2.prototype.stopPropagation = function() {
      this.stopped = true;
      this.stopPropagationHint = true;
      this.stopsPropagatingAt = this.currentTarget;
    };
    InteractionEvent2.prototype.reset = function() {
      this.stopped = false;
      this.stopsPropagatingAt = null;
      this.stopPropagationHint = false;
      this.currentTarget = null;
      this.target = null;
    };
    return InteractionEvent2;
  }()
);
var InteractionTrackingData = (
  /** @class */
  function() {
    function InteractionTrackingData2(pointerId) {
      this._pointerId = pointerId;
      this._flags = InteractionTrackingData2.FLAGS.NONE;
    }
    InteractionTrackingData2.prototype._doSet = function(flag, yn) {
      if (yn) {
        this._flags = this._flags | flag;
      } else {
        this._flags = this._flags & ~flag;
      }
    };
    Object.defineProperty(InteractionTrackingData2.prototype, "pointerId", {
      /**
       * Unique pointer id of the event
       * @readonly
       * @private
       * @member {number}
       */
      get: function() {
        return this._pointerId;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InteractionTrackingData2.prototype, "flags", {
      /**
       * State of the tracking data, expressed as bit flags
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags;
      },
      set: function(flags) {
        this._flags = flags;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InteractionTrackingData2.prototype, "none", {
      /**
       * Is the tracked event inactive (not over or down)?
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags === InteractionTrackingData2.FLAGS.NONE;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InteractionTrackingData2.prototype, "over", {
      /**
       * Is the tracked event over the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & InteractionTrackingData2.FLAGS.OVER) !== 0;
      },
      set: function(yn) {
        this._doSet(InteractionTrackingData2.FLAGS.OVER, yn);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InteractionTrackingData2.prototype, "rightDown", {
      /**
       * Did the right mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & InteractionTrackingData2.FLAGS.RIGHT_DOWN) !== 0;
      },
      set: function(yn) {
        this._doSet(InteractionTrackingData2.FLAGS.RIGHT_DOWN, yn);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InteractionTrackingData2.prototype, "leftDown", {
      /**
       * Did the left mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & InteractionTrackingData2.FLAGS.LEFT_DOWN) !== 0;
      },
      set: function(yn) {
        this._doSet(InteractionTrackingData2.FLAGS.LEFT_DOWN, yn);
      },
      enumerable: false,
      configurable: true
    });
    InteractionTrackingData2.FLAGS = Object.freeze({
      NONE: 0,
      OVER: 1 << 0,
      LEFT_DOWN: 1 << 1,
      RIGHT_DOWN: 1 << 2
    });
    return InteractionTrackingData2;
  }()
);
var TreeSearch = (
  /** @class */
  function() {
    function TreeSearch2() {
      this._tempPoint = new Point();
    }
    TreeSearch2.prototype.recursiveFindHit = function(interactionEvent, displayObject, func2, hitTest, interactive) {
      var _a2;
      if (!displayObject || !displayObject.visible) {
        return false;
      }
      var point = interactionEvent.data.global;
      interactive = displayObject.interactive || interactive;
      var hit = false;
      var interactiveParent = interactive;
      var hitTestChildren = true;
      if (displayObject.hitArea) {
        if (hitTest) {
          displayObject.worldTransform.applyInverse(point, this._tempPoint);
          if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
            hitTest = false;
            hitTestChildren = false;
          } else {
            hit = true;
          }
        }
        interactiveParent = false;
      } else if (displayObject._mask) {
        if (hitTest) {
          var maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
          if (maskObject && !((_a2 = maskObject.containsPoint) === null || _a2 === void 0 ? void 0 : _a2.call(maskObject, point))) {
            hitTest = false;
          }
        }
      }
      if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
        var children2 = displayObject.children;
        for (var i = children2.length - 1; i >= 0; i--) {
          var child = children2[i];
          var childHit = this.recursiveFindHit(interactionEvent, child, func2, hitTest, interactiveParent);
          if (childHit) {
            if (!child.parent) {
              continue;
            }
            interactiveParent = false;
            if (childHit) {
              if (interactionEvent.target) {
                hitTest = false;
              }
              hit = true;
            }
          }
        }
      }
      if (interactive) {
        if (hitTest && !interactionEvent.target) {
          if (!displayObject.hitArea && displayObject.containsPoint) {
            if (displayObject.containsPoint(point)) {
              hit = true;
            }
          }
        }
        if (displayObject.interactive) {
          if (hit && !interactionEvent.target) {
            interactionEvent.target = displayObject;
          }
          if (func2) {
            func2(interactionEvent, displayObject, !!hit);
          }
        }
      }
      return hit;
    };
    TreeSearch2.prototype.findHit = function(interactionEvent, displayObject, func2, hitTest) {
      this.recursiveFindHit(interactionEvent, displayObject, func2, hitTest, false);
    };
    return TreeSearch2;
  }()
);
var interactiveTarget = {
  interactive: false,
  interactiveChildren: true,
  hitArea: null,
  /**
   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
   * Setting this changes the 'cursor' property to `'pointer'`.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.buttonMode = true;
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(value) {
    if (value) {
      this.cursor = "pointer";
    } else if (this.cursor === "pointer") {
      this.cursor = null;
    }
  },
  /**
   * This defines what cursor mode is used when the mouse cursor
   * is hovered over the displayObject.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.cursor = 'wait';
   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  cursor: null,
  /**
   * Internal set of all active pointers, by identifier
   * @member {Map<number, InteractionTrackingData>}
   * @memberof PIXI.DisplayObject#
   * @private
   */
  get trackedPointers() {
    if (this._trackedPointers === void 0) {
      this._trackedPointers = {};
    }
    return this._trackedPointers;
  },
  /**
   * Map of all tracked pointers, by identifier. Use trackedPointers to access.
   * @private
   * @type {Map<number, InteractionTrackingData>}
   */
  _trackedPointers: void 0
};
DisplayObject.mixin(interactiveTarget);
var MOUSE_POINTER_ID = 1;
var hitTestEvent = {
  target: null,
  data: {
    global: null
  }
};
var InteractionManager = (
  /** @class */
  function(_super) {
    __extends$h(InteractionManager2, _super);
    function InteractionManager2(renderer, options) {
      var _this = _super.call(this) || this;
      options = options || {};
      _this.renderer = renderer;
      _this.autoPreventDefault = options.autoPreventDefault !== void 0 ? options.autoPreventDefault : true;
      _this.interactionFrequency = options.interactionFrequency || 10;
      _this.mouse = new InteractionData();
      _this.mouse.identifier = MOUSE_POINTER_ID;
      _this.mouse.global.set(-999999);
      _this.activeInteractionData = {};
      _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
      _this.interactionDataPool = [];
      _this.eventData = new InteractionEvent();
      _this.interactionDOMElement = null;
      _this.moveWhenInside = false;
      _this.eventsAdded = false;
      _this.tickerAdded = false;
      _this.mouseOverRenderer = !("PointerEvent" in globalThis);
      _this.supportsTouchEvents = "ontouchstart" in globalThis;
      _this.supportsPointerEvents = !!globalThis.PointerEvent;
      _this.onPointerUp = _this.onPointerUp.bind(_this);
      _this.processPointerUp = _this.processPointerUp.bind(_this);
      _this.onPointerCancel = _this.onPointerCancel.bind(_this);
      _this.processPointerCancel = _this.processPointerCancel.bind(_this);
      _this.onPointerDown = _this.onPointerDown.bind(_this);
      _this.processPointerDown = _this.processPointerDown.bind(_this);
      _this.onPointerMove = _this.onPointerMove.bind(_this);
      _this.processPointerMove = _this.processPointerMove.bind(_this);
      _this.onPointerOut = _this.onPointerOut.bind(_this);
      _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
      _this.onPointerOver = _this.onPointerOver.bind(_this);
      _this.cursorStyles = {
        default: "inherit",
        pointer: "pointer"
      };
      _this.currentCursorMode = null;
      _this.cursor = null;
      _this.resolution = 1;
      _this.delayedEvents = [];
      _this.search = new TreeSearch();
      _this._tempDisplayObject = new TemporaryDisplayObject();
      _this._eventListenerOptions = { capture: true, passive: false };
      _this._useSystemTicker = options.useSystemTicker !== void 0 ? options.useSystemTicker : true;
      _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);
      return _this;
    }
    Object.defineProperty(InteractionManager2.prototype, "useSystemTicker", {
      /**
       * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.
       * @default true
       */
      get: function() {
        return this._useSystemTicker;
      },
      set: function(useSystemTicker) {
        this._useSystemTicker = useSystemTicker;
        if (useSystemTicker) {
          this.addTickerListener();
        } else {
          this.removeTickerListener();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InteractionManager2.prototype, "lastObjectRendered", {
      /**
       * Last rendered object or temp object.
       * @readonly
       * @protected
       */
      get: function() {
        return this.renderer._lastObjectRendered || this._tempDisplayObject;
      },
      enumerable: false,
      configurable: true
    });
    InteractionManager2.prototype.hitTest = function(globalPoint, root2) {
      hitTestEvent.target = null;
      hitTestEvent.data.global = globalPoint;
      if (!root2) {
        root2 = this.lastObjectRendered;
      }
      this.processInteractive(hitTestEvent, root2, null, true);
      return hitTestEvent.target;
    };
    InteractionManager2.prototype.setTargetElement = function(element, resolution) {
      if (resolution === void 0) {
        resolution = 1;
      }
      this.removeTickerListener();
      this.removeEvents();
      this.interactionDOMElement = element;
      this.resolution = resolution;
      this.addEvents();
      this.addTickerListener();
    };
    InteractionManager2.prototype.addTickerListener = function() {
      if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {
        return;
      }
      Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
      this.tickerAdded = true;
    };
    InteractionManager2.prototype.removeTickerListener = function() {
      if (!this.tickerAdded) {
        return;
      }
      Ticker.system.remove(this.tickerUpdate, this);
      this.tickerAdded = false;
    };
    InteractionManager2.prototype.addEvents = function() {
      if (this.eventsAdded || !this.interactionDOMElement) {
        return;
      }
      var style = this.interactionDOMElement.style;
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "none";
        style.msTouchAction = "none";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "none";
      }
      if (this.supportsPointerEvents) {
        globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions);
        globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions);
        globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions);
      } else {
        globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions);
        globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions);
      }
      if (this.supportsTouchEvents) {
        this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions);
      }
      this.eventsAdded = true;
    };
    InteractionManager2.prototype.removeEvents = function() {
      if (!this.eventsAdded || !this.interactionDOMElement) {
        return;
      }
      var style = this.interactionDOMElement.style;
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "";
        style.msTouchAction = "";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "";
      }
      if (this.supportsPointerEvents) {
        globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions);
        globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions);
        globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions);
      } else {
        globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions);
        globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions);
      }
      if (this.supportsTouchEvents) {
        this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions);
      }
      this.interactionDOMElement = null;
      this.eventsAdded = false;
    };
    InteractionManager2.prototype.tickerUpdate = function(deltaTime) {
      this._deltaTime += deltaTime;
      if (this._deltaTime < this.interactionFrequency) {
        return;
      }
      this._deltaTime = 0;
      this.update();
    };
    InteractionManager2.prototype.update = function() {
      if (!this.interactionDOMElement) {
        return;
      }
      if (this._didMove) {
        this._didMove = false;
        return;
      }
      this.cursor = null;
      for (var k in this.activeInteractionData) {
        if (this.activeInteractionData.hasOwnProperty(k)) {
          var interactionData = this.activeInteractionData[k];
          if (interactionData.originalEvent && interactionData.pointerType !== "touch") {
            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
            this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, true);
          }
        }
      }
      this.setCursorMode(this.cursor);
    };
    InteractionManager2.prototype.setCursorMode = function(mode) {
      mode = mode || "default";
      var applyStyles = true;
      if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas) {
        applyStyles = false;
      }
      if (this.currentCursorMode === mode) {
        return;
      }
      this.currentCursorMode = mode;
      var style = this.cursorStyles[mode];
      if (style) {
        switch (typeof style) {
          case "string":
            if (applyStyles) {
              this.interactionDOMElement.style.cursor = style;
            }
            break;
          case "function":
            style(mode);
            break;
          case "object":
            if (applyStyles) {
              Object.assign(this.interactionDOMElement.style, style);
            }
            break;
        }
      } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
        this.interactionDOMElement.style.cursor = mode;
      }
    };
    InteractionManager2.prototype.dispatchEvent = function(displayObject, eventString, eventData) {
      if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {
        eventData.currentTarget = displayObject;
        eventData.type = eventString;
        displayObject.emit(eventString, eventData);
        if (displayObject[eventString]) {
          displayObject[eventString](eventData);
        }
      }
    };
    InteractionManager2.prototype.delayDispatchEvent = function(displayObject, eventString, eventData) {
      this.delayedEvents.push({ displayObject, eventString, eventData });
    };
    InteractionManager2.prototype.mapPositionToPoint = function(point, x, y) {
      var rect;
      if (!this.interactionDOMElement.parentElement) {
        rect = {
          x: 0,
          y: 0,
          width: this.interactionDOMElement.width,
          height: this.interactionDOMElement.height,
          left: 0,
          top: 0
        };
      } else {
        rect = this.interactionDOMElement.getBoundingClientRect();
      }
      var resolutionMultiplier = 1 / this.resolution;
      point.x = (x - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
      point.y = (y - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
    };
    InteractionManager2.prototype.processInteractive = function(interactionEvent, displayObject, func2, hitTest) {
      var hit = this.search.findHit(interactionEvent, displayObject, func2, hitTest);
      var delayedEvents = this.delayedEvents;
      if (!delayedEvents.length) {
        return hit;
      }
      interactionEvent.stopPropagationHint = false;
      var delayedLen = delayedEvents.length;
      this.delayedEvents = [];
      for (var i = 0; i < delayedLen; i++) {
        var _a2 = delayedEvents[i], displayObject_1 = _a2.displayObject, eventString = _a2.eventString, eventData = _a2.eventData;
        if (eventData.stopsPropagatingAt === displayObject_1) {
          eventData.stopPropagationHint = true;
        }
        this.dispatchEvent(displayObject_1, eventString, eventData);
      }
      return hit;
    };
    InteractionManager2.prototype.onPointerDown = function(originalEvent) {
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
        return;
      }
      var events = this.normalizeToPointerData(originalEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        var cancelable = originalEvent.cancelable || !("cancelable" in originalEvent);
        if (cancelable) {
          originalEvent.preventDefault();
        }
      }
      var eventLen = events.length;
      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerDown, true);
        this.emit("pointerdown", interactionEvent);
        if (event.pointerType === "touch") {
          this.emit("touchstart", interactionEvent);
        } else if (event.pointerType === "mouse" || event.pointerType === "pen") {
          var isRightButton = event.button === 2;
          this.emit(isRightButton ? "rightdown" : "mousedown", this.eventData);
        }
      }
    };
    InteractionManager2.prototype.processPointerDown = function(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id2 = interactionEvent.data.identifier;
      if (hit) {
        if (!displayObject.trackedPointers[id2]) {
          displayObject.trackedPointers[id2] = new InteractionTrackingData(id2);
        }
        this.dispatchEvent(displayObject, "pointerdown", interactionEvent);
        if (data.pointerType === "touch") {
          this.dispatchEvent(displayObject, "touchstart", interactionEvent);
        } else if (data.pointerType === "mouse" || data.pointerType === "pen") {
          var isRightButton = data.button === 2;
          if (isRightButton) {
            displayObject.trackedPointers[id2].rightDown = true;
          } else {
            displayObject.trackedPointers[id2].leftDown = true;
          }
          this.dispatchEvent(displayObject, isRightButton ? "rightdown" : "mousedown", interactionEvent);
        }
      }
    };
    InteractionManager2.prototype.onPointerComplete = function(originalEvent, cancelled, func2) {
      var events = this.normalizeToPointerData(originalEvent);
      var eventLen = events.length;
      var target = originalEvent.target;
      if (originalEvent.composedPath && originalEvent.composedPath().length > 0) {
        target = originalEvent.composedPath()[0];
      }
      var eventAppend = target !== this.interactionDOMElement ? "outside" : "";
      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        this.processInteractive(interactionEvent, this.lastObjectRendered, func2, cancelled || !eventAppend);
        this.emit(cancelled ? "pointercancel" : "pointerup" + eventAppend, interactionEvent);
        if (event.pointerType === "mouse" || event.pointerType === "pen") {
          var isRightButton = event.button === 2;
          this.emit(isRightButton ? "rightup" + eventAppend : "mouseup" + eventAppend, interactionEvent);
        } else if (event.pointerType === "touch") {
          this.emit(cancelled ? "touchcancel" : "touchend" + eventAppend, interactionEvent);
          this.releaseInteractionDataForPointerId(event.pointerId);
        }
      }
    };
    InteractionManager2.prototype.onPointerCancel = function(event) {
      if (this.supportsTouchEvents && event.pointerType === "touch") {
        return;
      }
      this.onPointerComplete(event, true, this.processPointerCancel);
    };
    InteractionManager2.prototype.processPointerCancel = function(interactionEvent, displayObject) {
      var data = interactionEvent.data;
      var id2 = interactionEvent.data.identifier;
      if (displayObject.trackedPointers[id2] !== void 0) {
        delete displayObject.trackedPointers[id2];
        this.dispatchEvent(displayObject, "pointercancel", interactionEvent);
        if (data.pointerType === "touch") {
          this.dispatchEvent(displayObject, "touchcancel", interactionEvent);
        }
      }
    };
    InteractionManager2.prototype.onPointerUp = function(event) {
      if (this.supportsTouchEvents && event.pointerType === "touch") {
        return;
      }
      this.onPointerComplete(event, false, this.processPointerUp);
    };
    InteractionManager2.prototype.processPointerUp = function(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id2 = interactionEvent.data.identifier;
      var trackingData = displayObject.trackedPointers[id2];
      var isTouch = data.pointerType === "touch";
      var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
      var isMouseTap = false;
      if (isMouse) {
        var isRightButton = data.button === 2;
        var flags = InteractionTrackingData.FLAGS;
        var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
        var isDown = trackingData !== void 0 && trackingData.flags & test;
        if (hit) {
          this.dispatchEvent(displayObject, isRightButton ? "rightup" : "mouseup", interactionEvent);
          if (isDown) {
            this.dispatchEvent(displayObject, isRightButton ? "rightclick" : "click", interactionEvent);
            isMouseTap = true;
          }
        } else if (isDown) {
          this.dispatchEvent(displayObject, isRightButton ? "rightupoutside" : "mouseupoutside", interactionEvent);
        }
        if (trackingData) {
          if (isRightButton) {
            trackingData.rightDown = false;
          } else {
            trackingData.leftDown = false;
          }
        }
      }
      if (hit) {
        this.dispatchEvent(displayObject, "pointerup", interactionEvent);
        if (isTouch) {
          this.dispatchEvent(displayObject, "touchend", interactionEvent);
        }
        if (trackingData) {
          if (!isMouse || isMouseTap) {
            this.dispatchEvent(displayObject, "pointertap", interactionEvent);
          }
          if (isTouch) {
            this.dispatchEvent(displayObject, "tap", interactionEvent);
            trackingData.over = false;
          }
        }
      } else if (trackingData) {
        this.dispatchEvent(displayObject, "pointerupoutside", interactionEvent);
        if (isTouch) {
          this.dispatchEvent(displayObject, "touchendoutside", interactionEvent);
        }
      }
      if (trackingData && trackingData.none) {
        delete displayObject.trackedPointers[id2];
      }
    };
    InteractionManager2.prototype.onPointerMove = function(originalEvent) {
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
        return;
      }
      var events = this.normalizeToPointerData(originalEvent);
      if (events[0].pointerType === "mouse" || events[0].pointerType === "pen") {
        this._didMove = true;
        this.cursor = null;
      }
      var eventLen = events.length;
      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerMove, true);
        this.emit("pointermove", interactionEvent);
        if (event.pointerType === "touch") {
          this.emit("touchmove", interactionEvent);
        }
        if (event.pointerType === "mouse" || event.pointerType === "pen") {
          this.emit("mousemove", interactionEvent);
        }
      }
      if (events[0].pointerType === "mouse") {
        this.setCursorMode(this.cursor);
      }
    };
    InteractionManager2.prototype.processPointerMove = function(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var isTouch = data.pointerType === "touch";
      var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
      if (isMouse) {
        this.processPointerOverOut(interactionEvent, displayObject, hit);
      }
      if (!this.moveWhenInside || hit) {
        this.dispatchEvent(displayObject, "pointermove", interactionEvent);
        if (isTouch) {
          this.dispatchEvent(displayObject, "touchmove", interactionEvent);
        }
        if (isMouse) {
          this.dispatchEvent(displayObject, "mousemove", interactionEvent);
        }
      }
    };
    InteractionManager2.prototype.onPointerOut = function(originalEvent) {
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
        return;
      }
      var events = this.normalizeToPointerData(originalEvent);
      var event = events[0];
      if (event.pointerType === "mouse") {
        this.mouseOverRenderer = false;
        this.setCursorMode(null);
      }
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = event;
      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, false);
      this.emit("pointerout", interactionEvent);
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        this.emit("mouseout", interactionEvent);
      } else {
        this.releaseInteractionDataForPointerId(interactionData.identifier);
      }
    };
    InteractionManager2.prototype.processPointerOverOut = function(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id2 = interactionEvent.data.identifier;
      var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
      var trackingData = displayObject.trackedPointers[id2];
      if (hit && !trackingData) {
        trackingData = displayObject.trackedPointers[id2] = new InteractionTrackingData(id2);
      }
      if (trackingData === void 0) {
        return;
      }
      if (hit && this.mouseOverRenderer) {
        if (!trackingData.over) {
          trackingData.over = true;
          this.delayDispatchEvent(displayObject, "pointerover", interactionEvent);
          if (isMouse) {
            this.delayDispatchEvent(displayObject, "mouseover", interactionEvent);
          }
        }
        if (isMouse && this.cursor === null) {
          this.cursor = displayObject.cursor;
        }
      } else if (trackingData.over) {
        trackingData.over = false;
        this.dispatchEvent(displayObject, "pointerout", this.eventData);
        if (isMouse) {
          this.dispatchEvent(displayObject, "mouseout", interactionEvent);
        }
        if (trackingData.none) {
          delete displayObject.trackedPointers[id2];
        }
      }
    };
    InteractionManager2.prototype.onPointerOver = function(originalEvent) {
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
        return;
      }
      var events = this.normalizeToPointerData(originalEvent);
      var event = events[0];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = event;
      if (event.pointerType === "mouse") {
        this.mouseOverRenderer = true;
      }
      this.emit("pointerover", interactionEvent);
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        this.emit("mouseover", interactionEvent);
      }
    };
    InteractionManager2.prototype.getInteractionDataForPointerId = function(event) {
      var pointerId = event.pointerId;
      var interactionData;
      if (pointerId === MOUSE_POINTER_ID || event.pointerType === "mouse") {
        interactionData = this.mouse;
      } else if (this.activeInteractionData[pointerId]) {
        interactionData = this.activeInteractionData[pointerId];
      } else {
        interactionData = this.interactionDataPool.pop() || new InteractionData();
        interactionData.identifier = pointerId;
        this.activeInteractionData[pointerId] = interactionData;
      }
      interactionData.copyEvent(event);
      return interactionData;
    };
    InteractionManager2.prototype.releaseInteractionDataForPointerId = function(pointerId) {
      var interactionData = this.activeInteractionData[pointerId];
      if (interactionData) {
        delete this.activeInteractionData[pointerId];
        interactionData.reset();
        this.interactionDataPool.push(interactionData);
      }
    };
    InteractionManager2.prototype.configureInteractionEventForDOMEvent = function(interactionEvent, pointerEvent, interactionData) {
      interactionEvent.data = interactionData;
      this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
      if (pointerEvent.pointerType === "touch") {
        pointerEvent.globalX = interactionData.global.x;
        pointerEvent.globalY = interactionData.global.y;
      }
      interactionData.originalEvent = pointerEvent;
      interactionEvent.reset();
      return interactionEvent;
    };
    InteractionManager2.prototype.normalizeToPointerData = function(event) {
      var normalizedEvents = [];
      if (this.supportsTouchEvents && event instanceof TouchEvent) {
        for (var i = 0, li = event.changedTouches.length; i < li; i++) {
          var touch = event.changedTouches[i];
          if (typeof touch.button === "undefined") {
            touch.button = event.touches.length ? 1 : 0;
          }
          if (typeof touch.buttons === "undefined") {
            touch.buttons = event.touches.length ? 1 : 0;
          }
          if (typeof touch.isPrimary === "undefined") {
            touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
          }
          if (typeof touch.width === "undefined") {
            touch.width = touch.radiusX || 1;
          }
          if (typeof touch.height === "undefined") {
            touch.height = touch.radiusY || 1;
          }
          if (typeof touch.tiltX === "undefined") {
            touch.tiltX = 0;
          }
          if (typeof touch.tiltY === "undefined") {
            touch.tiltY = 0;
          }
          if (typeof touch.pointerType === "undefined") {
            touch.pointerType = "touch";
          }
          if (typeof touch.pointerId === "undefined") {
            touch.pointerId = touch.identifier || 0;
          }
          if (typeof touch.pressure === "undefined") {
            touch.pressure = touch.force || 0.5;
          }
          if (typeof touch.twist === "undefined") {
            touch.twist = 0;
          }
          if (typeof touch.tangentialPressure === "undefined") {
            touch.tangentialPressure = 0;
          }
          if (typeof touch.layerX === "undefined") {
            touch.layerX = touch.offsetX = touch.clientX;
          }
          if (typeof touch.layerY === "undefined") {
            touch.layerY = touch.offsetY = touch.clientY;
          }
          touch.isNormalized = true;
          normalizedEvents.push(touch);
        }
      } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
        var tempEvent = event;
        if (typeof tempEvent.isPrimary === "undefined") {
          tempEvent.isPrimary = true;
        }
        if (typeof tempEvent.width === "undefined") {
          tempEvent.width = 1;
        }
        if (typeof tempEvent.height === "undefined") {
          tempEvent.height = 1;
        }
        if (typeof tempEvent.tiltX === "undefined") {
          tempEvent.tiltX = 0;
        }
        if (typeof tempEvent.tiltY === "undefined") {
          tempEvent.tiltY = 0;
        }
        if (typeof tempEvent.pointerType === "undefined") {
          tempEvent.pointerType = "mouse";
        }
        if (typeof tempEvent.pointerId === "undefined") {
          tempEvent.pointerId = MOUSE_POINTER_ID;
        }
        if (typeof tempEvent.pressure === "undefined") {
          tempEvent.pressure = 0.5;
        }
        if (typeof tempEvent.twist === "undefined") {
          tempEvent.twist = 0;
        }
        if (typeof tempEvent.tangentialPressure === "undefined") {
          tempEvent.tangentialPressure = 0;
        }
        tempEvent.isNormalized = true;
        normalizedEvents.push(tempEvent);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    };
    InteractionManager2.prototype.destroy = function() {
      this.removeEvents();
      this.removeTickerListener();
      this.removeAllListeners();
      this.renderer = null;
      this.mouse = null;
      this.eventData = null;
      this.interactionDOMElement = null;
      this.onPointerDown = null;
      this.processPointerDown = null;
      this.onPointerUp = null;
      this.processPointerUp = null;
      this.onPointerCancel = null;
      this.processPointerCancel = null;
      this.onPointerMove = null;
      this.processPointerMove = null;
      this.onPointerOut = null;
      this.processPointerOverOut = null;
      this.onPointerOver = null;
      this.search = null;
    };
    InteractionManager2.extension = {
      name: "interaction",
      type: [
        ExtensionType.RendererPlugin,
        ExtensionType.CanvasRendererPlugin
      ]
    };
    return InteractionManager2;
  }(EventEmitter)
);
/*!
 * @pixi/extract - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var TEMP_RECT = new Rectangle();
var BYTES_PER_PIXEL = 4;
var Extract = (
  /** @class */
  function() {
    function Extract2(renderer) {
      this.renderer = renderer;
    }
    Extract2.prototype.image = function(target, format2, quality) {
      var image = new Image();
      image.src = this.base64(target, format2, quality);
      return image;
    };
    Extract2.prototype.base64 = function(target, format2, quality) {
      return this.canvas(target).toDataURL(format2, quality);
    };
    Extract2.prototype.canvas = function(target, frame2) {
      var _a2 = this._rawPixels(target, frame2), pixels = _a2.pixels, width = _a2.width, height = _a2.height, flipY = _a2.flipY;
      var canvasBuffer = new CanvasRenderTarget(width, height, 1);
      var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
      Extract2.arrayPostDivide(pixels, canvasData.data);
      canvasBuffer.context.putImageData(canvasData, 0, 0);
      if (flipY) {
        var target_1 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
        target_1.context.scale(1, -1);
        target_1.context.drawImage(canvasBuffer.canvas, 0, -height);
        canvasBuffer.destroy();
        canvasBuffer = target_1;
      }
      return canvasBuffer.canvas;
    };
    Extract2.prototype.pixels = function(target, frame2) {
      var pixels = this._rawPixels(target, frame2).pixels;
      Extract2.arrayPostDivide(pixels, pixels);
      return pixels;
    };
    Extract2.prototype._rawPixels = function(target, frame2) {
      var renderer = this.renderer;
      var resolution;
      var flipY = false;
      var renderTexture;
      var generated = false;
      if (target) {
        if (target instanceof RenderTexture) {
          renderTexture = target;
        } else {
          var multisample = renderer.context.webGLVersion >= 2 ? renderer.multisample : MSAA_QUALITY.NONE;
          renderTexture = this.renderer.generateTexture(target, { multisample });
          if (multisample !== MSAA_QUALITY.NONE) {
            var resolvedTexture = RenderTexture.create({
              width: renderTexture.width,
              height: renderTexture.height
            });
            renderer.framebuffer.bind(renderTexture.framebuffer);
            renderer.framebuffer.blit(resolvedTexture.framebuffer);
            renderer.framebuffer.bind(null);
            renderTexture.destroy(true);
            renderTexture = resolvedTexture;
          }
          generated = true;
        }
      }
      if (renderTexture) {
        resolution = renderTexture.baseTexture.resolution;
        frame2 = frame2 !== null && frame2 !== void 0 ? frame2 : renderTexture.frame;
        flipY = false;
        renderer.renderTexture.bind(renderTexture);
      } else {
        resolution = renderer.resolution;
        if (!frame2) {
          frame2 = TEMP_RECT;
          frame2.width = renderer.width;
          frame2.height = renderer.height;
        }
        flipY = true;
        renderer.renderTexture.bind(null);
      }
      var width = Math.round(frame2.width * resolution);
      var height = Math.round(frame2.height * resolution);
      var pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
      var gl = renderer.gl;
      gl.readPixels(Math.round(frame2.x * resolution), Math.round(frame2.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      if (generated) {
        renderTexture.destroy(true);
      }
      return { pixels, width, height, flipY };
    };
    Extract2.prototype.destroy = function() {
      this.renderer = null;
    };
    Extract2.arrayPostDivide = function(pixels, out) {
      for (var i = 0; i < pixels.length; i += 4) {
        var alpha = out[i + 3] = pixels[i + 3];
        if (alpha !== 0) {
          out[i] = Math.round(Math.min(pixels[i] * 255 / alpha, 255));
          out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255 / alpha, 255));
          out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255 / alpha, 255));
        } else {
          out[i] = pixels[i];
          out[i + 1] = pixels[i + 1];
          out[i + 2] = pixels[i + 2];
        }
      }
    };
    Extract2.extension = {
      name: "extract",
      type: ExtensionType.RendererPlugin
    };
    return Extract2;
  }()
);
/*!
 * @pixi/loaders - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var SignalBinding = (
  /** @class */
  function() {
    function SignalBinding2(fn, once, thisArg) {
      if (once === void 0) {
        once = false;
      }
      this._fn = fn;
      this._once = once;
      this._thisArg = thisArg;
      this._next = this._prev = this._owner = null;
    }
    SignalBinding2.prototype.detach = function() {
      if (this._owner === null) {
        return false;
      }
      this._owner.detach(this);
      return true;
    };
    return SignalBinding2;
  }()
);
function _addSignalBinding(self2, node) {
  if (!self2._head) {
    self2._head = node;
    self2._tail = node;
  } else {
    self2._tail._next = node;
    node._prev = self2._tail;
    self2._tail = node;
  }
  node._owner = self2;
  return node;
}
var Signal = (
  /** @class */
  function() {
    function Signal2() {
      this._head = this._tail = void 0;
    }
    Signal2.prototype.handlers = function(exists) {
      if (exists === void 0) {
        exists = false;
      }
      var node = this._head;
      if (exists) {
        return !!node;
      }
      var ee = [];
      while (node) {
        ee.push(node);
        node = node._next;
      }
      return ee;
    };
    Signal2.prototype.has = function(node) {
      if (!(node instanceof SignalBinding)) {
        throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
      }
      return node._owner === this;
    };
    Signal2.prototype.dispatch = function() {
      var arguments$1 = arguments;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments$1[_i];
      }
      var node = this._head;
      if (!node) {
        return false;
      }
      while (node) {
        if (node._once) {
          this.detach(node);
        }
        node._fn.apply(node._thisArg, args);
        node = node._next;
      }
      return true;
    };
    Signal2.prototype.add = function(fn, thisArg) {
      if (thisArg === void 0) {
        thisArg = null;
      }
      if (typeof fn !== "function") {
        throw new Error("MiniSignal#add(): First arg must be a Function.");
      }
      return _addSignalBinding(this, new SignalBinding(fn, false, thisArg));
    };
    Signal2.prototype.once = function(fn, thisArg) {
      if (thisArg === void 0) {
        thisArg = null;
      }
      if (typeof fn !== "function") {
        throw new Error("MiniSignal#once(): First arg must be a Function.");
      }
      return _addSignalBinding(this, new SignalBinding(fn, true, thisArg));
    };
    Signal2.prototype.detach = function(node) {
      if (!(node instanceof SignalBinding)) {
        throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
      }
      if (node._owner !== this) {
        return this;
      }
      if (node._prev) {
        node._prev._next = node._next;
      }
      if (node._next) {
        node._next._prev = node._prev;
      }
      if (node === this._head) {
        this._head = node._next;
        if (node._next === null) {
          this._tail = null;
        }
      } else if (node === this._tail) {
        this._tail = node._prev;
        this._tail._next = null;
      }
      node._owner = null;
      return this;
    };
    Signal2.prototype.detachAll = function() {
      var node = this._head;
      if (!node) {
        return this;
      }
      this._head = this._tail = null;
      while (node) {
        node._owner = null;
        node = node._next;
      }
      return this;
    };
    return Signal2;
  }()
);
function parseUri(str, opts) {
  opts = opts || {};
  var o = {
    // eslint-disable-next-line max-len
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      // eslint-disable-next-line max-len
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      // eslint-disable-next-line max-len
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  };
  var m = o.parser[opts.strictMode ? "strict" : "loose"].exec(str);
  var uri2 = {};
  var i = 14;
  while (i--) {
    uri2[o.key[i]] = m[i] || "";
  }
  uri2[o.q.name] = {};
  uri2[o.key[12]].replace(o.q.parser, function(_t0, t1, t2) {
    if (t1) {
      uri2[o.q.name][t1] = t2;
    }
  });
  return uri2;
}
var useXdr;
var tempAnchor = null;
var STATUS_NONE = 0;
var STATUS_OK = 200;
var STATUS_EMPTY = 204;
var STATUS_IE_BUG_EMPTY = 1223;
var STATUS_TYPE_OK = 2;
function _noop$1() {
}
function setExtMap(map2, extname, val) {
  if (extname && extname.indexOf(".") === 0) {
    extname = extname.substring(1);
  }
  if (!extname) {
    return;
  }
  map2[extname] = val;
}
function reqType(xhr) {
  return xhr.toString().replace("object ", "");
}
var LoaderResource = (
  /** @class */
  function() {
    function LoaderResource2(name2, url2, options) {
      this._dequeue = _noop$1;
      this._onLoadBinding = null;
      this._elementTimer = 0;
      this._boundComplete = null;
      this._boundOnError = null;
      this._boundOnProgress = null;
      this._boundOnTimeout = null;
      this._boundXhrOnError = null;
      this._boundXhrOnTimeout = null;
      this._boundXhrOnAbort = null;
      this._boundXhrOnLoad = null;
      if (typeof name2 !== "string" || typeof url2 !== "string") {
        throw new Error("Both name and url are required for constructing a resource.");
      }
      options = options || {};
      this._flags = 0;
      this._setFlag(LoaderResource2.STATUS_FLAGS.DATA_URL, url2.indexOf("data:") === 0);
      this.name = name2;
      this.url = url2;
      this.extension = this._getExtension();
      this.data = null;
      this.crossOrigin = options.crossOrigin === true ? "anonymous" : options.crossOrigin;
      this.timeout = options.timeout || 0;
      this.loadType = options.loadType || this._determineLoadType();
      this.xhrType = options.xhrType;
      this.metadata = options.metadata || {};
      this.error = null;
      this.xhr = null;
      this.children = [];
      this.type = LoaderResource2.TYPE.UNKNOWN;
      this.progressChunk = 0;
      this._dequeue = _noop$1;
      this._onLoadBinding = null;
      this._elementTimer = 0;
      this._boundComplete = this.complete.bind(this);
      this._boundOnError = this._onError.bind(this);
      this._boundOnProgress = this._onProgress.bind(this);
      this._boundOnTimeout = this._onTimeout.bind(this);
      this._boundXhrOnError = this._xhrOnError.bind(this);
      this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);
      this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
      this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
      this.onStart = new Signal();
      this.onProgress = new Signal();
      this.onComplete = new Signal();
      this.onAfterMiddleware = new Signal();
    }
    LoaderResource2.setExtensionLoadType = function(extname, loadType) {
      setExtMap(LoaderResource2._loadTypeMap, extname, loadType);
    };
    LoaderResource2.setExtensionXhrType = function(extname, xhrType) {
      setExtMap(LoaderResource2._xhrTypeMap, extname, xhrType);
    };
    Object.defineProperty(LoaderResource2.prototype, "isDataUrl", {
      /**
       * When the resource starts to load.
       * @memberof PIXI.LoaderResource
       * @callback OnStartSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * When the resource reports loading progress.
       * @memberof PIXI.LoaderResource
       * @callback OnProgressSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       * @param {number} percentage - The progress of the load in the range [0, 1].
       */
      /**
       * When the resource finishes loading.
       * @memberof PIXI.LoaderResource
       * @callback OnCompleteSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * @memberof PIXI.LoaderResource
       * @typedef {object} IMetadata
       * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
       *      element to use for loading, instead of creating one.
       * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
       *      is useful if you want to pass in a `loadElement` that you already added load sources to.
       * @property {string|string[]} [mimeType] - The mime type to use for the source element
       *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
       *      where each index is the mime type to use for the corresponding url index.
       */
      /**
       * Stores whether or not this url is a data url.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(LoaderResource2.STATUS_FLAGS.DATA_URL);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LoaderResource2.prototype, "isComplete", {
      /**
       * Describes if this resource has finished loading. Is true when the resource has completely
       * loaded.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(LoaderResource2.STATUS_FLAGS.COMPLETE);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LoaderResource2.prototype, "isLoading", {
      /**
       * Describes if this resource is currently loading. Is true when the resource starts loading,
       * and is false again when complete.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(LoaderResource2.STATUS_FLAGS.LOADING);
      },
      enumerable: false,
      configurable: true
    });
    LoaderResource2.prototype.complete = function() {
      this._clearEvents();
      this._finish();
    };
    LoaderResource2.prototype.abort = function(message) {
      if (this.error) {
        return;
      }
      this.error = new Error(message);
      this._clearEvents();
      if (this.xhr) {
        this.xhr.abort();
      } else if (this.xdr) {
        this.xdr.abort();
      } else if (this.data) {
        if (this.data.src) {
          this.data.src = LoaderResource2.EMPTY_GIF;
        } else {
          while (this.data.firstChild) {
            this.data.removeChild(this.data.firstChild);
          }
        }
      }
      this._finish();
    };
    LoaderResource2.prototype.load = function(cb) {
      var _this = this;
      if (this.isLoading) {
        return;
      }
      if (this.isComplete) {
        if (cb) {
          setTimeout(function() {
            return cb(_this);
          }, 1);
        }
        return;
      } else if (cb) {
        this.onComplete.once(cb);
      }
      this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, true);
      this.onStart.dispatch(this);
      if (this.crossOrigin === false || typeof this.crossOrigin !== "string") {
        this.crossOrigin = this._determineCrossOrigin(this.url);
      }
      switch (this.loadType) {
        case LoaderResource2.LOAD_TYPE.IMAGE:
          this.type = LoaderResource2.TYPE.IMAGE;
          this._loadElement("image");
          break;
        case LoaderResource2.LOAD_TYPE.AUDIO:
          this.type = LoaderResource2.TYPE.AUDIO;
          this._loadSourceElement("audio");
          break;
        case LoaderResource2.LOAD_TYPE.VIDEO:
          this.type = LoaderResource2.TYPE.VIDEO;
          this._loadSourceElement("video");
          break;
        case LoaderResource2.LOAD_TYPE.XHR:
        default:
          if (typeof useXdr === "undefined") {
            useXdr = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()));
          }
          if (useXdr && this.crossOrigin) {
            this._loadXdr();
          } else {
            this._loadXhr();
          }
          break;
      }
    };
    LoaderResource2.prototype._hasFlag = function(flag) {
      return (this._flags & flag) !== 0;
    };
    LoaderResource2.prototype._setFlag = function(flag, value) {
      this._flags = value ? this._flags | flag : this._flags & ~flag;
    };
    LoaderResource2.prototype._clearEvents = function() {
      clearTimeout(this._elementTimer);
      if (this.data && this.data.removeEventListener) {
        this.data.removeEventListener("error", this._boundOnError, false);
        this.data.removeEventListener("load", this._boundComplete, false);
        this.data.removeEventListener("progress", this._boundOnProgress, false);
        this.data.removeEventListener("canplaythrough", this._boundComplete, false);
      }
      if (this.xhr) {
        if (this.xhr.removeEventListener) {
          this.xhr.removeEventListener("error", this._boundXhrOnError, false);
          this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false);
          this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false);
          this.xhr.removeEventListener("progress", this._boundOnProgress, false);
          this.xhr.removeEventListener("load", this._boundXhrOnLoad, false);
        } else {
          this.xhr.onerror = null;
          this.xhr.ontimeout = null;
          this.xhr.onprogress = null;
          this.xhr.onload = null;
        }
      }
    };
    LoaderResource2.prototype._finish = function() {
      if (this.isComplete) {
        throw new Error("Complete called again for an already completed resource.");
      }
      this._setFlag(LoaderResource2.STATUS_FLAGS.COMPLETE, true);
      this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, false);
      this.onComplete.dispatch(this);
    };
    LoaderResource2.prototype._loadElement = function(type2) {
      if (this.metadata.loadElement) {
        this.data = this.metadata.loadElement;
      } else if (type2 === "image" && typeof globalThis.Image !== "undefined") {
        this.data = new Image();
      } else {
        this.data = document.createElement(type2);
      }
      if (this.crossOrigin) {
        this.data.crossOrigin = this.crossOrigin;
      }
      if (!this.metadata.skipSource) {
        this.data.src = this.url;
      }
      this.data.addEventListener("error", this._boundOnError, false);
      this.data.addEventListener("load", this._boundComplete, false);
      this.data.addEventListener("progress", this._boundOnProgress, false);
      if (this.timeout) {
        this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
      }
    };
    LoaderResource2.prototype._loadSourceElement = function(type2) {
      if (this.metadata.loadElement) {
        this.data = this.metadata.loadElement;
      } else if (type2 === "audio" && typeof globalThis.Audio !== "undefined") {
        this.data = new Audio();
      } else {
        this.data = document.createElement(type2);
      }
      if (this.data === null) {
        this.abort("Unsupported element: " + type2);
        return;
      }
      if (this.crossOrigin) {
        this.data.crossOrigin = this.crossOrigin;
      }
      if (!this.metadata.skipSource) {
        if (navigator.isCocoonJS) {
          this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
        } else if (Array.isArray(this.url)) {
          var mimeTypes = this.metadata.mimeType;
          for (var i = 0; i < this.url.length; ++i) {
            this.data.appendChild(this._createSource(type2, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
          }
        } else {
          var mimeTypes = this.metadata.mimeType;
          this.data.appendChild(this._createSource(type2, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes));
        }
      }
      this.data.addEventListener("error", this._boundOnError, false);
      this.data.addEventListener("load", this._boundComplete, false);
      this.data.addEventListener("progress", this._boundOnProgress, false);
      this.data.addEventListener("canplaythrough", this._boundComplete, false);
      this.data.load();
      if (this.timeout) {
        this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
      }
    };
    LoaderResource2.prototype._loadXhr = function() {
      if (typeof this.xhrType !== "string") {
        this.xhrType = this._determineXhrType();
      }
      var xhr = this.xhr = new XMLHttpRequest();
      if (this.crossOrigin === "use-credentials") {
        xhr.withCredentials = true;
      }
      xhr.open("GET", this.url, true);
      xhr.timeout = this.timeout;
      if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON || this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {
        xhr.responseType = LoaderResource2.XHR_RESPONSE_TYPE.TEXT;
      } else {
        xhr.responseType = this.xhrType;
      }
      xhr.addEventListener("error", this._boundXhrOnError, false);
      xhr.addEventListener("timeout", this._boundXhrOnTimeout, false);
      xhr.addEventListener("abort", this._boundXhrOnAbort, false);
      xhr.addEventListener("progress", this._boundOnProgress, false);
      xhr.addEventListener("load", this._boundXhrOnLoad, false);
      xhr.send();
    };
    LoaderResource2.prototype._loadXdr = function() {
      if (typeof this.xhrType !== "string") {
        this.xhrType = this._determineXhrType();
      }
      var xdr = this.xhr = new globalThis.XDomainRequest();
      xdr.timeout = this.timeout || 5e3;
      xdr.onerror = this._boundXhrOnError;
      xdr.ontimeout = this._boundXhrOnTimeout;
      xdr.onprogress = this._boundOnProgress;
      xdr.onload = this._boundXhrOnLoad;
      xdr.open("GET", this.url, true);
      setTimeout(function() {
        return xdr.send();
      }, 1);
    };
    LoaderResource2.prototype._createSource = function(type2, url2, mime) {
      if (!mime) {
        mime = type2 + "/" + this._getExtension(url2);
      }
      var source = document.createElement("source");
      source.src = url2;
      source.type = mime;
      return source;
    };
    LoaderResource2.prototype._onError = function(event) {
      this.abort("Failed to load element using: " + event.target.nodeName);
    };
    LoaderResource2.prototype._onProgress = function(event) {
      if (event && event.lengthComputable) {
        this.onProgress.dispatch(this, event.loaded / event.total);
      }
    };
    LoaderResource2.prototype._onTimeout = function() {
      this.abort("Load timed out.");
    };
    LoaderResource2.prototype._xhrOnError = function() {
      var xhr = this.xhr;
      this.abort(reqType(xhr) + " Request failed. Status: " + xhr.status + ', text: "' + xhr.statusText + '"');
    };
    LoaderResource2.prototype._xhrOnTimeout = function() {
      var xhr = this.xhr;
      this.abort(reqType(xhr) + " Request timed out.");
    };
    LoaderResource2.prototype._xhrOnAbort = function() {
      var xhr = this.xhr;
      this.abort(reqType(xhr) + " Request was aborted by the user.");
    };
    LoaderResource2.prototype._xhrOnLoad = function() {
      var xhr = this.xhr;
      var text2 = "";
      var status = typeof xhr.status === "undefined" ? STATUS_OK : xhr.status;
      if (xhr.responseType === "" || xhr.responseType === "text" || typeof xhr.responseType === "undefined") {
        text2 = xhr.responseText;
      }
      if (status === STATUS_NONE && (text2.length > 0 || xhr.responseType === LoaderResource2.XHR_RESPONSE_TYPE.BUFFER)) {
        status = STATUS_OK;
      } else if (status === STATUS_IE_BUG_EMPTY) {
        status = STATUS_EMPTY;
      }
      var statusType = status / 100 | 0;
      if (statusType === STATUS_TYPE_OK) {
        if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.TEXT) {
          this.data = text2;
          this.type = LoaderResource2.TYPE.TEXT;
        } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON) {
          try {
            this.data = JSON.parse(text2);
            this.type = LoaderResource2.TYPE.JSON;
          } catch (e) {
            this.abort("Error trying to parse loaded json: " + e);
            return;
          }
        } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {
          try {
            if (globalThis.DOMParser) {
              var domparser = new DOMParser();
              this.data = domparser.parseFromString(text2, "text/xml");
            } else {
              var div2 = document.createElement("div");
              div2.innerHTML = text2;
              this.data = div2;
            }
            this.type = LoaderResource2.TYPE.XML;
          } catch (e$1) {
            this.abort("Error trying to parse loaded xml: " + e$1);
            return;
          }
        } else {
          this.data = xhr.response || text2;
        }
      } else {
        this.abort("[" + xhr.status + "] " + xhr.statusText + ": " + xhr.responseURL);
        return;
      }
      this.complete();
    };
    LoaderResource2.prototype._determineCrossOrigin = function(url2, loc) {
      if (url2.indexOf("data:") === 0) {
        return "";
      }
      if (globalThis.origin !== globalThis.location.origin) {
        return "anonymous";
      }
      loc = loc || globalThis.location;
      if (!tempAnchor) {
        tempAnchor = document.createElement("a");
      }
      tempAnchor.href = url2;
      var parsedUrl = parseUri(tempAnchor.href, { strictMode: true });
      var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
      var protocol = parsedUrl.protocol ? parsedUrl.protocol + ":" : "";
      if (parsedUrl.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
        return "anonymous";
      }
      return "";
    };
    LoaderResource2.prototype._determineXhrType = function() {
      return LoaderResource2._xhrTypeMap[this.extension] || LoaderResource2.XHR_RESPONSE_TYPE.TEXT;
    };
    LoaderResource2.prototype._determineLoadType = function() {
      return LoaderResource2._loadTypeMap[this.extension] || LoaderResource2.LOAD_TYPE.XHR;
    };
    LoaderResource2.prototype._getExtension = function(url2) {
      if (url2 === void 0) {
        url2 = this.url;
      }
      var ext = "";
      if (this.isDataUrl) {
        var slashIndex = url2.indexOf("/");
        ext = url2.substring(slashIndex + 1, url2.indexOf(";", slashIndex));
      } else {
        var queryStart = url2.indexOf("?");
        var hashStart = url2.indexOf("#");
        var index = Math.min(queryStart > -1 ? queryStart : url2.length, hashStart > -1 ? hashStart : url2.length);
        url2 = url2.substring(0, index);
        ext = url2.substring(url2.lastIndexOf(".") + 1);
      }
      return ext.toLowerCase();
    };
    LoaderResource2.prototype._getMimeFromXhrType = function(type2) {
      switch (type2) {
        case LoaderResource2.XHR_RESPONSE_TYPE.BUFFER:
          return "application/octet-binary";
        case LoaderResource2.XHR_RESPONSE_TYPE.BLOB:
          return "application/blob";
        case LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT:
          return "application/xml";
        case LoaderResource2.XHR_RESPONSE_TYPE.JSON:
          return "application/json";
        case LoaderResource2.XHR_RESPONSE_TYPE.DEFAULT:
        case LoaderResource2.XHR_RESPONSE_TYPE.TEXT:
        default:
          return "text/plain";
      }
    };
    return LoaderResource2;
  }()
);
(function(LoaderResource2) {
  (function(STATUS_FLAGS) {
    STATUS_FLAGS[STATUS_FLAGS["NONE"] = 0] = "NONE";
    STATUS_FLAGS[STATUS_FLAGS["DATA_URL"] = 1] = "DATA_URL";
    STATUS_FLAGS[STATUS_FLAGS["COMPLETE"] = 2] = "COMPLETE";
    STATUS_FLAGS[STATUS_FLAGS["LOADING"] = 4] = "LOADING";
  })(LoaderResource2.STATUS_FLAGS || (LoaderResource2.STATUS_FLAGS = {}));
  (function(TYPE) {
    TYPE[TYPE["UNKNOWN"] = 0] = "UNKNOWN";
    TYPE[TYPE["JSON"] = 1] = "JSON";
    TYPE[TYPE["XML"] = 2] = "XML";
    TYPE[TYPE["IMAGE"] = 3] = "IMAGE";
    TYPE[TYPE["AUDIO"] = 4] = "AUDIO";
    TYPE[TYPE["VIDEO"] = 5] = "VIDEO";
    TYPE[TYPE["TEXT"] = 6] = "TEXT";
  })(LoaderResource2.TYPE || (LoaderResource2.TYPE = {}));
  (function(LOAD_TYPE) {
    LOAD_TYPE[LOAD_TYPE["XHR"] = 1] = "XHR";
    LOAD_TYPE[LOAD_TYPE["IMAGE"] = 2] = "IMAGE";
    LOAD_TYPE[LOAD_TYPE["AUDIO"] = 3] = "AUDIO";
    LOAD_TYPE[LOAD_TYPE["VIDEO"] = 4] = "VIDEO";
  })(LoaderResource2.LOAD_TYPE || (LoaderResource2.LOAD_TYPE = {}));
  (function(XHR_RESPONSE_TYPE) {
    XHR_RESPONSE_TYPE["DEFAULT"] = "text";
    XHR_RESPONSE_TYPE["BUFFER"] = "arraybuffer";
    XHR_RESPONSE_TYPE["BLOB"] = "blob";
    XHR_RESPONSE_TYPE["DOCUMENT"] = "document";
    XHR_RESPONSE_TYPE["JSON"] = "json";
    XHR_RESPONSE_TYPE["TEXT"] = "text";
  })(LoaderResource2.XHR_RESPONSE_TYPE || (LoaderResource2.XHR_RESPONSE_TYPE = {}));
  LoaderResource2._loadTypeMap = {
    // images
    gif: LoaderResource2.LOAD_TYPE.IMAGE,
    png: LoaderResource2.LOAD_TYPE.IMAGE,
    bmp: LoaderResource2.LOAD_TYPE.IMAGE,
    jpg: LoaderResource2.LOAD_TYPE.IMAGE,
    jpeg: LoaderResource2.LOAD_TYPE.IMAGE,
    tif: LoaderResource2.LOAD_TYPE.IMAGE,
    tiff: LoaderResource2.LOAD_TYPE.IMAGE,
    webp: LoaderResource2.LOAD_TYPE.IMAGE,
    tga: LoaderResource2.LOAD_TYPE.IMAGE,
    avif: LoaderResource2.LOAD_TYPE.IMAGE,
    svg: LoaderResource2.LOAD_TYPE.IMAGE,
    "svg+xml": LoaderResource2.LOAD_TYPE.IMAGE,
    // audio
    mp3: LoaderResource2.LOAD_TYPE.AUDIO,
    ogg: LoaderResource2.LOAD_TYPE.AUDIO,
    wav: LoaderResource2.LOAD_TYPE.AUDIO,
    // videos
    mp4: LoaderResource2.LOAD_TYPE.VIDEO,
    webm: LoaderResource2.LOAD_TYPE.VIDEO
  };
  LoaderResource2._xhrTypeMap = {
    // xml
    xhtml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    html: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
    // this should probably be fine.
    tsx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    // images
    gif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    png: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    bmp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    jpg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    jpeg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tiff: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    webp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tga: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    avif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    // json
    json: LoaderResource2.XHR_RESPONSE_TYPE.JSON,
    // text
    text: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
    txt: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
    // fonts
    ttf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER,
    otf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER
  };
  LoaderResource2.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(LoaderResource || (LoaderResource = {}));
function _noop() {
}
function onlyOnce(fn) {
  return function onceWrapper() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    if (fn === null) {
      throw new Error("Callback was already called.");
    }
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  };
}
var AsyncQueueItem = (
  /** @class */
  /* @__PURE__ */ function() {
    function AsyncQueueItem2(data, callback) {
      this.data = data;
      this.callback = callback;
    }
    return AsyncQueueItem2;
  }()
);
var AsyncQueue = (
  /** @class */
  function() {
    function AsyncQueue2(worker, concurrency) {
      var _this = this;
      if (concurrency === void 0) {
        concurrency = 1;
      }
      this.workers = 0;
      this.saturated = _noop;
      this.unsaturated = _noop;
      this.empty = _noop;
      this.drain = _noop;
      this.error = _noop;
      this.started = false;
      this.paused = false;
      this._tasks = [];
      this._insert = function(data, insertAtFront, callback) {
        if (callback && typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        _this.started = true;
        if (data == null && _this.idle()) {
          setTimeout(function() {
            return _this.drain();
          }, 1);
          return;
        }
        var item = new AsyncQueueItem(data, typeof callback === "function" ? callback : _noop);
        if (insertAtFront) {
          _this._tasks.unshift(item);
        } else {
          _this._tasks.push(item);
        }
        setTimeout(_this.process, 1);
      };
      this.process = function() {
        while (!_this.paused && _this.workers < _this.concurrency && _this._tasks.length) {
          var task = _this._tasks.shift();
          if (_this._tasks.length === 0) {
            _this.empty();
          }
          _this.workers += 1;
          if (_this.workers === _this.concurrency) {
            _this.saturated();
          }
          _this._worker(task.data, onlyOnce(_this._next(task)));
        }
      };
      this._worker = worker;
      if (concurrency === 0) {
        throw new Error("Concurrency must not be zero");
      }
      this.concurrency = concurrency;
      this.buffer = concurrency / 4;
    }
    AsyncQueue2.prototype._next = function(task) {
      var _this = this;
      return function() {
        var arguments$1 = arguments;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments$1[_i];
        }
        _this.workers -= 1;
        task.callback.apply(task, args);
        if (args[0] != null) {
          _this.error(args[0], task.data);
        }
        if (_this.workers <= _this.concurrency - _this.buffer) {
          _this.unsaturated();
        }
        if (_this.idle()) {
          _this.drain();
        }
        _this.process();
      };
    };
    AsyncQueue2.prototype.push = function(data, callback) {
      this._insert(data, false, callback);
    };
    AsyncQueue2.prototype.kill = function() {
      this.workers = 0;
      this.drain = _noop;
      this.started = false;
      this._tasks = [];
    };
    AsyncQueue2.prototype.unshift = function(data, callback) {
      this._insert(data, true, callback);
    };
    AsyncQueue2.prototype.length = function() {
      return this._tasks.length;
    };
    AsyncQueue2.prototype.running = function() {
      return this.workers;
    };
    AsyncQueue2.prototype.idle = function() {
      return this._tasks.length + this.workers === 0;
    };
    AsyncQueue2.prototype.pause = function() {
      if (this.paused === true) {
        return;
      }
      this.paused = true;
    };
    AsyncQueue2.prototype.resume = function() {
      if (this.paused === false) {
        return;
      }
      this.paused = false;
      for (var w = 1; w <= this.concurrency; w++) {
        this.process();
      }
    };
    AsyncQueue2.eachSeries = function(array2, iterator, callback, deferNext) {
      var i = 0;
      var len = array2.length;
      function next(err) {
        if (err || i === len) {
          if (callback) {
            callback(err);
          }
          return;
        }
        if (deferNext) {
          setTimeout(function() {
            iterator(array2[i++], next);
          }, 1);
        } else {
          iterator(array2[i++], next);
        }
      }
      next();
    };
    AsyncQueue2.queue = function(worker, concurrency) {
      return new AsyncQueue2(worker, concurrency);
    };
    return AsyncQueue2;
  }()
);
var MAX_PROGRESS = 100;
var rgxExtractUrlHash = /(#[\w-]+)?$/;
var Loader = (
  /** @class */
  function() {
    function Loader2(baseUrl, concurrency) {
      var _this = this;
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      if (concurrency === void 0) {
        concurrency = 10;
      }
      this.progress = 0;
      this.loading = false;
      this.defaultQueryString = "";
      this._beforeMiddleware = [];
      this._afterMiddleware = [];
      this._resourcesParsing = [];
      this._boundLoadResource = function(r, d) {
        return _this._loadResource(r, d);
      };
      this.resources = {};
      this.baseUrl = baseUrl;
      this._beforeMiddleware = [];
      this._afterMiddleware = [];
      this._resourcesParsing = [];
      this._boundLoadResource = function(r, d) {
        return _this._loadResource(r, d);
      };
      this._queue = AsyncQueue.queue(this._boundLoadResource, concurrency);
      this._queue.pause();
      this.resources = {};
      this.onProgress = new Signal();
      this.onError = new Signal();
      this.onLoad = new Signal();
      this.onStart = new Signal();
      this.onComplete = new Signal();
      for (var i = 0; i < Loader2._plugins.length; ++i) {
        var plugin = Loader2._plugins[i];
        var pre = plugin.pre, use = plugin.use;
        if (pre) {
          this.pre(pre);
        }
        if (use) {
          this.use(use);
        }
      }
      this._protected = false;
    }
    Loader2.prototype._add = function(name2, url2, options, callback) {
      if (this.loading && (!options || !options.parentResource)) {
        throw new Error("Cannot add resources while the loader is running.");
      }
      if (this.resources[name2]) {
        throw new Error('Resource named "' + name2 + '" already exists.');
      }
      url2 = this._prepareUrl(url2);
      this.resources[name2] = new LoaderResource(name2, url2, options);
      if (typeof callback === "function") {
        this.resources[name2].onAfterMiddleware.once(callback);
      }
      if (this.loading) {
        var parent = options.parentResource;
        var incompleteChildren = [];
        for (var i = 0; i < parent.children.length; ++i) {
          if (!parent.children[i].isComplete) {
            incompleteChildren.push(parent.children[i]);
          }
        }
        var fullChunk = parent.progressChunk * (incompleteChildren.length + 1);
        var eachChunk = fullChunk / (incompleteChildren.length + 2);
        parent.children.push(this.resources[name2]);
        parent.progressChunk = eachChunk;
        for (var i = 0; i < incompleteChildren.length; ++i) {
          incompleteChildren[i].progressChunk = eachChunk;
        }
        this.resources[name2].progressChunk = eachChunk;
      }
      this._queue.push(this.resources[name2]);
      return this;
    };
    Loader2.prototype.pre = function(fn) {
      this._beforeMiddleware.push(fn);
      return this;
    };
    Loader2.prototype.use = function(fn) {
      this._afterMiddleware.push(fn);
      return this;
    };
    Loader2.prototype.reset = function() {
      this.progress = 0;
      this.loading = false;
      this._queue.kill();
      this._queue.pause();
      for (var k in this.resources) {
        var res = this.resources[k];
        if (res._onLoadBinding) {
          res._onLoadBinding.detach();
        }
        if (res.isLoading) {
          res.abort("loader reset");
        }
      }
      this.resources = {};
      return this;
    };
    Loader2.prototype.load = function(cb) {
      deprecation("6.5.0", "@pixi/loaders is being replaced with @pixi/assets in the next major release.");
      if (typeof cb === "function") {
        this.onComplete.once(cb);
      }
      if (this.loading) {
        return this;
      }
      if (this._queue.idle()) {
        this._onStart();
        this._onComplete();
      } else {
        var numTasks = this._queue._tasks.length;
        var chunk = MAX_PROGRESS / numTasks;
        for (var i = 0; i < this._queue._tasks.length; ++i) {
          this._queue._tasks[i].data.progressChunk = chunk;
        }
        this._onStart();
        this._queue.resume();
      }
      return this;
    };
    Object.defineProperty(Loader2.prototype, "concurrency", {
      /**
       * The number of resources to load concurrently.
       * @default 10
       */
      get: function() {
        return this._queue.concurrency;
      },
      set: function(concurrency) {
        this._queue.concurrency = concurrency;
      },
      enumerable: false,
      configurable: true
    });
    Loader2.prototype._prepareUrl = function(url2) {
      var parsedUrl = parseUri(url2, { strictMode: true });
      var result;
      if (parsedUrl.protocol || !parsedUrl.path || url2.indexOf("//") === 0) {
        result = url2;
      } else if (this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && url2.charAt(0) !== "/") {
        result = this.baseUrl + "/" + url2;
      } else {
        result = this.baseUrl + url2;
      }
      if (this.defaultQueryString) {
        var hash2 = rgxExtractUrlHash.exec(result)[0];
        result = result.slice(0, result.length - hash2.length);
        if (result.indexOf("?") !== -1) {
          result += "&" + this.defaultQueryString;
        } else {
          result += "?" + this.defaultQueryString;
        }
        result += hash2;
      }
      return result;
    };
    Loader2.prototype._loadResource = function(resource, dequeue) {
      var _this = this;
      resource._dequeue = dequeue;
      AsyncQueue.eachSeries(this._beforeMiddleware, function(fn, next) {
        fn.call(_this, resource, function() {
          next(resource.isComplete ? {} : null);
        });
      }, function() {
        if (resource.isComplete) {
          _this._onLoad(resource);
        } else {
          resource._onLoadBinding = resource.onComplete.once(_this._onLoad, _this);
          resource.load();
        }
      }, true);
    };
    Loader2.prototype._onStart = function() {
      this.progress = 0;
      this.loading = true;
      this.onStart.dispatch(this);
    };
    Loader2.prototype._onComplete = function() {
      this.progress = MAX_PROGRESS;
      this.loading = false;
      this.onComplete.dispatch(this, this.resources);
    };
    Loader2.prototype._onLoad = function(resource) {
      var _this = this;
      resource._onLoadBinding = null;
      this._resourcesParsing.push(resource);
      resource._dequeue();
      AsyncQueue.eachSeries(this._afterMiddleware, function(fn, next) {
        fn.call(_this, resource, next);
      }, function() {
        resource.onAfterMiddleware.dispatch(resource);
        _this.progress = Math.min(MAX_PROGRESS, _this.progress + resource.progressChunk);
        _this.onProgress.dispatch(_this, resource);
        if (resource.error) {
          _this.onError.dispatch(resource.error, _this, resource);
        } else {
          _this.onLoad.dispatch(_this, resource);
        }
        _this._resourcesParsing.splice(_this._resourcesParsing.indexOf(resource), 1);
        if (_this._queue.idle() && _this._resourcesParsing.length === 0) {
          _this._onComplete();
        }
      }, true);
    };
    Loader2.prototype.destroy = function() {
      if (!this._protected) {
        this.reset();
      }
    };
    Object.defineProperty(Loader2, "shared", {
      /** A premade instance of the loader that can be used to load resources. */
      get: function() {
        var shared = Loader2._shared;
        if (!shared) {
          shared = new Loader2();
          shared._protected = true;
          Loader2._shared = shared;
        }
        return shared;
      },
      enumerable: false,
      configurable: true
    });
    Loader2.registerPlugin = function(plugin) {
      deprecation("6.5.0", "Loader.registerPlugin() is deprecated, use extensions.add() instead.");
      extensions.add({
        type: ExtensionType.Loader,
        ref: plugin
      });
      return Loader2;
    };
    Loader2._plugins = [];
    return Loader2;
  }()
);
extensions.handleByList(ExtensionType.Loader, Loader._plugins);
Loader.prototype.add = function add(name2, url2, options, callback) {
  if (Array.isArray(name2)) {
    for (var i = 0; i < name2.length; ++i) {
      this.add(name2[i]);
    }
    return this;
  }
  if (typeof name2 === "object") {
    options = name2;
    callback = url2 || options.callback || options.onComplete;
    url2 = options.url;
    name2 = options.name || options.key || options.url;
  }
  if (typeof url2 !== "string") {
    callback = options;
    options = url2;
    url2 = name2;
  }
  if (typeof url2 !== "string") {
    throw new Error("No url passed to add resource to loader.");
  }
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  return this._add(name2, url2, options, callback);
};
var AppLoaderPlugin = (
  /** @class */
  function() {
    function AppLoaderPlugin2() {
    }
    AppLoaderPlugin2.init = function(options) {
      options = Object.assign({
        sharedLoader: false
      }, options);
      this.loader = options.sharedLoader ? Loader.shared : new Loader();
    };
    AppLoaderPlugin2.destroy = function() {
      if (this.loader) {
        this.loader.destroy();
        this.loader = null;
      }
    };
    AppLoaderPlugin2.extension = ExtensionType.Application;
    return AppLoaderPlugin2;
  }()
);
var TextureLoader = (
  /** @class */
  function() {
    function TextureLoader2() {
    }
    TextureLoader2.add = function() {
      LoaderResource.setExtensionLoadType("svg", LoaderResource.LOAD_TYPE.XHR);
      LoaderResource.setExtensionXhrType("svg", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
    };
    TextureLoader2.use = function(resource, next) {
      if (resource.data && (resource.type === LoaderResource.TYPE.IMAGE || resource.extension === "svg")) {
        var data = resource.data, url2 = resource.url, name2 = resource.name, metadata = resource.metadata;
        Texture.fromLoader(data, url2, name2, metadata).then(function(texture) {
          resource.texture = texture;
          next();
        }).catch(next);
      } else {
        next();
      }
    };
    TextureLoader2.extension = ExtensionType.Loader;
    return TextureLoader2;
  }()
);
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBinary(input) {
  var output = "";
  var inx = 0;
  while (inx < input.length) {
    var bytebuffer = [0, 0, 0];
    var encodedCharIndexes = [0, 0, 0, 0];
    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
      if (inx < input.length) {
        bytebuffer[jnx] = input.charCodeAt(inx++) & 255;
      } else {
        bytebuffer[jnx] = 0;
      }
    }
    encodedCharIndexes[0] = bytebuffer[0] >> 2;
    encodedCharIndexes[1] = (bytebuffer[0] & 3) << 4 | bytebuffer[1] >> 4;
    encodedCharIndexes[2] = (bytebuffer[1] & 15) << 2 | bytebuffer[2] >> 6;
    encodedCharIndexes[3] = bytebuffer[2] & 63;
    var paddingBytes = inx - (input.length - 1);
    switch (paddingBytes) {
      case 2:
        encodedCharIndexes[3] = 64;
        encodedCharIndexes[2] = 64;
        break;
      case 1:
        encodedCharIndexes[3] = 64;
        break;
    }
    for (var jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {
      output += _keyStr.charAt(encodedCharIndexes[jnx]);
    }
  }
  return output;
}
function parsing(resource, next) {
  if (!resource.data) {
    next();
    return;
  }
  if (resource.xhr && resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof resource.data === "string") {
      var type2 = resource.xhr.getResponseHeader("content-type");
      if (type2 && type2.indexOf("image") === 0) {
        resource.data = new Image();
        resource.data.src = "data:" + type2 + ";base64," + encodeBinary(resource.xhr.responseText);
        resource.type = LoaderResource.TYPE.IMAGE;
        resource.data.onload = function() {
          resource.data.onload = null;
          next();
        };
        return;
      }
    } else if (resource.data.type.indexOf("image") === 0) {
      var Url_1 = globalThis.URL || globalThis.webkitURL;
      var src_1 = Url_1.createObjectURL(resource.data);
      resource.blob = resource.data;
      resource.data = new Image();
      resource.data.src = src_1;
      resource.type = LoaderResource.TYPE.IMAGE;
      resource.data.onload = function() {
        Url_1.revokeObjectURL(src_1);
        resource.data.onload = null;
        next();
      };
      return;
    }
  }
  next();
}
var ParsingLoader = (
  /** @class */
  function() {
    function ParsingLoader2() {
    }
    ParsingLoader2.extension = ExtensionType.Loader;
    ParsingLoader2.use = parsing;
    return ParsingLoader2;
  }()
);
extensions.add(TextureLoader, ParsingLoader);
/*!
 * @pixi/compressed-textures - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _a$2;
var INTERNAL_FORMATS;
(function(INTERNAL_FORMATS2) {
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));
var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$2 = {}, // WEBGL_compressed_texture_s3tc
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_s3tc
_a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_etc
_a$2[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, // WEBGL_compressed_texture_pvrtc
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, // WEBGL_compressed_texture_etc1
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt
// WEBGL_compressed_texture_atc
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, // @see https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt
// WEBGL_compressed_texture_astc
/* eslint-disable-next-line camelcase */
_a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ASTC_4x4_KHR] = 1, _a$2);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$g = function(d, b) {
  extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$g(d, b);
};
function __extends$g(d, b) {
  extendStatics$g(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) {
      throw t[1];
    }
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v2) {
      return step([n, v2]);
    };
  }
  function step(op) {
    if (f) {
      throw new TypeError("Generator is already executing.");
    }
    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) {
          return t;
        }
        if (y = 0, t) {
          op = [op[0] & 2, t.value];
        }
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) {
              _.ops.pop();
            }
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }
    if (op[0] & 5) {
      throw op[1];
    }
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var BlobResource = (
  /** @class */
  function(_super) {
    __extends$g(BlobResource2, _super);
    function BlobResource2(source, options) {
      if (options === void 0) {
        options = { width: 1, height: 1, autoLoad: true };
      }
      var _this = this;
      var origin;
      var data;
      if (typeof source === "string") {
        origin = source;
        data = new Uint8Array();
      } else {
        origin = null;
        data = source;
      }
      _this = _super.call(this, data, options) || this;
      _this.origin = origin;
      _this.buffer = data ? new ViewableBuffer(data) : null;
      if (_this.origin && options.autoLoad !== false) {
        _this.load();
      }
      if (data && data.length) {
        _this.loaded = true;
        _this.onBlobLoaded(_this.buffer.rawBinaryData);
      }
      return _this;
    }
    BlobResource2.prototype.onBlobLoaded = function(_data) {
    };
    BlobResource2.prototype.load = function() {
      return __awaiter(this, void 0, Promise, function() {
        var response, blob, arrayBuffer;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, fetch(this.origin)];
            case 1:
              response = _a2.sent();
              return [4, response.blob()];
            case 2:
              blob = _a2.sent();
              return [4, blob.arrayBuffer()];
            case 3:
              arrayBuffer = _a2.sent();
              this.data = new Uint32Array(arrayBuffer);
              this.buffer = new ViewableBuffer(arrayBuffer);
              this.loaded = true;
              this.onBlobLoaded(arrayBuffer);
              this.update();
              return [2, this];
          }
        });
      });
    };
    return BlobResource2;
  }(BufferResource)
);
var CompressedTextureResource = (
  /** @class */
  function(_super) {
    __extends$g(CompressedTextureResource2, _super);
    function CompressedTextureResource2(source, options) {
      var _this = _super.call(this, source, options) || this;
      _this.format = options.format;
      _this.levels = options.levels || 1;
      _this._width = options.width;
      _this._height = options.height;
      _this._extension = CompressedTextureResource2._formatToExtension(_this.format);
      if (options.levelBuffers || _this.buffer) {
        _this._levelBuffers = options.levelBuffers || CompressedTextureResource2._createLevelBuffers(
          source instanceof Uint8Array ? source : _this.buffer.uint8View,
          _this.format,
          _this.levels,
          4,
          4,
          // PVRTC has 8x4 blocks in 2bpp mode
          _this.width,
          _this.height
        );
      }
      return _this;
    }
    CompressedTextureResource2.prototype.upload = function(renderer, _texture, _glTexture) {
      var gl = renderer.gl;
      var extension = renderer.context.extensions[this._extension];
      if (!extension) {
        throw new Error(this._extension + " textures are not supported on the current machine");
      }
      if (!this._levelBuffers) {
        return false;
      }
      for (var i = 0, j = this.levels; i < j; i++) {
        var _a2 = this._levelBuffers[i], levelID = _a2.levelID, levelWidth = _a2.levelWidth, levelHeight = _a2.levelHeight, levelBuffer = _a2.levelBuffer;
        gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
      }
      return true;
    };
    CompressedTextureResource2.prototype.onBlobLoaded = function() {
      this._levelBuffers = CompressedTextureResource2._createLevelBuffers(
        this.buffer.uint8View,
        this.format,
        this.levels,
        4,
        4,
        // PVRTC has 8x4 blocks in 2bpp mode
        this.width,
        this.height
      );
    };
    CompressedTextureResource2._formatToExtension = function(format2) {
      if (format2 >= 33776 && format2 <= 33779) {
        return "s3tc";
      } else if (format2 >= 37488 && format2 <= 37497) {
        return "etc";
      } else if (format2 >= 35840 && format2 <= 35843) {
        return "pvrtc";
      } else if (format2 >= 36196) {
        return "etc1";
      } else if (format2 >= 35986 && format2 <= 34798) {
        return "atc";
      }
      throw new Error("Invalid (compressed) texture format given!");
    };
    CompressedTextureResource2._createLevelBuffers = function(buffer, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
      var buffers = new Array(levels);
      var offset = buffer.byteOffset;
      var levelWidth = imageWidth;
      var levelHeight = imageHeight;
      var alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      var alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      var levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
      for (var i = 0; i < levels; i++) {
        buffers[i] = {
          levelID: i,
          levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
          levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
          levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
        };
        offset += levelSize;
        levelWidth = levelWidth >> 1 || 1;
        levelHeight = levelHeight >> 1 || 1;
        alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
        alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
        levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
      }
      return buffers;
    };
    return CompressedTextureResource2;
  }(BlobResource)
);
var CompressedTextureLoader = (
  /** @class */
  function() {
    function CompressedTextureLoader2() {
    }
    CompressedTextureLoader2.use = function(resource, next) {
      var data = resource.data;
      var loader = this;
      if (resource.type === LoaderResource.TYPE.JSON && data && data.cacheID && data.textures) {
        var textures = data.textures;
        var textureURL = void 0;
        var fallbackURL = void 0;
        for (var i = 0, j = textures.length; i < j; i++) {
          var texture = textures[i];
          var url_1 = texture.src;
          var format2 = texture.format;
          if (!format2) {
            fallbackURL = url_1;
          }
          if (CompressedTextureLoader2.textureFormats[format2]) {
            textureURL = url_1;
            break;
          }
        }
        textureURL = textureURL || fallbackURL;
        if (!textureURL) {
          next(new Error("Cannot load compressed-textures in " + resource.url + ", make sure you provide a fallback"));
          return;
        }
        if (textureURL === resource.url) {
          next(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
          return;
        }
        var loadOptions = {
          crossOrigin: resource.crossOrigin,
          metadata: resource.metadata.imageMetadata,
          parentResource: resource
        };
        var resourcePath = url.resolve(resource.url.replace(loader.baseUrl, ""), textureURL);
        var resourceName = data.cacheID;
        loader.add(resourceName, resourcePath, loadOptions, function(res) {
          if (res.error) {
            next(res.error);
            return;
          }
          var _a2 = res.texture, texture2 = _a2 === void 0 ? null : _a2, _b2 = res.textures, textures2 = _b2 === void 0 ? {} : _b2;
          Object.assign(resource, { texture: texture2, textures: textures2 });
          next();
        });
      } else {
        next();
      }
    };
    Object.defineProperty(CompressedTextureLoader2, "textureExtensions", {
      /**  Map of available texture extensions. */
      get: function() {
        if (!CompressedTextureLoader2._textureExtensions) {
          var canvas = settings.ADAPTER.createCanvas();
          var gl = canvas.getContext("webgl");
          if (!gl) {
            console.warn("WebGL not available for compressed textures. Silently failing.");
            return {};
          }
          var extensions2 = {
            s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: gl.getExtension("WEBGL_compressed_texture_etc"),
            etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: gl.getExtension("WEBGL_compressed_texture_atc"),
            astc: gl.getExtension("WEBGL_compressed_texture_astc")
          };
          CompressedTextureLoader2._textureExtensions = extensions2;
        }
        return CompressedTextureLoader2._textureExtensions;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CompressedTextureLoader2, "textureFormats", {
      /** Map of available texture formats. */
      get: function() {
        if (!CompressedTextureLoader2._textureFormats) {
          var extensions2 = CompressedTextureLoader2.textureExtensions;
          CompressedTextureLoader2._textureFormats = {};
          for (var extensionName in extensions2) {
            var extension = extensions2[extensionName];
            if (!extension) {
              continue;
            }
            Object.assign(CompressedTextureLoader2._textureFormats, Object.getPrototypeOf(extension));
          }
        }
        return CompressedTextureLoader2._textureFormats;
      },
      enumerable: false,
      configurable: true
    });
    CompressedTextureLoader2.extension = ExtensionType.Loader;
    return CompressedTextureLoader2;
  }()
);
function registerCompressedTextures(url2, resources, metadata) {
  var result = {
    textures: {},
    texture: null
  };
  if (!resources) {
    return result;
  }
  var textures = resources.map(function(resource) {
    return new Texture(new BaseTexture(resource, Object.assign({
      mipmap: MIPMAP_MODES.OFF,
      alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA
    }, metadata)));
  });
  textures.forEach(function(texture, i) {
    var baseTexture = texture.baseTexture;
    var cacheID = url2 + "-" + (i + 1);
    BaseTexture.addToCache(baseTexture, cacheID);
    Texture.addToCache(texture, cacheID);
    if (i === 0) {
      BaseTexture.addToCache(baseTexture, url2);
      Texture.addToCache(texture, url2);
      result.texture = texture;
    }
    result.textures[cacheID] = texture;
  });
  return result;
}
var _a$1, _b$1;
var DDS_MAGIC_SIZE = 4;
var DDS_HEADER_SIZE = 124;
var DDS_HEADER_PF_SIZE = 32;
var DDS_HEADER_DX10_SIZE = 20;
var DDS_MAGIC = 542327876;
var DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
};
var DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
};
var DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
var DXGI_FORMAT;
(function(DXGI_FORMAT2) {
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
})(DXGI_FORMAT || (DXGI_FORMAT = {}));
var D3D10_RESOURCE_DIMENSION;
(function(D3D10_RESOURCE_DIMENSION2) {
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));
var PF_FLAGS = 1;
var DDPF_ALPHA = 2;
var DDPF_FOURCC = 4;
var DDPF_RGB = 64;
var DDPF_YUV = 512;
var DDPF_LUMINANCE = 131072;
var FOURCC_DXT1 = 827611204;
var FOURCC_DXT3 = 861165636;
var FOURCC_DXT5 = 894720068;
var FOURCC_DX10 = 808540228;
var DDS_RESOURCE_MISC_TEXTURECUBE = 4;
var FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1);
var DXGI_TO_FORMAT = (_b$1 = {}, // WEBGL_compressed_texture_s3tc
_b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, // WEBGL_compressed_texture_s3tc_srgb
_b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b$1);
function parseDDS(arrayBuffer) {
  var data = new Uint32Array(arrayBuffer);
  var magicWord = data[0];
  if (magicWord !== DDS_MAGIC) {
    throw new Error("Invalid DDS file magic word");
  }
  var header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  var height = header[DDS_FIELDS.HEIGHT];
  var width = header[DDS_FIELDS.WIDTH];
  var mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
  var pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  var formatFlags = pixelFormat[PF_FLAGS];
  if (formatFlags & DDPF_FOURCC) {
    var fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
    if (fourCC !== FOURCC_DX10) {
      var internalFormat_1 = FOURCC_TO_FORMAT[fourCC];
      var dataOffset_1 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      var texData = new Uint8Array(arrayBuffer, dataOffset_1);
      var resource = new CompressedTextureResource(texData, {
        format: internalFormat_1,
        width,
        height,
        levels: mipmapCount
        // CompressedTextureResource will separate the levelBuffers for us!
      });
      return [resource];
    }
    var dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
    var dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    var dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
    var resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
    var miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
    var arraySize2 = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
    var internalFormat_2 = DXGI_TO_FORMAT[dxgiFormat];
    if (internalFormat_2 === void 0) {
      throw new Error("DDSParser cannot parse texture data with DXGI format " + dxgiFormat);
    }
    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
      throw new Error("DDSParser does not support cubemap textures");
    }
    if (resourceDimension === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {
      throw new Error("DDSParser does not supported 3D texture data");
    }
    var imageBuffers = new Array();
    var dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (arraySize2 === 1) {
      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
    } else {
      var pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat_2];
      var imageSize = 0;
      var levelWidth = width;
      var levelHeight = height;
      for (var i = 0; i < mipmapCount; i++) {
        var alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
        var alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
        var levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
        imageSize += levelSize;
        levelWidth = levelWidth >>> 1;
        levelHeight = levelHeight >>> 1;
      }
      var imageOffset = dataOffset;
      for (var i = 0; i < arraySize2; i++) {
        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
        imageOffset += imageSize;
      }
    }
    return imageBuffers.map(function(buffer) {
      return new CompressedTextureResource(buffer, {
        format: internalFormat_2,
        width,
        height,
        levels: mipmapCount
      });
    });
  }
  if (formatFlags & DDPF_RGB) {
    throw new Error("DDSParser does not support uncompressed texture data.");
  }
  if (formatFlags & DDPF_YUV) {
    throw new Error("DDSParser does not supported YUV uncompressed texture data.");
  }
  if (formatFlags & DDPF_LUMINANCE) {
    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
  }
  if (formatFlags & DDPF_ALPHA) {
    throw new Error("DDSParser does not support single-channel (alpha) texture data!");
  }
  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
var _a$3, _b, _c;
var FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
var ENDIANNESS = 67305985;
var KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
var FILE_HEADER_SIZE = 64;
var TYPES_TO_BYTES_PER_COMPONENT = (_a$3 = {}, _a$3[TYPES.UNSIGNED_BYTE] = 1, _a$3[TYPES.UNSIGNED_SHORT] = 2, _a$3[TYPES.INT] = 4, _a$3[TYPES.UNSIGNED_INT] = 4, _a$3[TYPES.FLOAT] = 4, _a$3[TYPES.HALF_FLOAT] = 8, _a$3);
var FORMATS_TO_COMPONENTS = (_b = {}, _b[FORMATS.RGBA] = 4, _b[FORMATS.RGB] = 3, _b[FORMATS.RG] = 2, _b[FORMATS.RED] = 1, _b[FORMATS.LUMINANCE] = 1, _b[FORMATS.LUMINANCE_ALPHA] = 2, _b[FORMATS.ALPHA] = 1, _b);
var TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES.UNSIGNED_SHORT_5_6_5] = 2, _c);
function parseKTX(url2, arrayBuffer, loadKeyValueData) {
  if (loadKeyValueData === void 0) {
    loadKeyValueData = false;
  }
  var dataView = new DataView(arrayBuffer);
  if (!validate$1(url2, dataView)) {
    return null;
  }
  var littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
  var glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
  var glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
  var glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
  var pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
  var pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
  var pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
  var numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
  var numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
  var numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
  var bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1) {
    throw new Error("Only 2D textures are supported");
  }
  if (numberOfFaces !== 1) {
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  }
  if (numberOfArrayElements !== 1) {
    throw new Error("WebGL does not support array textures");
  }
  var blockWidth = 4;
  var blockHeight = 4;
  var alignedWidth = pixelWidth + 3 & ~3;
  var alignedHeight = pixelHeight + 3 & ~3;
  var imageBuffers = new Array(numberOfArrayElements);
  var imagePixels = pixelWidth * pixelHeight;
  if (glType === 0) {
    imagePixels = alignedWidth * alignedHeight;
  }
  var imagePixelByteSize;
  if (glType !== 0) {
    if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
      imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
    } else {
      imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
    }
  } else {
    imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
  }
  if (imagePixelByteSize === void 0) {
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  }
  var kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
  var imageByteSize = imagePixels * imagePixelByteSize;
  var mipByteSize = imageByteSize;
  var mipWidth = pixelWidth;
  var mipHeight = pixelHeight;
  var alignedMipWidth = alignedWidth;
  var alignedMipHeight = alignedHeight;
  var imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
  for (var mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    var imageSize = dataView.getUint32(imageOffset, littleEndian);
    var elementOffset = imageOffset + 4;
    for (var arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
      var mips = imageBuffers[arrayElement];
      if (!mips) {
        mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
      }
      mips[mipmapLevel] = {
        levelID: mipmapLevel,
        // don't align mipWidth when texture not compressed! (glType not zero)
        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
      };
      elementOffset += mipByteSize;
    }
    imageOffset += imageSize + 4;
    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
    mipWidth = mipWidth >> 1 || 1;
    mipHeight = mipHeight >> 1 || 1;
    alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
    alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  if (glType !== 0) {
    return {
      uncompressed: imageBuffers.map(function(levelBuffers) {
        var buffer = levelBuffers[0].levelBuffer;
        var convertToInt = false;
        if (glType === TYPES.FLOAT) {
          buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === TYPES.UNSIGNED_INT) {
          convertToInt = true;
          buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === TYPES.INT) {
          convertToInt = true;
          buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        }
        return {
          resource: new BufferResource(buffer, {
            width: levelBuffers[0].levelWidth,
            height: levelBuffers[0].levelHeight
          }),
          type: glType,
          format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
        };
      }),
      kvData
    };
  }
  return {
    compressed: imageBuffers.map(function(levelBuffers) {
      return new CompressedTextureResource(null, {
        format: glInternalFormat,
        width: pixelWidth,
        height: pixelHeight,
        levels: numberOfMipmapLevels,
        levelBuffers
      });
    }),
    kvData
  };
}
function validate$1(url2, dataView) {
  for (var i = 0; i < FILE_IDENTIFIER.length; i++) {
    if (dataView.getUint8(i) !== FILE_IDENTIFIER[i]) {
      console.error(url2 + " is not a valid *.ktx file!");
      return false;
    }
  }
  return true;
}
function convertFormatToInteger(format2) {
  switch (format2) {
    case FORMATS.RGBA:
      return FORMATS.RGBA_INTEGER;
    case FORMATS.RGB:
      return FORMATS.RGB_INTEGER;
    case FORMATS.RG:
      return FORMATS.RG_INTEGER;
    case FORMATS.RED:
      return FORMATS.RED_INTEGER;
    default:
      return format2;
  }
}
function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
  var kvData = /* @__PURE__ */ new Map();
  var bytesIntoKeyValueData = 0;
  while (bytesIntoKeyValueData < bytesOfKeyValueData) {
    var keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);
    var keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;
    var valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    var keyNulByte = 0;
    for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {
      if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {
        break;
      }
    }
    if (keyNulByte === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    var key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
    var value = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
    kvData.set(key, value);
    bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
  }
  return kvData;
}
LoaderResource.setExtensionXhrType("dds", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var DDSLoader = (
  /** @class */
  function() {
    function DDSLoader2() {
    }
    DDSLoader2.use = function(resource, next) {
      if (resource.extension === "dds" && resource.data) {
        try {
          Object.assign(resource, registerCompressedTextures(resource.name || resource.url, parseDDS(resource.data), resource.metadata));
        } catch (err) {
          next(err);
          return;
        }
      }
      next();
    };
    DDSLoader2.extension = ExtensionType.Loader;
    return DDSLoader2;
  }()
);
LoaderResource.setExtensionXhrType("ktx", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var KTXLoader = (
  /** @class */
  function() {
    function KTXLoader2() {
    }
    KTXLoader2.use = function(resource, next) {
      if (resource.extension === "ktx" && resource.data) {
        try {
          var url_1 = resource.name || resource.url;
          var _a2 = parseKTX(url_1, resource.data, this.loadKeyValueData), compressed = _a2.compressed, uncompressed = _a2.uncompressed, kvData_1 = _a2.kvData;
          if (compressed) {
            var result = registerCompressedTextures(url_1, compressed, resource.metadata);
            if (kvData_1 && result.textures) {
              for (var textureId in result.textures) {
                result.textures[textureId].baseTexture.ktxKeyValueData = kvData_1;
              }
            }
            Object.assign(resource, result);
          } else if (uncompressed) {
            var textures_1 = {};
            uncompressed.forEach(function(image, i) {
              var texture = new Texture(new BaseTexture(image.resource, {
                mipmap: MIPMAP_MODES.OFF,
                alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
                type: image.type,
                format: image.format
              }));
              var cacheID = url_1 + "-" + (i + 1);
              if (kvData_1) {
                texture.baseTexture.ktxKeyValueData = kvData_1;
              }
              BaseTexture.addToCache(texture.baseTexture, cacheID);
              Texture.addToCache(texture, cacheID);
              if (i === 0) {
                textures_1[url_1] = texture;
                BaseTexture.addToCache(texture.baseTexture, url_1);
                Texture.addToCache(texture, url_1);
              }
              textures_1[cacheID] = texture;
            });
            Object.assign(resource, { textures: textures_1 });
          }
        } catch (err) {
          next(err);
          return;
        }
      }
      next();
    };
    KTXLoader2.extension = ExtensionType.Loader;
    KTXLoader2.loadKeyValueData = false;
    return KTXLoader2;
  }()
);
/*!
 * @pixi/particle-container - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$f = function(d, b) {
  extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$f(d, b);
};
function __extends$f(d, b) {
  extendStatics$f(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
(function(_super) {
  __extends$f(ParticleContainer, _super);
  function ParticleContainer(maxSize, properties, batchSize, autoResize) {
    if (maxSize === void 0) {
      maxSize = 1500;
    }
    if (batchSize === void 0) {
      batchSize = 16384;
    }
    if (autoResize === void 0) {
      autoResize = false;
    }
    var _this = _super.call(this) || this;
    var maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
      batchSize = maxBatchSize;
    }
    _this._properties = [false, true, false, false, false];
    _this._maxSize = maxSize;
    _this._batchSize = batchSize;
    _this._buffers = null;
    _this._bufferUpdateIDs = [];
    _this._updateID = 0;
    _this.interactiveChildren = false;
    _this.blendMode = BLEND_MODES.NORMAL;
    _this.autoResize = autoResize;
    _this.roundPixels = true;
    _this.baseTexture = null;
    _this.setProperties(properties);
    _this._tint = 0;
    _this.tintRgb = new Float32Array(4);
    _this.tint = 16777215;
    return _this;
  }
  ParticleContainer.prototype.setProperties = function(properties) {
    if (properties) {
      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
    }
  };
  ParticleContainer.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  };
  Object.defineProperty(ParticleContainer.prototype, "tint", {
    /**
     * The tint applied to the container. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
     * @default 0xFFFFFF
     */
    get: function() {
      return this._tint;
    },
    set: function(value) {
      this._tint = value;
      hex2rgb(value, this.tintRgb);
    },
    enumerable: false,
    configurable: true
  });
  ParticleContainer.prototype.render = function(renderer) {
    var _this = this;
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
      return;
    }
    if (!this.baseTexture) {
      this.baseTexture = this.children[0]._texture.baseTexture;
      if (!this.baseTexture.valid) {
        this.baseTexture.once("update", function() {
          return _this.onChildrenChange(0);
        });
      }
    }
    renderer.batch.setObjectRenderer(renderer.plugins.particle);
    renderer.plugins.particle.render(this);
  };
  ParticleContainer.prototype.onChildrenChange = function(smallestChildIndex) {
    var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    while (this._bufferUpdateIDs.length < bufferIndex) {
      this._bufferUpdateIDs.push(0);
    }
    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
  };
  ParticleContainer.prototype.dispose = function() {
    if (this._buffers) {
      for (var i = 0; i < this._buffers.length; ++i) {
        this._buffers[i].destroy();
      }
      this._buffers = null;
    }
  };
  ParticleContainer.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this.dispose();
    this._properties = null;
    this._buffers = null;
    this._bufferUpdateIDs = null;
  };
  return ParticleContainer;
})(Container);
var ParticleBuffer = (
  /** @class */
  function() {
    function ParticleBuffer2(properties, dynamicPropertyFlags, size2) {
      this.geometry = new Geometry();
      this.indexBuffer = null;
      this.size = size2;
      this.dynamicProperties = [];
      this.staticProperties = [];
      for (var i = 0; i < properties.length; ++i) {
        var property = properties[i];
        property = {
          attributeName: property.attributeName,
          size: property.size,
          uploadFunction: property.uploadFunction,
          type: property.type || TYPES.FLOAT,
          offset: property.offset
        };
        if (dynamicPropertyFlags[i]) {
          this.dynamicProperties.push(property);
        } else {
          this.staticProperties.push(property);
        }
      }
      this.staticStride = 0;
      this.staticBuffer = null;
      this.staticData = null;
      this.staticDataUint32 = null;
      this.dynamicStride = 0;
      this.dynamicBuffer = null;
      this.dynamicData = null;
      this.dynamicDataUint32 = null;
      this._updateID = 0;
      this.initBuffers();
    }
    ParticleBuffer2.prototype.initBuffers = function() {
      var geometry = this.geometry;
      var dynamicOffset = 0;
      this.indexBuffer = new Buffer2(createIndicesForQuads(this.size), true, true);
      geometry.addIndex(this.indexBuffer);
      this.dynamicStride = 0;
      for (var i = 0; i < this.dynamicProperties.length; ++i) {
        var property = this.dynamicProperties[i];
        property.offset = dynamicOffset;
        dynamicOffset += property.size;
        this.dynamicStride += property.size;
      }
      var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
      this.dynamicData = new Float32Array(dynBuffer);
      this.dynamicDataUint32 = new Uint32Array(dynBuffer);
      this.dynamicBuffer = new Buffer2(this.dynamicData, false, false);
      var staticOffset = 0;
      this.staticStride = 0;
      for (var i = 0; i < this.staticProperties.length; ++i) {
        var property = this.staticProperties[i];
        property.offset = staticOffset;
        staticOffset += property.size;
        this.staticStride += property.size;
      }
      var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
      this.staticData = new Float32Array(statBuffer);
      this.staticDataUint32 = new Uint32Array(statBuffer);
      this.staticBuffer = new Buffer2(this.staticData, true, false);
      for (var i = 0; i < this.dynamicProperties.length; ++i) {
        var property = this.dynamicProperties[i];
        geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
      }
      for (var i = 0; i < this.staticProperties.length; ++i) {
        var property = this.staticProperties[i];
        geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
      }
    };
    ParticleBuffer2.prototype.uploadDynamic = function(children2, startIndex, amount) {
      for (var i = 0; i < this.dynamicProperties.length; i++) {
        var property = this.dynamicProperties[i];
        property.uploadFunction(children2, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
      }
      this.dynamicBuffer._updateID++;
    };
    ParticleBuffer2.prototype.uploadStatic = function(children2, startIndex, amount) {
      for (var i = 0; i < this.staticProperties.length; i++) {
        var property = this.staticProperties[i];
        property.uploadFunction(children2, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
      }
      this.staticBuffer._updateID++;
    };
    ParticleBuffer2.prototype.destroy = function() {
      this.indexBuffer = null;
      this.dynamicProperties = null;
      this.dynamicBuffer = null;
      this.dynamicData = null;
      this.dynamicDataUint32 = null;
      this.staticProperties = null;
      this.staticBuffer = null;
      this.staticData = null;
      this.staticDataUint32 = null;
      this.geometry.destroy();
    };
    return ParticleBuffer2;
  }()
);
var fragment$6 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
var vertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
var ParticleRenderer = (
  /** @class */
  function(_super) {
    __extends$f(ParticleRenderer2, _super);
    function ParticleRenderer2(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.shader = null;
      _this.properties = null;
      _this.tempMatrix = new Matrix$1();
      _this.properties = [
        // verticesData
        {
          attributeName: "aVertexPosition",
          size: 2,
          uploadFunction: _this.uploadVertices,
          offset: 0
        },
        // positionData
        {
          attributeName: "aPositionCoord",
          size: 2,
          uploadFunction: _this.uploadPosition,
          offset: 0
        },
        // rotationData
        {
          attributeName: "aRotation",
          size: 1,
          uploadFunction: _this.uploadRotation,
          offset: 0
        },
        // uvsData
        {
          attributeName: "aTextureCoord",
          size: 2,
          uploadFunction: _this.uploadUvs,
          offset: 0
        },
        // tintData
        {
          attributeName: "aColor",
          size: 1,
          type: TYPES.UNSIGNED_BYTE,
          uploadFunction: _this.uploadTint,
          offset: 0
        }
      ];
      _this.shader = Shader.from(vertex$3, fragment$6, {});
      _this.state = State.for2d();
      return _this;
    }
    ParticleRenderer2.prototype.render = function(container) {
      var children2 = container.children;
      var maxSize = container._maxSize;
      var batchSize = container._batchSize;
      var renderer = this.renderer;
      var totalChildren = children2.length;
      if (totalChildren === 0) {
        return;
      } else if (totalChildren > maxSize && !container.autoResize) {
        totalChildren = maxSize;
      }
      var buffers = container._buffers;
      if (!buffers) {
        buffers = container._buffers = this.generateBuffers(container);
      }
      var baseTexture = children2[0]._texture.baseTexture;
      var premultiplied = baseTexture.alphaMode > 0;
      this.state.blendMode = correctBlendMode(container.blendMode, premultiplied);
      renderer.state.set(this.state);
      var gl = renderer.gl;
      var m = container.worldTransform.copyTo(this.tempMatrix);
      m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
      this.shader.uniforms.translationMatrix = m.toArray(true);
      this.shader.uniforms.uColor = premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, premultiplied);
      this.shader.uniforms.uSampler = baseTexture;
      this.renderer.shader.bind(this.shader);
      var updateStatic = false;
      for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
        var amount = totalChildren - i;
        if (amount > batchSize) {
          amount = batchSize;
        }
        if (j >= buffers.length) {
          buffers.push(this._generateOneMoreBuffer(container));
        }
        var buffer = buffers[j];
        buffer.uploadDynamic(children2, i, amount);
        var bid = container._bufferUpdateIDs[j] || 0;
        updateStatic = updateStatic || buffer._updateID < bid;
        if (updateStatic) {
          buffer._updateID = container._updateID;
          buffer.uploadStatic(children2, i, amount);
        }
        renderer.geometry.bind(buffer.geometry);
        gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
      }
    };
    ParticleRenderer2.prototype.generateBuffers = function(container) {
      var buffers = [];
      var size2 = container._maxSize;
      var batchSize = container._batchSize;
      var dynamicPropertyFlags = container._properties;
      for (var i = 0; i < size2; i += batchSize) {
        buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
      }
      return buffers;
    };
    ParticleRenderer2.prototype._generateOneMoreBuffer = function(container) {
      var batchSize = container._batchSize;
      var dynamicPropertyFlags = container._properties;
      return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
    };
    ParticleRenderer2.prototype.uploadVertices = function(children2, startIndex, amount, array2, stride, offset) {
      var w0 = 0;
      var w1 = 0;
      var h0 = 0;
      var h1 = 0;
      for (var i = 0; i < amount; ++i) {
        var sprite = children2[startIndex + i];
        var texture = sprite._texture;
        var sx = sprite.scale.x;
        var sy = sprite.scale.y;
        var trim = texture.trim;
        var orig = texture.orig;
        if (trim) {
          w1 = trim.x - sprite.anchor.x * orig.width;
          w0 = w1 + trim.width;
          h1 = trim.y - sprite.anchor.y * orig.height;
          h0 = h1 + trim.height;
        } else {
          w0 = orig.width * (1 - sprite.anchor.x);
          w1 = orig.width * -sprite.anchor.x;
          h0 = orig.height * (1 - sprite.anchor.y);
          h1 = orig.height * -sprite.anchor.y;
        }
        array2[offset] = w1 * sx;
        array2[offset + 1] = h1 * sy;
        array2[offset + stride] = w0 * sx;
        array2[offset + stride + 1] = h1 * sy;
        array2[offset + stride * 2] = w0 * sx;
        array2[offset + stride * 2 + 1] = h0 * sy;
        array2[offset + stride * 3] = w1 * sx;
        array2[offset + stride * 3 + 1] = h0 * sy;
        offset += stride * 4;
      }
    };
    ParticleRenderer2.prototype.uploadPosition = function(children2, startIndex, amount, array2, stride, offset) {
      for (var i = 0; i < amount; i++) {
        var spritePosition = children2[startIndex + i].position;
        array2[offset] = spritePosition.x;
        array2[offset + 1] = spritePosition.y;
        array2[offset + stride] = spritePosition.x;
        array2[offset + stride + 1] = spritePosition.y;
        array2[offset + stride * 2] = spritePosition.x;
        array2[offset + stride * 2 + 1] = spritePosition.y;
        array2[offset + stride * 3] = spritePosition.x;
        array2[offset + stride * 3 + 1] = spritePosition.y;
        offset += stride * 4;
      }
    };
    ParticleRenderer2.prototype.uploadRotation = function(children2, startIndex, amount, array2, stride, offset) {
      for (var i = 0; i < amount; i++) {
        var spriteRotation = children2[startIndex + i].rotation;
        array2[offset] = spriteRotation;
        array2[offset + stride] = spriteRotation;
        array2[offset + stride * 2] = spriteRotation;
        array2[offset + stride * 3] = spriteRotation;
        offset += stride * 4;
      }
    };
    ParticleRenderer2.prototype.uploadUvs = function(children2, startIndex, amount, array2, stride, offset) {
      for (var i = 0; i < amount; ++i) {
        var textureUvs = children2[startIndex + i]._texture._uvs;
        if (textureUvs) {
          array2[offset] = textureUvs.x0;
          array2[offset + 1] = textureUvs.y0;
          array2[offset + stride] = textureUvs.x1;
          array2[offset + stride + 1] = textureUvs.y1;
          array2[offset + stride * 2] = textureUvs.x2;
          array2[offset + stride * 2 + 1] = textureUvs.y2;
          array2[offset + stride * 3] = textureUvs.x3;
          array2[offset + stride * 3 + 1] = textureUvs.y3;
          offset += stride * 4;
        } else {
          array2[offset] = 0;
          array2[offset + 1] = 0;
          array2[offset + stride] = 0;
          array2[offset + stride + 1] = 0;
          array2[offset + stride * 2] = 0;
          array2[offset + stride * 2 + 1] = 0;
          array2[offset + stride * 3] = 0;
          array2[offset + stride * 3 + 1] = 0;
          offset += stride * 4;
        }
      }
    };
    ParticleRenderer2.prototype.uploadTint = function(children2, startIndex, amount, array2, stride, offset) {
      for (var i = 0; i < amount; ++i) {
        var sprite = children2[startIndex + i];
        var premultiplied = sprite._texture.baseTexture.alphaMode > 0;
        var alpha = sprite.alpha;
        var argb = alpha < 1 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);
        array2[offset] = argb;
        array2[offset + stride] = argb;
        array2[offset + stride * 2] = argb;
        array2[offset + stride * 3] = argb;
        offset += stride * 4;
      }
    };
    ParticleRenderer2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (this.shader) {
        this.shader.destroy();
        this.shader = null;
      }
      this.tempMatrix = null;
    };
    ParticleRenderer2.extension = {
      name: "particle",
      type: ExtensionType.RendererPlugin
    };
    return ParticleRenderer2;
  }(ObjectRenderer)
);
/*!
 * @pixi/graphics - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var LINE_JOIN;
(function(LINE_JOIN2) {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
})(LINE_JOIN || (LINE_JOIN = {}));
var LINE_CAP;
(function(LINE_CAP2) {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
})(LINE_CAP || (LINE_CAP = {}));
var GRAPHICS_CURVES = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(length, defaultSegments) {
    if (defaultSegments === void 0) {
      defaultSegments = 20;
    }
    if (!this.adaptive || !length || isNaN(length)) {
      return defaultSegments;
    }
    var result = Math.ceil(length / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};
var FillStyle = (
  /** @class */
  function() {
    function FillStyle2() {
      this.color = 16777215;
      this.alpha = 1;
      this.texture = Texture.WHITE;
      this.matrix = null;
      this.visible = false;
      this.reset();
    }
    FillStyle2.prototype.clone = function() {
      var obj = new FillStyle2();
      obj.color = this.color;
      obj.alpha = this.alpha;
      obj.texture = this.texture;
      obj.matrix = this.matrix;
      obj.visible = this.visible;
      return obj;
    };
    FillStyle2.prototype.reset = function() {
      this.color = 16777215;
      this.alpha = 1;
      this.texture = Texture.WHITE;
      this.matrix = null;
      this.visible = false;
    };
    FillStyle2.prototype.destroy = function() {
      this.texture = null;
      this.matrix = null;
    };
    return FillStyle2;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$e = function(d, b) {
  extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$e(d, b);
};
function __extends$e(d, b) {
  extendStatics$e(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function fixOrientation(points, hole) {
  var _a2, _b2;
  if (hole === void 0) {
    hole = false;
  }
  var m = points.length;
  if (m < 6) {
    return;
  }
  var area2 = 0;
  for (var i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {
    var x2 = points[i];
    var y2 = points[i + 1];
    area2 += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (!hole && area2 > 0 || hole && area2 <= 0) {
    var n = m / 2;
    for (var i = n + n % 2; i < m; i += 2) {
      var i1 = m - i - 2;
      var i2 = m - i - 1;
      var i3 = i;
      var i4 = i + 1;
      _a2 = [points[i3], points[i1]], points[i1] = _a2[0], points[i3] = _a2[1];
      _b2 = [points[i4], points[i2]], points[i2] = _b2[0], points[i4] = _b2[1];
    }
  }
}
var buildPoly = {
  build: function(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var holes = graphicsData.holes;
    var verts = graphicsGeometry.points;
    var indices3 = graphicsGeometry.indices;
    if (points.length >= 6) {
      fixOrientation(points, false);
      var holeArray = [];
      for (var i = 0; i < holes.length; i++) {
        var hole = holes[i];
        fixOrientation(hole.points, true);
        holeArray.push(points.length / 2);
        points = points.concat(hole.points);
      }
      var triangles = earcut$1(points, holeArray, 2);
      if (!triangles) {
        return;
      }
      var vertPos = verts.length / 2;
      for (var i = 0; i < triangles.length; i += 3) {
        indices3.push(triangles[i] + vertPos);
        indices3.push(triangles[i + 1] + vertPos);
        indices3.push(triangles[i + 2] + vertPos);
      }
      for (var i = 0; i < points.length; i++) {
        verts.push(points[i]);
      }
    }
  }
};
var buildCircle = {
  build: function(graphicsData) {
    var points = graphicsData.points;
    var x;
    var y;
    var dx;
    var dy;
    var rx;
    var ry;
    if (graphicsData.type === SHAPES.CIRC) {
      var circle = graphicsData.shape;
      x = circle.x;
      y = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (graphicsData.type === SHAPES.ELIP) {
      var ellipse = graphicsData.shape;
      x = ellipse.x;
      y = ellipse.y;
      rx = ellipse.width;
      ry = ellipse.height;
      dx = dy = 0;
    } else {
      var roundedRect = graphicsData.shape;
      var halfWidth = roundedRect.width / 2;
      var halfHeight = roundedRect.height / 2;
      x = roundedRect.x + halfWidth;
      y = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points.length = 0;
      return;
    }
    var n = Math.ceil(2.3 * Math.sqrt(rx + ry));
    var m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    points.length = m;
    if (m === 0) {
      return;
    }
    if (n === 0) {
      points.length = 8;
      points[0] = points[6] = x + dx;
      points[1] = points[3] = y + dy;
      points[2] = points[4] = x - dx;
      points[5] = points[7] = y - dy;
      return;
    }
    var j1 = 0;
    var j2 = n * 4 + (dx ? 2 : 0) + 2;
    var j3 = j2;
    var j4 = m;
    {
      var x0 = dx + rx;
      var y0 = dy;
      var x1 = x + x0;
      var x2 = x - x0;
      var y1 = y + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      if (dy) {
        var y2 = y - y0;
        points[j3++] = x2;
        points[j3++] = y2;
        points[--j4] = y2;
        points[--j4] = x1;
      }
    }
    for (var i = 1; i < n; i++) {
      var a = Math.PI / 2 * (i / n);
      var x0 = dx + Math.cos(a) * rx;
      var y0 = dy + Math.sin(a) * ry;
      var x1 = x + x0;
      var x2 = x - x0;
      var y1 = y + y0;
      var y2 = y - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      points[j3++] = x2;
      points[j3++] = y2;
      points[--j4] = y2;
      points[--j4] = x1;
    }
    {
      var x0 = dx;
      var y0 = dy + ry;
      var x1 = x + x0;
      var x2 = x - x0;
      var y1 = y + y0;
      var y2 = y - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y2;
      points[--j4] = x1;
      if (dx) {
        points[j1++] = x2;
        points[j1++] = y1;
        points[--j4] = y2;
        points[--j4] = x2;
      }
    }
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var indices3 = graphicsGeometry.indices;
    if (points.length === 0) {
      return;
    }
    var vertPos = verts.length / 2;
    var center = vertPos;
    var x;
    var y;
    if (graphicsData.type !== SHAPES.RREC) {
      var circle = graphicsData.shape;
      x = circle.x;
      y = circle.y;
    } else {
      var roundedRect = graphicsData.shape;
      x = roundedRect.x + roundedRect.width / 2;
      y = roundedRect.y + roundedRect.height / 2;
    }
    var matrix2 = graphicsData.matrix;
    verts.push(graphicsData.matrix ? matrix2.a * x + matrix2.c * y + matrix2.tx : x, graphicsData.matrix ? matrix2.b * x + matrix2.d * y + matrix2.ty : y);
    vertPos++;
    verts.push(points[0], points[1]);
    for (var i = 2; i < points.length; i += 2) {
      verts.push(points[i], points[i + 1]);
      indices3.push(vertPos++, center, vertPos);
    }
    indices3.push(center + 1, center, vertPos);
  }
};
var buildRectangle = {
  build: function(graphicsData) {
    var rectData = graphicsData.shape;
    var x = rectData.x;
    var y = rectData.y;
    var width = rectData.width;
    var height = rectData.height;
    var points = graphicsData.points;
    points.length = 0;
    points.push(x, y, x + width, y, x + width, y + height, x, y + height);
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var vertPos = verts.length / 2;
    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};
function getPt(n12, n22, perc) {
  var diff = n22 - n12;
  return n12 + diff * perc;
}
function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
  if (out === void 0) {
    out = [];
  }
  var n = 20;
  var points = out;
  var xa = 0;
  var ya = 0;
  var xb = 0;
  var yb = 0;
  var x = 0;
  var y = 0;
  for (var i = 0, j = 0; i <= n; ++i) {
    j = i / n;
    xa = getPt(fromX, cpX, j);
    ya = getPt(fromY, cpY, j);
    xb = getPt(cpX, toX, j);
    yb = getPt(cpY, toY, j);
    x = getPt(xa, xb, j);
    y = getPt(ya, yb, j);
    if (i === 0 && points[points.length - 2] === x && points[points.length - 1] === y) {
      continue;
    }
    points.push(x, y);
  }
  return points;
}
var buildRoundedRectangle = {
  build: function(graphicsData) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.build(graphicsData);
      return;
    }
    var rrectData = graphicsData.shape;
    var points = graphicsData.points;
    var x = rrectData.x;
    var y = rrectData.y;
    var width = rrectData.width;
    var height = rrectData.height;
    var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));
    points.length = 0;
    if (!radius) {
      points.push(x, y, x + width, y, x + width, y + height, x, y + height);
    } else {
      quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);
      quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);
      quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);
      quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points);
    }
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.triangulate(graphicsData, graphicsGeometry);
      return;
    }
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var indices3 = graphicsGeometry.indices;
    var vecPos = verts.length / 2;
    var triangles = earcut$1(points, null, 2);
    for (var i = 0, j = triangles.length; i < j; i += 3) {
      indices3.push(triangles[i] + vecPos);
      indices3.push(triangles[i + 1] + vecPos);
      indices3.push(triangles[i + 2] + vecPos);
    }
    for (var i = 0, j = points.length; i < j; i++) {
      verts.push(points[i], points[++i]);
    }
  }
};
function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  var ix = x - nx * innerWeight;
  var iy = y - ny * innerWeight;
  var ox = x + nx * outerWeight;
  var oy = y + ny * outerWeight;
  var exx;
  var eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  var eix = ix + exx;
  var eiy = iy + eyy;
  var eox = ox + exx;
  var eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round$1(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  var cx2p0x = sx - cx;
  var cy2p0y = sy - cy;
  var angle0 = Math.atan2(cx2p0x, cy2p0y);
  var angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  var startAngle = angle0;
  var angleDiff = angle1 - angle0;
  var absAngleDiff = Math.abs(angleDiff);
  var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  var angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  var shape = graphicsData.shape;
  var points = graphicsData.points || shape.points.slice();
  var eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  var style = graphicsData.lineStyle;
  var firstPoint = new Point(points[0], points[1]);
  var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    var midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    var midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  var verts = graphicsGeometry.points;
  var length = points.length / 2;
  var indexCount = points.length;
  var indexStart = verts.length / 2;
  var width = style.width / 2;
  var widthSquared = width * width;
  var miterLimitSquared = style.miterLimit * style.miterLimit;
  var x0 = points[0];
  var y0 = points[1];
  var x1 = points[2];
  var y1 = points[3];
  var x2 = 0;
  var y2 = 0;
  var perpx = -(y0 - y1);
  var perpy = x0 - x1;
  var perp1x = 0;
  var perp1y = 0;
  var dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  var ratio = style.alignment;
  var innerWeight = (1 - ratio) * 2;
  var outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round$1(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);
  verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (var i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2];
    y0 = points[(i - 1) * 2 + 1];
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    x2 = points[(i + 1) * 2];
    y2 = points[(i + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    var dx0 = x1 - x0;
    var dy0 = y0 - y1;
    var dx1 = x1 - x2;
    var dy1 = y2 - y1;
    var dot2 = dx0 * dx1 + dy0 * dy1;
    var cross = dy0 * dx1 - dy1 * dx0;
    var clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot2)) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (dot2 >= 0) {
        if (style.join === LINE_JOIN.ROUND) {
          indexCount += round$1(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);
        verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
      }
      continue;
    }
    var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    var px = (dx0 * c2 - dx1 * c1) / cross;
    var py = (dy1 * c1 - dy0 * c2) / cross;
    var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    var imx = x1 + (px - x1) * innerWeight;
    var imy = y1 + (py - y1) * innerWeight;
    var omx = x1 - (px - x1) * outerWeight;
    var omy = y1 - (py - y1) * outerWeight;
    var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    var insideWeight = clockwise ? innerWeight : outerWeight;
    var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    var insideMiterOk = pdist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === LINE_JOIN.ROUND) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          indexCount += round$1(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(omx, omy);
          indexCount += round$1(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (style.join === LINE_JOIN.ROUND) {
        if (clockwise) {
          indexCount += round$1(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
        } else {
          indexCount += round$1(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
        }
      } else if (style.join === LINE_JOIN.MITER && pdist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
  verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round$1(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  var indices3 = graphicsGeometry.indices;
  var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;
  for (var i = indexStart; i < indexCount + indexStart - 2; ++i) {
    x0 = verts[i * 2];
    y0 = verts[i * 2 + 1];
    x1 = verts[(i + 1) * 2];
    y1 = verts[(i + 1) * 2 + 1];
    x2 = verts[(i + 2) * 2];
    y2 = verts[(i + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices3.push(i, i + 1, i + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  var i = 0;
  var shape = graphicsData.shape;
  var points = graphicsData.points || shape.points;
  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  if (points.length === 0) {
    return;
  }
  var verts = graphicsGeometry.points;
  var indices3 = graphicsGeometry.indices;
  var length = points.length / 2;
  var startIndex = verts.length / 2;
  var currentIndex = startIndex;
  verts.push(points[0], points[1]);
  for (i = 1; i < length; i++) {
    verts.push(points[i * 2], points[i * 2 + 1]);
    indices3.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices3.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}
var ArcUtils = (
  /** @class */
  function() {
    function ArcUtils2() {
    }
    ArcUtils2.curveTo = function(x1, y1, x2, y2, radius, points) {
      var fromX = points[points.length - 2];
      var fromY = points[points.length - 1];
      var a1 = fromY - y1;
      var b1 = fromX - x1;
      var a2 = y2 - y1;
      var b2 = x2 - x1;
      var mm = Math.abs(a1 * b2 - b1 * a2);
      if (mm < 1e-8 || radius === 0) {
        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
          points.push(x1, y1);
        }
        return null;
      }
      var dd = a1 * a1 + b1 * b1;
      var cc = a2 * a2 + b2 * b2;
      var tt = a1 * a2 + b1 * b2;
      var k1 = radius * Math.sqrt(dd) / mm;
      var k2 = radius * Math.sqrt(cc) / mm;
      var j1 = k1 * tt / dd;
      var j2 = k2 * tt / cc;
      var cx = k1 * b2 + k2 * b1;
      var cy = k1 * a2 + k2 * a1;
      var px = b1 * (k2 + j1);
      var py = a1 * (k2 + j1);
      var qx = b2 * (k1 + j2);
      var qy = a2 * (k1 + j2);
      var startAngle = Math.atan2(py - cy, px - cx);
      var endAngle = Math.atan2(qy - cy, qx - cx);
      return {
        cx: cx + x1,
        cy: cy + y1,
        radius,
        startAngle,
        endAngle,
        anticlockwise: b1 * a2 > b2 * a1
      };
    };
    ArcUtils2.arc = function(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
      var sweep = endAngle - startAngle;
      var n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
      var theta = sweep / (n * 2);
      var theta2 = theta * 2;
      var cTheta = Math.cos(theta);
      var sTheta = Math.sin(theta);
      var segMinus = n - 1;
      var remainder = segMinus % 1 / segMinus;
      for (var i = 0; i <= segMinus; ++i) {
        var real = i + remainder * i;
        var angle = theta + startAngle + theta2 * real;
        var c2 = Math.cos(angle);
        var s = -Math.sin(angle);
        points.push((cTheta * c2 + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c2) * radius + cy);
      }
    };
    return ArcUtils2;
  }()
);
var BezierUtils = (
  /** @class */
  function() {
    function BezierUtils2() {
    }
    BezierUtils2.curveLength = function(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
      var n = 10;
      var result = 0;
      var t = 0;
      var t2 = 0;
      var t3 = 0;
      var nt = 0;
      var nt2 = 0;
      var nt3 = 0;
      var x = 0;
      var y = 0;
      var dx = 0;
      var dy = 0;
      var prevX = fromX;
      var prevY = fromY;
      for (var i = 1; i <= n; ++i) {
        t = i / n;
        t2 = t * t;
        t3 = t2 * t;
        nt = 1 - t;
        nt2 = nt * nt;
        nt3 = nt2 * nt;
        x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;
        y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
        dx = prevX - x;
        dy = prevY - y;
        prevX = x;
        prevY = y;
        result += Math.sqrt(dx * dx + dy * dy);
      }
      return result;
    };
    BezierUtils2.curveTo = function(cpX, cpY, cpX2, cpY2, toX, toY, points) {
      var fromX = points[points.length - 2];
      var fromY = points[points.length - 1];
      points.length -= 2;
      var n = GRAPHICS_CURVES._segmentsCount(BezierUtils2.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
      var dt = 0;
      var dt2 = 0;
      var dt3 = 0;
      var t2 = 0;
      var t3 = 0;
      points.push(fromX, fromY);
      for (var i = 1, j = 0; i <= n; ++i) {
        j = i / n;
        dt = 1 - j;
        dt2 = dt * dt;
        dt3 = dt2 * dt;
        t2 = j * j;
        t3 = t2 * j;
        points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
      }
    };
    return BezierUtils2;
  }()
);
var QuadraticUtils = (
  /** @class */
  function() {
    function QuadraticUtils2() {
    }
    QuadraticUtils2.curveLength = function(fromX, fromY, cpX, cpY, toX, toY) {
      var ax = fromX - 2 * cpX + toX;
      var ay = fromY - 2 * cpY + toY;
      var bx = 2 * cpX - 2 * fromX;
      var by = 2 * cpY - 2 * fromY;
      var a = 4 * (ax * ax + ay * ay);
      var b = 4 * (ax * bx + ay * by);
      var c2 = bx * bx + by * by;
      var s = 2 * Math.sqrt(a + b + c2);
      var a2 = Math.sqrt(a);
      var a32 = 2 * a * a2;
      var c22 = 2 * Math.sqrt(c2);
      var ba = b / a2;
      return (a32 * s + a2 * b * (s - c22) + (4 * c2 * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c22))) / (4 * a32);
    };
    QuadraticUtils2.curveTo = function(cpX, cpY, toX, toY, points) {
      var fromX = points[points.length - 2];
      var fromY = points[points.length - 1];
      var n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils2.curveLength(fromX, fromY, cpX, cpY, toX, toY));
      var xa = 0;
      var ya = 0;
      for (var i = 1; i <= n; ++i) {
        var j = i / n;
        xa = fromX + (cpX - fromX) * j;
        ya = fromY + (cpY - fromY) * j;
        points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
      }
    };
    return QuadraticUtils2;
  }()
);
var BatchPart = (
  /** @class */
  function() {
    function BatchPart2() {
      this.reset();
    }
    BatchPart2.prototype.begin = function(style, startIndex, attribStart) {
      this.reset();
      this.style = style;
      this.start = startIndex;
      this.attribStart = attribStart;
    };
    BatchPart2.prototype.end = function(endIndex, endAttrib) {
      this.attribSize = endAttrib - this.attribStart;
      this.size = endIndex - this.start;
    };
    BatchPart2.prototype.reset = function() {
      this.style = null;
      this.size = 0;
      this.start = 0;
      this.attribStart = 0;
      this.attribSize = 0;
    };
    return BatchPart2;
  }()
);
var _a;
var FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);
var BATCH_POOL = [];
var DRAW_CALL_POOL = [];
var GraphicsData = (
  /** @class */
  function() {
    function GraphicsData2(shape, fillStyle, lineStyle, matrix2) {
      if (fillStyle === void 0) {
        fillStyle = null;
      }
      if (lineStyle === void 0) {
        lineStyle = null;
      }
      if (matrix2 === void 0) {
        matrix2 = null;
      }
      this.points = [];
      this.holes = [];
      this.shape = shape;
      this.lineStyle = lineStyle;
      this.fillStyle = fillStyle;
      this.matrix = matrix2;
      this.type = shape.type;
    }
    GraphicsData2.prototype.clone = function() {
      return new GraphicsData2(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    };
    GraphicsData2.prototype.destroy = function() {
      this.shape = null;
      this.holes.length = 0;
      this.holes = null;
      this.points.length = 0;
      this.points = null;
      this.lineStyle = null;
      this.fillStyle = null;
    };
    return GraphicsData2;
  }()
);
var tmpPoint = new Point();
var GraphicsGeometry = (
  /** @class */
  function(_super) {
    __extends$e(GraphicsGeometry2, _super);
    function GraphicsGeometry2() {
      var _this = _super.call(this) || this;
      _this.closePointEps = 1e-4;
      _this.boundsPadding = 0;
      _this.uvsFloat32 = null;
      _this.indicesUint16 = null;
      _this.batchable = false;
      _this.points = [];
      _this.colors = [];
      _this.uvs = [];
      _this.indices = [];
      _this.textureIds = [];
      _this.graphicsData = [];
      _this.drawCalls = [];
      _this.batchDirty = -1;
      _this.batches = [];
      _this.dirty = 0;
      _this.cacheDirty = -1;
      _this.clearDirty = 0;
      _this.shapeIndex = 0;
      _this._bounds = new Bounds();
      _this.boundsDirty = -1;
      return _this;
    }
    Object.defineProperty(GraphicsGeometry2.prototype, "bounds", {
      /**
       * Get the current bounds of the graphic geometry.
       * @readonly
       */
      get: function() {
        this.updateBatches();
        if (this.boundsDirty !== this.dirty) {
          this.boundsDirty = this.dirty;
          this.calculateBounds();
        }
        return this._bounds;
      },
      enumerable: false,
      configurable: true
    });
    GraphicsGeometry2.prototype.invalidate = function() {
      this.boundsDirty = -1;
      this.dirty++;
      this.batchDirty++;
      this.shapeIndex = 0;
      this.points.length = 0;
      this.colors.length = 0;
      this.uvs.length = 0;
      this.indices.length = 0;
      this.textureIds.length = 0;
      for (var i = 0; i < this.drawCalls.length; i++) {
        this.drawCalls[i].texArray.clear();
        DRAW_CALL_POOL.push(this.drawCalls[i]);
      }
      this.drawCalls.length = 0;
      for (var i = 0; i < this.batches.length; i++) {
        var batchPart = this.batches[i];
        batchPart.reset();
        BATCH_POOL.push(batchPart);
      }
      this.batches.length = 0;
    };
    GraphicsGeometry2.prototype.clear = function() {
      if (this.graphicsData.length > 0) {
        this.invalidate();
        this.clearDirty++;
        this.graphicsData.length = 0;
      }
      return this;
    };
    GraphicsGeometry2.prototype.drawShape = function(shape, fillStyle, lineStyle, matrix2) {
      if (fillStyle === void 0) {
        fillStyle = null;
      }
      if (lineStyle === void 0) {
        lineStyle = null;
      }
      if (matrix2 === void 0) {
        matrix2 = null;
      }
      var data = new GraphicsData(shape, fillStyle, lineStyle, matrix2);
      this.graphicsData.push(data);
      this.dirty++;
      return this;
    };
    GraphicsGeometry2.prototype.drawHole = function(shape, matrix2) {
      if (matrix2 === void 0) {
        matrix2 = null;
      }
      if (!this.graphicsData.length) {
        return null;
      }
      var data = new GraphicsData(shape, null, null, matrix2);
      var lastShape = this.graphicsData[this.graphicsData.length - 1];
      data.lineStyle = lastShape.lineStyle;
      lastShape.holes.push(data);
      this.dirty++;
      return this;
    };
    GraphicsGeometry2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      for (var i = 0; i < this.graphicsData.length; ++i) {
        this.graphicsData[i].destroy();
      }
      this.points.length = 0;
      this.points = null;
      this.colors.length = 0;
      this.colors = null;
      this.uvs.length = 0;
      this.uvs = null;
      this.indices.length = 0;
      this.indices = null;
      this.indexBuffer.destroy();
      this.indexBuffer = null;
      this.graphicsData.length = 0;
      this.graphicsData = null;
      this.drawCalls.length = 0;
      this.drawCalls = null;
      this.batches.length = 0;
      this.batches = null;
      this._bounds = null;
    };
    GraphicsGeometry2.prototype.containsPoint = function(point) {
      var graphicsData = this.graphicsData;
      for (var i = 0; i < graphicsData.length; ++i) {
        var data = graphicsData[i];
        if (!data.fillStyle.visible) {
          continue;
        }
        if (data.shape) {
          if (data.matrix) {
            data.matrix.applyInverse(point, tmpPoint);
          } else {
            tmpPoint.copyFrom(point);
          }
          if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
            var hitHole = false;
            if (data.holes) {
              for (var i_1 = 0; i_1 < data.holes.length; i_1++) {
                var hole = data.holes[i_1];
                if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                  hitHole = true;
                  break;
                }
              }
            }
            if (!hitHole) {
              return true;
            }
          }
        }
      }
      return false;
    };
    GraphicsGeometry2.prototype.updateBatches = function() {
      if (!this.graphicsData.length) {
        this.batchable = true;
        return;
      }
      if (!this.validateBatching()) {
        return;
      }
      this.cacheDirty = this.dirty;
      var uvs = this.uvs;
      var graphicsData = this.graphicsData;
      var batchPart = null;
      var currentStyle = null;
      if (this.batches.length > 0) {
        batchPart = this.batches[this.batches.length - 1];
        currentStyle = batchPart.style;
      }
      for (var i = this.shapeIndex; i < graphicsData.length; i++) {
        this.shapeIndex++;
        var data = graphicsData[i];
        var fillStyle = data.fillStyle;
        var lineStyle = data.lineStyle;
        var command = FILL_COMMANDS[data.type];
        command.build(data);
        if (data.matrix) {
          this.transformPoints(data.points, data.matrix);
        }
        if (fillStyle.visible || lineStyle.visible) {
          this.processHoles(data.holes);
        }
        for (var j = 0; j < 2; j++) {
          var style = j === 0 ? fillStyle : lineStyle;
          if (!style.visible) {
            continue;
          }
          var nextTexture = style.texture.baseTexture;
          var index_1 = this.indices.length;
          var attribIndex = this.points.length / 2;
          nextTexture.wrapMode = WRAP_MODES.REPEAT;
          if (j === 0) {
            this.processFill(data);
          } else {
            this.processLine(data);
          }
          var size2 = this.points.length / 2 - attribIndex;
          if (size2 === 0) {
            continue;
          }
          if (batchPart && !this._compareStyles(currentStyle, style)) {
            batchPart.end(index_1, attribIndex);
            batchPart = null;
          }
          if (!batchPart) {
            batchPart = BATCH_POOL.pop() || new BatchPart();
            batchPart.begin(style, index_1, attribIndex);
            this.batches.push(batchPart);
            currentStyle = style;
          }
          this.addUvs(this.points, uvs, style.texture, attribIndex, size2, style.matrix);
        }
      }
      var index = this.indices.length;
      var attrib = this.points.length / 2;
      if (batchPart) {
        batchPart.end(index, attrib);
      }
      if (this.batches.length === 0) {
        this.batchable = true;
        return;
      }
      var need32 = attrib > 65535;
      if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {
        this.indicesUint16.set(this.indices);
      } else {
        this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
      }
      this.batchable = this.isBatchable();
      if (this.batchable) {
        this.packBatches();
      } else {
        this.buildDrawCalls();
      }
    };
    GraphicsGeometry2.prototype._compareStyles = function(styleA, styleB) {
      if (!styleA || !styleB) {
        return false;
      }
      if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
        return false;
      }
      if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
        return false;
      }
      if (!!styleA.native !== !!styleB.native) {
        return false;
      }
      return true;
    };
    GraphicsGeometry2.prototype.validateBatching = function() {
      if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
        return false;
      }
      for (var i = 0, l = this.graphicsData.length; i < l; i++) {
        var data = this.graphicsData[i];
        var fill = data.fillStyle;
        var line = data.lineStyle;
        if (fill && !fill.texture.baseTexture.valid) {
          return false;
        }
        if (line && !line.texture.baseTexture.valid) {
          return false;
        }
      }
      return true;
    };
    GraphicsGeometry2.prototype.packBatches = function() {
      this.batchDirty++;
      this.uvsFloat32 = new Float32Array(this.uvs);
      var batches = this.batches;
      for (var i = 0, l = batches.length; i < l; i++) {
        var batch = batches[i];
        for (var j = 0; j < batch.size; j++) {
          var index = batch.start + j;
          this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
        }
      }
    };
    GraphicsGeometry2.prototype.isBatchable = function() {
      if (this.points.length > 65535 * 2) {
        return false;
      }
      var batches = this.batches;
      for (var i = 0; i < batches.length; i++) {
        if (batches[i].style.native) {
          return false;
        }
      }
      return this.points.length < GraphicsGeometry2.BATCHABLE_SIZE * 2;
    };
    GraphicsGeometry2.prototype.buildDrawCalls = function() {
      var TICK = ++BaseTexture._globalBatch;
      for (var i = 0; i < this.drawCalls.length; i++) {
        this.drawCalls[i].texArray.clear();
        DRAW_CALL_POOL.push(this.drawCalls[i]);
      }
      this.drawCalls.length = 0;
      var colors2 = this.colors;
      var textureIds = this.textureIds;
      var currentGroup = DRAW_CALL_POOL.pop();
      if (!currentGroup) {
        currentGroup = new BatchDrawCall();
        currentGroup.texArray = new BatchTextureArray();
      }
      currentGroup.texArray.count = 0;
      currentGroup.start = 0;
      currentGroup.size = 0;
      currentGroup.type = DRAW_MODES.TRIANGLES;
      var textureCount = 0;
      var currentTexture = null;
      var textureId = 0;
      var native = false;
      var drawMode = DRAW_MODES.TRIANGLES;
      var index = 0;
      this.drawCalls.push(currentGroup);
      for (var i = 0; i < this.batches.length; i++) {
        var data = this.batches[i];
        var MAX_TEXTURES = 8;
        var style = data.style;
        var nextTexture = style.texture.baseTexture;
        if (native !== !!style.native) {
          native = !!style.native;
          drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;
          currentTexture = null;
          textureCount = MAX_TEXTURES;
          TICK++;
        }
        if (currentTexture !== nextTexture) {
          currentTexture = nextTexture;
          if (nextTexture._batchEnabled !== TICK) {
            if (textureCount === MAX_TEXTURES) {
              TICK++;
              textureCount = 0;
              if (currentGroup.size > 0) {
                currentGroup = DRAW_CALL_POOL.pop();
                if (!currentGroup) {
                  currentGroup = new BatchDrawCall();
                  currentGroup.texArray = new BatchTextureArray();
                }
                this.drawCalls.push(currentGroup);
              }
              currentGroup.start = index;
              currentGroup.size = 0;
              currentGroup.texArray.count = 0;
              currentGroup.type = drawMode;
            }
            nextTexture.touched = 1;
            nextTexture._batchEnabled = TICK;
            nextTexture._batchLocation = textureCount;
            nextTexture.wrapMode = WRAP_MODES.REPEAT;
            currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
            textureCount++;
          }
        }
        currentGroup.size += data.size;
        index += data.size;
        textureId = nextTexture._batchLocation;
        this.addColors(colors2, style.color, style.alpha, data.attribSize, data.attribStart);
        this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
      }
      BaseTexture._globalBatch = TICK;
      this.packAttributes();
    };
    GraphicsGeometry2.prototype.packAttributes = function() {
      var verts = this.points;
      var uvs = this.uvs;
      var colors2 = this.colors;
      var textureIds = this.textureIds;
      var glPoints = new ArrayBuffer(verts.length * 3 * 4);
      var f32 = new Float32Array(glPoints);
      var u32 = new Uint32Array(glPoints);
      var p = 0;
      for (var i = 0; i < verts.length / 2; i++) {
        f32[p++] = verts[i * 2];
        f32[p++] = verts[i * 2 + 1];
        f32[p++] = uvs[i * 2];
        f32[p++] = uvs[i * 2 + 1];
        u32[p++] = colors2[i];
        f32[p++] = textureIds[i];
      }
      this._buffer.update(glPoints);
      this._indexBuffer.update(this.indicesUint16);
    };
    GraphicsGeometry2.prototype.processFill = function(data) {
      if (data.holes.length) {
        buildPoly.triangulate(data, this);
      } else {
        var command = FILL_COMMANDS[data.type];
        command.triangulate(data, this);
      }
    };
    GraphicsGeometry2.prototype.processLine = function(data) {
      buildLine(data, this);
      for (var i = 0; i < data.holes.length; i++) {
        buildLine(data.holes[i], this);
      }
    };
    GraphicsGeometry2.prototype.processHoles = function(holes) {
      for (var i = 0; i < holes.length; i++) {
        var hole = holes[i];
        var command = FILL_COMMANDS[hole.type];
        command.build(hole);
        if (hole.matrix) {
          this.transformPoints(hole.points, hole.matrix);
        }
      }
    };
    GraphicsGeometry2.prototype.calculateBounds = function() {
      var bounds = this._bounds;
      bounds.clear();
      bounds.addVertexData(this.points, 0, this.points.length);
      bounds.pad(this.boundsPadding, this.boundsPadding);
    };
    GraphicsGeometry2.prototype.transformPoints = function(points, matrix2) {
      for (var i = 0; i < points.length / 2; i++) {
        var x = points[i * 2];
        var y = points[i * 2 + 1];
        points[i * 2] = matrix2.a * x + matrix2.c * y + matrix2.tx;
        points[i * 2 + 1] = matrix2.b * x + matrix2.d * y + matrix2.ty;
      }
    };
    GraphicsGeometry2.prototype.addColors = function(colors2, color2, alpha, size2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var rgb2 = (color2 >> 16) + (color2 & 65280) + ((color2 & 255) << 16);
      var rgba2 = premultiplyTint(rgb2, alpha);
      colors2.length = Math.max(colors2.length, offset + size2);
      for (var i = 0; i < size2; i++) {
        colors2[offset + i] = rgba2;
      }
    };
    GraphicsGeometry2.prototype.addTextureIds = function(textureIds, id2, size2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      textureIds.length = Math.max(textureIds.length, offset + size2);
      for (var i = 0; i < size2; i++) {
        textureIds[offset + i] = id2;
      }
    };
    GraphicsGeometry2.prototype.addUvs = function(verts, uvs, texture, start2, size2, matrix2) {
      if (matrix2 === void 0) {
        matrix2 = null;
      }
      var index = 0;
      var uvsStart = uvs.length;
      var frame2 = texture.frame;
      while (index < size2) {
        var x = verts[(start2 + index) * 2];
        var y = verts[(start2 + index) * 2 + 1];
        if (matrix2) {
          var nx = matrix2.a * x + matrix2.c * y + matrix2.tx;
          y = matrix2.b * x + matrix2.d * y + matrix2.ty;
          x = nx;
        }
        index++;
        uvs.push(x / frame2.width, y / frame2.height);
      }
      var baseTexture = texture.baseTexture;
      if (frame2.width < baseTexture.width || frame2.height < baseTexture.height) {
        this.adjustUvs(uvs, texture, uvsStart, size2);
      }
    };
    GraphicsGeometry2.prototype.adjustUvs = function(uvs, texture, start2, size2) {
      var baseTexture = texture.baseTexture;
      var eps = 1e-6;
      var finish = start2 + size2 * 2;
      var frame2 = texture.frame;
      var scaleX = frame2.width / baseTexture.width;
      var scaleY = frame2.height / baseTexture.height;
      var offsetX = frame2.x / frame2.width;
      var offsetY = frame2.y / frame2.height;
      var minX = Math.floor(uvs[start2] + eps);
      var minY = Math.floor(uvs[start2 + 1] + eps);
      for (var i = start2 + 2; i < finish; i += 2) {
        minX = Math.min(minX, Math.floor(uvs[i] + eps));
        minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
      }
      offsetX -= minX;
      offsetY -= minY;
      for (var i = start2; i < finish; i += 2) {
        uvs[i] = (uvs[i] + offsetX) * scaleX;
        uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
      }
    };
    GraphicsGeometry2.BATCHABLE_SIZE = 100;
    return GraphicsGeometry2;
  }(BatchGeometry)
);
var LineStyle = (
  /** @class */
  function(_super) {
    __extends$e(LineStyle2, _super);
    function LineStyle2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.width = 0;
      _this.alignment = 0.5;
      _this.native = false;
      _this.cap = LINE_CAP.BUTT;
      _this.join = LINE_JOIN.MITER;
      _this.miterLimit = 10;
      return _this;
    }
    LineStyle2.prototype.clone = function() {
      var obj = new LineStyle2();
      obj.color = this.color;
      obj.alpha = this.alpha;
      obj.texture = this.texture;
      obj.matrix = this.matrix;
      obj.visible = this.visible;
      obj.width = this.width;
      obj.alignment = this.alignment;
      obj.native = this.native;
      obj.cap = this.cap;
      obj.join = this.join;
      obj.miterLimit = this.miterLimit;
      return obj;
    };
    LineStyle2.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.color = 0;
      this.alignment = 0.5;
      this.width = 0;
      this.native = false;
    };
    return LineStyle2;
  }(FillStyle)
);
var temp = new Float32Array(3);
var DEFAULT_SHADERS = {};
var Graphics = (
  /** @class */
  function(_super) {
    __extends$e(Graphics2, _super);
    function Graphics2(geometry) {
      if (geometry === void 0) {
        geometry = null;
      }
      var _this = _super.call(this) || this;
      _this.shader = null;
      _this.pluginName = "batch";
      _this.currentPath = null;
      _this.batches = [];
      _this.batchTint = -1;
      _this.batchDirty = -1;
      _this.vertexData = null;
      _this._fillStyle = new FillStyle();
      _this._lineStyle = new LineStyle();
      _this._matrix = null;
      _this._holeMode = false;
      _this.state = State.for2d();
      _this._geometry = geometry || new GraphicsGeometry();
      _this._geometry.refCount++;
      _this._transformID = -1;
      _this.tint = 16777215;
      _this.blendMode = BLEND_MODES.NORMAL;
      return _this;
    }
    Object.defineProperty(Graphics2.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
       * @readonly
       */
      get: function() {
        return this._geometry;
      },
      enumerable: false,
      configurable: true
    });
    Graphics2.prototype.clone = function() {
      this.finishPoly();
      return new Graphics2(this._geometry);
    };
    Object.defineProperty(Graphics2.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the graphic shape. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
       * primitive in the GraphicsGeometry list is rendered sequentially, modes
       * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
       * be applied per-primitive.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      set: function(value) {
        this.state.blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Graphics2.prototype, "tint", {
      /**
       * The tint applied to each graphic shape. This is a hex value. A value of
       * 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(value) {
        this._tint = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Graphics2.prototype, "fill", {
      /**
       * The current fill style.
       * @readonly
       */
      get: function() {
        return this._fillStyle;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Graphics2.prototype, "line", {
      /**
       * The current line style.
       * @readonly
       */
      get: function() {
        return this._lineStyle;
      },
      enumerable: false,
      configurable: true
    });
    Graphics2.prototype.lineStyle = function(options, color2, alpha, alignment, native) {
      if (options === void 0) {
        options = null;
      }
      if (color2 === void 0) {
        color2 = 0;
      }
      if (alpha === void 0) {
        alpha = 1;
      }
      if (alignment === void 0) {
        alignment = 0.5;
      }
      if (native === void 0) {
        native = false;
      }
      if (typeof options === "number") {
        options = { width: options, color: color2, alpha, alignment, native };
      }
      return this.lineTextureStyle(options);
    };
    Graphics2.prototype.lineTextureStyle = function(options) {
      options = Object.assign({
        width: 0,
        texture: Texture.WHITE,
        color: options && options.texture ? 16777215 : 0,
        alpha: 1,
        matrix: null,
        alignment: 0.5,
        native: false,
        cap: LINE_CAP.BUTT,
        join: LINE_JOIN.MITER,
        miterLimit: 10
      }, options);
      if (this.currentPath) {
        this.startPoly();
      }
      var visible = options.width > 0 && options.alpha > 0;
      if (!visible) {
        this._lineStyle.reset();
      } else {
        if (options.matrix) {
          options.matrix = options.matrix.clone();
          options.matrix.invert();
        }
        Object.assign(this._lineStyle, { visible }, options);
      }
      return this;
    };
    Graphics2.prototype.startPoly = function() {
      if (this.currentPath) {
        var points = this.currentPath.points;
        var len = this.currentPath.points.length;
        if (len > 2) {
          this.drawShape(this.currentPath);
          this.currentPath = new Polygon();
          this.currentPath.closeStroke = false;
          this.currentPath.points.push(points[len - 2], points[len - 1]);
        }
      } else {
        this.currentPath = new Polygon();
        this.currentPath.closeStroke = false;
      }
    };
    Graphics2.prototype.finishPoly = function() {
      if (this.currentPath) {
        if (this.currentPath.points.length > 2) {
          this.drawShape(this.currentPath);
          this.currentPath = null;
        } else {
          this.currentPath.points.length = 0;
        }
      }
    };
    Graphics2.prototype.moveTo = function(x, y) {
      this.startPoly();
      this.currentPath.points[0] = x;
      this.currentPath.points[1] = y;
      return this;
    };
    Graphics2.prototype.lineTo = function(x, y) {
      if (!this.currentPath) {
        this.moveTo(0, 0);
      }
      var points = this.currentPath.points;
      var fromX = points[points.length - 2];
      var fromY = points[points.length - 1];
      if (fromX !== x || fromY !== y) {
        points.push(x, y);
      }
      return this;
    };
    Graphics2.prototype._initCurve = function(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (this.currentPath) {
        if (this.currentPath.points.length === 0) {
          this.currentPath.points = [x, y];
        }
      } else {
        this.moveTo(x, y);
      }
    };
    Graphics2.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
      this._initCurve();
      var points = this.currentPath.points;
      if (points.length === 0) {
        this.moveTo(0, 0);
      }
      QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
      return this;
    };
    Graphics2.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
      this._initCurve();
      BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
      return this;
    };
    Graphics2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
      this._initCurve(x1, y1);
      var points = this.currentPath.points;
      var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
      if (result) {
        var cx = result.cx, cy = result.cy, radius_1 = result.radius, startAngle = result.startAngle, endAngle = result.endAngle, anticlockwise = result.anticlockwise;
        this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);
      }
      return this;
    };
    Graphics2.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
      if (anticlockwise === void 0) {
        anticlockwise = false;
      }
      if (startAngle === endAngle) {
        return this;
      }
      if (!anticlockwise && endAngle <= startAngle) {
        endAngle += PI_2;
      } else if (anticlockwise && startAngle <= endAngle) {
        startAngle += PI_2;
      }
      var sweep = endAngle - startAngle;
      if (sweep === 0) {
        return this;
      }
      var startX = cx + Math.cos(startAngle) * radius;
      var startY = cy + Math.sin(startAngle) * radius;
      var eps = this._geometry.closePointEps;
      var points = this.currentPath ? this.currentPath.points : null;
      if (points) {
        var xDiff = Math.abs(points[points.length - 2] - startX);
        var yDiff = Math.abs(points[points.length - 1] - startY);
        if (xDiff < eps && yDiff < eps)
          ;
        else {
          points.push(startX, startY);
        }
      } else {
        this.moveTo(startX, startY);
        points = this.currentPath.points;
      }
      ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
      return this;
    };
    Graphics2.prototype.beginFill = function(color2, alpha) {
      if (color2 === void 0) {
        color2 = 0;
      }
      if (alpha === void 0) {
        alpha = 1;
      }
      return this.beginTextureFill({ texture: Texture.WHITE, color: color2, alpha });
    };
    Graphics2.prototype.beginTextureFill = function(options) {
      options = Object.assign({
        texture: Texture.WHITE,
        color: 16777215,
        alpha: 1,
        matrix: null
      }, options);
      if (this.currentPath) {
        this.startPoly();
      }
      var visible = options.alpha > 0;
      if (!visible) {
        this._fillStyle.reset();
      } else {
        if (options.matrix) {
          options.matrix = options.matrix.clone();
          options.matrix.invert();
        }
        Object.assign(this._fillStyle, { visible }, options);
      }
      return this;
    };
    Graphics2.prototype.endFill = function() {
      this.finishPoly();
      this._fillStyle.reset();
      return this;
    };
    Graphics2.prototype.drawRect = function(x, y, width, height) {
      return this.drawShape(new Rectangle(x, y, width, height));
    };
    Graphics2.prototype.drawRoundedRect = function(x, y, width, height, radius) {
      return this.drawShape(new RoundedRectangle(x, y, width, height, radius));
    };
    Graphics2.prototype.drawCircle = function(x, y, radius) {
      return this.drawShape(new Circle(x, y, radius));
    };
    Graphics2.prototype.drawEllipse = function(x, y, width, height) {
      return this.drawShape(new Ellipse(x, y, width, height));
    };
    Graphics2.prototype.drawPolygon = function() {
      var arguments$1 = arguments;
      var path = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        path[_i] = arguments$1[_i];
      }
      var points;
      var closeStroke = true;
      var poly = path[0];
      if (poly.points) {
        closeStroke = poly.closeStroke;
        points = poly.points;
      } else if (Array.isArray(path[0])) {
        points = path[0];
      } else {
        points = path;
      }
      var shape = new Polygon(points);
      shape.closeStroke = closeStroke;
      this.drawShape(shape);
      return this;
    };
    Graphics2.prototype.drawShape = function(shape) {
      if (!this._holeMode) {
        this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
      } else {
        this._geometry.drawHole(shape, this._matrix);
      }
      return this;
    };
    Graphics2.prototype.clear = function() {
      this._geometry.clear();
      this._lineStyle.reset();
      this._fillStyle.reset();
      this._boundsID++;
      this._matrix = null;
      this._holeMode = false;
      this.currentPath = null;
      return this;
    };
    Graphics2.prototype.isFastRect = function() {
      var data = this._geometry.graphicsData;
      return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
    };
    Graphics2.prototype._render = function(renderer) {
      this.finishPoly();
      var geometry = this._geometry;
      geometry.updateBatches();
      if (geometry.batchable) {
        if (this.batchDirty !== geometry.batchDirty) {
          this._populateBatches();
        }
        this._renderBatched(renderer);
      } else {
        renderer.batch.flush();
        this._renderDirect(renderer);
      }
    };
    Graphics2.prototype._populateBatches = function() {
      var geometry = this._geometry;
      var blendMode = this.blendMode;
      var len = geometry.batches.length;
      this.batchTint = -1;
      this._transformID = -1;
      this.batchDirty = geometry.batchDirty;
      this.batches.length = len;
      this.vertexData = new Float32Array(geometry.points);
      for (var i = 0; i < len; i++) {
        var gI = geometry.batches[i];
        var color2 = gI.style.color;
        var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
        var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
        var indices3 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
        var batch = {
          vertexData,
          blendMode,
          indices: indices3,
          uvs,
          _batchRGB: hex2rgb(color2),
          _tintRGB: color2,
          _texture: gI.style.texture,
          alpha: gI.style.alpha,
          worldAlpha: 1
        };
        this.batches[i] = batch;
      }
    };
    Graphics2.prototype._renderBatched = function(renderer) {
      if (!this.batches.length) {
        return;
      }
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
      this.calculateVertices();
      this.calculateTints();
      for (var i = 0, l = this.batches.length; i < l; i++) {
        var batch = this.batches[i];
        batch.worldAlpha = this.worldAlpha * batch.alpha;
        renderer.plugins[this.pluginName].render(batch);
      }
    };
    Graphics2.prototype._renderDirect = function(renderer) {
      var shader = this._resolveDirectShader(renderer);
      var geometry = this._geometry;
      var tint = this.tint;
      var worldAlpha = this.worldAlpha;
      var uniforms = shader.uniforms;
      var drawCalls = geometry.drawCalls;
      uniforms.translationMatrix = this.transform.worldTransform;
      uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
      uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
      uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
      uniforms.tint[3] = worldAlpha;
      renderer.shader.bind(shader);
      renderer.geometry.bind(geometry, shader);
      renderer.state.set(this.state);
      for (var i = 0, l = drawCalls.length; i < l; i++) {
        this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
      }
    };
    Graphics2.prototype._renderDrawCallDirect = function(renderer, drawCall) {
      var texArray = drawCall.texArray, type2 = drawCall.type, size2 = drawCall.size, start2 = drawCall.start;
      var groupTextureCount = texArray.count;
      for (var j = 0; j < groupTextureCount; j++) {
        renderer.texture.bind(texArray.elements[j], j);
      }
      renderer.geometry.draw(type2, size2, start2);
    };
    Graphics2.prototype._resolveDirectShader = function(renderer) {
      var shader = this.shader;
      var pluginName = this.pluginName;
      if (!shader) {
        if (!DEFAULT_SHADERS[pluginName]) {
          var MAX_TEXTURES = renderer.plugins[pluginName].MAX_TEXTURES;
          var sampleValues = new Int32Array(MAX_TEXTURES);
          for (var i = 0; i < MAX_TEXTURES; i++) {
            sampleValues[i] = i;
          }
          var uniforms = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Matrix$1(),
            default: UniformGroup.from({ uSamplers: sampleValues }, true)
          };
          var program = renderer.plugins[pluginName]._shader.program;
          DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
        }
        shader = DEFAULT_SHADERS[pluginName];
      }
      return shader;
    };
    Graphics2.prototype._calculateBounds = function() {
      this.finishPoly();
      var geometry = this._geometry;
      if (!geometry.graphicsData.length) {
        return;
      }
      var _a2 = geometry.bounds, minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY = _a2.maxY;
      this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
    };
    Graphics2.prototype.containsPoint = function(point) {
      this.worldTransform.applyInverse(point, Graphics2._TEMP_POINT);
      return this._geometry.containsPoint(Graphics2._TEMP_POINT);
    };
    Graphics2.prototype.calculateTints = function() {
      if (this.batchTint !== this.tint) {
        this.batchTint = this.tint;
        var tintRGB = hex2rgb(this.tint, temp);
        for (var i = 0; i < this.batches.length; i++) {
          var batch = this.batches[i];
          var batchTint = batch._batchRGB;
          var r = tintRGB[0] * batchTint[0] * 255;
          var g = tintRGB[1] * batchTint[1] * 255;
          var b = tintRGB[2] * batchTint[2] * 255;
          var color2 = (r << 16) + (g << 8) + (b | 0);
          batch._tintRGB = (color2 >> 16) + (color2 & 65280) + ((color2 & 255) << 16);
        }
      }
    };
    Graphics2.prototype.calculateVertices = function() {
      var wtID = this.transform._worldID;
      if (this._transformID === wtID) {
        return;
      }
      this._transformID = wtID;
      var wt = this.transform.worldTransform;
      var a = wt.a;
      var b = wt.b;
      var c2 = wt.c;
      var d = wt.d;
      var tx = wt.tx;
      var ty = wt.ty;
      var data = this._geometry.points;
      var vertexData = this.vertexData;
      var count = 0;
      for (var i = 0; i < data.length; i += 2) {
        var x = data[i];
        var y = data[i + 1];
        vertexData[count++] = a * x + c2 * y + tx;
        vertexData[count++] = d * y + b * x + ty;
      }
    };
    Graphics2.prototype.closePath = function() {
      var currentPath = this.currentPath;
      if (currentPath) {
        currentPath.closeStroke = true;
        this.finishPoly();
      }
      return this;
    };
    Graphics2.prototype.setMatrix = function(matrix2) {
      this._matrix = matrix2;
      return this;
    };
    Graphics2.prototype.beginHole = function() {
      this.finishPoly();
      this._holeMode = true;
      return this;
    };
    Graphics2.prototype.endHole = function() {
      this.finishPoly();
      this._holeMode = false;
      return this;
    };
    Graphics2.prototype.destroy = function(options) {
      this._geometry.refCount--;
      if (this._geometry.refCount === 0) {
        this._geometry.dispose();
      }
      this._matrix = null;
      this.currentPath = null;
      this._lineStyle.destroy();
      this._lineStyle = null;
      this._fillStyle.destroy();
      this._fillStyle = null;
      this._geometry = null;
      this.shader = null;
      this.vertexData = null;
      this.batches.length = 0;
      this.batches = null;
      _super.prototype.destroy.call(this, options);
    };
    Graphics2.nextRoundedRectBehavior = false;
    Graphics2._TEMP_POINT = new Point();
    return Graphics2;
  }(Container)
);
/*!
 * @pixi/sprite - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$d = function(d, b) {
  extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$d(d, b);
};
function __extends$d(d, b) {
  extendStatics$d(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var tempPoint$2 = new Point();
var indices2 = new Uint16Array([0, 1, 2, 0, 2, 3]);
var Sprite = (
  /** @class */
  function(_super) {
    __extends$d(Sprite2, _super);
    function Sprite2(texture) {
      var _this = _super.call(this) || this;
      _this._anchor = new ObservablePoint(_this._onAnchorUpdate, _this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
      _this._texture = null;
      _this._width = 0;
      _this._height = 0;
      _this._tint = null;
      _this._tintRGB = null;
      _this.tint = 16777215;
      _this.blendMode = BLEND_MODES.NORMAL;
      _this._cachedTint = 16777215;
      _this.uvs = null;
      _this.texture = texture || Texture.EMPTY;
      _this.vertexData = new Float32Array(8);
      _this.vertexTrimmedData = null;
      _this._transformID = -1;
      _this._textureID = -1;
      _this._transformTrimmedID = -1;
      _this._textureTrimmedID = -1;
      _this.indices = indices2;
      _this.pluginName = "batch";
      _this.isSprite = true;
      _this._roundPixels = settings.ROUND_PIXELS;
      return _this;
    }
    Sprite2.prototype._onTextureUpdate = function() {
      this._textureID = -1;
      this._textureTrimmedID = -1;
      this._cachedTint = 16777215;
      if (this._width) {
        this.scale.x = sign$1(this.scale.x) * this._width / this._texture.orig.width;
      }
      if (this._height) {
        this.scale.y = sign$1(this.scale.y) * this._height / this._texture.orig.height;
      }
    };
    Sprite2.prototype._onAnchorUpdate = function() {
      this._transformID = -1;
      this._transformTrimmedID = -1;
    };
    Sprite2.prototype.calculateVertices = function() {
      var texture = this._texture;
      if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
        return;
      }
      if (this._textureID !== texture._updateID) {
        this.uvs = this._texture._uvs.uvsFloat32;
      }
      this._transformID = this.transform._worldID;
      this._textureID = texture._updateID;
      var wt = this.transform.worldTransform;
      var a = wt.a;
      var b = wt.b;
      var c2 = wt.c;
      var d = wt.d;
      var tx = wt.tx;
      var ty = wt.ty;
      var vertexData = this.vertexData;
      var trim = texture.trim;
      var orig = texture.orig;
      var anchor = this._anchor;
      var w0 = 0;
      var w1 = 0;
      var h0 = 0;
      var h1 = 0;
      if (trim) {
        w1 = trim.x - anchor._x * orig.width;
        w0 = w1 + trim.width;
        h1 = trim.y - anchor._y * orig.height;
        h0 = h1 + trim.height;
      } else {
        w1 = -anchor._x * orig.width;
        w0 = w1 + orig.width;
        h1 = -anchor._y * orig.height;
        h0 = h1 + orig.height;
      }
      vertexData[0] = a * w1 + c2 * h1 + tx;
      vertexData[1] = d * h1 + b * w1 + ty;
      vertexData[2] = a * w0 + c2 * h1 + tx;
      vertexData[3] = d * h1 + b * w0 + ty;
      vertexData[4] = a * w0 + c2 * h0 + tx;
      vertexData[5] = d * h0 + b * w0 + ty;
      vertexData[6] = a * w1 + c2 * h0 + tx;
      vertexData[7] = d * h0 + b * w1 + ty;
      if (this._roundPixels) {
        var resolution = settings.RESOLUTION;
        for (var i = 0; i < vertexData.length; ++i) {
          vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);
        }
      }
    };
    Sprite2.prototype.calculateTrimmedVertices = function() {
      if (!this.vertexTrimmedData) {
        this.vertexTrimmedData = new Float32Array(8);
      } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
        return;
      }
      this._transformTrimmedID = this.transform._worldID;
      this._textureTrimmedID = this._texture._updateID;
      var texture = this._texture;
      var vertexData = this.vertexTrimmedData;
      var orig = texture.orig;
      var anchor = this._anchor;
      var wt = this.transform.worldTransform;
      var a = wt.a;
      var b = wt.b;
      var c2 = wt.c;
      var d = wt.d;
      var tx = wt.tx;
      var ty = wt.ty;
      var w1 = -anchor._x * orig.width;
      var w0 = w1 + orig.width;
      var h1 = -anchor._y * orig.height;
      var h0 = h1 + orig.height;
      vertexData[0] = a * w1 + c2 * h1 + tx;
      vertexData[1] = d * h1 + b * w1 + ty;
      vertexData[2] = a * w0 + c2 * h1 + tx;
      vertexData[3] = d * h1 + b * w0 + ty;
      vertexData[4] = a * w0 + c2 * h0 + tx;
      vertexData[5] = d * h0 + b * w0 + ty;
      vertexData[6] = a * w1 + c2 * h0 + tx;
      vertexData[7] = d * h0 + b * w1 + ty;
    };
    Sprite2.prototype._render = function(renderer) {
      this.calculateVertices();
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
      renderer.plugins[this.pluginName].render(this);
    };
    Sprite2.prototype._calculateBounds = function() {
      var trim = this._texture.trim;
      var orig = this._texture.orig;
      if (!trim || trim.width === orig.width && trim.height === orig.height) {
        this.calculateVertices();
        this._bounds.addQuad(this.vertexData);
      } else {
        this.calculateTrimmedVertices();
        this._bounds.addQuad(this.vertexTrimmedData);
      }
    };
    Sprite2.prototype.getLocalBounds = function(rect) {
      if (this.children.length === 0) {
        if (!this._localBounds) {
          this._localBounds = new Bounds();
        }
        this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
        this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
        this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
        this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
        if (!rect) {
          if (!this._localBoundsRect) {
            this._localBoundsRect = new Rectangle();
          }
          rect = this._localBoundsRect;
        }
        return this._localBounds.getRectangle(rect);
      }
      return _super.prototype.getLocalBounds.call(this, rect);
    };
    Sprite2.prototype.containsPoint = function(point) {
      this.worldTransform.applyInverse(point, tempPoint$2);
      var width = this._texture.orig.width;
      var height = this._texture.orig.height;
      var x1 = -width * this.anchor.x;
      var y1 = 0;
      if (tempPoint$2.x >= x1 && tempPoint$2.x < x1 + width) {
        y1 = -height * this.anchor.y;
        if (tempPoint$2.y >= y1 && tempPoint$2.y < y1 + height) {
          return true;
        }
      }
      return false;
    };
    Sprite2.prototype.destroy = function(options) {
      _super.prototype.destroy.call(this, options);
      this._texture.off("update", this._onTextureUpdate, this);
      this._anchor = null;
      var destroyTexture = typeof options === "boolean" ? options : options && options.texture;
      if (destroyTexture) {
        var destroyBaseTexture = typeof options === "boolean" ? options : options && options.baseTexture;
        this._texture.destroy(!!destroyBaseTexture);
      }
      this._texture = null;
    };
    Sprite2.from = function(source, options) {
      var texture = source instanceof Texture ? source : Texture.from(source, options);
      return new Sprite2(texture);
    };
    Object.defineProperty(Sprite2.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       *
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       *
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.
       * @default false
       */
      set: function(value) {
        if (this._roundPixels !== value) {
          this._transformID = -1;
        }
        this._roundPixels = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "width", {
      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(value) {
        var s = sign$1(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "height", {
      /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(value) {
        var s = sign$1(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "anchor", {
      /**
       * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}
       * and passed to the constructor.
       *
       * The default is `(0,0)`, this means the sprite's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
       *
       * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       * @example
       * const sprite = new PIXI.Sprite(texture);
       * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
       */
      get: function() {
        return this._anchor;
      },
      set: function(value) {
        this._anchor.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "tint", {
      /**
       * The tint applied to the sprite. This is a hex value.
       *
       * A value of 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(value) {
        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "texture", {
      /** The texture that the sprite is using. */
      get: function() {
        return this._texture;
      },
      set: function(value) {
        if (this._texture === value) {
          return;
        }
        if (this._texture) {
          this._texture.off("update", this._onTextureUpdate, this);
        }
        this._texture = value || Texture.EMPTY;
        this._cachedTint = 16777215;
        this._textureID = -1;
        this._textureTrimmedID = -1;
        if (value) {
          if (value.baseTexture.valid) {
            this._onTextureUpdate();
          } else {
            value.once("update", this._onTextureUpdate, this);
          }
        }
      },
      enumerable: false,
      configurable: true
    });
    return Sprite2;
  }(Container)
);
/*!
 * @pixi/text - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$c = function(d, b) {
  extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$c(d, b);
};
function __extends$c(d, b) {
  extendStatics$c(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var TEXT_GRADIENT;
(function(TEXT_GRADIENT2) {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
var defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100,
  leading: 0
};
var genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
var TextStyle = (
  /** @class */
  function() {
    function TextStyle2(style) {
      this.styleID = 0;
      this.reset();
      deepCopyProperties(this, style, style);
    }
    TextStyle2.prototype.clone = function() {
      var clonedProperties = {};
      deepCopyProperties(clonedProperties, this, defaultStyle);
      return new TextStyle2(clonedProperties);
    };
    TextStyle2.prototype.reset = function() {
      deepCopyProperties(this, defaultStyle, defaultStyle);
    };
    Object.defineProperty(TextStyle2.prototype, "align", {
      /**
       * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
       *
       * @member {string}
       */
      get: function() {
        return this._align;
      },
      set: function(align) {
        if (this._align !== align) {
          this._align = align;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "breakWords", {
      /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
      get: function() {
        return this._breakWords;
      },
      set: function(breakWords) {
        if (this._breakWords !== breakWords) {
          this._breakWords = breakWords;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "dropShadow", {
      /** Set a drop shadow for the text. */
      get: function() {
        return this._dropShadow;
      },
      set: function(dropShadow) {
        if (this._dropShadow !== dropShadow) {
          this._dropShadow = dropShadow;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "dropShadowAlpha", {
      /** Set alpha for the drop shadow. */
      get: function() {
        return this._dropShadowAlpha;
      },
      set: function(dropShadowAlpha) {
        if (this._dropShadowAlpha !== dropShadowAlpha) {
          this._dropShadowAlpha = dropShadowAlpha;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "dropShadowAngle", {
      /** Set a angle of the drop shadow. */
      get: function() {
        return this._dropShadowAngle;
      },
      set: function(dropShadowAngle) {
        if (this._dropShadowAngle !== dropShadowAngle) {
          this._dropShadowAngle = dropShadowAngle;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "dropShadowBlur", {
      /** Set a shadow blur radius. */
      get: function() {
        return this._dropShadowBlur;
      },
      set: function(dropShadowBlur) {
        if (this._dropShadowBlur !== dropShadowBlur) {
          this._dropShadowBlur = dropShadowBlur;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "dropShadowColor", {
      /** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */
      get: function() {
        return this._dropShadowColor;
      },
      set: function(dropShadowColor) {
        var outputColor = getColor(dropShadowColor);
        if (this._dropShadowColor !== outputColor) {
          this._dropShadowColor = outputColor;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "dropShadowDistance", {
      /** Set a distance of the drop shadow. */
      get: function() {
        return this._dropShadowDistance;
      },
      set: function(dropShadowDistance) {
        if (this._dropShadowDistance !== dropShadowDistance) {
          this._dropShadowDistance = dropShadowDistance;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fill", {
      /**
       * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
       *
       * Can be an array to create a gradient eg ['#000000','#FFFFFF']
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
       *
       * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
       */
      get: function() {
        return this._fill;
      },
      set: function(fill) {
        var outputColor = getColor(fill);
        if (this._fill !== outputColor) {
          this._fill = outputColor;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fillGradientType", {
      /**
       * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
       *
       * @see PIXI.TEXT_GRADIENT
       */
      get: function() {
        return this._fillGradientType;
      },
      set: function(fillGradientType) {
        if (this._fillGradientType !== fillGradientType) {
          this._fillGradientType = fillGradientType;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fillGradientStops", {
      /**
       * If fill is an array of colours to create a gradient, this array can set the stop points
       * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
       */
      get: function() {
        return this._fillGradientStops;
      },
      set: function(fillGradientStops) {
        if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
          this._fillGradientStops = fillGradientStops;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fontFamily", {
      /** The font family. */
      get: function() {
        return this._fontFamily;
      },
      set: function(fontFamily) {
        if (this.fontFamily !== fontFamily) {
          this._fontFamily = fontFamily;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fontSize", {
      /**
       * The font size
       * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
       */
      get: function() {
        return this._fontSize;
      },
      set: function(fontSize) {
        if (this._fontSize !== fontSize) {
          this._fontSize = fontSize;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fontStyle", {
      /**
       * The font style
       * ('normal', 'italic' or 'oblique')
       *
       * @member {string}
       */
      get: function() {
        return this._fontStyle;
      },
      set: function(fontStyle) {
        if (this._fontStyle !== fontStyle) {
          this._fontStyle = fontStyle;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fontVariant", {
      /**
       * The font variant
       * ('normal' or 'small-caps')
       *
       * @member {string}
       */
      get: function() {
        return this._fontVariant;
      },
      set: function(fontVariant) {
        if (this._fontVariant !== fontVariant) {
          this._fontVariant = fontVariant;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fontWeight", {
      /**
       * The font weight
       * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
       *
       * @member {string}
       */
      get: function() {
        return this._fontWeight;
      },
      set: function(fontWeight) {
        if (this._fontWeight !== fontWeight) {
          this._fontWeight = fontWeight;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "letterSpacing", {
      /** The amount of spacing between letters, default is 0. */
      get: function() {
        return this._letterSpacing;
      },
      set: function(letterSpacing) {
        if (this._letterSpacing !== letterSpacing) {
          this._letterSpacing = letterSpacing;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "lineHeight", {
      /** The line height, a number that represents the vertical space that a letter uses. */
      get: function() {
        return this._lineHeight;
      },
      set: function(lineHeight) {
        if (this._lineHeight !== lineHeight) {
          this._lineHeight = lineHeight;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "leading", {
      /** The space between lines. */
      get: function() {
        return this._leading;
      },
      set: function(leading) {
        if (this._leading !== leading) {
          this._leading = leading;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "lineJoin", {
      /**
       * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
       * Default is 'miter' (creates a sharp corner).
       *
       * @member {string}
       */
      get: function() {
        return this._lineJoin;
      },
      set: function(lineJoin) {
        if (this._lineJoin !== lineJoin) {
          this._lineJoin = lineJoin;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "miterLimit", {
      /**
       * The miter limit to use when using the 'miter' lineJoin mode.
       *
       * This can reduce or increase the spikiness of rendered text.
       */
      get: function() {
        return this._miterLimit;
      },
      set: function(miterLimit) {
        if (this._miterLimit !== miterLimit) {
          this._miterLimit = miterLimit;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "padding", {
      /**
       * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
       * by adding padding to all sides of the text.
       */
      get: function() {
        return this._padding;
      },
      set: function(padding) {
        if (this._padding !== padding) {
          this._padding = padding;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "stroke", {
      /**
       * A canvas fillstyle that will be used on the text stroke
       * e.g 'blue', '#FCFF00'
       */
      get: function() {
        return this._stroke;
      },
      set: function(stroke) {
        var outputColor = getColor(stroke);
        if (this._stroke !== outputColor) {
          this._stroke = outputColor;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "strokeThickness", {
      /**
       * A number that represents the thickness of the stroke.
       *
       * @default 0
       */
      get: function() {
        return this._strokeThickness;
      },
      set: function(strokeThickness) {
        if (this._strokeThickness !== strokeThickness) {
          this._strokeThickness = strokeThickness;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "textBaseline", {
      /**
       * The baseline of the text that is rendered.
       *
       * @member {string}
       */
      get: function() {
        return this._textBaseline;
      },
      set: function(textBaseline) {
        if (this._textBaseline !== textBaseline) {
          this._textBaseline = textBaseline;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "trim", {
      /** Trim transparent borders. */
      get: function() {
        return this._trim;
      },
      set: function(trim) {
        if (this._trim !== trim) {
          this._trim = trim;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "whiteSpace", {
      /**
       * How newlines and spaces should be handled.
       * Default is 'pre' (preserve, preserve).
       *
       *  value       | New lines     |   Spaces
       *  ---         | ---           |   ---
       * 'normal'     | Collapse      |   Collapse
       * 'pre'        | Preserve      |   Preserve
       * 'pre-line'   | Preserve      |   Collapse
       *
       * @member {string}
       */
      get: function() {
        return this._whiteSpace;
      },
      set: function(whiteSpace) {
        if (this._whiteSpace !== whiteSpace) {
          this._whiteSpace = whiteSpace;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "wordWrap", {
      /** Indicates if word wrap should be used. */
      get: function() {
        return this._wordWrap;
      },
      set: function(wordWrap) {
        if (this._wordWrap !== wordWrap) {
          this._wordWrap = wordWrap;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "wordWrapWidth", {
      /** The width at which text will wrap, it needs wordWrap to be set to true. */
      get: function() {
        return this._wordWrapWidth;
      },
      set: function(wordWrapWidth) {
        if (this._wordWrapWidth !== wordWrapWidth) {
          this._wordWrapWidth = wordWrapWidth;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    TextStyle2.prototype.toFontString = function() {
      var fontSizeString = typeof this.fontSize === "number" ? this.fontSize + "px" : this.fontSize;
      var fontFamilies = this.fontFamily;
      if (!Array.isArray(this.fontFamily)) {
        fontFamilies = this.fontFamily.split(",");
      }
      for (var i = fontFamilies.length - 1; i >= 0; i--) {
        var fontFamily = fontFamilies[i].trim();
        if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
          fontFamily = '"' + fontFamily + '"';
        }
        fontFamilies[i] = fontFamily;
      }
      return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
    };
    return TextStyle2;
  }()
);
function getSingleColor(color2) {
  if (typeof color2 === "number") {
    return hex2string(color2);
  } else if (typeof color2 === "string") {
    if (color2.indexOf("0x") === 0) {
      color2 = color2.replace("0x", "#");
    }
  }
  return color2;
}
function getColor(color2) {
  if (!Array.isArray(color2)) {
    return getSingleColor(color2);
  } else {
    for (var i = 0; i < color2.length; ++i) {
      color2[i] = getSingleColor(color2[i]);
    }
    return color2;
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (var i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (var prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}
var contextSettings = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: true
};
var TextMetrics = (
  /** @class */
  function() {
    function TextMetrics2(text2, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
      this.text = text2;
      this.style = style;
      this.width = width;
      this.height = height;
      this.lines = lines;
      this.lineWidths = lineWidths;
      this.lineHeight = lineHeight;
      this.maxLineWidth = maxLineWidth;
      this.fontProperties = fontProperties;
    }
    TextMetrics2.measureText = function(text2, style, wordWrap, canvas) {
      if (canvas === void 0) {
        canvas = TextMetrics2._canvas;
      }
      wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
      var font = style.toFontString();
      var fontProperties = TextMetrics2.measureFont(font);
      if (fontProperties.fontSize === 0) {
        fontProperties.fontSize = style.fontSize;
        fontProperties.ascent = style.fontSize;
      }
      var context2 = canvas.getContext("2d", contextSettings);
      context2.font = font;
      var outputText = wordWrap ? TextMetrics2.wordWrap(text2, style, canvas) : text2;
      var lines = outputText.split(/(?:\r\n|\r|\n)/);
      var lineWidths = new Array(lines.length);
      var maxLineWidth = 0;
      for (var i = 0; i < lines.length; i++) {
        var lineWidth = context2.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;
        lineWidths[i] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
      }
      var width = maxLineWidth + style.strokeThickness;
      if (style.dropShadow) {
        width += style.dropShadowDistance;
      }
      var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
      var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);
      if (style.dropShadow) {
        height += style.dropShadowDistance;
      }
      return new TextMetrics2(text2, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
    };
    TextMetrics2.wordWrap = function(text2, style, canvas) {
      if (canvas === void 0) {
        canvas = TextMetrics2._canvas;
      }
      var context2 = canvas.getContext("2d", contextSettings);
      var width = 0;
      var line = "";
      var lines = "";
      var cache = /* @__PURE__ */ Object.create(null);
      var letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace;
      var collapseSpaces = TextMetrics2.collapseSpaces(whiteSpace);
      var collapseNewlines = TextMetrics2.collapseNewlines(whiteSpace);
      var canPrependSpaces = !collapseSpaces;
      var wordWrapWidth = style.wordWrapWidth + letterSpacing;
      var tokens = TextMetrics2.tokenize(text2);
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (TextMetrics2.isNewline(token)) {
          if (!collapseNewlines) {
            lines += TextMetrics2.addLine(line);
            canPrependSpaces = !collapseSpaces;
            line = "";
            width = 0;
            continue;
          }
          token = " ";
        }
        if (collapseSpaces) {
          var currIsBreakingSpace = TextMetrics2.isBreakingSpace(token);
          var lastIsBreakingSpace = TextMetrics2.isBreakingSpace(line[line.length - 1]);
          if (currIsBreakingSpace && lastIsBreakingSpace) {
            continue;
          }
        }
        var tokenWidth = TextMetrics2.getFromCache(token, letterSpacing, cache, context2);
        if (tokenWidth > wordWrapWidth) {
          if (line !== "") {
            lines += TextMetrics2.addLine(line);
            line = "";
            width = 0;
          }
          if (TextMetrics2.canBreakWords(token, style.breakWords)) {
            var characters = TextMetrics2.wordWrapSplit(token);
            for (var j = 0; j < characters.length; j++) {
              var char = characters[j];
              var k = 1;
              while (characters[j + k]) {
                var nextChar = characters[j + k];
                var lastChar = char[char.length - 1];
                if (!TextMetrics2.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                  char += nextChar;
                } else {
                  break;
                }
                k++;
              }
              j += char.length - 1;
              var characterWidth = TextMetrics2.getFromCache(char, letterSpacing, cache, context2);
              if (characterWidth + width > wordWrapWidth) {
                lines += TextMetrics2.addLine(line);
                canPrependSpaces = false;
                line = "";
                width = 0;
              }
              line += char;
              width += characterWidth;
            }
          } else {
            if (line.length > 0) {
              lines += TextMetrics2.addLine(line);
              line = "";
              width = 0;
            }
            var isLastToken = i === tokens.length - 1;
            lines += TextMetrics2.addLine(token, !isLastToken);
            canPrependSpaces = false;
            line = "";
            width = 0;
          }
        } else {
          if (tokenWidth + width > wordWrapWidth) {
            canPrependSpaces = false;
            lines += TextMetrics2.addLine(line);
            line = "";
            width = 0;
          }
          if (line.length > 0 || !TextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
            line += token;
            width += tokenWidth;
          }
        }
      }
      lines += TextMetrics2.addLine(line, false);
      return lines;
    };
    TextMetrics2.addLine = function(line, newLine) {
      if (newLine === void 0) {
        newLine = true;
      }
      line = TextMetrics2.trimRight(line);
      line = newLine ? line + "\n" : line;
      return line;
    };
    TextMetrics2.getFromCache = function(key, letterSpacing, cache, context2) {
      var width = cache[key];
      if (typeof width !== "number") {
        var spacing = key.length * letterSpacing;
        width = context2.measureText(key).width + spacing;
        cache[key] = width;
      }
      return width;
    };
    TextMetrics2.collapseSpaces = function(whiteSpace) {
      return whiteSpace === "normal" || whiteSpace === "pre-line";
    };
    TextMetrics2.collapseNewlines = function(whiteSpace) {
      return whiteSpace === "normal";
    };
    TextMetrics2.trimRight = function(text2) {
      if (typeof text2 !== "string") {
        return "";
      }
      for (var i = text2.length - 1; i >= 0; i--) {
        var char = text2[i];
        if (!TextMetrics2.isBreakingSpace(char)) {
          break;
        }
        text2 = text2.slice(0, -1);
      }
      return text2;
    };
    TextMetrics2.isNewline = function(char) {
      if (typeof char !== "string") {
        return false;
      }
      return TextMetrics2._newlines.indexOf(char.charCodeAt(0)) >= 0;
    };
    TextMetrics2.isBreakingSpace = function(char, _nextChar) {
      if (typeof char !== "string") {
        return false;
      }
      return TextMetrics2._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
    };
    TextMetrics2.tokenize = function(text2) {
      var tokens = [];
      var token = "";
      if (typeof text2 !== "string") {
        return tokens;
      }
      for (var i = 0; i < text2.length; i++) {
        var char = text2[i];
        var nextChar = text2[i + 1];
        if (TextMetrics2.isBreakingSpace(char, nextChar) || TextMetrics2.isNewline(char)) {
          if (token !== "") {
            tokens.push(token);
            token = "";
          }
          tokens.push(char);
          continue;
        }
        token += char;
      }
      if (token !== "") {
        tokens.push(token);
      }
      return tokens;
    };
    TextMetrics2.canBreakWords = function(_token, breakWords) {
      return breakWords;
    };
    TextMetrics2.canBreakChars = function(_char, _nextChar, _token, _index, _breakWords) {
      return true;
    };
    TextMetrics2.wordWrapSplit = function(token) {
      return token.split("");
    };
    TextMetrics2.measureFont = function(font) {
      if (TextMetrics2._fonts[font]) {
        return TextMetrics2._fonts[font];
      }
      var properties = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      };
      var canvas = TextMetrics2._canvas;
      var context2 = TextMetrics2._context;
      context2.font = font;
      var metricsString = TextMetrics2.METRICS_STRING + TextMetrics2.BASELINE_SYMBOL;
      var width = Math.ceil(context2.measureText(metricsString).width);
      var baseline = Math.ceil(context2.measureText(TextMetrics2.BASELINE_SYMBOL).width);
      var height = Math.ceil(TextMetrics2.HEIGHT_MULTIPLIER * baseline);
      baseline = baseline * TextMetrics2.BASELINE_MULTIPLIER | 0;
      canvas.width = width;
      canvas.height = height;
      context2.fillStyle = "#f00";
      context2.fillRect(0, 0, width, height);
      context2.font = font;
      context2.textBaseline = "alphabetic";
      context2.fillStyle = "#000";
      context2.fillText(metricsString, 0, baseline);
      var imagedata = context2.getImageData(0, 0, width, height).data;
      var pixels = imagedata.length;
      var line = width * 4;
      var i = 0;
      var idx = 0;
      var stop = false;
      for (i = 0; i < baseline; ++i) {
        for (var j = 0; j < line; j += 4) {
          if (imagedata[idx + j] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx += line;
        } else {
          break;
        }
      }
      properties.ascent = baseline - i;
      idx = pixels - line;
      stop = false;
      for (i = height; i > baseline; --i) {
        for (var j = 0; j < line; j += 4) {
          if (imagedata[idx + j] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx -= line;
        } else {
          break;
        }
      }
      properties.descent = i - baseline;
      properties.fontSize = properties.ascent + properties.descent;
      TextMetrics2._fonts[font] = properties;
      return properties;
    };
    TextMetrics2.clearMetrics = function(font) {
      if (font === void 0) {
        font = "";
      }
      if (font) {
        delete TextMetrics2._fonts[font];
      } else {
        TextMetrics2._fonts = {};
      }
    };
    Object.defineProperty(TextMetrics2, "_canvas", {
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        if (!TextMetrics2.__canvas) {
          var canvas = void 0;
          try {
            var c2 = new OffscreenCanvas(0, 0);
            var context2 = c2.getContext("2d", contextSettings);
            if (context2 && context2.measureText) {
              TextMetrics2.__canvas = c2;
              return c2;
            }
            canvas = settings.ADAPTER.createCanvas();
          } catch (ex) {
            canvas = settings.ADAPTER.createCanvas();
          }
          canvas.width = canvas.height = 10;
          TextMetrics2.__canvas = canvas;
        }
        return TextMetrics2.__canvas;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextMetrics2, "_context", {
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        if (!TextMetrics2.__context) {
          TextMetrics2.__context = TextMetrics2._canvas.getContext("2d", contextSettings);
        }
        return TextMetrics2.__context;
      },
      enumerable: false,
      configurable: true
    });
    return TextMetrics2;
  }()
);
TextMetrics._fonts = {};
TextMetrics.METRICS_STRING = "|ÉqÅ";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
var Text = (
  /** @class */
  function(_super) {
    __extends$c(Text2, _super);
    function Text2(text2, style, canvas) {
      var _this = this;
      var ownCanvas = false;
      if (!canvas) {
        canvas = settings.ADAPTER.createCanvas();
        ownCanvas = true;
      }
      canvas.width = 3;
      canvas.height = 3;
      var texture = Texture.from(canvas);
      texture.orig = new Rectangle();
      texture.trim = new Rectangle();
      _this = _super.call(this, texture) || this;
      _this._ownCanvas = ownCanvas;
      _this.canvas = canvas;
      _this.context = canvas.getContext("2d", {
        // required for trimming to work without warnings
        willReadFrequently: true
      });
      _this._resolution = settings.RESOLUTION;
      _this._autoResolution = true;
      _this._text = null;
      _this._style = null;
      _this._styleListener = null;
      _this._font = "";
      _this.text = text2;
      _this.style = style;
      _this.localStyleID = -1;
      return _this;
    }
    Text2.prototype.updateText = function(respectDirty) {
      var style = this._style;
      if (this.localStyleID !== style.styleID) {
        this.dirty = true;
        this.localStyleID = style.styleID;
      }
      if (!this.dirty && respectDirty) {
        return;
      }
      this._font = this._style.toFontString();
      var context2 = this.context;
      var measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
      var width = measured.width;
      var height = measured.height;
      var lines = measured.lines;
      var lineHeight = measured.lineHeight;
      var lineWidths = measured.lineWidths;
      var maxLineWidth = measured.maxLineWidth;
      var fontProperties = measured.fontProperties;
      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
      this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
      context2.scale(this._resolution, this._resolution);
      context2.clearRect(0, 0, this.canvas.width, this.canvas.height);
      context2.font = this._font;
      context2.lineWidth = style.strokeThickness;
      context2.textBaseline = style.textBaseline;
      context2.lineJoin = style.lineJoin;
      context2.miterLimit = style.miterLimit;
      var linePositionX;
      var linePositionY;
      var passesCount = style.dropShadow ? 2 : 1;
      for (var i = 0; i < passesCount; ++i) {
        var isShadowPass = style.dropShadow && i === 0;
        var dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
        var dsOffsetShadow = dsOffsetText * this._resolution;
        if (isShadowPass) {
          context2.fillStyle = "black";
          context2.strokeStyle = "black";
          var dropShadowColor = style.dropShadowColor;
          var rgb2 = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
          var dropShadowBlur = style.dropShadowBlur * this._resolution;
          var dropShadowDistance = style.dropShadowDistance * this._resolution;
          context2.shadowColor = "rgba(" + rgb2[0] * 255 + "," + rgb2[1] * 255 + "," + rgb2[2] * 255 + "," + style.dropShadowAlpha + ")";
          context2.shadowBlur = dropShadowBlur;
          context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
          context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
        } else {
          context2.fillStyle = this._generateFillStyle(style, lines, measured);
          context2.strokeStyle = style.stroke;
          context2.shadowColor = "black";
          context2.shadowBlur = 0;
          context2.shadowOffsetX = 0;
          context2.shadowOffsetY = 0;
        }
        var linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
        if (!Text2.nextLineHeightBehavior || lineHeight - fontProperties.fontSize < 0) {
          linePositionYShift = 0;
        }
        for (var i_1 = 0; i_1 < lines.length; i_1++) {
          linePositionX = style.strokeThickness / 2;
          linePositionY = style.strokeThickness / 2 + i_1 * lineHeight + fontProperties.ascent + linePositionYShift;
          if (style.align === "right") {
            linePositionX += maxLineWidth - lineWidths[i_1];
          } else if (style.align === "center") {
            linePositionX += (maxLineWidth - lineWidths[i_1]) / 2;
          }
          if (style.stroke && style.strokeThickness) {
            this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
          }
          if (style.fill) {
            this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
          }
        }
      }
      this.updateTexture();
    };
    Text2.prototype.drawLetterSpacing = function(text2, x, y, isStroke) {
      if (isStroke === void 0) {
        isStroke = false;
      }
      var style = this._style;
      var letterSpacing = style.letterSpacing;
      var supportLetterSpacing = Text2.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
      if (letterSpacing === 0 || supportLetterSpacing) {
        if (supportLetterSpacing) {
          this.context.letterSpacing = letterSpacing;
          this.context.textLetterSpacing = letterSpacing;
        }
        if (isStroke) {
          this.context.strokeText(text2, x, y);
        } else {
          this.context.fillText(text2, x, y);
        }
        return;
      }
      var currentPosition = x;
      var stringArray = Array.from ? Array.from(text2) : text2.split("");
      var previousWidth = this.context.measureText(text2).width;
      var currentWidth = 0;
      for (var i = 0; i < stringArray.length; ++i) {
        var currentChar = stringArray[i];
        if (isStroke) {
          this.context.strokeText(currentChar, currentPosition, y);
        } else {
          this.context.fillText(currentChar, currentPosition, y);
        }
        var textStr = "";
        for (var j = i + 1; j < stringArray.length; ++j) {
          textStr += stringArray[j];
        }
        currentWidth = this.context.measureText(textStr).width;
        currentPosition += previousWidth - currentWidth + letterSpacing;
        previousWidth = currentWidth;
      }
    };
    Text2.prototype.updateTexture = function() {
      var canvas = this.canvas;
      if (this._style.trim) {
        var trimmed = trimCanvas(canvas);
        if (trimmed.data) {
          canvas.width = trimmed.width;
          canvas.height = trimmed.height;
          this.context.putImageData(trimmed.data, 0, 0);
        }
      }
      var texture = this._texture;
      var style = this._style;
      var padding = style.trim ? 0 : style.padding;
      var baseTexture = texture.baseTexture;
      texture.trim.width = texture._frame.width = canvas.width / this._resolution;
      texture.trim.height = texture._frame.height = canvas.height / this._resolution;
      texture.trim.x = -padding;
      texture.trim.y = -padding;
      texture.orig.width = texture._frame.width - padding * 2;
      texture.orig.height = texture._frame.height - padding * 2;
      this._onTextureUpdate();
      baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
      texture.updateUvs();
      this.dirty = false;
    };
    Text2.prototype._render = function(renderer) {
      if (this._autoResolution && this._resolution !== renderer.resolution) {
        this._resolution = renderer.resolution;
        this.dirty = true;
      }
      this.updateText(true);
      _super.prototype._render.call(this, renderer);
    };
    Text2.prototype.updateTransform = function() {
      this.updateText(true);
      _super.prototype.updateTransform.call(this);
    };
    Text2.prototype.getBounds = function(skipUpdate, rect) {
      this.updateText(true);
      if (this._textureID === -1) {
        skipUpdate = false;
      }
      return _super.prototype.getBounds.call(this, skipUpdate, rect);
    };
    Text2.prototype.getLocalBounds = function(rect) {
      this.updateText(true);
      return _super.prototype.getLocalBounds.call(this, rect);
    };
    Text2.prototype._calculateBounds = function() {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    };
    Text2.prototype._generateFillStyle = function(style, lines, metrics) {
      var fillStyle = style.fill;
      if (!Array.isArray(fillStyle)) {
        return fillStyle;
      } else if (fillStyle.length === 1) {
        return fillStyle[0];
      }
      var gradient;
      var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
      var padding = style.padding || 0;
      var width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
      var height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
      var fill = fillStyle.slice();
      var fillGradientStops = style.fillGradientStops.slice();
      if (!fillGradientStops.length) {
        var lengthPlus1 = fill.length + 1;
        for (var i = 1; i < lengthPlus1; ++i) {
          fillGradientStops.push(i / lengthPlus1);
        }
      }
      fill.unshift(fillStyle[0]);
      fillGradientStops.unshift(0);
      fill.push(fillStyle[fillStyle.length - 1]);
      fillGradientStops.push(1);
      if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
        gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
        var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
        for (var i = 0; i < lines.length; i++) {
          var lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;
          var thisLineTop = metrics.lineHeight * i;
          var thisLineGradientStart = thisLineTop;
          if (i > 0 && lastLineBottom > thisLineTop) {
            thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
          }
          var thisLineBottom = thisLineTop + textHeight;
          var nextLineTop = metrics.lineHeight * (i + 1);
          var thisLineGradientEnd = thisLineBottom;
          if (i + 1 < lines.length && nextLineTop < thisLineBottom) {
            thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
          }
          var gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
          for (var j = 0; j < fill.length; j++) {
            var lineStop = 0;
            if (typeof fillGradientStops[j] === "number") {
              lineStop = fillGradientStops[j];
            } else {
              lineStop = j / fill.length;
            }
            var globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
            globalStop = Number(globalStop.toFixed(5));
            gradient.addColorStop(globalStop, fill[j]);
          }
        }
      } else {
        gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
        var totalIterations = fill.length + 1;
        var currentIteration = 1;
        for (var i = 0; i < fill.length; i++) {
          var stop = void 0;
          if (typeof fillGradientStops[i] === "number") {
            stop = fillGradientStops[i];
          } else {
            stop = currentIteration / totalIterations;
          }
          gradient.addColorStop(stop, fill[i]);
          currentIteration++;
        }
      }
      return gradient;
    };
    Text2.prototype.destroy = function(options) {
      if (typeof options === "boolean") {
        options = { children: options };
      }
      options = Object.assign({}, defaultDestroyOptions, options);
      _super.prototype.destroy.call(this, options);
      if (this._ownCanvas) {
        this.canvas.height = this.canvas.width = 0;
      }
      this.context = null;
      this.canvas = null;
      this._style = null;
    };
    Object.defineProperty(Text2.prototype, "width", {
      /** The width of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        this.updateText(true);
        return Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(value) {
        this.updateText(true);
        var s = sign$1(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Text2.prototype, "height", {
      /** The height of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        this.updateText(true);
        return Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(value) {
        this.updateText(true);
        var s = sign$1(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Text2.prototype, "style", {
      /**
       * Set the style of the text.
       *
       * Set up an event listener to listen for changes on the style object and mark the text as dirty.
       */
      get: function() {
        return this._style;
      },
      set: function(style) {
        style = style || {};
        if (style instanceof TextStyle) {
          this._style = style;
        } else {
          this._style = new TextStyle(style);
        }
        this.localStyleID = -1;
        this.dirty = true;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Text2.prototype, "text", {
      /** Set the copy for the text object. To split a line you can use '\n'. */
      get: function() {
        return this._text;
      },
      set: function(text2) {
        text2 = String(text2 === null || text2 === void 0 ? "" : text2);
        if (this._text === text2) {
          return;
        }
        this._text = text2;
        this.dirty = true;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Text2.prototype, "resolution", {
      /**
       * The resolution / device pixel ratio of the canvas.
       *
       * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
       * @default 1
       */
      get: function() {
        return this._resolution;
      },
      set: function(value) {
        this._autoResolution = false;
        if (this._resolution === value) {
          return;
        }
        this._resolution = value;
        this.dirty = true;
      },
      enumerable: false,
      configurable: true
    });
    Text2.nextLineHeightBehavior = false;
    Text2.experimentalLetterSpacing = false;
    return Text2;
  }(Sprite)
);
/*!
 * @pixi/prepare - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$b = function(d, b) {
  extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$b(d, b);
};
function __extends$b(d, b) {
  extendStatics$b(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var CountLimiter = (
  /** @class */
  function() {
    function CountLimiter2(maxItemsPerFrame) {
      this.maxItemsPerFrame = maxItemsPerFrame;
      this.itemsLeft = 0;
    }
    CountLimiter2.prototype.beginFrame = function() {
      this.itemsLeft = this.maxItemsPerFrame;
    };
    CountLimiter2.prototype.allowedToUpload = function() {
      return this.itemsLeft-- > 0;
    };
    return CountLimiter2;
  }()
);
function findMultipleBaseTextures(item, queue) {
  var result = false;
  if (item && item._textures && item._textures.length) {
    for (var i = 0; i < item._textures.length; i++) {
      if (item._textures[i] instanceof Texture) {
        var baseTexture = item._textures[i].baseTexture;
        if (queue.indexOf(baseTexture) === -1) {
          queue.push(baseTexture);
          result = true;
        }
      }
    }
  }
  return result;
}
function findBaseTexture(item, queue) {
  if (item.baseTexture instanceof BaseTexture) {
    var texture = item.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTexture(item, queue) {
  if (item._texture && item._texture instanceof Texture) {
    var texture = item._texture.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function drawText(_helper, item) {
  if (item instanceof Text) {
    item.updateText(true);
    return true;
  }
  return false;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof TextStyle) {
    var font = item.toFontString();
    TextMetrics.measureFont(font);
    return true;
  }
  return false;
}
function findText(item, queue) {
  if (item instanceof Text) {
    if (queue.indexOf(item.style) === -1) {
      queue.push(item.style);
    }
    if (queue.indexOf(item) === -1) {
      queue.push(item);
    }
    var texture = item._texture.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTextStyle(item, queue) {
  if (item instanceof TextStyle) {
    if (queue.indexOf(item) === -1) {
      queue.push(item);
    }
    return true;
  }
  return false;
}
var BasePrepare = (
  /** @class */
  function() {
    function BasePrepare2(renderer) {
      var _this = this;
      this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);
      this.renderer = renderer;
      this.uploadHookHelper = null;
      this.queue = [];
      this.addHooks = [];
      this.uploadHooks = [];
      this.completes = [];
      this.ticking = false;
      this.delayedTick = function() {
        if (!_this.queue) {
          return;
        }
        _this.prepareItems();
      };
      this.registerFindHook(findText);
      this.registerFindHook(findTextStyle);
      this.registerFindHook(findMultipleBaseTextures);
      this.registerFindHook(findBaseTexture);
      this.registerFindHook(findTexture);
      this.registerUploadHook(drawText);
      this.registerUploadHook(calculateTextStyle);
    }
    BasePrepare2.prototype.upload = function(item, done) {
      var _this = this;
      if (typeof item === "function") {
        done = item;
        item = null;
      }
      if (done) {
        deprecation("6.5.0", "BasePrepare.upload callback is deprecated, use the return Promise instead.");
      }
      return new Promise(function(resolve2) {
        if (item) {
          _this.add(item);
        }
        var complete = function() {
          done === null || done === void 0 ? void 0 : done();
          resolve2();
        };
        if (_this.queue.length) {
          _this.completes.push(complete);
          if (!_this.ticking) {
            _this.ticking = true;
            Ticker.system.addOnce(_this.tick, _this, UPDATE_PRIORITY.UTILITY);
          }
        } else {
          complete();
        }
      });
    };
    BasePrepare2.prototype.tick = function() {
      setTimeout(this.delayedTick, 0);
    };
    BasePrepare2.prototype.prepareItems = function() {
      this.limiter.beginFrame();
      while (this.queue.length && this.limiter.allowedToUpload()) {
        var item = this.queue[0];
        var uploaded = false;
        if (item && !item._destroyed) {
          for (var i = 0, len = this.uploadHooks.length; i < len; i++) {
            if (this.uploadHooks[i](this.uploadHookHelper, item)) {
              this.queue.shift();
              uploaded = true;
              break;
            }
          }
        }
        if (!uploaded) {
          this.queue.shift();
        }
      }
      if (!this.queue.length) {
        this.ticking = false;
        var completes = this.completes.slice(0);
        this.completes.length = 0;
        for (var i = 0, len = completes.length; i < len; i++) {
          completes[i]();
        }
      } else {
        Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
      }
    };
    BasePrepare2.prototype.registerFindHook = function(addHook) {
      if (addHook) {
        this.addHooks.push(addHook);
      }
      return this;
    };
    BasePrepare2.prototype.registerUploadHook = function(uploadHook) {
      if (uploadHook) {
        this.uploadHooks.push(uploadHook);
      }
      return this;
    };
    BasePrepare2.prototype.add = function(item) {
      for (var i = 0, len = this.addHooks.length; i < len; i++) {
        if (this.addHooks[i](item, this.queue)) {
          break;
        }
      }
      if (item instanceof Container) {
        for (var i = item.children.length - 1; i >= 0; i--) {
          this.add(item.children[i]);
        }
      }
      return this;
    };
    BasePrepare2.prototype.destroy = function() {
      if (this.ticking) {
        Ticker.system.remove(this.tick, this);
      }
      this.ticking = false;
      this.addHooks = null;
      this.uploadHooks = null;
      this.renderer = null;
      this.completes = null;
      this.queue = null;
      this.limiter = null;
      this.uploadHookHelper = null;
    };
    return BasePrepare2;
  }()
);
function uploadBaseTextures(renderer, item) {
  if (item instanceof BaseTexture) {
    if (!item._glTextures[renderer.CONTEXT_UID]) {
      renderer.texture.bind(item);
    }
    return true;
  }
  return false;
}
function uploadGraphics(renderer, item) {
  if (!(item instanceof Graphics)) {
    return false;
  }
  var geometry = item.geometry;
  item.finishPoly();
  geometry.updateBatches();
  var batches = geometry.batches;
  for (var i = 0; i < batches.length; i++) {
    var texture = batches[i].style.texture;
    if (texture) {
      uploadBaseTextures(renderer, texture.baseTexture);
    }
  }
  if (!geometry.batchable) {
    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
  }
  return true;
}
function findGraphics(item, queue) {
  if (item instanceof Graphics) {
    queue.push(item);
    return true;
  }
  return false;
}
var Prepare = (
  /** @class */
  function(_super) {
    __extends$b(Prepare2, _super);
    function Prepare2(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.uploadHookHelper = _this.renderer;
      _this.registerFindHook(findGraphics);
      _this.registerUploadHook(uploadBaseTextures);
      _this.registerUploadHook(uploadGraphics);
      return _this;
    }
    Prepare2.extension = {
      name: "prepare",
      type: ExtensionType.RendererPlugin
    };
    return Prepare2;
  }(BasePrepare)
);
/*!
 * @pixi/spritesheet - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Spritesheet = (
  /** @class */
  function() {
    function Spritesheet2(texture, data, resolutionFilename) {
      if (resolutionFilename === void 0) {
        resolutionFilename = null;
      }
      this.linkedSheets = [];
      this._texture = texture instanceof Texture ? texture : null;
      this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;
      this.textures = {};
      this.animations = {};
      this.data = data;
      var resource = this.baseTexture.resource;
      this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
      this._frames = this.data.frames;
      this._frameKeys = Object.keys(this._frames);
      this._batchIndex = 0;
      this._callback = null;
    }
    Spritesheet2.prototype._updateResolution = function(resolutionFilename) {
      if (resolutionFilename === void 0) {
        resolutionFilename = null;
      }
      var scale = this.data.meta.scale;
      var resolution = getResolutionOfUrl(resolutionFilename, null);
      if (resolution === null) {
        resolution = scale !== void 0 ? parseFloat(scale) : 1;
      }
      if (resolution !== 1) {
        this.baseTexture.setResolution(resolution);
      }
      return resolution;
    };
    Spritesheet2.prototype.parse = function(callback) {
      var _this = this;
      if (callback) {
        deprecation("6.5.0", "Spritesheet.parse callback is deprecated, use the return Promise instead.");
      }
      return new Promise(function(resolve2) {
        _this._callback = function(textures) {
          callback === null || callback === void 0 ? void 0 : callback(textures);
          resolve2(textures);
        };
        _this._batchIndex = 0;
        if (_this._frameKeys.length <= Spritesheet2.BATCH_SIZE) {
          _this._processFrames(0);
          _this._processAnimations();
          _this._parseComplete();
        } else {
          _this._nextBatch();
        }
      });
    };
    Spritesheet2.prototype._processFrames = function(initialFrameIndex) {
      var frameIndex = initialFrameIndex;
      var maxFrames = Spritesheet2.BATCH_SIZE;
      while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
        var i = this._frameKeys[frameIndex];
        var data = this._frames[i];
        var rect = data.frame;
        if (rect) {
          var frame2 = null;
          var trim = null;
          var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
          var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
          if (data.rotated) {
            frame2 = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
          } else {
            frame2 = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
          }
          if (data.trimmed !== false && data.spriteSourceSize) {
            trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
          }
          this.textures[i] = new Texture(this.baseTexture, frame2, orig, trim, data.rotated ? 2 : 0, data.anchor);
          Texture.addToCache(this.textures[i], i);
        }
        frameIndex++;
      }
    };
    Spritesheet2.prototype._processAnimations = function() {
      var animations = this.data.animations || {};
      for (var animName in animations) {
        this.animations[animName] = [];
        for (var i = 0; i < animations[animName].length; i++) {
          var frameName = animations[animName][i];
          this.animations[animName].push(this.textures[frameName]);
        }
      }
    };
    Spritesheet2.prototype._parseComplete = function() {
      var callback = this._callback;
      this._callback = null;
      this._batchIndex = 0;
      callback.call(this, this.textures);
    };
    Spritesheet2.prototype._nextBatch = function() {
      var _this = this;
      this._processFrames(this._batchIndex * Spritesheet2.BATCH_SIZE);
      this._batchIndex++;
      setTimeout(function() {
        if (_this._batchIndex * Spritesheet2.BATCH_SIZE < _this._frameKeys.length) {
          _this._nextBatch();
        } else {
          _this._processAnimations();
          _this._parseComplete();
        }
      }, 0);
    };
    Spritesheet2.prototype.destroy = function(destroyBase) {
      var _a2;
      if (destroyBase === void 0) {
        destroyBase = false;
      }
      for (var i in this.textures) {
        this.textures[i].destroy();
      }
      this._frames = null;
      this._frameKeys = null;
      this.data = null;
      this.textures = null;
      if (destroyBase) {
        (_a2 = this._texture) === null || _a2 === void 0 ? void 0 : _a2.destroy();
        this.baseTexture.destroy();
      }
      this._texture = null;
      this.baseTexture = null;
      this.linkedSheets = [];
    };
    Spritesheet2.BATCH_SIZE = 1e3;
    return Spritesheet2;
  }()
);
var SpritesheetLoader = (
  /** @class */
  function() {
    function SpritesheetLoader2() {
    }
    SpritesheetLoader2.use = function(resource, next) {
      var _a2, _b2;
      var loader = this;
      var imageResourceName = resource.name + "_image";
      if (!resource.data || resource.type !== LoaderResource.TYPE.JSON || !resource.data.frames || loader.resources[imageResourceName]) {
        next();
        return;
      }
      var multiPacks = (_b2 = (_a2 = resource.data) === null || _a2 === void 0 ? void 0 : _a2.meta) === null || _b2 === void 0 ? void 0 : _b2.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        var _loop_1 = function(item2) {
          if (typeof item2 !== "string") {
            return "continue";
          }
          var itemName = item2.replace(".json", "");
          var itemUrl = url.resolve(resource.url.replace(loader.baseUrl, ""), item2);
          if (loader.resources[itemName] || Object.values(loader.resources).some(function(r) {
            return url.format(url.parse(r.url)) === itemUrl;
          })) {
            return "continue";
          }
          var options = {
            crossOrigin: resource.crossOrigin,
            loadType: LoaderResource.LOAD_TYPE.XHR,
            xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,
            parentResource: resource,
            metadata: resource.metadata
          };
          loader.add(itemName, itemUrl, options);
        };
        for (var _i = 0, multiPacks_1 = multiPacks; _i < multiPacks_1.length; _i++) {
          var item = multiPacks_1[_i];
          _loop_1(item);
        }
      }
      var loadOptions = {
        crossOrigin: resource.crossOrigin,
        metadata: resource.metadata.imageMetadata,
        parentResource: resource
      };
      var resourcePath = SpritesheetLoader2.getResourcePath(resource, loader.baseUrl);
      loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {
        if (res.error) {
          next(res.error);
          return;
        }
        var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);
        spritesheet.parse().then(function() {
          resource.spritesheet = spritesheet;
          resource.textures = spritesheet.textures;
          next();
        });
      });
    };
    SpritesheetLoader2.getResourcePath = function(resource, baseUrl) {
      if (resource.isDataUrl) {
        return resource.data.meta.image;
      }
      return url.resolve(resource.url.replace(baseUrl, ""), resource.data.meta.image);
    };
    SpritesheetLoader2.extension = ExtensionType.Loader;
    return SpritesheetLoader2;
  }()
);
/*!
 * @pixi/sprite-tiling - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$a = function(d, b) {
  extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$a(d, b);
};
function __extends$a(d, b) {
  extendStatics$a(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var tempPoint$1 = new Point();
(function(_super) {
  __extends$a(TilingSprite, _super);
  function TilingSprite(texture, width, height) {
    if (width === void 0) {
      width = 100;
    }
    if (height === void 0) {
      height = 100;
    }
    var _this = _super.call(this, texture) || this;
    _this.tileTransform = new Transform();
    _this._width = width;
    _this._height = height;
    _this.uvMatrix = _this.texture.uvMatrix || new TextureMatrix(texture);
    _this.pluginName = "tilingSprite";
    _this.uvRespectAnchor = false;
    return _this;
  }
  Object.defineProperty(TilingSprite.prototype, "clampMargin", {
    /**
     * Changes frame clamping in corresponding textureTransform, shortcut
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     * @default 0.5
     * @member {number}
     */
    get: function() {
      return this.uvMatrix.clampMargin;
    },
    set: function(value) {
      this.uvMatrix.clampMargin = value;
      this.uvMatrix.update(true);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TilingSprite.prototype, "tileScale", {
    /** The scaling of the image that is being tiled. */
    get: function() {
      return this.tileTransform.scale;
    },
    set: function(value) {
      this.tileTransform.scale.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TilingSprite.prototype, "tilePosition", {
    /** The offset of the image that is being tiled. */
    get: function() {
      return this.tileTransform.position;
    },
    set: function(value) {
      this.tileTransform.position.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  TilingSprite.prototype._onTextureUpdate = function() {
    if (this.uvMatrix) {
      this.uvMatrix.texture = this._texture;
    }
    this._cachedTint = 16777215;
  };
  TilingSprite.prototype._render = function(renderer) {
    var texture = this._texture;
    if (!texture || !texture.valid) {
      return;
    }
    this.tileTransform.updateLocalTransform();
    this.uvMatrix.update();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  };
  TilingSprite.prototype._calculateBounds = function() {
    var minX = this._width * -this._anchor._x;
    var minY = this._height * -this._anchor._y;
    var maxX = this._width * (1 - this._anchor._x);
    var maxY = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  };
  TilingSprite.prototype.getLocalBounds = function(rect) {
    if (this.children.length === 0) {
      this._bounds.minX = this._width * -this._anchor._x;
      this._bounds.minY = this._height * -this._anchor._y;
      this._bounds.maxX = this._width * (1 - this._anchor._x);
      this._bounds.maxY = this._height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._bounds.getRectangle(rect);
    }
    return _super.prototype.getLocalBounds.call(this, rect);
  };
  TilingSprite.prototype.containsPoint = function(point) {
    this.worldTransform.applyInverse(point, tempPoint$1);
    var width = this._width;
    var height = this._height;
    var x1 = -width * this.anchor._x;
    if (tempPoint$1.x >= x1 && tempPoint$1.x < x1 + width) {
      var y1 = -height * this.anchor._y;
      if (tempPoint$1.y >= y1 && tempPoint$1.y < y1 + height) {
        return true;
      }
    }
    return false;
  };
  TilingSprite.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this.tileTransform = null;
    this.uvMatrix = null;
  };
  TilingSprite.from = function(source, options) {
    var texture = source instanceof Texture ? source : Texture.from(source, options);
    return new TilingSprite(texture, options.width, options.height);
  };
  Object.defineProperty(TilingSprite.prototype, "width", {
    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._width;
    },
    set: function(value) {
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TilingSprite.prototype, "height", {
    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._height;
    },
    set: function(value) {
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  return TilingSprite;
})(Sprite);
var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";
var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";
var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";
var tempMat = new Matrix$1();
var TilingSpriteRenderer = (
  /** @class */
  function(_super) {
    __extends$a(TilingSpriteRenderer2, _super);
    function TilingSpriteRenderer2(renderer) {
      var _this = _super.call(this, renderer) || this;
      renderer.runners.contextChange.add(_this);
      _this.quad = new QuadUv();
      _this.state = State.for2d();
      return _this;
    }
    TilingSpriteRenderer2.prototype.contextChange = function() {
      var renderer = this.renderer;
      var uniforms = { globals: renderer.globalUniforms };
      this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
      this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
    };
    TilingSpriteRenderer2.prototype.render = function(ts) {
      var renderer = this.renderer;
      var quad = this.quad;
      var vertices = quad.vertices;
      vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
      vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
      vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
      vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
      var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
      var anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
      vertices = quad.uvs;
      vertices[0] = vertices[6] = -anchorX;
      vertices[1] = vertices[3] = -anchorY;
      vertices[2] = vertices[4] = 1 - anchorX;
      vertices[5] = vertices[7] = 1 - anchorY;
      quad.invalidate();
      var tex = ts._texture;
      var baseTex = tex.baseTexture;
      var premultiplied = baseTex.alphaMode > 0;
      var lt = ts.tileTransform.localTransform;
      var uv = ts.uvMatrix;
      var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
      if (isSimple) {
        if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
          if (baseTex.wrapMode === WRAP_MODES.CLAMP) {
            baseTex.wrapMode = WRAP_MODES.REPEAT;
          }
        } else {
          isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;
        }
      }
      var shader = isSimple ? this.simpleShader : this.shader;
      var w = tex.width;
      var h = tex.height;
      var W = ts._width;
      var H = ts._height;
      tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
      tempMat.invert();
      if (isSimple) {
        tempMat.prepend(uv.mapCoord);
      } else {
        shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
        shader.uniforms.uClampFrame = uv.uClampFrame;
        shader.uniforms.uClampOffset = uv.uClampOffset;
      }
      shader.uniforms.uTransform = tempMat.toArray(true);
      shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, premultiplied);
      shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
      shader.uniforms.uSampler = tex;
      renderer.shader.bind(shader);
      renderer.geometry.bind(quad);
      this.state.blendMode = correctBlendMode(ts.blendMode, premultiplied);
      renderer.state.set(this.state);
      renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    };
    TilingSpriteRenderer2.extension = {
      name: "tilingSprite",
      type: ExtensionType.RendererPlugin
    };
    return TilingSpriteRenderer2;
  }(ObjectRenderer)
);
/*!
 * @pixi/mesh - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$9 = function(d, b) {
  extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$9(d, b);
};
function __extends$9(d, b) {
  extendStatics$9(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var MeshBatchUvs = (
  /** @class */
  function() {
    function MeshBatchUvs2(uvBuffer, uvMatrix) {
      this.uvBuffer = uvBuffer;
      this.uvMatrix = uvMatrix;
      this.data = null;
      this._bufferUpdateId = -1;
      this._textureUpdateId = -1;
      this._updateID = 0;
    }
    MeshBatchUvs2.prototype.update = function(forceUpdate) {
      if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
        return;
      }
      this._bufferUpdateId = this.uvBuffer._updateID;
      this._textureUpdateId = this.uvMatrix._updateID;
      var data = this.uvBuffer.data;
      if (!this.data || this.data.length !== data.length) {
        this.data = new Float32Array(data.length);
      }
      this.uvMatrix.multiplyUvs(data, this.data);
      this._updateID++;
    };
    return MeshBatchUvs2;
  }()
);
var tempPoint = new Point();
var tempPolygon = new Polygon();
var Mesh = (
  /** @class */
  function(_super) {
    __extends$9(Mesh2, _super);
    function Mesh2(geometry, shader, state, drawMode) {
      if (drawMode === void 0) {
        drawMode = DRAW_MODES.TRIANGLES;
      }
      var _this = _super.call(this) || this;
      _this.geometry = geometry;
      _this.shader = shader;
      _this.state = state || State.for2d();
      _this.drawMode = drawMode;
      _this.start = 0;
      _this.size = 0;
      _this.uvs = null;
      _this.indices = null;
      _this.vertexData = new Float32Array(1);
      _this.vertexDirty = -1;
      _this._transformID = -1;
      _this._roundPixels = settings.ROUND_PIXELS;
      _this.batchUvs = null;
      return _this;
    }
    Object.defineProperty(Mesh2.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh objects.
       */
      get: function() {
        return this._geometry;
      },
      set: function(value) {
        if (this._geometry === value) {
          return;
        }
        if (this._geometry) {
          this._geometry.refCount--;
          if (this._geometry.refCount === 0) {
            this._geometry.dispose();
          }
        }
        this._geometry = value;
        if (this._geometry) {
          this._geometry.refCount++;
        }
        this.vertexDirty = -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "uvBuffer", {
      /**
       * To change mesh uv's, change its uvBuffer data and increment its _updateID.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[1];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "verticesBuffer", {
      /**
       * To change mesh vertices, change its uvBuffer data and increment its _updateID.
       * Incrementing _updateID is optional because most of Mesh objects do it anyway.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[0];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "material", {
      get: function() {
        return this.shader;
      },
      /** Alias for {@link PIXI.Mesh#shader}. */
      set: function(value) {
        this.shader = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the Mesh. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * @default PIXI.BLEND_MODES.NORMAL;
       */
      set: function(value) {
        this.state.blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
       * @default false
       */
      set: function(value) {
        if (this._roundPixels !== value) {
          this._transformID = -1;
        }
        this._roundPixels = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "tint", {
      /**
       * The multiply tint applied to the Mesh. This is a hex value. A value of
       * `0xFFFFFF` will remove any tint effect.
       *
       * Null for non-MeshMaterial shaders
       * @default 0xFFFFFF
       */
      get: function() {
        return "tint" in this.shader ? this.shader.tint : null;
      },
      set: function(value) {
        this.shader.tint = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "texture", {
      /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
      get: function() {
        return "texture" in this.shader ? this.shader.texture : null;
      },
      set: function(value) {
        this.shader.texture = value;
      },
      enumerable: false,
      configurable: true
    });
    Mesh2.prototype._render = function(renderer) {
      var vertices = this.geometry.buffers[0].data;
      var shader = this.shader;
      if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < Mesh2.BATCHABLE_SIZE * 2) {
        this._renderToBatch(renderer);
      } else {
        this._renderDefault(renderer);
      }
    };
    Mesh2.prototype._renderDefault = function(renderer) {
      var shader = this.shader;
      shader.alpha = this.worldAlpha;
      if (shader.update) {
        shader.update();
      }
      renderer.batch.flush();
      shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
      renderer.shader.bind(shader);
      renderer.state.set(this.state);
      renderer.geometry.bind(this.geometry, shader);
      renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    };
    Mesh2.prototype._renderToBatch = function(renderer) {
      var geometry = this.geometry;
      var shader = this.shader;
      if (shader.uvMatrix) {
        shader.uvMatrix.update();
        this.calculateUvs();
      }
      this.calculateVertices();
      this.indices = geometry.indexBuffer.data;
      this._tintRGB = shader._tintRGB;
      this._texture = shader.texture;
      var pluginName = this.material.pluginName;
      renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
      renderer.plugins[pluginName].render(this);
    };
    Mesh2.prototype.calculateVertices = function() {
      var geometry = this.geometry;
      var verticesBuffer = geometry.buffers[0];
      var vertices = verticesBuffer.data;
      var vertexDirtyId = verticesBuffer._updateID;
      if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
        return;
      }
      this._transformID = this.transform._worldID;
      if (this.vertexData.length !== vertices.length) {
        this.vertexData = new Float32Array(vertices.length);
      }
      var wt = this.transform.worldTransform;
      var a = wt.a;
      var b = wt.b;
      var c2 = wt.c;
      var d = wt.d;
      var tx = wt.tx;
      var ty = wt.ty;
      var vertexData = this.vertexData;
      for (var i = 0; i < vertexData.length / 2; i++) {
        var x = vertices[i * 2];
        var y = vertices[i * 2 + 1];
        vertexData[i * 2] = a * x + c2 * y + tx;
        vertexData[i * 2 + 1] = b * x + d * y + ty;
      }
      if (this._roundPixels) {
        var resolution = settings.RESOLUTION;
        for (var i = 0; i < vertexData.length; ++i) {
          vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);
        }
      }
      this.vertexDirty = vertexDirtyId;
    };
    Mesh2.prototype.calculateUvs = function() {
      var geomUvs = this.geometry.buffers[1];
      var shader = this.shader;
      if (!shader.uvMatrix.isSimple) {
        if (!this.batchUvs) {
          this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
        }
        this.batchUvs.update();
        this.uvs = this.batchUvs.data;
      } else {
        this.uvs = geomUvs.data;
      }
    };
    Mesh2.prototype._calculateBounds = function() {
      this.calculateVertices();
      this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    };
    Mesh2.prototype.containsPoint = function(point) {
      if (!this.getBounds().contains(point.x, point.y)) {
        return false;
      }
      this.worldTransform.applyInverse(point, tempPoint);
      var vertices = this.geometry.getBuffer("aVertexPosition").data;
      var points = tempPolygon.points;
      var indices3 = this.geometry.getIndex().data;
      var len = indices3.length;
      var step = this.drawMode === 4 ? 3 : 1;
      for (var i = 0; i + 2 < len; i += step) {
        var ind0 = indices3[i] * 2;
        var ind1 = indices3[i + 1] * 2;
        var ind2 = indices3[i + 2] * 2;
        points[0] = vertices[ind0];
        points[1] = vertices[ind0 + 1];
        points[2] = vertices[ind1];
        points[3] = vertices[ind1 + 1];
        points[4] = vertices[ind2];
        points[5] = vertices[ind2 + 1];
        if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
          return true;
        }
      }
      return false;
    };
    Mesh2.prototype.destroy = function(options) {
      _super.prototype.destroy.call(this, options);
      if (this._cachedTexture) {
        this._cachedTexture.destroy();
        this._cachedTexture = null;
      }
      this.geometry = null;
      this.shader = null;
      this.state = null;
      this.uvs = null;
      this.indices = null;
      this.vertexData = null;
    };
    Mesh2.BATCHABLE_SIZE = 100;
    return Mesh2;
  }(Container)
);
var fragment$5 = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
var vertex$2 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var MeshMaterial = (
  /** @class */
  function(_super) {
    __extends$9(MeshMaterial2, _super);
    function MeshMaterial2(uSampler, options) {
      var _this = this;
      var uniforms = {
        uSampler,
        alpha: 1,
        uTextureMatrix: Matrix$1.IDENTITY,
        uColor: new Float32Array([1, 1, 1, 1])
      };
      options = Object.assign({
        tint: 16777215,
        alpha: 1,
        pluginName: "batch"
      }, options);
      if (options.uniforms) {
        Object.assign(uniforms, options.uniforms);
      }
      _this = _super.call(this, options.program || Program.from(vertex$2, fragment$5), uniforms) || this;
      _this._colorDirty = false;
      _this.uvMatrix = new TextureMatrix(uSampler);
      _this.batchable = options.program === void 0;
      _this.pluginName = options.pluginName;
      _this.tint = options.tint;
      _this.alpha = options.alpha;
      return _this;
    }
    Object.defineProperty(MeshMaterial2.prototype, "texture", {
      /** Reference to the texture being rendered. */
      get: function() {
        return this.uniforms.uSampler;
      },
      set: function(value) {
        if (this.uniforms.uSampler !== value) {
          if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {
            this._colorDirty = true;
          }
          this.uniforms.uSampler = value;
          this.uvMatrix.texture = value;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MeshMaterial2.prototype, "alpha", {
      get: function() {
        return this._alpha;
      },
      /**
       * This gets automatically set by the object using this.
       * @default 1
       */
      set: function(value) {
        if (value === this._alpha) {
          return;
        }
        this._alpha = value;
        this._colorDirty = true;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MeshMaterial2.prototype, "tint", {
      get: function() {
        return this._tint;
      },
      /**
       * Multiply tint for the material.
       * @default 0xFFFFFF
       */
      set: function(value) {
        if (value === this._tint) {
          return;
        }
        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
        this._colorDirty = true;
      },
      enumerable: false,
      configurable: true
    });
    MeshMaterial2.prototype.update = function() {
      if (this._colorDirty) {
        this._colorDirty = false;
        var baseTexture = this.texture.baseTexture;
        premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);
      }
      if (this.uvMatrix.update()) {
        this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
      }
    };
    return MeshMaterial2;
  }(Shader)
);
var MeshGeometry = (
  /** @class */
  function(_super) {
    __extends$9(MeshGeometry2, _super);
    function MeshGeometry2(vertices, uvs, index) {
      var _this = _super.call(this) || this;
      var verticesBuffer = new Buffer2(vertices);
      var uvsBuffer = new Buffer2(uvs, true);
      var indexBuffer = new Buffer2(index, true, true);
      _this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer);
      _this._updateId = -1;
      return _this;
    }
    Object.defineProperty(MeshGeometry2.prototype, "vertexDirtyId", {
      /**
       * If the vertex position is updated.
       * @readonly
       * @private
       */
      get: function() {
        return this.buffers[0]._updateID;
      },
      enumerable: false,
      configurable: true
    });
    return MeshGeometry2;
  }(Geometry)
);
/*!
 * @pixi/text-bitmap - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$8 = function(d, b) {
  extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$8(d, b);
};
function __extends$8(d, b) {
  extendStatics$8(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var BitmapFontData = (
  /** @class */
  /* @__PURE__ */ function() {
    function BitmapFontData2() {
      this.info = [];
      this.common = [];
      this.page = [];
      this.char = [];
      this.kerning = [];
      this.distanceField = [];
    }
    return BitmapFontData2;
  }()
);
var TextFormat = (
  /** @class */
  function() {
    function TextFormat2() {
    }
    TextFormat2.test = function(data) {
      return typeof data === "string" && data.indexOf("info face=") === 0;
    };
    TextFormat2.parse = function(txt) {
      var items = txt.match(/^[a-z]+\s+.+$/gm);
      var rawData = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (var i in items) {
        var name2 = items[i].match(/^[a-z]+/gm)[0];
        var attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
        var itemData = {};
        for (var i_1 in attributeList) {
          var split = attributeList[i_1].split("=");
          var key = split[0];
          var strValue = split[1].replace(/"/gm, "");
          var floatValue = parseFloat(strValue);
          var value = isNaN(floatValue) ? strValue : floatValue;
          itemData[key] = value;
        }
        rawData[name2].push(itemData);
      }
      var font = new BitmapFontData();
      rawData.info.forEach(function(info) {
        return font.info.push({
          face: info.face,
          size: parseInt(info.size, 10)
        });
      });
      rawData.common.forEach(function(common) {
        return font.common.push({
          lineHeight: parseInt(common.lineHeight, 10)
        });
      });
      rawData.page.forEach(function(page) {
        return font.page.push({
          id: parseInt(page.id, 10),
          file: page.file
        });
      });
      rawData.char.forEach(function(char) {
        return font.char.push({
          id: parseInt(char.id, 10),
          page: parseInt(char.page, 10),
          x: parseInt(char.x, 10),
          y: parseInt(char.y, 10),
          width: parseInt(char.width, 10),
          height: parseInt(char.height, 10),
          xoffset: parseInt(char.xoffset, 10),
          yoffset: parseInt(char.yoffset, 10),
          xadvance: parseInt(char.xadvance, 10)
        });
      });
      rawData.kerning.forEach(function(kerning) {
        return font.kerning.push({
          first: parseInt(kerning.first, 10),
          second: parseInt(kerning.second, 10),
          amount: parseInt(kerning.amount, 10)
        });
      });
      rawData.distanceField.forEach(function(df) {
        return font.distanceField.push({
          distanceRange: parseInt(df.distanceRange, 10),
          fieldType: df.fieldType
        });
      });
      return font;
    };
    return TextFormat2;
  }()
);
var XMLFormat = (
  /** @class */
  function() {
    function XMLFormat2() {
    }
    XMLFormat2.test = function(data) {
      return data instanceof XMLDocument && data.getElementsByTagName("page").length && data.getElementsByTagName("info")[0].getAttribute("face") !== null;
    };
    XMLFormat2.parse = function(xml) {
      var data = new BitmapFontData();
      var info = xml.getElementsByTagName("info");
      var common = xml.getElementsByTagName("common");
      var page = xml.getElementsByTagName("page");
      var char = xml.getElementsByTagName("char");
      var kerning = xml.getElementsByTagName("kerning");
      var distanceField = xml.getElementsByTagName("distanceField");
      for (var i = 0; i < info.length; i++) {
        data.info.push({
          face: info[i].getAttribute("face"),
          size: parseInt(info[i].getAttribute("size"), 10)
        });
      }
      for (var i = 0; i < common.length; i++) {
        data.common.push({
          lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
        });
      }
      for (var i = 0; i < page.length; i++) {
        data.page.push({
          id: parseInt(page[i].getAttribute("id"), 10) || 0,
          file: page[i].getAttribute("file")
        });
      }
      for (var i = 0; i < char.length; i++) {
        var letter = char[i];
        data.char.push({
          id: parseInt(letter.getAttribute("id"), 10),
          page: parseInt(letter.getAttribute("page"), 10) || 0,
          x: parseInt(letter.getAttribute("x"), 10),
          y: parseInt(letter.getAttribute("y"), 10),
          width: parseInt(letter.getAttribute("width"), 10),
          height: parseInt(letter.getAttribute("height"), 10),
          xoffset: parseInt(letter.getAttribute("xoffset"), 10),
          yoffset: parseInt(letter.getAttribute("yoffset"), 10),
          xadvance: parseInt(letter.getAttribute("xadvance"), 10)
        });
      }
      for (var i = 0; i < kerning.length; i++) {
        data.kerning.push({
          first: parseInt(kerning[i].getAttribute("first"), 10),
          second: parseInt(kerning[i].getAttribute("second"), 10),
          amount: parseInt(kerning[i].getAttribute("amount"), 10)
        });
      }
      for (var i = 0; i < distanceField.length; i++) {
        data.distanceField.push({
          fieldType: distanceField[i].getAttribute("fieldType"),
          distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)
        });
      }
      return data;
    };
    return XMLFormat2;
  }()
);
var XMLStringFormat = (
  /** @class */
  function() {
    function XMLStringFormat2() {
    }
    XMLStringFormat2.test = function(data) {
      if (typeof data === "string" && data.indexOf("<font>") > -1) {
        var xml = new globalThis.DOMParser().parseFromString(data, "text/xml");
        return XMLFormat.test(xml);
      }
      return false;
    };
    XMLStringFormat2.parse = function(xmlTxt) {
      var xml = new globalThis.DOMParser().parseFromString(xmlTxt, "text/xml");
      return XMLFormat.parse(xml);
    };
    return XMLStringFormat2;
  }()
);
var formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(data) {
  for (var i = 0; i < formats.length; i++) {
    if (formats[i].test(data)) {
      return formats[i];
    }
  }
  return null;
}
function generateFillStyle(canvas, context2, style, resolution, lines, metrics) {
  var fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  var gradient;
  var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  var padding = style.padding || 0;
  var width = canvas.width / resolution - dropShadowCorrection - padding * 2;
  var height = canvas.height / resolution - dropShadowCorrection - padding * 2;
  var fill = fillStyle.slice();
  var fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    var lengthPlus1 = fill.length + 1;
    for (var i = 1; i < lengthPlus1; ++i) {
      fillGradientStops.push(i / lengthPlus1);
    }
  }
  fill.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context2.createLinearGradient(width / 2, padding, width / 2, height + padding);
    var lastIterationStop = 0;
    var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    var gradStopLineHeight = textHeight / height;
    for (var i = 0; i < lines.length; i++) {
      var thisLineTop = metrics.lineHeight * i;
      for (var j = 0; j < fill.length; j++) {
        var lineStop = 0;
        if (typeof fillGradientStops[j] === "number") {
          lineStop = fillGradientStops[j];
        } else {
          lineStop = j / fill.length;
        }
        var globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        var clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill[j]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context2.createLinearGradient(padding, height / 2, width + padding, height / 2);
    var totalIterations = fill.length + 1;
    var currentIteration = 1;
    for (var i = 0; i < fill.length; i++) {
      var stop = void 0;
      if (typeof fillGradientStops[i] === "number") {
        stop = fillGradientStops[i];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill[i]);
      currentIteration++;
    }
  }
  return gradient;
}
function drawGlyph(canvas, context2, metrics, x, y, resolution, style) {
  var char = metrics.text;
  var fontProperties = metrics.fontProperties;
  context2.translate(x, y);
  context2.scale(resolution, resolution);
  var tx = style.strokeThickness / 2;
  var ty = -(style.strokeThickness / 2);
  context2.font = style.toFontString();
  context2.lineWidth = style.strokeThickness;
  context2.textBaseline = style.textBaseline;
  context2.lineJoin = style.lineJoin;
  context2.miterLimit = style.miterLimit;
  context2.fillStyle = generateFillStyle(canvas, context2, style, resolution, [char], metrics);
  context2.strokeStyle = style.stroke;
  if (style.dropShadow) {
    var dropShadowColor = style.dropShadowColor;
    var rgb2 = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
    var dropShadowBlur = style.dropShadowBlur * resolution;
    var dropShadowDistance = style.dropShadowDistance * resolution;
    context2.shadowColor = "rgba(" + rgb2[0] * 255 + "," + rgb2[1] * 255 + "," + rgb2[2] * 255 + "," + style.dropShadowAlpha + ")";
    context2.shadowBlur = dropShadowBlur;
    context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context2.shadowColor = "black";
    context2.shadowBlur = 0;
    context2.shadowOffsetX = 0;
    context2.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context2.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context2.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context2.setTransform(1, 0, 0, 1, 0, 0);
  context2.fillStyle = "rgba(0, 0, 0, 0)";
}
function splitTextToCharacters(text2) {
  return Array.from ? Array.from(text2) : text2.split("");
}
function resolveCharacters(chars) {
  if (typeof chars === "string") {
    chars = [chars];
  }
  var result = [];
  for (var i = 0, j = chars.length; i < j; i++) {
    var item = chars[i];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + item.length + ".");
      }
      var startCode = item[0].charCodeAt(0);
      var endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (var i_1 = startCode, j_1 = endCode; i_1 <= j_1; i_1++) {
        result.push(String.fromCharCode(i_1));
      }
    } else {
      result.push.apply(result, splitTextToCharacters(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
function extractCharCode(str) {
  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
}
var BitmapFont = (
  /** @class */
  function() {
    function BitmapFont2(data, textures, ownsTextures) {
      var _a2, _b2;
      var info = data.info[0];
      var common = data.common[0];
      var page = data.page[0];
      var distanceField = data.distanceField[0];
      var res = getResolutionOfUrl(page.file);
      var pageTextures = {};
      this._ownsTextures = ownsTextures;
      this.font = info.face;
      this.size = info.size;
      this.lineHeight = common.lineHeight / res;
      this.chars = {};
      this.pageTextures = pageTextures;
      for (var i = 0; i < data.page.length; i++) {
        var _c2 = data.page[i], id2 = _c2.id, file = _c2.file;
        pageTextures[id2] = textures instanceof Array ? textures[i] : textures[file];
        if ((distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) && distanceField.fieldType !== "none") {
          pageTextures[id2].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
          pageTextures[id2].baseTexture.mipmap = MIPMAP_MODES.OFF;
        }
      }
      for (var i = 0; i < data.char.length; i++) {
        var _d = data.char[i], id2 = _d.id, page_1 = _d.page;
        var _e = data.char[i], x = _e.x, y = _e.y, width = _e.width, height = _e.height, xoffset = _e.xoffset, yoffset = _e.yoffset, xadvance = _e.xadvance;
        x /= res;
        y /= res;
        width /= res;
        height /= res;
        xoffset /= res;
        yoffset /= res;
        xadvance /= res;
        var rect = new Rectangle(x + pageTextures[page_1].frame.x / res, y + pageTextures[page_1].frame.y / res, width, height);
        this.chars[id2] = {
          xOffset: xoffset,
          yOffset: yoffset,
          xAdvance: xadvance,
          kerning: {},
          texture: new Texture(pageTextures[page_1].baseTexture, rect),
          page: page_1
        };
      }
      for (var i = 0; i < data.kerning.length; i++) {
        var _f = data.kerning[i], first = _f.first, second = _f.second, amount = _f.amount;
        first /= res;
        second /= res;
        amount /= res;
        if (this.chars[second]) {
          this.chars[second].kerning[first] = amount;
        }
      }
      this.distanceFieldRange = distanceField === null || distanceField === void 0 ? void 0 : distanceField.distanceRange;
      this.distanceFieldType = (_b2 = (_a2 = distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) !== null && _b2 !== void 0 ? _b2 : "none";
    }
    BitmapFont2.prototype.destroy = function() {
      for (var id2 in this.chars) {
        this.chars[id2].texture.destroy();
        this.chars[id2].texture = null;
      }
      for (var id2 in this.pageTextures) {
        if (this._ownsTextures) {
          this.pageTextures[id2].destroy(true);
        }
        this.pageTextures[id2] = null;
      }
      this.chars = null;
      this.pageTextures = null;
    };
    BitmapFont2.install = function(data, textures, ownsTextures) {
      var fontData;
      if (data instanceof BitmapFontData) {
        fontData = data;
      } else {
        var format2 = autoDetectFormat(data);
        if (!format2) {
          throw new Error("Unrecognized data format for font.");
        }
        fontData = format2.parse(data);
      }
      if (textures instanceof Texture) {
        textures = [textures];
      }
      var font = new BitmapFont2(fontData, textures, ownsTextures);
      BitmapFont2.available[font.font] = font;
      return font;
    };
    BitmapFont2.uninstall = function(name2) {
      var font = BitmapFont2.available[name2];
      if (!font) {
        throw new Error("No font found named '" + name2 + "'");
      }
      font.destroy();
      delete BitmapFont2.available[name2];
    };
    BitmapFont2.from = function(name2, textStyle, options) {
      if (!name2) {
        throw new Error("[BitmapFont] Property `name` is required.");
      }
      var _a2 = Object.assign({}, BitmapFont2.defaultOptions, options), chars = _a2.chars, padding = _a2.padding, resolution = _a2.resolution, textureWidth = _a2.textureWidth, textureHeight = _a2.textureHeight;
      var charsList = resolveCharacters(chars);
      var style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
      var lineWidth = textureWidth;
      var fontData = new BitmapFontData();
      fontData.info[0] = {
        face: style.fontFamily,
        size: style.fontSize
      };
      fontData.common[0] = {
        lineHeight: style.fontSize
      };
      var positionX = 0;
      var positionY = 0;
      var canvas;
      var context2;
      var baseTexture;
      var maxCharHeight = 0;
      var textures = [];
      for (var i = 0; i < charsList.length; i++) {
        if (!canvas) {
          canvas = settings.ADAPTER.createCanvas();
          canvas.width = textureWidth;
          canvas.height = textureHeight;
          context2 = canvas.getContext("2d");
          baseTexture = new BaseTexture(canvas, { resolution });
          textures.push(new Texture(baseTexture));
          fontData.page.push({
            id: textures.length - 1,
            file: ""
          });
        }
        var character = charsList[i];
        var metrics = TextMetrics.measureText(character, style, false, canvas);
        var width = metrics.width;
        var height = Math.ceil(metrics.height);
        var textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
        if (positionY >= textureHeight - height * resolution) {
          if (positionY === 0) {
            throw new Error("[BitmapFont] textureHeight " + textureHeight + "px is too small " + ("(fontFamily: '" + style.fontFamily + "', fontSize: " + style.fontSize + "px, char: '" + character + "')"));
          }
          --i;
          canvas = null;
          context2 = null;
          baseTexture = null;
          positionY = 0;
          positionX = 0;
          maxCharHeight = 0;
          continue;
        }
        maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
        if (textureGlyphWidth * resolution + positionX >= lineWidth) {
          if (positionX === 0) {
            throw new Error("[BitmapFont] textureWidth " + textureWidth + "px is too small " + ("(fontFamily: '" + style.fontFamily + "', fontSize: " + style.fontSize + "px, char: '" + character + "')"));
          }
          --i;
          positionY += maxCharHeight * resolution;
          positionY = Math.ceil(positionY);
          positionX = 0;
          maxCharHeight = 0;
          continue;
        }
        drawGlyph(canvas, context2, metrics, positionX, positionY, resolution, style);
        var id2 = extractCharCode(metrics.text);
        fontData.char.push({
          id: id2,
          page: textures.length - 1,
          x: positionX / resolution,
          y: positionY / resolution,
          width: textureGlyphWidth,
          height,
          xoffset: 0,
          yoffset: 0,
          xadvance: Math.ceil(width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))
        });
        positionX += (textureGlyphWidth + 2 * padding) * resolution;
        positionX = Math.ceil(positionX);
      }
      if (!(options === null || options === void 0 ? void 0 : options.skipKerning)) {
        for (var i = 0, len = charsList.length; i < len; i++) {
          var first = charsList[i];
          for (var j = 0; j < len; j++) {
            var second = charsList[j];
            var c1 = context2.measureText(first).width;
            var c2 = context2.measureText(second).width;
            var total = context2.measureText(first + second).width;
            var amount = total - (c1 + c2);
            if (amount) {
              fontData.kerning.push({
                first: extractCharCode(first),
                second: extractCharCode(second),
                amount
              });
            }
          }
        }
      }
      var font = new BitmapFont2(fontData, textures, true);
      if (BitmapFont2.available[name2] !== void 0) {
        BitmapFont2.uninstall(name2);
      }
      BitmapFont2.available[name2] = font;
      return font;
    };
    BitmapFont2.ALPHA = [["a", "z"], ["A", "Z"], " "];
    BitmapFont2.NUMERIC = [["0", "9"]];
    BitmapFont2.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
    BitmapFont2.ASCII = [[" ", "~"]];
    BitmapFont2.defaultOptions = {
      resolution: 1,
      textureWidth: 512,
      textureHeight: 512,
      padding: 4,
      chars: BitmapFont2.ALPHANUMERIC
    };
    BitmapFont2.available = {};
    return BitmapFont2;
  }()
);
var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n";
var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
var pageMeshDataDefaultPageMeshData = [];
var pageMeshDataMSDFPageMeshData = [];
var charRenderDataPool = [];
(function(_super) {
  __extends$8(BitmapText, _super);
  function BitmapText(text2, style) {
    if (style === void 0) {
      style = {};
    }
    var _this = _super.call(this) || this;
    _this._tint = 16777215;
    var _a2 = Object.assign({}, BitmapText.styleDefaults, style), align = _a2.align, tint = _a2.tint, maxWidth = _a2.maxWidth, letterSpacing = _a2.letterSpacing, fontName = _a2.fontName, fontSize = _a2.fontSize;
    if (!BitmapFont.available[fontName]) {
      throw new Error('Missing BitmapFont "' + fontName + '"');
    }
    _this._activePagesMeshData = [];
    _this._textWidth = 0;
    _this._textHeight = 0;
    _this._align = align;
    _this._tint = tint;
    _this._font = void 0;
    _this._fontName = fontName;
    _this._fontSize = fontSize;
    _this.text = text2;
    _this._maxWidth = maxWidth;
    _this._maxLineHeight = 0;
    _this._letterSpacing = letterSpacing;
    _this._anchor = new ObservablePoint(function() {
      _this.dirty = true;
    }, _this, 0, 0);
    _this._roundPixels = settings.ROUND_PIXELS;
    _this.dirty = true;
    _this._resolution = settings.RESOLUTION;
    _this._autoResolution = true;
    _this._textureCache = {};
    return _this;
  }
  BitmapText.prototype.updateText = function() {
    var _a2;
    var data = BitmapFont.available[this._fontName];
    var fontSize = this.fontSize;
    var scale = fontSize / data.size;
    var pos = new Point();
    var chars = [];
    var lineWidths = [];
    var lineSpaces = [];
    var text2 = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
    var charsInput = splitTextToCharacters(text2);
    var maxWidth = this._maxWidth * data.size / fontSize;
    var pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    var prevCharCode = null;
    var lastLineWidth = 0;
    var maxLineWidth = 0;
    var line = 0;
    var lastBreakPos = -1;
    var lastBreakWidth = 0;
    var spacesRemoved = 0;
    var maxLineHeight = 0;
    var spaceCount = 0;
    for (var i = 0; i < charsInput.length; i++) {
      var char = charsInput[i];
      var charCode = extractCharCode(char);
      if (/(?:\s)/.test(char)) {
        lastBreakPos = i;
        lastBreakWidth = lastLineWidth;
        spaceCount++;
      }
      if (char === "\r" || char === "\n") {
        lineWidths.push(lastLineWidth);
        lineSpaces.push(-1);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        ++line;
        ++spacesRemoved;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
        continue;
      }
      var charData = data.chars[charCode];
      if (!charData) {
        continue;
      }
      if (prevCharCode && charData.kerning[prevCharCode]) {
        pos.x += charData.kerning[prevCharCode];
      }
      var charRenderData = charRenderDataPool.pop() || {
        texture: Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new Point()
      };
      charRenderData.texture = charData.texture;
      charRenderData.line = line;
      charRenderData.charCode = charCode;
      charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;
      charRenderData.position.y = pos.y + charData.yOffset;
      charRenderData.prevSpaces = spaceCount;
      chars.push(charRenderData);
      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);
      pos.x += charData.xAdvance + this._letterSpacing;
      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
      prevCharCode = charCode;
      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
        ++spacesRemoved;
        removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
        i = lastBreakPos;
        lastBreakPos = -1;
        lineWidths.push(lastBreakWidth);
        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
        line++;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
      }
    }
    var lastChar = charsInput[charsInput.length - 1];
    if (lastChar !== "\r" && lastChar !== "\n") {
      if (/(?:\s)/.test(lastChar)) {
        lastLineWidth = lastBreakWidth;
      }
      lineWidths.push(lastLineWidth);
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lineSpaces.push(-1);
    }
    var lineAlignOffsets = [];
    for (var i = 0; i <= line; i++) {
      var alignOffset = 0;
      if (this._align === "right") {
        alignOffset = maxLineWidth - lineWidths[i];
      } else if (this._align === "center") {
        alignOffset = (maxLineWidth - lineWidths[i]) / 2;
      } else if (this._align === "justify") {
        alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];
      }
      lineAlignOffsets.push(alignOffset);
    }
    var lenChars = chars.length;
    var pagesMeshData = {};
    var newPagesMeshData = [];
    var activePagesMeshData = this._activePagesMeshData;
    pageMeshDataPool.push.apply(pageMeshDataPool, activePagesMeshData);
    for (var i = 0; i < lenChars; i++) {
      var texture = chars[i].texture;
      var baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        var pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          var geometry = new MeshGeometry();
          var material = void 0;
          var meshBlendMode = void 0;
          if (data.distanceFieldType === "none") {
            material = new MeshMaterial(Texture.EMPTY);
            meshBlendMode = BLEND_MODES.NORMAL;
          } else {
            material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
            meshBlendMode = BLEND_MODES.NORMAL_NPM;
          }
          var mesh = new Mesh(geometry, material);
          mesh.blendMode = meshBlendMode;
          pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0;
        pageMeshData.indexCount = 0;
        pageMeshData.vertexCount = 0;
        pageMeshData.uvsCount = 0;
        pageMeshData.total = 0;
        var _textureCache = this._textureCache;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
        pageMeshData.mesh.texture = _textureCache[baseTextureUid];
        pageMeshData.mesh.tint = this._tint;
        newPagesMeshData.push(pageMeshData);
        pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (var i = 0; i < activePagesMeshData.length; i++) {
      if (newPagesMeshData.indexOf(activePagesMeshData[i]) === -1) {
        this.removeChild(activePagesMeshData[i].mesh);
      }
    }
    for (var i = 0; i < newPagesMeshData.length; i++) {
      if (newPagesMeshData[i].mesh.parent !== this) {
        this.addChild(newPagesMeshData[i].mesh);
      }
    }
    this._activePagesMeshData = newPagesMeshData;
    for (var i in pagesMeshData) {
      var pageMeshData = pagesMeshData[i];
      var total = pageMeshData.total;
      if (!(((_a2 = pageMeshData.indices) === null || _a2 === void 0 ? void 0 : _a2.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
        pageMeshData.vertices = new Float32Array(4 * 2 * total);
        pageMeshData.uvs = new Float32Array(4 * 2 * total);
        pageMeshData.indices = new Uint16Array(6 * total);
      } else {
        var total_1 = pageMeshData.total;
        var vertices = pageMeshData.vertices;
        for (var i_1 = total_1 * 4 * 2; i_1 < vertices.length; i_1++) {
          vertices[i_1] = 0;
        }
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (var i = 0; i < lenChars; i++) {
      var char = chars[i];
      var offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      if (this._roundPixels) {
        offset = Math.round(offset);
      }
      var xPos = offset * scale;
      var yPos = char.position.y * scale;
      var texture = char.texture;
      var pageMesh = pagesMeshData[texture.baseTexture.uid];
      var textureFrame = texture.frame;
      var textureUvs = texture._uvs;
      var index = pageMesh.index++;
      pageMesh.indices[index * 6 + 0] = 0 + index * 4;
      pageMesh.indices[index * 6 + 1] = 1 + index * 4;
      pageMesh.indices[index * 6 + 2] = 2 + index * 4;
      pageMesh.indices[index * 6 + 3] = 0 + index * 4;
      pageMesh.indices[index * 6 + 4] = 2 + index * 4;
      pageMesh.indices[index * 6 + 5] = 3 + index * 4;
      pageMesh.vertices[index * 8 + 0] = xPos;
      pageMesh.vertices[index * 8 + 1] = yPos;
      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 3] = yPos;
      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;
      pageMesh.vertices[index * 8 + 6] = xPos;
      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;
      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;
      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;
      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;
      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;
      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;
      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;
      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;
      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale;
    this._textHeight = (pos.y + data.lineHeight) * scale;
    for (var i in pagesMeshData) {
      var pageMeshData = pagesMeshData[i];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        var vertexCount = 0;
        var anchorOffsetX = this._textWidth * this.anchor.x;
        var anchorOffsetY = this._textHeight * this.anchor.y;
        for (var i_2 = 0; i_2 < pageMeshData.total; i_2++) {
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
        }
      }
      this._maxLineHeight = maxLineHeight * scale;
      var vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
      var textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
      var indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices;
      textureBuffer.data = pageMeshData.uvs;
      indexBuffer.data = pageMeshData.indices;
      vertexBuffer.update();
      textureBuffer.update();
      indexBuffer.update();
    }
    for (var i = 0; i < chars.length; i++) {
      charRenderDataPool.push(chars[i]);
    }
    this._font = data;
    this.dirty = false;
  };
  BitmapText.prototype.updateTransform = function() {
    this.validate();
    this.containerUpdateTransform();
  };
  BitmapText.prototype._render = function(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    var _a2 = BitmapFont.available[this._fontName], distanceFieldRange = _a2.distanceFieldRange, distanceFieldType = _a2.distanceFieldType, size2 = _a2.size;
    if (distanceFieldType !== "none") {
      var _b2 = this.worldTransform, a = _b2.a, b = _b2.b, c2 = _b2.c, d = _b2.d;
      var dx = Math.sqrt(a * a + b * b);
      var dy = Math.sqrt(c2 * c2 + d * d);
      var worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
      var fontScale = this.fontSize / size2;
      for (var _i = 0, _c2 = this._activePagesMeshData; _i < _c2.length; _i++) {
        var mesh = _c2[_i];
        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * this._resolution;
      }
    }
    _super.prototype._render.call(this, renderer);
  };
  BitmapText.prototype.getLocalBounds = function() {
    this.validate();
    return _super.prototype.getLocalBounds.call(this);
  };
  BitmapText.prototype.validate = function() {
    var font = BitmapFont.available[this._fontName];
    if (!font) {
      throw new Error('Missing BitmapFont "' + this._fontName + '"');
    }
    if (this._font !== font) {
      this.dirty = true;
    }
    if (this.dirty) {
      this.updateText();
    }
  };
  Object.defineProperty(BitmapText.prototype, "tint", {
    /**
     * The tint of the BitmapText object.
     * @default 0xffffff
     */
    get: function() {
      return this._tint;
    },
    set: function(value) {
      if (this._tint === value) {
        return;
      }
      this._tint = value;
      for (var i = 0; i < this._activePagesMeshData.length; i++) {
        this._activePagesMeshData[i].mesh.tint = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "align", {
    /**
     * The alignment of the BitmapText object.
     * @member {string}
     * @default 'left'
     */
    get: function() {
      return this._align;
    },
    set: function(value) {
      if (this._align !== value) {
        this._align = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "fontName", {
    /** The name of the BitmapFont. */
    get: function() {
      return this._fontName;
    },
    set: function(value) {
      if (!BitmapFont.available[value]) {
        throw new Error('Missing BitmapFont "' + value + '"');
      }
      if (this._fontName !== value) {
        this._fontName = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "fontSize", {
    /** The size of the font to display. */
    get: function() {
      var _a2;
      return (_a2 = this._fontSize) !== null && _a2 !== void 0 ? _a2 : BitmapFont.available[this._fontName].size;
    },
    set: function(value) {
      if (this._fontSize !== value) {
        this._fontSize = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "anchor", {
    /**
     * The anchor sets the origin point of the text.
     *
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     */
    get: function() {
      return this._anchor;
    },
    set: function(value) {
      if (typeof value === "number") {
        this._anchor.set(value);
      } else {
        this._anchor.copyFrom(value);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "text", {
    /** The text of the BitmapText object. */
    get: function() {
      return this._text;
    },
    set: function(text2) {
      text2 = String(text2 === null || text2 === void 0 ? "" : text2);
      if (this._text === text2) {
        return;
      }
      this._text = text2;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "maxWidth", {
    /**
     * The max width of this bitmap text in pixels. If the text provided is longer than the
     * value provided, line breaks will be automatically inserted in the last whitespace.
     * Disable by setting the value to 0.
     */
    get: function() {
      return this._maxWidth;
    },
    set: function(value) {
      if (this._maxWidth === value) {
        return;
      }
      this._maxWidth = value;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "maxLineHeight", {
    /**
     * The max line height. This is useful when trying to use the total height of the Text,
     * i.e. when trying to vertically align.
     * @readonly
     */
    get: function() {
      this.validate();
      return this._maxLineHeight;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "textWidth", {
    /**
     * The width of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      this.validate();
      return this._textWidth;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "letterSpacing", {
    /** Additional space between characters. */
    get: function() {
      return this._letterSpacing;
    },
    set: function(value) {
      if (this._letterSpacing !== value) {
        this._letterSpacing = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "roundPixels", {
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     * @default PIXI.settings.ROUND_PIXELS
     */
    get: function() {
      return this._roundPixels;
    },
    set: function(value) {
      if (value !== this._roundPixels) {
        this._roundPixels = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "textHeight", {
    /**
     * The height of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      this.validate();
      return this._textHeight;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "resolution", {
    /**
     * The resolution / device pixel ratio of the canvas.
     *
     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
     * @default 1
     */
    get: function() {
      return this._resolution;
    },
    set: function(value) {
      this._autoResolution = false;
      if (this._resolution === value) {
        return;
      }
      this._resolution = value;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  BitmapText.prototype.destroy = function(options) {
    var _textureCache = this._textureCache;
    var data = BitmapFont.available[this._fontName];
    var pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    pageMeshDataPool.push.apply(pageMeshDataPool, this._activePagesMeshData);
    for (var _i = 0, _a2 = this._activePagesMeshData; _i < _a2.length; _i++) {
      var pageMeshData = _a2[_i];
      this.removeChild(pageMeshData.mesh);
    }
    this._activePagesMeshData = [];
    pageMeshDataPool.filter(function(page) {
      return _textureCache[page.mesh.texture.baseTexture.uid];
    }).forEach(function(page) {
      page.mesh.texture = Texture.EMPTY;
    });
    for (var id2 in _textureCache) {
      var texture = _textureCache[id2];
      texture.destroy();
      delete _textureCache[id2];
    }
    this._font = null;
    this._textureCache = null;
    _super.prototype.destroy.call(this, options);
  };
  BitmapText.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  };
  return BitmapText;
})(Container);
var BitmapFontLoader = (
  /** @class */
  function() {
    function BitmapFontLoader2() {
    }
    BitmapFontLoader2.add = function() {
      LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
    };
    BitmapFontLoader2.use = function(resource, next) {
      var format2 = autoDetectFormat(resource.data);
      if (!format2) {
        next();
        return;
      }
      var baseUrl = BitmapFontLoader2.getBaseUrl(this, resource);
      var data = format2.parse(resource.data);
      var textures = {};
      var completed = function(page) {
        textures[page.metadata.pageFile] = page.texture;
        if (Object.keys(textures).length === data.page.length) {
          resource.bitmapFont = BitmapFont.install(data, textures, true);
          next();
        }
      };
      for (var i = 0; i < data.page.length; ++i) {
        var pageFile = data.page[i].file;
        var url2 = baseUrl + pageFile;
        var exists = false;
        for (var name2 in this.resources) {
          var bitmapResource = this.resources[name2];
          if (bitmapResource.url === url2) {
            bitmapResource.metadata.pageFile = pageFile;
            if (bitmapResource.texture) {
              completed(bitmapResource);
            } else {
              bitmapResource.onAfterMiddleware.add(completed);
            }
            exists = true;
            break;
          }
        }
        if (!exists) {
          var options = {
            crossOrigin: resource.crossOrigin,
            loadType: LoaderResource.LOAD_TYPE.IMAGE,
            metadata: Object.assign({ pageFile }, resource.metadata.imageMetadata),
            parentResource: resource
          };
          this.add(url2, options, completed);
        }
      }
    };
    BitmapFontLoader2.getBaseUrl = function(loader, resource) {
      var resUrl = !resource.isDataUrl ? BitmapFontLoader2.dirname(resource.url) : "";
      if (resource.isDataUrl) {
        if (resUrl === ".") {
          resUrl = "";
        }
        if (loader.baseUrl && resUrl) {
          if (loader.baseUrl.charAt(loader.baseUrl.length - 1) === "/") {
            resUrl += "/";
          }
        }
      }
      resUrl = resUrl.replace(loader.baseUrl, "");
      if (resUrl && resUrl.charAt(resUrl.length - 1) !== "/") {
        resUrl += "/";
      }
      return resUrl;
    };
    BitmapFontLoader2.dirname = function(url2) {
      var dir = url2.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
      if (dir === url2) {
        return ".";
      } else if (dir === "") {
        return "/";
      }
      return dir;
    };
    BitmapFontLoader2.extension = ExtensionType.Loader;
    return BitmapFontLoader2;
  }()
);
/*!
 * @pixi/filter-alpha - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$7 = function(d, b) {
  extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$7(d, b);
};
function __extends$7(d, b) {
  extendStatics$7(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var fragment$4 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";
(function(_super) {
  __extends$7(AlphaFilter, _super);
  function AlphaFilter(alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    var _this = _super.call(this, defaultVertex$1, fragment$4, { uAlpha: 1 }) || this;
    _this.alpha = alpha;
    return _this;
  }
  Object.defineProperty(AlphaFilter.prototype, "alpha", {
    /**
     * Coefficient for alpha multiplication
     * @default 1
     */
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(value) {
      this.uniforms.uAlpha = value;
    },
    enumerable: false,
    configurable: true
  });
  return AlphaFilter;
})(Filter);
/*!
 * @pixi/filter-blur - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$6 = function(d, b) {
  extendStatics$6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$6(d, b);
};
function __extends$6(d, b) {
  extendStatics$6(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
function generateBlurVertSource(kernelSize, x) {
  var halfLength = Math.ceil(kernelSize / 2);
  var vertSource = vertTemplate;
  var blurLoop = "";
  var template;
  if (x) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  }
  for (var i = 0; i < kernelSize; i++) {
    var blur = template.replace("%index%", i.toString());
    blur = blur.replace("%sampleIndex%", i - (halfLength - 1) + ".0");
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  return vertSource;
}
var GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
var fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  var kernel = GAUSSIAN_VALUES[kernelSize];
  var halfLength = kernel.length;
  var fragSource = fragTemplate;
  var blurLoop = "";
  var template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  var value;
  for (var i = 0; i < kernelSize; i++) {
    var blur = template.replace("%index%", i.toString());
    value = i;
    if (i >= halfLength) {
      value = kernelSize - i - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}
var BlurFilterPass = (
  /** @class */
  function(_super) {
    __extends$6(BlurFilterPass2, _super);
    function BlurFilterPass2(horizontal, strength, quality, resolution, kernelSize) {
      if (strength === void 0) {
        strength = 8;
      }
      if (quality === void 0) {
        quality = 4;
      }
      if (resolution === void 0) {
        resolution = settings.FILTER_RESOLUTION;
      }
      if (kernelSize === void 0) {
        kernelSize = 5;
      }
      var _this = this;
      var vertSrc = generateBlurVertSource(kernelSize, horizontal);
      var fragSrc = generateBlurFragSource(kernelSize);
      _this = _super.call(
        this,
        // vertex shader
        vertSrc,
        // fragment shader
        fragSrc
      ) || this;
      _this.horizontal = horizontal;
      _this.resolution = resolution;
      _this._quality = 0;
      _this.quality = quality;
      _this.blur = strength;
      return _this;
    }
    BlurFilterPass2.prototype.apply = function(filterManager, input, output, clearMode) {
      if (output) {
        if (this.horizontal) {
          this.uniforms.strength = 1 / output.width * (output.width / input.width);
        } else {
          this.uniforms.strength = 1 / output.height * (output.height / input.height);
        }
      } else {
        if (this.horizontal) {
          this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
        } else {
          this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
        }
      }
      this.uniforms.strength *= this.strength;
      this.uniforms.strength /= this.passes;
      if (this.passes === 1) {
        filterManager.applyFilter(this, input, output, clearMode);
      } else {
        var renderTarget = filterManager.getFilterTexture();
        var renderer = filterManager.renderer;
        var flip = input;
        var flop = renderTarget;
        this.state.blend = false;
        filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);
        for (var i = 1; i < this.passes - 1; i++) {
          filterManager.bindAndClear(flip, CLEAR_MODES.BLIT);
          this.uniforms.uSampler = flop;
          var temp2 = flop;
          flop = flip;
          flip = temp2;
          renderer.shader.bind(this);
          renderer.geometry.draw(5);
        }
        this.state.blend = true;
        filterManager.applyFilter(this, flop, output, clearMode);
        filterManager.returnFilterTexture(renderTarget);
      }
    };
    Object.defineProperty(BlurFilterPass2.prototype, "blur", {
      /**
       * Sets the strength of both the blur.
       * @default 16
       */
      get: function() {
        return this.strength;
      },
      set: function(value) {
        this.padding = 1 + Math.abs(value) * 2;
        this.strength = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BlurFilterPass2.prototype, "quality", {
      /**
       * Sets the quality of the blur by modifying the number of passes. More passes means higher
       * quality bluring but the lower the performance.
       * @default 4
       */
      get: function() {
        return this._quality;
      },
      set: function(value) {
        this._quality = value;
        this.passes = value;
      },
      enumerable: false,
      configurable: true
    });
    return BlurFilterPass2;
  }(Filter)
);
(function(_super) {
  __extends$6(BlurFilter, _super);
  function BlurFilter(strength, quality, resolution, kernelSize) {
    if (strength === void 0) {
      strength = 8;
    }
    if (quality === void 0) {
      quality = 4;
    }
    if (resolution === void 0) {
      resolution = settings.FILTER_RESOLUTION;
    }
    if (kernelSize === void 0) {
      kernelSize = 5;
    }
    var _this = _super.call(this) || this;
    _this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
    _this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
    _this.resolution = resolution;
    _this.quality = quality;
    _this.blur = strength;
    _this.repeatEdgePixels = false;
    return _this;
  }
  BlurFilter.prototype.apply = function(filterManager, input, output, clearMode) {
    var xStrength = Math.abs(this.blurXFilter.strength);
    var yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      var renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR);
      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    } else if (yStrength) {
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  };
  BlurFilter.prototype.updatePadding = function() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
  };
  Object.defineProperty(BlurFilter.prototype, "blur", {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(value) {
      this.blurXFilter.blur = this.blurYFilter.blur = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "quality", {
    /**
     * Sets the number of passes for blur. More passes means higher quality bluring.
     * @default 1
     */
    get: function() {
      return this.blurXFilter.quality;
    },
    set: function(value) {
      this.blurXFilter.quality = this.blurYFilter.quality = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "blurX", {
    /**
     * Sets the strength of the blurX property
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(value) {
      this.blurXFilter.blur = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "blurY", {
    /**
     * Sets the strength of the blurY property
     * @default 2
     */
    get: function() {
      return this.blurYFilter.blur;
    },
    set: function(value) {
      this.blurYFilter.blur = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "blendMode", {
    /**
     * Sets the blendmode of the filter
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get: function() {
      return this.blurYFilter.blendMode;
    },
    set: function(value) {
      this.blurYFilter.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "repeatEdgePixels", {
    /**
     * If set to true the edge of the target will be clamped
     * @default false
     */
    get: function() {
      return this._repeatEdgePixels;
    },
    set: function(value) {
      this._repeatEdgePixels = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  return BlurFilter;
})(Filter);
/*!
 * @pixi/filter-color-matrix - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$5 = function(d, b) {
  extendStatics$5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$5(d, b);
};
function __extends$5(d, b) {
  extendStatics$5(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var fragment$3 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
var ColorMatrixFilter = (
  /** @class */
  function(_super) {
    __extends$5(ColorMatrixFilter2, _super);
    function ColorMatrixFilter2() {
      var _this = this;
      var uniforms = {
        m: new Float32Array([
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]),
        uAlpha: 1
      };
      _this = _super.call(this, defaultFilterVertex, fragment$3, uniforms) || this;
      _this.alpha = 1;
      return _this;
    }
    ColorMatrixFilter2.prototype._loadMatrix = function(matrix2, multiply2) {
      if (multiply2 === void 0) {
        multiply2 = false;
      }
      var newMatrix = matrix2;
      if (multiply2) {
        this._multiply(newMatrix, this.uniforms.m, matrix2);
        newMatrix = this._colorMatrix(newMatrix);
      }
      this.uniforms.m = newMatrix;
    };
    ColorMatrixFilter2.prototype._multiply = function(out, a, b) {
      out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
      out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
      out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
      out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
      out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];
      out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
      out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
      out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
      out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
      out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];
      out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
      out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
      out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
      out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
      out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];
      out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
      out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
      out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
      out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
      out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];
      return out;
    };
    ColorMatrixFilter2.prototype._colorMatrix = function(matrix2) {
      var m = new Float32Array(matrix2);
      m[4] /= 255;
      m[9] /= 255;
      m[14] /= 255;
      m[19] /= 255;
      return m;
    };
    ColorMatrixFilter2.prototype.brightness = function(b, multiply2) {
      var matrix2 = [
        b,
        0,
        0,
        0,
        0,
        0,
        b,
        0,
        0,
        0,
        0,
        0,
        b,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.tint = function(color2, multiply2) {
      var r = color2 >> 16 & 255;
      var g = color2 >> 8 & 255;
      var b = color2 & 255;
      var matrix2 = [
        r / 255,
        0,
        0,
        0,
        0,
        0,
        g / 255,
        0,
        0,
        0,
        0,
        0,
        b / 255,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.greyscale = function(scale, multiply2) {
      var matrix2 = [
        scale,
        scale,
        scale,
        0,
        0,
        scale,
        scale,
        scale,
        0,
        0,
        scale,
        scale,
        scale,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.blackAndWhite = function(multiply2) {
      var matrix2 = [
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.hue = function(rotation, multiply2) {
      rotation = (rotation || 0) / 180 * Math.PI;
      var cosR = Math.cos(rotation);
      var sinR = Math.sin(rotation);
      var sqrt2 = Math.sqrt;
      var w = 1 / 3;
      var sqrW = sqrt2(w);
      var a00 = cosR + (1 - cosR) * w;
      var a01 = w * (1 - cosR) - sqrW * sinR;
      var a02 = w * (1 - cosR) + sqrW * sinR;
      var a10 = w * (1 - cosR) + sqrW * sinR;
      var a11 = cosR + w * (1 - cosR);
      var a12 = w * (1 - cosR) - sqrW * sinR;
      var a20 = w * (1 - cosR) - sqrW * sinR;
      var a21 = w * (1 - cosR) + sqrW * sinR;
      var a22 = cosR + w * (1 - cosR);
      var matrix2 = [
        a00,
        a01,
        a02,
        0,
        0,
        a10,
        a11,
        a12,
        0,
        0,
        a20,
        a21,
        a22,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.contrast = function(amount, multiply2) {
      var v2 = (amount || 0) + 1;
      var o = -0.5 * (v2 - 1);
      var matrix2 = [
        v2,
        0,
        0,
        0,
        o,
        0,
        v2,
        0,
        0,
        o,
        0,
        0,
        v2,
        0,
        o,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.saturate = function(amount, multiply2) {
      if (amount === void 0) {
        amount = 0;
      }
      var x = amount * 2 / 3 + 1;
      var y = (x - 1) * -0.5;
      var matrix2 = [
        x,
        y,
        y,
        0,
        0,
        y,
        x,
        y,
        0,
        0,
        y,
        y,
        x,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.desaturate = function() {
      this.saturate(-1);
    };
    ColorMatrixFilter2.prototype.negative = function(multiply2) {
      var matrix2 = [
        -1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        -1,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.sepia = function(multiply2) {
      var matrix2 = [
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.technicolor = function(multiply2) {
      var matrix2 = [
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.polaroid = function(multiply2) {
      var matrix2 = [
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.toBGR = function(multiply2) {
      var matrix2 = [
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.kodachrome = function(multiply2) {
      var matrix2 = [
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.browni = function(multiply2) {
      var matrix2 = [
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.vintage = function(multiply2) {
      var matrix2 = [
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.colorTone = function(desaturation, toned, lightColor, darkColor, multiply2) {
      desaturation = desaturation || 0.2;
      toned = toned || 0.15;
      lightColor = lightColor || 16770432;
      darkColor = darkColor || 3375104;
      var lR = (lightColor >> 16 & 255) / 255;
      var lG = (lightColor >> 8 & 255) / 255;
      var lB = (lightColor & 255) / 255;
      var dR = (darkColor >> 16 & 255) / 255;
      var dG = (darkColor >> 8 & 255) / 255;
      var dB = (darkColor & 255) / 255;
      var matrix2 = [
        0.3,
        0.59,
        0.11,
        0,
        0,
        lR,
        lG,
        lB,
        desaturation,
        0,
        dR,
        dG,
        dB,
        toned,
        0,
        lR - dR,
        lG - dG,
        lB - dB,
        0,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.night = function(intensity, multiply2) {
      intensity = intensity || 0.1;
      var matrix2 = [
        intensity * -2,
        -intensity,
        0,
        0,
        0,
        -intensity,
        0,
        intensity,
        0,
        0,
        0,
        intensity,
        intensity * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.predator = function(amount, multiply2) {
      var matrix2 = [
        // row 1
        11.224130630493164 * amount,
        -4.794486999511719 * amount,
        -2.8746118545532227 * amount,
        0 * amount,
        0.40342438220977783 * amount,
        // row 2
        -3.6330697536468506 * amount,
        9.193157196044922 * amount,
        -2.951810836791992 * amount,
        0 * amount,
        -1.316135048866272 * amount,
        // row 3
        -3.2184197902679443 * amount,
        -4.2375030517578125 * amount,
        7.476448059082031 * amount,
        0 * amount,
        0.8044459223747253 * amount,
        // row 4
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.lsd = function(multiply2) {
      var matrix2 = [
        2,
        -0.4,
        0.5,
        0,
        0,
        -0.5,
        2,
        -0.4,
        0,
        0,
        -0.4,
        -0.5,
        3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, multiply2);
    };
    ColorMatrixFilter2.prototype.reset = function() {
      var matrix2 = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix2, false);
    };
    Object.defineProperty(ColorMatrixFilter2.prototype, "matrix", {
      /**
       * The matrix of the color matrix filter
       * @member {number[]}
       * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
       */
      get: function() {
        return this.uniforms.m;
      },
      set: function(value) {
        this.uniforms.m = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ColorMatrixFilter2.prototype, "alpha", {
      /**
       * The opacity value to use when mixing the original and resultant colors.
       *
       * When the value is 0, the original color is used without modification.
       * When the value is 1, the result color is used.
       * When in the range (0, 1) the color is interpolated between the original and result by this amount.
       * @default 1
       */
      get: function() {
        return this.uniforms.uAlpha;
      },
      set: function(value) {
        this.uniforms.uAlpha = value;
      },
      enumerable: false,
      configurable: true
    });
    return ColorMatrixFilter2;
  }(Filter)
);
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$4 = function(d, b) {
  extendStatics$4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$4(d, b);
};
function __extends$4(d, b) {
  extendStatics$4(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var fragment$2 = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";
var vertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";
(function(_super) {
  __extends$4(DisplacementFilter, _super);
  function DisplacementFilter(sprite, scale) {
    var _this = this;
    var maskMatrix = new Matrix$1();
    sprite.renderable = false;
    _this = _super.call(this, vertex$1, fragment$2, {
      mapSampler: sprite._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }) || this;
    _this.maskSprite = sprite;
    _this.maskMatrix = maskMatrix;
    if (scale === null || scale === void 0) {
      scale = 20;
    }
    _this.scale = new Point(scale, scale);
    return _this;
  }
  DisplacementFilter.prototype.apply = function(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
    this.uniforms.scale.x = this.scale.x;
    this.uniforms.scale.y = this.scale.y;
    var wt = this.maskSprite.worldTransform;
    var lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
    var lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    if (lenX !== 0 && lenY !== 0) {
      this.uniforms.rotation[0] = wt.a / lenX;
      this.uniforms.rotation[1] = wt.b / lenX;
      this.uniforms.rotation[2] = wt.c / lenY;
      this.uniforms.rotation[3] = wt.d / lenY;
    }
    filterManager.applyFilter(this, input, output, clearMode);
  };
  Object.defineProperty(DisplacementFilter.prototype, "map", {
    /** The texture used for the displacement map. Must be power of 2 sized texture. */
    get: function() {
      return this.uniforms.mapSampler;
    },
    set: function(value) {
      this.uniforms.mapSampler = value;
    },
    enumerable: false,
    configurable: true
  });
  return DisplacementFilter;
})(Filter);
/*!
 * @pixi/filter-fxaa - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$3 = function(d, b) {
  extendStatics$3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$3(d, b);
};
function __extends$3(d, b) {
  extendStatics$3(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var vertex = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";
var fragment$1 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
(function(_super) {
  __extends$3(FXAAFilter, _super);
  function FXAAFilter() {
    return _super.call(this, vertex, fragment$1) || this;
  }
  return FXAAFilter;
})(Filter);
/*!
 * @pixi/filter-noise - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$2 = function(d, b) {
  extendStatics$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$2(d, b);
};
function __extends$2(d, b) {
  extendStatics$2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var fragment = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";
(function(_super) {
  __extends$2(NoiseFilter, _super);
  function NoiseFilter(noise, seed) {
    if (noise === void 0) {
      noise = 0.5;
    }
    if (seed === void 0) {
      seed = Math.random();
    }
    var _this = _super.call(this, defaultFilterVertex, fragment, {
      uNoise: 0,
      uSeed: 0
    }) || this;
    _this.noise = noise;
    _this.seed = seed;
    return _this;
  }
  Object.defineProperty(NoiseFilter.prototype, "noise", {
    /**
     * The amount of noise to apply, this value should be in the range (0, 1].
     * @default 0.5
     */
    get: function() {
      return this.uniforms.uNoise;
    },
    set: function(value) {
      this.uniforms.uNoise = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NoiseFilter.prototype, "seed", {
    /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
    get: function() {
      return this.uniforms.uSeed;
    },
    set: function(value) {
      this.uniforms.uSeed = value;
    },
    enumerable: false,
    configurable: true
  });
  return NoiseFilter;
})(Filter);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _tempMatrix = new Matrix$1();
DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY.NONE;
var CacheData = (
  /** @class */
  /* @__PURE__ */ function() {
    function CacheData2() {
      this.textureCacheId = null;
      this.originalRender = null;
      this.originalRenderCanvas = null;
      this.originalCalculateBounds = null;
      this.originalGetLocalBounds = null;
      this.originalUpdateTransform = null;
      this.originalDestroy = null;
      this.originalMask = null;
      this.originalFilterArea = null;
      this.originalContainsPoint = null;
      this.sprite = null;
    }
    return CacheData2;
  }()
);
Object.defineProperties(DisplayObject.prototype, {
  /**
   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution
   * but can be overriden for performance. Lower values will reduce memory usage at the expense
   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.
   * @member {number} cacheAsBitmapResolution
   * @memberof PIXI.DisplayObject#
   * @default null
   */
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(resolution) {
      if (resolution === this._cacheAsBitmapResolution) {
        return;
      }
      this._cacheAsBitmapResolution = resolution;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  /**
   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's
   * sample count is used.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.
   * @member {number} cacheAsBitmapMultisample
   * @memberof PIXI.DisplayObject#
   * @default PIXI.MSAA_QUALITY.NONE
   */
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(multisample) {
      if (multisample === this._cacheAsBitmapMultisample) {
        return;
      }
      this._cacheAsBitmapMultisample = multisample;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  /**
   * Set this to true if you want this display object to be cached as a bitmap.
   * This basically takes a snap shot of the display object as it is at that moment. It can
   * provide a performance benefit for complex static displayObjects.
   * To remove simply set this property to `false`
   *
   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(value) {
      if (this._cacheAsBitmap === value) {
        return;
      }
      this._cacheAsBitmap = value;
      var data;
      if (value) {
        if (!this._cacheData) {
          this._cacheData = new CacheData();
        }
        data = this._cacheData;
        data.originalRender = this.render;
        data.originalRenderCanvas = this.renderCanvas;
        data.originalUpdateTransform = this.updateTransform;
        data.originalCalculateBounds = this.calculateBounds;
        data.originalGetLocalBounds = this.getLocalBounds;
        data.originalDestroy = this.destroy;
        data.originalContainsPoint = this.containsPoint;
        data.originalMask = this._mask;
        data.originalFilterArea = this.filterArea;
        this.render = this._renderCached;
        this.renderCanvas = this._renderCachedCanvas;
        this.destroy = this._cacheAsBitmapDestroy;
      } else {
        data = this._cacheData;
        if (data.sprite) {
          this._destroyCachedDisplayObject();
        }
        this.render = data.originalRender;
        this.renderCanvas = data.originalRenderCanvas;
        this.calculateBounds = data.originalCalculateBounds;
        this.getLocalBounds = data.originalGetLocalBounds;
        this.destroy = data.originalDestroy;
        this.updateTransform = data.originalUpdateTransform;
        this.containsPoint = data.originalContainsPoint;
        this._mask = data.originalMask;
        this.filterArea = data.originalFilterArea;
      }
    }
  }
});
DisplayObject.prototype._renderCached = function _renderCached(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObject(renderer);
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._render(renderer);
};
DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
  var _a2;
  if (this._cacheData && this._cacheData.sprite) {
    return;
  }
  var cacheAlpha = this.alpha;
  this.alpha = 1;
  renderer.batch.flush();
  var bounds = this.getLocalBounds(null, true).clone();
  if (this.filters && this.filters.length) {
    var padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  bounds.ceil(settings.RESOLUTION);
  var cachedRenderTexture = renderer.renderTexture.current;
  var cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
  var cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
  var cachedProjectionTransform = renderer.projection.transform;
  var renderTexture = RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution: this.cacheAsBitmapResolution || renderer.resolution,
    multisample: (_a2 = this.cacheAsBitmapMultisample) !== null && _a2 !== void 0 ? _a2 : renderer.multisample
  });
  var textureCacheId = "cacheAsBitmap_" + uid();
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  var m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender;
  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
  renderer.framebuffer.blit();
  renderer.projection.transform = cachedProjectionTransform;
  renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
  this.render = this._renderCached;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  var cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.enableTempParent();
    this.updateTransform();
    this.disableTempParent(null);
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObjectCanvas(renderer);
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._renderCanvas(renderer);
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
  if (this._cacheData && this._cacheData.sprite) {
    return;
  }
  var bounds = this.getLocalBounds(null, true);
  var cacheAlpha = this.alpha;
  this.alpha = 1;
  var cachedRenderTarget = renderer.context;
  var cachedProjectionTransform = renderer._projTransform;
  bounds.ceil(settings.RESOLUTION);
  var renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
  var textureCacheId = "cacheAsBitmap_" + uid();
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  var m = _tempMatrix;
  this.transform.localTransform.copyTo(m);
  m.invert();
  m.tx -= bounds.x;
  m.ty -= bounds.y;
  this.renderCanvas = this._cacheData.originalRenderCanvas;
  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
  renderer.context = cachedRenderTarget;
  renderer._projTransform = cachedProjectionTransform;
  this.renderCanvas = this._renderCachedCanvas;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  var cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.parent = renderer._tempDisplayObjectParent;
    this.updateTransform();
    this.parent = null;
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
  this._bounds.clear();
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite._calculateBounds();
  this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
  this._cacheData.sprite._texture.destroy(true);
  this._cacheData.sprite = null;
  BaseTexture.removeFromCache(this._cacheData.textureCacheId);
  Texture.removeFromCache(this._cacheData.textureCacheId);
  this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
  this.cacheAsBitmap = false;
  this.destroy(options);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.name = null;
Container.prototype.getChildByName = function getChildByName(name2, deep) {
  for (var i = 0, j = this.children.length; i < j; i++) {
    if (this.children[i].name === name2) {
      return this.children[i];
    }
  }
  if (deep) {
    for (var i = 0, j = this.children.length; i < j; i++) {
      var child = this.children[i];
      if (!child.getChildByName) {
        continue;
      }
      var target = child.getChildByName(name2, true);
      if (target) {
        return target;
      }
    }
  }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point, skipUpdate) {
  if (point === void 0) {
    point = new Point();
  }
  if (skipUpdate === void 0) {
    skipUpdate = false;
  }
  if (this.parent) {
    this.parent.toGlobal(this.position, point, skipUpdate);
  } else {
    point.x = this.position.x;
    point.y = this.position.y;
  }
  return point;
};
/*!
 * @pixi/app - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ResizePlugin = (
  /** @class */
  function() {
    function ResizePlugin2() {
    }
    ResizePlugin2.init = function(options) {
      var _this = this;
      Object.defineProperty(
        this,
        "resizeTo",
        /**
         * The HTML element or window to automatically resize the
         * renderer's view element to match width and height.
         * @member {Window|HTMLElement}
         * @name resizeTo
         * @memberof PIXI.Application#
         */
        {
          set: function(dom) {
            globalThis.removeEventListener("resize", this.queueResize);
            this._resizeTo = dom;
            if (dom) {
              globalThis.addEventListener("resize", this.queueResize);
              this.resize();
            }
          },
          get: function() {
            return this._resizeTo;
          }
        }
      );
      this.queueResize = function() {
        if (!_this._resizeTo) {
          return;
        }
        _this.cancelResize();
        _this._resizeId = requestAnimationFrame(function() {
          return _this.resize();
        });
      };
      this.cancelResize = function() {
        if (_this._resizeId) {
          cancelAnimationFrame(_this._resizeId);
          _this._resizeId = null;
        }
      };
      this.resize = function() {
        if (!_this._resizeTo) {
          return;
        }
        _this.cancelResize();
        var width;
        var height;
        if (_this._resizeTo === globalThis.window) {
          width = globalThis.innerWidth;
          height = globalThis.innerHeight;
        } else {
          var _a2 = _this._resizeTo, clientWidth = _a2.clientWidth, clientHeight = _a2.clientHeight;
          width = clientWidth;
          height = clientHeight;
        }
        _this.renderer.resize(width, height);
      };
      this._resizeId = null;
      this._resizeTo = null;
      this.resizeTo = options.resizeTo || null;
    };
    ResizePlugin2.destroy = function() {
      globalThis.removeEventListener("resize", this.queueResize);
      this.cancelResize();
      this.cancelResize = null;
      this.queueResize = null;
      this.resizeTo = null;
      this.resize = null;
    };
    ResizePlugin2.extension = ExtensionType.Application;
    return ResizePlugin2;
  }()
);
var Application = (
  /** @class */
  function() {
    function Application2(options) {
      var _this = this;
      this.stage = new Container();
      options = Object.assign({
        forceCanvas: false
      }, options);
      this.renderer = autoDetectRenderer(options);
      Application2._plugins.forEach(function(plugin) {
        plugin.init.call(_this, options);
      });
    }
    Application2.registerPlugin = function(plugin) {
      deprecation("6.5.0", "Application.registerPlugin() is deprecated, use extensions.add()");
      extensions.add({
        type: ExtensionType.Application,
        ref: plugin
      });
    };
    Application2.prototype.render = function() {
      this.renderer.render(this.stage);
    };
    Object.defineProperty(Application2.prototype, "view", {
      /**
       * Reference to the renderer's canvas element.
       * @member {HTMLCanvasElement}
       * @readonly
       */
      get: function() {
        return this.renderer.view;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Application2.prototype, "screen", {
      /**
       * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
       * @member {PIXI.Rectangle}
       * @readonly
       */
      get: function() {
        return this.renderer.screen;
      },
      enumerable: false,
      configurable: true
    });
    Application2.prototype.destroy = function(removeView, stageOptions) {
      var _this = this;
      var plugins = Application2._plugins.slice(0);
      plugins.reverse();
      plugins.forEach(function(plugin) {
        plugin.destroy.call(_this);
      });
      this.stage.destroy(stageOptions);
      this.stage = null;
      this.renderer.destroy(removeView);
      this.renderer = null;
    };
    Application2._plugins = [];
    return Application2;
  }()
);
extensions.handleByList(ExtensionType.Application, Application._plugins);
extensions.add(ResizePlugin);
/*!
 * @pixi/mesh-extras - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(d, b) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics$1(d, b);
};
function __extends$1(d, b) {
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var PlaneGeometry = (
  /** @class */
  function(_super) {
    __extends$1(PlaneGeometry2, _super);
    function PlaneGeometry2(width, height, segWidth, segHeight) {
      if (width === void 0) {
        width = 100;
      }
      if (height === void 0) {
        height = 100;
      }
      if (segWidth === void 0) {
        segWidth = 10;
      }
      if (segHeight === void 0) {
        segHeight = 10;
      }
      var _this = _super.call(this) || this;
      _this.segWidth = segWidth;
      _this.segHeight = segHeight;
      _this.width = width;
      _this.height = height;
      _this.build();
      return _this;
    }
    PlaneGeometry2.prototype.build = function() {
      var total = this.segWidth * this.segHeight;
      var verts = [];
      var uvs = [];
      var indices3 = [];
      var segmentsX = this.segWidth - 1;
      var segmentsY = this.segHeight - 1;
      var sizeX = this.width / segmentsX;
      var sizeY = this.height / segmentsY;
      for (var i = 0; i < total; i++) {
        var x = i % this.segWidth;
        var y = i / this.segWidth | 0;
        verts.push(x * sizeX, y * sizeY);
        uvs.push(x / segmentsX, y / segmentsY);
      }
      var totalSub = segmentsX * segmentsY;
      for (var i = 0; i < totalSub; i++) {
        var xpos = i % segmentsX;
        var ypos = i / segmentsX | 0;
        var value = ypos * this.segWidth + xpos;
        var value2 = ypos * this.segWidth + xpos + 1;
        var value3 = (ypos + 1) * this.segWidth + xpos;
        var value4 = (ypos + 1) * this.segWidth + xpos + 1;
        indices3.push(value, value2, value3, value2, value4, value3);
      }
      this.buffers[0].data = new Float32Array(verts);
      this.buffers[1].data = new Float32Array(uvs);
      this.indexBuffer.data = new Uint16Array(indices3);
      this.buffers[0].update();
      this.buffers[1].update();
      this.indexBuffer.update();
    };
    return PlaneGeometry2;
  }(MeshGeometry)
);
var RopeGeometry = (
  /** @class */
  function(_super) {
    __extends$1(RopeGeometry2, _super);
    function RopeGeometry2(width, points, textureScale) {
      if (width === void 0) {
        width = 200;
      }
      if (textureScale === void 0) {
        textureScale = 0;
      }
      var _this = _super.call(this, new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6)) || this;
      _this.points = points;
      _this._width = width;
      _this.textureScale = textureScale;
      _this.build();
      return _this;
    }
    Object.defineProperty(RopeGeometry2.prototype, "width", {
      /**
       * The width (i.e., thickness) of the rope.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: false,
      configurable: true
    });
    RopeGeometry2.prototype.build = function() {
      var points = this.points;
      if (!points) {
        return;
      }
      var vertexBuffer = this.getBuffer("aVertexPosition");
      var uvBuffer = this.getBuffer("aTextureCoord");
      var indexBuffer = this.getIndex();
      if (points.length < 1) {
        return;
      }
      if (vertexBuffer.data.length / 4 !== points.length) {
        vertexBuffer.data = new Float32Array(points.length * 4);
        uvBuffer.data = new Float32Array(points.length * 4);
        indexBuffer.data = new Uint16Array((points.length - 1) * 6);
      }
      var uvs = uvBuffer.data;
      var indices3 = indexBuffer.data;
      uvs[0] = 0;
      uvs[1] = 0;
      uvs[2] = 0;
      uvs[3] = 1;
      var amount = 0;
      var prev = points[0];
      var textureWidth = this._width * this.textureScale;
      var total = points.length;
      for (var i = 0; i < total; i++) {
        var index = i * 4;
        if (this.textureScale > 0) {
          var dx = prev.x - points[i].x;
          var dy = prev.y - points[i].y;
          var distance = Math.sqrt(dx * dx + dy * dy);
          prev = points[i];
          amount += distance / textureWidth;
        } else {
          amount = i / (total - 1);
        }
        uvs[index] = amount;
        uvs[index + 1] = 0;
        uvs[index + 2] = amount;
        uvs[index + 3] = 1;
      }
      var indexCount = 0;
      for (var i = 0; i < total - 1; i++) {
        var index = i * 2;
        indices3[indexCount++] = index;
        indices3[indexCount++] = index + 1;
        indices3[indexCount++] = index + 2;
        indices3[indexCount++] = index + 2;
        indices3[indexCount++] = index + 1;
        indices3[indexCount++] = index + 3;
      }
      uvBuffer.update();
      indexBuffer.update();
      this.updateVertices();
    };
    RopeGeometry2.prototype.updateVertices = function() {
      var points = this.points;
      if (points.length < 1) {
        return;
      }
      var lastPoint = points[0];
      var nextPoint;
      var perpX = 0;
      var perpY = 0;
      var vertices = this.buffers[0].data;
      var total = points.length;
      for (var i = 0; i < total; i++) {
        var point = points[i];
        var index = i * 4;
        if (i < points.length - 1) {
          nextPoint = points[i + 1];
        } else {
          nextPoint = point;
        }
        perpY = -(nextPoint.x - lastPoint.x);
        perpX = nextPoint.y - lastPoint.y;
        var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
        var num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
        perpX /= perpLength;
        perpY /= perpLength;
        perpX *= num;
        perpY *= num;
        vertices[index] = point.x + perpX;
        vertices[index + 1] = point.y + perpY;
        vertices[index + 2] = point.x - perpX;
        vertices[index + 3] = point.y - perpY;
        lastPoint = point;
      }
      this.buffers[0].update();
    };
    RopeGeometry2.prototype.update = function() {
      if (this.textureScale > 0) {
        this.build();
      } else {
        this.updateVertices();
      }
    };
    return RopeGeometry2;
  }(MeshGeometry)
);
(function(_super) {
  __extends$1(SimpleRope, _super);
  function SimpleRope(texture, points, textureScale) {
    if (textureScale === void 0) {
      textureScale = 0;
    }
    var _this = this;
    var ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
    var meshMaterial = new MeshMaterial(texture);
    if (textureScale > 0) {
      texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;
    }
    _this = _super.call(this, ropeGeometry, meshMaterial) || this;
    _this.autoUpdate = true;
    return _this;
  }
  SimpleRope.prototype._render = function(renderer) {
    var geometry = this.geometry;
    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
      geometry._width = this.shader.texture.height;
      geometry.update();
    }
    _super.prototype._render.call(this, renderer);
  };
  return SimpleRope;
})(Mesh);
var SimplePlane = (
  /** @class */
  function(_super) {
    __extends$1(SimplePlane2, _super);
    function SimplePlane2(texture, verticesX, verticesY) {
      var _this = this;
      var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
      var meshMaterial = new MeshMaterial(Texture.WHITE);
      _this = _super.call(this, planeGeometry, meshMaterial) || this;
      _this.texture = texture;
      _this.autoResize = true;
      return _this;
    }
    SimplePlane2.prototype.textureUpdated = function() {
      this._textureID = this.shader.texture._updateID;
      var geometry = this.geometry;
      var _a2 = this.shader.texture, width = _a2.width, height = _a2.height;
      if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
        geometry.width = this.shader.texture.width;
        geometry.height = this.shader.texture.height;
        geometry.build();
      }
    };
    Object.defineProperty(SimplePlane2.prototype, "texture", {
      get: function() {
        return this.shader.texture;
      },
      set: function(value) {
        if (this.shader.texture === value) {
          return;
        }
        this.shader.texture = value;
        this._textureID = -1;
        if (value.baseTexture.valid) {
          this.textureUpdated();
        } else {
          value.once("update", this.textureUpdated, this);
        }
      },
      enumerable: false,
      configurable: true
    });
    SimplePlane2.prototype._render = function(renderer) {
      if (this._textureID !== this.shader.texture._updateID) {
        this.textureUpdated();
      }
      _super.prototype._render.call(this, renderer);
    };
    SimplePlane2.prototype.destroy = function(options) {
      this.shader.texture.off("update", this.textureUpdated, this);
      _super.prototype.destroy.call(this, options);
    };
    return SimplePlane2;
  }(Mesh)
);
(function(_super) {
  __extends$1(SimpleMesh, _super);
  function SimpleMesh(texture, vertices, uvs, indices3, drawMode) {
    if (texture === void 0) {
      texture = Texture.EMPTY;
    }
    var _this = this;
    var geometry = new MeshGeometry(vertices, uvs, indices3);
    geometry.getBuffer("aVertexPosition").static = false;
    var meshMaterial = new MeshMaterial(texture);
    _this = _super.call(this, geometry, meshMaterial, null, drawMode) || this;
    _this.autoUpdate = true;
    return _this;
  }
  Object.defineProperty(SimpleMesh.prototype, "vertices", {
    /**
     * Collection of vertices data.
     * @type {Float32Array}
     */
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(value) {
      this.geometry.getBuffer("aVertexPosition").data = value;
    },
    enumerable: false,
    configurable: true
  });
  SimpleMesh.prototype._render = function(renderer) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    _super.prototype._render.call(this, renderer);
  };
  return SimpleMesh;
})(Mesh);
var DEFAULT_BORDER_SIZE = 10;
(function(_super) {
  __extends$1(NineSlicePlane, _super);
  function NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
    if (leftWidth === void 0) {
      leftWidth = DEFAULT_BORDER_SIZE;
    }
    if (topHeight === void 0) {
      topHeight = DEFAULT_BORDER_SIZE;
    }
    if (rightWidth === void 0) {
      rightWidth = DEFAULT_BORDER_SIZE;
    }
    if (bottomHeight === void 0) {
      bottomHeight = DEFAULT_BORDER_SIZE;
    }
    var _this = _super.call(this, Texture.WHITE, 4, 4) || this;
    _this._origWidth = texture.orig.width;
    _this._origHeight = texture.orig.height;
    _this._width = _this._origWidth;
    _this._height = _this._origHeight;
    _this._leftWidth = leftWidth;
    _this._rightWidth = rightWidth;
    _this._topHeight = topHeight;
    _this._bottomHeight = bottomHeight;
    _this.texture = texture;
    return _this;
  }
  NineSlicePlane.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID;
    this._refresh();
  };
  Object.defineProperty(NineSlicePlane.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(value) {
      this.geometry.getBuffer("aVertexPosition").data = value;
    },
    enumerable: false,
    configurable: true
  });
  NineSlicePlane.prototype.updateHorizontalVertices = function() {
    var vertices = this.vertices;
    var scale = this._getMinScale();
    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
  };
  NineSlicePlane.prototype.updateVerticalVertices = function() {
    var vertices = this.vertices;
    var scale = this._getMinScale();
    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
  };
  NineSlicePlane.prototype._getMinScale = function() {
    var w = this._leftWidth + this._rightWidth;
    var scaleW = this._width > w ? 1 : this._width / w;
    var h = this._topHeight + this._bottomHeight;
    var scaleH = this._height > h ? 1 : this._height / h;
    var scale = Math.min(scaleW, scaleH);
    return scale;
  };
  Object.defineProperty(NineSlicePlane.prototype, "width", {
    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._width;
    },
    set: function(value) {
      this._width = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "height", {
    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._height;
    },
    set: function(value) {
      this._height = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "leftWidth", {
    /** The width of the left column. */
    get: function() {
      return this._leftWidth;
    },
    set: function(value) {
      this._leftWidth = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "rightWidth", {
    /** The width of the right column. */
    get: function() {
      return this._rightWidth;
    },
    set: function(value) {
      this._rightWidth = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "topHeight", {
    /** The height of the top row. */
    get: function() {
      return this._topHeight;
    },
    set: function(value) {
      this._topHeight = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "bottomHeight", {
    /** The height of the bottom row. */
    get: function() {
      return this._bottomHeight;
    },
    set: function(value) {
      this._bottomHeight = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  NineSlicePlane.prototype._refresh = function() {
    var texture = this.texture;
    var uvs = this.geometry.buffers[1].data;
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    var _uvw = 1 / this._origWidth;
    var _uvh = 1 / this._origHeight;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    this.updateHorizontalVertices();
    this.updateVerticalVertices();
    this.geometry.buffers[0].update();
    this.geometry.buffers[1].update();
  };
  return NineSlicePlane;
})(SimplePlane);
/*!
 * @pixi/sprite-animated - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
(function(_super) {
  __extends(AnimatedSprite, _super);
  function AnimatedSprite(textures, autoUpdate) {
    if (autoUpdate === void 0) {
      autoUpdate = true;
    }
    var _this = _super.call(this, textures[0] instanceof Texture ? textures[0] : textures[0].texture) || this;
    _this._textures = null;
    _this._durations = null;
    _this._autoUpdate = autoUpdate;
    _this._isConnectedToTicker = false;
    _this.animationSpeed = 1;
    _this.loop = true;
    _this.updateAnchor = false;
    _this.onComplete = null;
    _this.onFrameChange = null;
    _this.onLoop = null;
    _this._currentTime = 0;
    _this._playing = false;
    _this._previousFrame = null;
    _this.textures = textures;
    return _this;
  }
  AnimatedSprite.prototype.stop = function() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  };
  AnimatedSprite.prototype.play = function() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  };
  AnimatedSprite.prototype.gotoAndStop = function(frameNumber) {
    this.stop();
    var previousFrame = this.currentFrame;
    this._currentTime = frameNumber;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
  };
  AnimatedSprite.prototype.gotoAndPlay = function(frameNumber) {
    var previousFrame = this.currentFrame;
    this._currentTime = frameNumber;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
    this.play();
  };
  AnimatedSprite.prototype.update = function(deltaTime) {
    if (!this._playing) {
      return;
    }
    var elapsed = this.animationSpeed * deltaTime;
    var previousFrame = this.currentFrame;
    if (this._durations !== null) {
      var lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      var sign3 = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign3;
        this._currentTime += sign3;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
          this.onLoop();
        } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this.updateTexture();
    }
  };
  AnimatedSprite.prototype.updateTexture = function() {
    var currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this._texture = this._textures[currentFrame];
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    this.uvs = this._texture._uvs.uvsFloat32;
    if (this.updateAnchor) {
      this._anchor.copyFrom(this._texture.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  };
  AnimatedSprite.prototype.destroy = function(options) {
    this.stop();
    _super.prototype.destroy.call(this, options);
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  };
  AnimatedSprite.fromFrames = function(frames) {
    var textures = [];
    for (var i = 0; i < frames.length; ++i) {
      textures.push(Texture.from(frames[i]));
    }
    return new AnimatedSprite(textures);
  };
  AnimatedSprite.fromImages = function(images) {
    var textures = [];
    for (var i = 0; i < images.length; ++i) {
      textures.push(Texture.from(images[i]));
    }
    return new AnimatedSprite(textures);
  };
  Object.defineProperty(AnimatedSprite.prototype, "totalFrames", {
    /**
     * The total number of frames in the AnimatedSprite. This is the same as number of textures
     * assigned to the AnimatedSprite.
     * @readonly
     * @default 0
     */
    get: function() {
      return this._textures.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite.prototype, "textures", {
    /** The array of textures used for this AnimatedSprite. */
    get: function() {
      return this._textures;
    },
    set: function(value) {
      if (value[0] instanceof Texture) {
        this._textures = value;
        this._durations = null;
      } else {
        this._textures = [];
        this._durations = [];
        for (var i = 0; i < value.length; i++) {
          this._textures.push(value[i].texture);
          this._durations.push(value[i].time);
        }
      }
      this._previousFrame = null;
      this.gotoAndStop(0);
      this.updateTexture();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite.prototype, "currentFrame", {
    /**
     * The AnimatedSprites current frame index.
     * @readonly
     */
    get: function() {
      var currentFrame = Math.floor(this._currentTime) % this._textures.length;
      if (currentFrame < 0) {
        currentFrame += this._textures.length;
      }
      return currentFrame;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite.prototype, "playing", {
    /**
     * Indicates if the AnimatedSprite is currently playing.
     * @readonly
     */
    get: function() {
      return this._playing;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite.prototype, "autoUpdate", {
    /** Whether to use PIXI.Ticker.shared to auto update animation time. */
    get: function() {
      return this._autoUpdate;
    },
    set: function(value) {
      if (value !== this._autoUpdate) {
        this._autoUpdate = value;
        if (!this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  return AnimatedSprite;
})(Sprite);
/*!
 * pixi.js - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
extensions.add(
  // Install renderer plugins
  AccessibilityManager,
  Extract,
  InteractionManager,
  ParticleRenderer,
  Prepare,
  BatchRenderer,
  TilingSpriteRenderer,
  // Install loader plugins
  BitmapFontLoader,
  CompressedTextureLoader,
  DDSLoader,
  KTXLoader,
  SpritesheetLoader,
  // Install application plugins
  TickerPlugin,
  AppLoaderPlugin
);
function scaleCanvas(c2, w, h) {
  var result = c2.attr("width", w * window.devicePixelRatio).attr("height", h * window.devicePixelRatio).style("width", w + "px").style("height", h + "px");
  var context2 = c2.node().getContext("2d");
  context2.scale(window.devicePixelRatio, window.devicePixelRatio);
  return result;
}
function ColorIDMap(format2 = "css") {
  this.nextColor = 1;
  this.format = format2;
  this.mapping = {};
  this.reverseMapping = {};
  this._next = function() {
    var ret = [];
    if (this.nextColor < 16777215) {
      ret.push(this.nextColor & 255);
      ret.push((this.nextColor & 65280) >> 8);
      ret.push((this.nextColor & 16711680) >> 16);
      this.nextColor += 5;
    }
    if (this.format == "css")
      return "rgb(" + ret.join(",") + ")";
    else if (this.format == "hex")
      return this.nextColor;
  };
  this.id = function(id2, obj = null) {
    if (!this.mapping.hasOwnProperty(id2))
      this.mapping[id2] = this._next();
    this.reverseMapping[this.mapping[id2]] = obj || id2;
    return this.mapping[id2];
  };
  this.obj = function(color2) {
    return this.reverseMapping[color2];
  };
}
function shuffle(array2) {
  var currentIndex = array2.length, temporaryValue, randomIndex;
  while (0 !== currentIndex) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;
    temporaryValue = array2[currentIndex];
    array2[currentIndex] = array2[randomIndex];
    array2[randomIndex] = temporaryValue;
  }
  return array2;
}
function approxEquals(obj1, obj2) {
  if (typeof obj1 == "number" && typeof obj2 == "number") {
    return Math.abs(obj1 - obj2) <= 1e-3;
  }
  return obj1 == obj2;
}
function normalizeVector(vec) {
  let mag = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
  return [vec[0] / mag, vec[1] / mag];
}
function boundingBox(points) {
  let minX = 1e9;
  let maxX = -1e9;
  let minY = 1e9;
  let maxY = -1e9;
  points.forEach((point) => {
    if (point.x < minX)
      minX = point.x;
    if (point.x > maxX)
      maxX = point.x;
    if (point.y < minY)
      minY = point.y;
    if (point.y > maxY)
      maxY = point.y;
  });
  return { x: [minX, maxX], y: [minY, maxY] };
}
function padExtent(extent, padding) {
  return [extent[0] - padding, extent[1] + padding];
}
function transformPoint(transform, point) {
  return [
    transform[0][0] * point[0] + transform[0][1] * point[1] + transform[0][2],
    transform[1][0] * point[0] + transform[1][1] * point[1] + transform[1][2]
  ];
}
function makeTimeProvider() {
  var currentTime = 0;
  let fn = function() {
    return currentTime;
  };
  fn.advance = function(dt) {
    currentTime += dt;
  };
  return fn;
}
function distance2(a, b) {
  let dx = a.x - b.x;
  let dy = a.y - b.y;
  return dx * dx + dy * dy;
}
function euclideanDistance(a, b) {
  return Math.sqrt(distance2(a, b));
}
class ValueHistory {
  constructor() {
    __publicField(this, "lastValues", {});
  }
  update(newValues) {
    let changed = false;
    Object.keys(newValues).forEach((key) => {
      changed = changed || !approxEquals(newValues[key], this.lastValues[key]);
      this.lastValues[key] = newValues[key];
    });
    return changed;
  }
}
function base64ToBlob(b64Data, contentType = "", sliceSize = 512) {
  const byteCharacters = atob(b64Data);
  const byteArrays = [];
  for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
    const slice2 = byteCharacters.slice(offset, offset + sliceSize);
    const byteNumbers = new Array(slice2.length);
    for (let i = 0; i < slice2.length; i++) {
      byteNumbers[i] = slice2.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    byteArrays.push(byteArray);
  }
  const blob = new Blob(byteArrays, { type: contentType });
  return blob;
}
function getTextWidth(text2, font) {
  var canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
  var context2 = canvas.getContext("2d");
  context2.font = font;
  var metrics = context2.measureText(text2);
  return metrics.width;
}
function getOSName() {
  if (navigator.appVersion.indexOf("Win") != -1)
    return "Windows";
  if (navigator.appVersion.indexOf("Mac") != -1)
    return "MacOS";
  if (navigator.appVersion.indexOf("X11") != -1)
    return "UNIX";
  if (navigator.appVersion.indexOf("Linux") != -1)
    return "Linux";
  return "Unknown";
}
class Attribute {
  constructor(info) {
    __publicField(this, "value", null);
    __publicField(this, "valueFn", null);
    __publicField(this, "transform", null);
    __publicField(this, "cached", false);
    __publicField(this, "_cachedValue", null);
    __publicField(this, "computeArg", null);
    __publicField(this, "precompute", false);
    __publicField(this, "lazy", false);
    __publicField(this, "needsUpdate", false);
    __publicField(this, "animation", null);
    __publicField(this, "label", null);
    // for debugging
    __publicField(this, "_getterValue", null);
    // This is precomputed in advance() and returned by get()
    __publicField(this, "_computedLastValue", null);
    // Value to use as initial interpolant if this is a computed value and animated
    __publicField(this, "_hasComputed", false);
    __publicField(this, "_timeProvider", null);
    // REQUIRED for animation
    __publicField(this, "currentTime", 0);
    if (info == void 0 || info == null || !(info.hasOwnProperty("value") || info.hasOwnProperty("valueFn"))) {
      this.value = info;
      this.valueFn = null;
      this.transform = null;
      this.cached = false;
      this._cachedValue = null;
      this.computeArg = null;
      this.precompute = false;
      this.lazy = false;
    } else {
      if (info.hasOwnProperty("value")) {
        this.value = info.value;
      } else {
        this.valueFn = info.valueFn;
      }
      this.transform = info.transform || null;
      this.cached = info.cached || false;
      this._cachedValue = null;
      this.computeArg = info.computeArg || null;
      this.precompute = info.precompute || false;
      this.lazy = info.lazy || false;
    }
  }
  setTimeProvider(timeProvider) {
    this._timeProvider = timeProvider;
  }
  compute() {
    if (!!this.valueFn) {
      this._computedLastValue = this.valueFn(this.computeArg || this);
    }
  }
  // Advances the time of the animation by the given number of msec,
  // and returns whether or not a redraw is needed
  advance(dt) {
    if (this.animation != null || this.needsUpdate || !!this.valueFn) {
      if (!!dt)
        this.currentTime += dt;
      else
        this.currentTime = this._timeProvider();
    }
    if (this._animationFinished()) {
      this._computeAnimation();
    }
    if (this.animation != null || this.needsUpdate) {
      this.needsUpdate = false;
      return true;
    } else if (this.precompute) {
      this.compute();
    }
    return false;
  }
  _computeAnimation(recomputeOnComplete = true) {
    if (!this.animation)
      return;
    if (!!this._timeProvider)
      this.currentTime = this._timeProvider();
    let { animator, start: start2 } = this.animation;
    let value = animator.evaluate(
      !!this.valueFn ? this._computedLastValue : this.value,
      Math.min(this.currentTime - start2, animator.duration)
      // can add a debug flag here
    );
    if (this._animationFinished() && recomputeOnComplete) {
      if (!!this.valueFn)
        this.compute();
      else
        this.value = value;
      this.animation = null;
      this._getterValue = null;
    } else {
      this._getterValue = value;
    }
  }
  _animationFinished() {
    if (!this.animation)
      return true;
    return this.animation.animator.duration - 20 <= this.currentTime - this.animation.start;
  }
  _transform(value) {
    if (!!this.transform) {
      let cached = this._cachedValue;
      if (!!cached && approxEquals(cached.raw, value)) {
        value = cached.result;
      } else {
        let raw = value;
        value = this.transform(value, this.computeArg);
        if (this.cached) {
          this._cachedValue = {
            raw,
            result: value
          };
        }
      }
    }
    return value;
  }
  get(transform = true) {
    this._computeAnimation();
    let value;
    if (this._getterValue != null)
      value = this._getterValue;
    else if (!!this.valueFn) {
      if (!this.lazy || !this._hasComputed) {
        this.compute();
        this._hasComputed = true;
      }
      value = this._computedLastValue;
    } else
      value = this.value;
    if (transform) {
      value = this._transform(value);
    }
    return value;
  }
  // Returns an object that tells a renderer how to animate this attribute,
  // including four properties: start and end (the initial and final values of
  // the attribute) and startTime and endTime (the timestamps for the start and
  // end of the animation, in ms). If there is no animation, startTime and endTime
  // will be equal.
  // If currentTime is provided, the startTime and endTime values will be
  // converted to match this time.
  getPreload(transform = true, currentTime = null) {
    if (!!this._timeProvider)
      this.currentTime = this._timeProvider();
    if (!this.animation) {
      let value2 = this.get(transform);
      return {
        start: value2,
        end: value2,
        startTime: currentTime || this.currentTime,
        endTime: currentTime || this.currentTime
      };
    }
    if (!(this.animation.animator instanceof PreloadableAnimator)) {
      console.error(
        "Calling getPreload for a non-preloadable animation is forbidden. If using MarkSet, make sure this attribute is registered as preloadable."
      );
      return null;
    }
    if (this._animationFinished()) {
      this._computeAnimation();
      return this.getPreload(transform, currentTime);
    }
    let value;
    if (!!this.valueFn) {
      if (!this.lazy || !this._hasComputed) {
        this.compute();
        this._hasComputed = true;
      }
      value = this._computedLastValue;
    } else
      value = this.value;
    if (transform) {
      value = this._transform(value);
    }
    let finalValue = this.animation.animator.finalValue;
    if (transform) {
      finalValue = this._transform(finalValue);
    }
    let timeDelta = (currentTime || this.currentTime) - this.currentTime;
    return {
      start: value,
      end: finalValue,
      startTime: this.animation.start + timeDelta,
      endTime: this.animation.start + this.animation.animator.duration + timeDelta
    };
  }
  set(newValue) {
    if (typeof newValue == "function") {
      if (this.value != null)
        this._computedLastValue = this.value;
      this.valueFn = newValue;
      this.value = null;
      this._getterValue = null;
    } else {
      this.value = newValue;
      this.valueFn = null;
      this._getterValue = null;
    }
    this.needsUpdate = true;
  }
  // Gets the non-animated value
  data() {
    if (!!this.valueFn) {
      return this.valueFn(this.computeArg || this);
    } else {
      return this.value;
    }
  }
  // Returns the last value (including if computed), without doing any computation
  last() {
    if (!!this.animation) {
      this._computeAnimation(false);
    }
    if (this._getterValue != null)
      return this._getterValue;
    return this._computedLastValue;
  }
  // Returns the value that this attribute is approaching if animating (or null
  // if not available), or the current value if not animating.
  future() {
    if (!!this.animation) {
      return this.animation.animator.finalValue;
    }
    return this.last();
  }
  // Marks that the transform has changed for the given attribute
  updateTransform() {
    this._cachedValue = null;
  }
  // Animations should have an evaluate()
  // method that takes as parameter an initial value and a time
  // delta from start (in msec) and returns a new value for the
  // attribute, and a duration property in msec
  animate(animation) {
    if (!!this._timeProvider)
      this.currentTime = this._timeProvider();
    if (!!this.animation) {
      if (!this.valueFn) {
        this.value = this.last();
      } else {
        this._computedLastValue = this.last();
      }
    }
    this.animation = {
      animator: animation,
      start: this.currentTime
    };
    this._computeAnimation();
  }
}
const ExcessiveUpdateThreshold = 5e3;
class Mark {
  constructor(id2, attributes, special = false) {
    // Describes the appearance of a scatterplot point.
    __publicField(this, "_timeProvider", null);
    __publicField(this, "id");
    __publicField(this, "special", false);
    __publicField(this, "attributes", {});
    // Warning system to detect when an attribute is being listed as animated
    // for no reason
    __publicField(this, "framesWithUpdate", 0);
    this.id = id2;
    this.special = special;
    this.attributes = {};
    Object.keys(attributes).forEach((attrName) => {
      let attrib = new Attribute(attributes[attrName]);
      attrib.computeArg = this;
      this.attributes[attrName] = attrib;
    });
  }
  setTimeProvider(timeProvider) {
    this._timeProvider = timeProvider;
    Object.values(this.attributes).forEach(
      (attr2) => attr2.setTimeProvider(this._timeProvider)
    );
  }
  // Advances the time of the animations by the given number of msec,
  // and returns whether or not a redraw is needed
  advance() {
    let updated = false;
    Object.values(this.attributes).forEach((attr2) => {
      if (attr2.advance())
        updated = true;
    });
    if (updated) {
      this.framesWithUpdate += 1;
      if (this.framesWithUpdate > ExcessiveUpdateThreshold) {
        console.warn("Marks are being updated excessively!");
      }
      return true;
    }
    this.framesWithUpdate = 0;
    return false;
  }
  // Basically plays an instantaneous animation
  setAttr(attrName, newValue) {
    this.attributes[attrName].set(newValue);
    this.needsUpdate = true;
  }
  attr(attrName, transform = true) {
    if (!this.attributes[attrName]) {
      return void 0;
    }
    return this.attributes[attrName].get(transform);
  }
  // Gets the true data value (non-animated)
  data(attrName) {
    return this.attributes[attrName].data();
  }
  // Marks that the transform has changed for the given attribute
  updateTransform(attrName) {
    this.attributes[attrName].updateTransform();
  }
  // Animations should have an evaluate()
  // method that takes as parameter an initial value and a time
  // delta from start (in msec) and returns a new value for the
  // attribute, and a duration property in msec
  animate(attrName, animation) {
    if (!this.attributes.hasOwnProperty(attrName)) {
      console.error("Attempting to animate undefined property " + attrName);
      return;
    }
    this.attributes[attrName].animate(animation);
  }
}
class Decoration {
  constructor(type2, marks, attributes) {
    __publicField(this, "type");
    __publicField(this, "marks");
    this.type = type2;
    this.marks = marks;
    this.attributes = {};
    Object.keys(attributes).forEach((attrName) => {
      let attrib = new Attribute(attributes[attrName]);
      this.attributes[attrName] = attrib;
    });
    if (!this.attributes.hasOwnProperty("x")) {
      this.attributes.x = new Attribute({
        valueFn: () => this.marks[0].attr("x")
      });
    }
    if (!this.attributes.hasOwnProperty("y")) {
      this.attributes.y = new Attribute({
        valueFn: () => this.marks[0].attr("y")
      });
    }
    if (!this.attributes.hasOwnProperty("alpha")) {
      this.attributes.alpha = new Attribute(1);
    }
    if (this.marks.length > 1) {
      if (!this.attributes.hasOwnProperty("x2")) {
        this.attributes.x2 = new Attribute({
          valueFn: () => this.marks[1].attr("x")
        });
      }
      if (!this.attributes.hasOwnProperty("y2")) {
        this.attributes.y2 = new Attribute({
          valueFn: () => this.marks[1].attr("y")
        });
      }
    }
    Object.values(this.attributes).forEach((val) => {
      val.computeArg = this;
      val.compute();
    });
  }
  // Advances the time of the animations by the given number of msec,
  // and returns whether or not a redraw is needed
  advance(dt) {
    let updated = false;
    Object.values(this.attributes).forEach((attr2) => {
      if (attr2.advance(dt))
        updated = true;
    });
    return updated;
  }
  attr(attrName) {
    if (!this.attributes.hasOwnProperty(attrName))
      return null;
    return this.attributes[attrName].get();
  }
  data(attrName) {
    if (!this.attributes.hasOwnProperty(attrName))
      return null;
    return this.attributes[attrName].data();
  }
  setAttr(attrName, value) {
    this.attributes[attrName].set(value);
  }
  update() {
  }
  animate(attrName, animation) {
    this.attributes[attrName].animate(animation);
  }
}
function MarkSet(marks, decorations = null) {
  let timeProvider = makeTimeProvider();
  this.marks = marks;
  this.marksByID = /* @__PURE__ */ new Map();
  this.marks.forEach((m) => {
    this.marksByID.set(m.id, m);
    m.setTimeProvider(timeProvider);
  });
  this.decorations = decorations || [];
  this.decorationsByID = /* @__PURE__ */ new Map();
  this.decorations.forEach((d) => {
    d.marks.forEach((m) => {
      if (!this.decorationsByID.has(m.id)) {
        this.decorationsByID.set(m.id, /* @__PURE__ */ new Set([d]));
      } else {
        this.decorationsByID.get(m.id).add(d);
      }
    });
  });
  let animatingMarks = /* @__PURE__ */ new Set();
  let animatingDecorations = /* @__PURE__ */ new Set();
  let updatedMarks = /* @__PURE__ */ new Set();
  this.preloadableProperties = /* @__PURE__ */ new Set();
  let visibleMarks = null;
  let visibleMarksChanged = false;
  this.setVisibleMarks = function(ids) {
    ids = Array.from(ids);
    if (ids.length == 0)
      visibleMarks = null;
    else
      visibleMarks = ids.map((id2) => this.getMarkByID(id2));
    visibleMarksChanged = true;
  };
  this.getVisibleMarks = function() {
    if (visibleMarks == null)
      return this.marks;
    return visibleMarks;
  };
  this.registerPreloadableProperty = function(attrName) {
    this.preloadableProperties.add(attrName);
  };
  this.advance = function(dt) {
    timeProvider.advance(dt);
    updatedMarks = /* @__PURE__ */ new Set();
    if (animatingMarks.size == 0 && animatingDecorations.size == 0 && !visibleMarksChanged)
      return false;
    let updatedDecorations = /* @__PURE__ */ new Set();
    for (let mark of animatingMarks) {
      if (!mark.advance()) {
        animatingMarks.delete(mark);
      } else if (this.decorationsByID.has(mark.id)) {
        this.decorationsByID.get(mark.id).forEach((d) => {
          if (!updatedDecorations.has(d)) {
            d.advance(dt);
            d.update();
            updatedDecorations.add(d);
          }
        });
      }
    }
    for (let decoration of animatingDecorations) {
      if (updatedDecorations.has(decoration))
        continue;
      if (!decoration.advance(dt))
        animatingDecorations.delete(decoration);
    }
    visibleMarksChanged = false;
    return true;
  };
  this.marksChanged = function() {
    return updatedMarks.size > 0 || visibleMarksChanged;
  };
  this.marksAnimating = function() {
    return animatingMarks.size > 0;
  };
  this.decorationsAnimating = function() {
    return animatingDecorations.size > 0;
  };
  this.animateAll = function(attrName, interpolatorMapper, duration = 1e3, curve = null) {
    if (this.preloadableProperties.has(attrName)) {
      console.warn(
        "Attempted to call animateAll on a preloadable property. You must use animatePreload or animateOne with a PreloadableAnimator."
      );
      return;
    }
    animatingMarks = new Set(this.getVisibleMarks());
    updatedMarks = new Set(this.getVisibleMarks());
    this.forEach(
      (mark, i) => mark.animate(
        attrName,
        new Animator(interpolatorMapper(mark, i), duration, curve)
      )
    );
  };
  this.animatePreload = function(attrName, finalValueMapper, duration = 1e3) {
    if (!this.preloadableProperties.has(attrName)) {
      console.warn(
        "Attempted to call animatePreload on a non-preloadable property."
      );
      return;
    }
    updatedMarks = new Set(this.getVisibleMarks());
    this.forEach(
      (mark, i) => mark.animate(
        attrName,
        new PreloadableAnimator(finalValueMapper(mark, i), duration)
      )
    );
  };
  this.animateComputed = function(attrName, interpolatorFn, duration = 1e3, curve = null) {
    let preloadable = this.preloadableProperties.has(attrName);
    this.forEach((mark, i) => {
      let newValue = mark.data(attrName);
      if (!approxEquals(newValue, mark.attributes[attrName].last()) || !approxEquals(newValue, mark.attributes[attrName].future())) {
        mark.animate(
          attrName,
          preloadable ? new PreloadableAnimator(newValue, duration) : new Animator(interpolatorFn(newValue), duration, curve)
        );
        if (!preloadable)
          animatingMarks.add(mark);
        updatedMarks.add(mark);
      }
    });
  };
  this.updateComputed = function(attrName) {
    this.forEach((mark) => {
      let attr2 = mark.attributes[attrName];
      let oldValue = attr2.last();
      attr2.compute();
      if (!approxEquals(oldValue, attr2.data())) {
        animatingMarks.add(mark);
        updatedMarks.add(mark);
      }
    });
  };
  this.animateIf = function(attrName, predicateFn, interpolatorFn, duration = 1e3, curve = null) {
    this.forEach((mark, i) => {
      if (!predicateFn(mark, i))
        return;
      animatingMarks.add(mark);
      updatedMarks.add(mark);
      mark.animate(
        attrName,
        new Animator(interpolatorFn(mark, i), duration, curve)
      );
    });
  };
  this.animateOne = function(index, attrName, animator) {
    animatingMarks.add(this.marks[index]);
    updatedMarks.add(this.marks[index]);
    this.marks[index].animate(attrName, animator);
  };
  this.setAll = function(attrName, valueFn) {
    animatingMarks = new Set(this.getVisibleMarks());
    updatedMarks = new Set(this.getVisibleMarks());
    this.forEach((mark, i) => mark.setAttr(attrName, valueFn(mark, i)));
  };
  this.setIf = function(attrName, predicateFn, valueFn) {
    this.forEach((mark, i) => {
      if (!predicateFn(mark, i))
        return;
      animatingMarks.add(mark);
      updatedMarks.add(mark);
      mark.setAttr(attrName, valueFn(mark, i));
    });
  };
  this.setOne = function(index, attrName, value) {
    animatingMarks.add(this.marks[index]);
    updatedMarks.add(this.marks[index]);
    this.marks[index].setAttr(attrName, value);
  };
  this.addDecoration = function(decoration) {
    this.decorations.push(decoration);
    for (let m of decoration.marks) {
      if (!this.decorationsByID.has(m.id)) {
        this.decorationsByID.set(m.id, /* @__PURE__ */ new Set([decoration]));
      } else {
        this.decorationsByID.get(m.id).add(decoration);
      }
    }
  };
  this.removeDecoration = function(decoration) {
    let idx = this.decorations.indexOf(decoration);
    if (idx < 0) {
      console.warn("Attempted to remove decoration that does not exist");
      return;
    }
    this.decorations.splice(idx, 1);
    for (let m of decoration.marks) {
      this.decorationsByID.get(m.id).delete(decoration);
    }
  };
  this.animateDecoration = function(decoration, attrName, animation) {
    animatingDecorations.add(decoration);
    decoration.animate(attrName, animation);
  };
  this.animateDecorationComputed = function(decoration, attrName, duration = 1e3, curve = null) {
    let newValue = decoration.data(attrName);
    if (!approxEquals(newValue, decoration.attributes[attrName].last()) || !approxEquals(newValue, decoration.attributes[attrName].future())) {
      animatingDecorations.add(decoration);
      decoration.animate(
        attrName,
        new Animator(interpolateTo(newValue), duration, curve)
      );
    }
  };
  this.updateAllDecorations = function() {
    this.decorations.forEach((d) => d.update());
  };
  this.getMarkByID = function(id2) {
    return this.marksByID.get(id2);
  };
  this.forEach = function(callbackfn) {
    this.getVisibleMarks().forEach(callbackfn);
  };
  this.map = function(mapper) {
    return this.getVisibleMarks().map(mapper);
  };
  this.filter = function(filterer) {
    return this.getVisibleMarks().filter(filterer);
  };
  this.reduce = function(reducer, initial) {
    return this.getVisibleMarks().reduce(reducer, initial);
  };
  this.updateTransform = function(attrName) {
    this.marks.forEach((m) => m.updateTransform(attrName));
  };
}
function easeInOut(t) {
  return t * t * (3 - 2 * t);
}
function interpolateTo(finalValue) {
  return {
    finalValue,
    interpolator: (initialValue, interpolant, debug = false) => {
      if (typeof initialValue != "number" || typeof finalValue != "number") {
        if (debug) {
          console.log(
            "Not a number, returning final value",
            initialValue,
            finalValue
          );
        }
        return finalValue;
      }
      if (debug) {
        console.log("Interpolating", initialValue, finalValue, interpolant);
      }
      return initialValue * (1 - Math.min(interpolant, 1)) + finalValue * Math.min(interpolant, 1);
    }
  };
}
function interpolateToFunction(finalValueFn) {
  return (initialValue, interpolant) => initialValue * (1 - Math.min(interpolant, 1)) + finalValueFn() * Math.min(interpolant, 1);
}
class Animator {
  constructor(interpolator, duration = 1e3, curve = null) {
    __publicField(this, "duration", 0);
    __publicField(this, "finalValue", null);
    __publicField(this, "interpolator", null);
    __publicField(this, "curve", null);
    this.duration = duration;
    if (interpolator.hasOwnProperty("finalValue")) {
      this.finalValue = interpolator.finalValue;
      this.interpolator = interpolator.interpolator;
    } else {
      this.finalValue = null;
      this.interpolator = interpolator;
    }
    this.curve = curve || ((x) => x);
  }
  evaluate(initialValue, dt, debug = false) {
    let t = this.curve(this.duration > 0 ? dt / this.duration : 1);
    return this.interpolator(initialValue, t, debug);
  }
}
class PreloadableAnimator extends Animator {
  constructor(finalValue, duration) {
    super(interpolateTo(finalValue), duration, easeInOut);
  }
}
function AnimationPool(callbacks, defer = false) {
  this.callbacks = callbacks;
  this.defer = defer;
  if (!this.callbacks.create || !this.callbacks.show || !this.callbacks.hide || !this.callbacks.destroy)
    console.error("Missing required callbacks for AnimationPool");
  this.pool = /* @__PURE__ */ new Map();
  this.queuedAnimations = /* @__PURE__ */ new Map();
  this._flushTimer = null;
  this._perform = function(id2, action) {
    let item = this.pool.get(id2);
    if (!item || !item.element)
      return;
    if (action == "show") {
      if (item.lastState == "visible")
        return;
      item.lastState = "entering";
      this.callbacks.show(item.element).then(
        () => {
          if (item.state == "entering") {
            item.state = "visible";
            item.lastState = "visible";
          }
        },
        () => {
        }
      );
    } else if (action == "hide") {
      if (item.lastState == "exiting" || item.lastState == "waiting")
        return;
      item.lastState = "exiting";
      this.callbacks.hide(item.element).then(
        () => {
          let item2 = this.pool.get(id2);
          if (!!item2 && item2.lastState == "exiting") {
            this.callbacks.destroy(item2.element);
            this.pool.delete(id2);
          }
        },
        () => {
        }
      );
    }
  };
  this.flush = function() {
    this._flushTimer = null;
    this.queuedAnimations.forEach((action, id2) => {
      this._perform(id2, action);
    });
    this.queuedAnimations.clear();
  };
  this._enqueue = function(id2, action) {
    let item = this.pool.get(id2);
    if (!item.element)
      return false;
    if (action == "show") {
      if (item.state == "entering" || item.state == "visible")
        return false;
      item.state = "entering";
    } else if (action == "hide") {
      if (item.state == "exiting")
        return false;
      item.state = "exiting";
    } else {
      console.error("Unknown action enqueued:", action);
    }
    if (this.defer) {
      this.queuedAnimations.set(id2, action);
      if (!this._flushTimer) {
        this._flushTimer = setTimeout(() => this.flush(), 0);
      }
    } else {
      this._perform(id2, action);
    }
    return true;
  };
  this.show = function(id2, infoCB) {
    if (!this.pool.has(id2)) {
      let info = infoCB != null ? infoCB(id2) : null;
      this.pool.set(id2, {
        element: this.callbacks.create(id2, info),
        info,
        state: "waiting",
        lastState: "waiting"
      });
    }
    return this._enqueue(id2, "show");
  };
  this.getInfo = function(id2) {
    if (!this.pool.has(id2))
      return null;
    return this.pool.get(id2).info;
  };
  this.getElement = function(id2) {
    if (!this.pool.has(id2))
      return null;
    return this.pool.get(id2).element;
  };
  this.getAll = function() {
    return new Map(this.pool);
  };
  this.getAllIDs = function() {
    return Array.from(this.pool.keys());
  };
  this.getAllVisible = function() {
    let result = /* @__PURE__ */ new Map();
    for (let [key, value] of this.pool) {
      if ((value.state == "visible" || value.state == "entering") && !!value.element)
        result.set(key, value);
    }
    return result;
  };
  this.getAllVisibleIDs = function() {
    return Array.from(this.pool.keys()).filter(
      (key) => (this.pool.get(key).state == "visible" || this.pool.get(key).state == "entering") && !!this.pool.get(key).element
    );
  };
  this.hide = function(id2) {
    if (!this.pool.has(id2)) {
      return;
    }
    return this._enqueue(id2, "hide");
  };
}
if (!("hypot" in Math))
  Math.hypot = function(x, y) {
    return Math.sqrt(x * x + y * y);
  };
function DecorationStarGraph(centerMark, neighborMarks, outlineZIndex = 0, lineZIndex = 0) {
  this.centerMark = centerMark;
  this.neighborMarks = neighborMarks;
  this.isOn = false;
  this.outlineDecoration = new Decoration("outline", [this.centerMark], {
    r: {
      valueFn: () => this.isOn ? this.centerMark.attr("r") + 3 : 0
    },
    color: "007bff",
    lineWidth: 1,
    zIndex: outlineZIndex
  });
  this._makeNeighborDecoration = function(mark) {
    let dec = new Decoration("line", [this.centerMark, mark], {
      color: "007bff",
      lineWidth: 0.5,
      alpha: { valueFn: () => this.isOn ? 1 : 0 },
      x2: {
        valueFn: () => this.isOn ? mark.attr("x") : this.centerMark.attr("x")
      },
      y2: {
        valueFn: () => this.isOn ? mark.attr("y") : this.centerMark.attr("y")
      },
      zIndex: lineZIndex
    });
    return dec;
  };
  this.neighborDecorations = this.neighborMarks.map(
    (mark) => this._makeNeighborDecoration(mark)
  );
  this.getDecorations = function() {
    return [this.outlineDecoration, ...this.neighborDecorations];
  };
  this._updateNeighborDecoration = function(markSet, d, duration, curve) {
    markSet.animateDecorationComputed(d, "x2", duration, curve);
    markSet.animateDecorationComputed(d, "y2", duration, curve);
    markSet.animateDecorationComputed(d, "alpha", duration, curve);
  };
  this.enter = function(markSet, duration = 300, curve = null) {
    this.isOn = true;
    markSet.animateDecoration(
      this.outlineDecoration,
      "r",
      new Animator(
        interpolateTo(this.outlineDecoration.data("r")),
        duration,
        curve
      )
    );
    this.neighborDecorations.forEach(
      (d) => this._updateNeighborDecoration(markSet, d, duration, curve)
    );
  };
  this.exit = function(markSet, duration = 300, curve = null) {
    this.isOn = false;
    markSet.animateDecoration(
      this.outlineDecoration,
      "r",
      new Animator(interpolateTo(0), duration, curve)
    );
    this.neighborDecorations.forEach(
      (d) => this._updateNeighborDecoration(markSet, d, duration, curve)
    );
  };
  this.updateNeighborMarks = function(newMarks, markSet, duration = 300, curve = null) {
    let newMarkSet = new Set(newMarks);
    this.neighborMarks.forEach((m, i) => {
      if (!newMarkSet.has(m)) {
        let decoration = this.neighborDecorations[i];
        markSet.removeDecoration(decoration);
      }
    });
    let newDecorations = [];
    newMarks.forEach((m, i) => {
      let idx = this.neighborMarks.indexOf(m);
      if (idx >= 0) {
        newDecorations.push(this.neighborDecorations[idx]);
      } else {
        let dec = this._makeNeighborDecoration(m);
        markSet.addDecoration(dec);
        this._updateNeighborDecoration(markSet, dec, duration, curve);
        newDecorations.push(dec);
      }
    });
    this.neighborMarks = newMarks;
    this.neighborDecorations = newDecorations;
  };
}
class WideningLineDecoration extends Decoration {
  constructor(mark, frame2, lineWidthFn, lineAlphaFn) {
    super("wideningLine", [mark], {
      x2: {
        value: 0,
        transform: mark.attributes["x"].transform
      },
      y2: {
        value: 0,
        transform: mark.attributes["y"].transform
      },
      lineWidth: {
        valueFn: () => lineWidthFn(mark)
      },
      alpha: {
        valueFn: () => mark.attr("alpha") * lineAlphaFn(mark)
      },
      color: {
        valueFn: () => mark.attr("fillStyle")
      }
    });
    __publicField(this, "mark");
    __publicField(this, "dataItem");
    __publicField(this, "frame1");
    __publicField(this, "frame2");
    this.frame1 = frame2;
    this.frame2 = frame2;
    this.mark = mark;
    this.attributes["x2"].set(() => this._getX2());
    this.attributes["x2"].compute();
    this.attributes["y2"].set(() => this._getY2());
    this.attributes["y2"].compute();
  }
  _getX() {
    return this.frame1.get(this.mark.id, "x", this.mark.attr("x"));
  }
  _getY() {
    return this.frame1.get(this.mark.id, "y", this.mark.attr("y"));
  }
  _getX2() {
    return this.frame2.get(this.mark.id, "x", this.mark.attr("x"));
  }
  _getY2() {
    return this.frame2.get(this.mark.id, "y", this.mark.attr("y"));
  }
  animateToFrames(markSet, frame1, frame2, duration = 300) {
    if (this.frame1 !== frame1) {
      this.frame1 = frame1;
      markSet.animateDecorationComputed(this, "x", duration, easeInOut);
      markSet.animateDecorationComputed(this, "y", duration, easeInOut);
    }
    if (this.frame2 !== frame2) {
      this.frame2 = frame2;
      markSet.animateDecorationComputed(this, "x2", duration, easeInOut);
      markSet.animateDecorationComputed(this, "y2", duration, easeInOut);
    }
  }
  updateLineAppearance(markSet, duration = 300) {
    markSet.animateDecorationComputed(this, "lineWidth", duration, easeInOut);
    markSet.animateDecorationComputed(this, "alpha", duration, easeInOut);
    markSet.animateDecorationComputed(this, "color", duration, easeInOut);
  }
}
const frameDuration = 4e3;
const previewAnimDuration = 1e3;
const defaultDuration = 500;
const decorationDuration = 300;
const SelectionOutlineZIndex = 20;
const StarGraphZIndex = 15;
const HoverTextPriority = 150;
const SelectionTextPriority = 100;
const NeighborTextPriority = 50;
function instance$k($$self, $$props, $$invalidate) {
  let { data = null } = $$props;
  let { colorScale = null } = $$props;
  let { xScale = null } = $$props;
  let { yScale = null } = $$props;
  let { pointRadius = 1 } = $$props;
  let { hoveredID = null } = $$props;
  let { selectedIDs = [] } = $$props;
  let { alignedIDs = [] } = $$props;
  let { tentativeSelectedIDs = [] } = $$props;
  let { idsOfInterest = [] } = $$props;
  let { frame: frame2 = null } = $$props;
  let { previewFrame = null } = $$props;
  let { previewInfo = null } = $$props;
  let { previewProgress = 0 } = $$props;
  let { thumbnail = false } = $$props;
  let { marks = null } = $$props;
  let { colorMap } = $$props;
  let { filterIDs = [] } = $$props;
  let { colorFormat = "hex" } = $$props;
  let { numNeighbors = 10 } = $$props;
  let { highlightFocusedPoints = true } = $$props;
  let { showPreviewLines = true } = $$props;
  let { numPreviewPoints = 100 } = $$props;
  function initializeMarks() {
    $$invalidate(3, marks = new MarkSet(data.map((id2) => {
      let colorID = colorMap.id(id2, { type: "mark", id: id2 });
      return new Mark(
        id2,
        {
          x: {
            valueFn: _getX,
            transform: (v2) => xScale(v2),
            lazy: true
          },
          y: {
            valueFn: _getY,
            transform: (v2) => yScale(v2),
            lazy: true
          },
          halo: 0,
          fillStyle: {
            valueFn: () => frame2.get(id2, "color", 0),
            transform: _transformColor,
            cached: true
          },
          alpha: { valueFn: _getPointAlpha, lazy: true },
          r: { valueFn: _getPointRadius, lazy: true },
          visible: frame2.has(id2) || false,
          colorID,
          hoverText: frame2.get(id2, "hoverText")
        }
      );
    })));
    marks.registerPreloadableProperty("x");
    marks.registerPreloadableProperty("y");
    marks.registerPreloadableProperty("r");
    marks.registerPreloadableProperty("alpha");
    setupDecorationPools();
    $$invalidate(27, previousFrame = null);
  }
  function destroyMarks() {
    $$invalidate(3, marks = null);
  }
  onDestroy(() => {
    destroyMarks();
    $$invalidate(0, data = null);
  });
  let highlightedPoints = /* @__PURE__ */ new Set();
  let previewLinePoints = /* @__PURE__ */ new Set();
  let strongestPreviewPoints = [];
  function _getX(mark) {
    let id2 = mark.id;
    let base = frame2.get(id2, "x", mark.attributes.x.last() || 0);
    if (previewFrame != null && previewProgress > 0) {
      let dest = previewFrame.get(id2, "x", base);
      return base * (1 - previewProgress) + dest * previewProgress;
    }
    return base;
  }
  function _getY(mark) {
    let id2 = mark.id;
    let base = frame2.get(id2, "y", mark.attributes.y.last() || 0);
    if (previewFrame != null && previewProgress > 0) {
      let dest = previewFrame.get(id2, "y", base);
      return base * (1 - previewProgress) + dest * previewProgress;
    }
    return base;
  }
  let oldColorScale = null;
  function _transformColor(c2) {
    let color2 = color$2(colorScale(c2));
    if (color2 == null)
      return null;
    if (colorFormat == "hex")
      return color2.formatHex();
    else if (colorFormat == "rgb")
      return color2.formatRgb();
    else if (colorFormat == "rgbArray") {
      color2 = color2.rgb();
      return [color2.r / 255, color2.g / 255, color2.b / 255];
    }
    return c2;
  }
  function _getPointAlpha(mark) {
    let alpha = frame2.get(mark.id, "alpha") || 0;
    if (highlightFocusedPoints && highlightedPoints.size != 0 && !highlightedPoints.has(mark.id))
      alpha *= 0.3;
    return alpha;
  }
  function _getPointRadius(mark) {
    let r = frame2.get(mark.id, "r") || 0;
    if (highlightFocusedPoints) {
      if (highlightedPoints.size != 0 && !highlightedPoints.has(mark.id))
        r *= 0.7;
      if (selectedIDs.includes(mark.id))
        r *= 1.5;
    }
    return r * pointRadius;
  }
  function _getLineAlpha(mark) {
    if (filter2.size > 0 && !filter2.has(mark.id))
      return 0;
    if (previewLinePoints.size > 0 && !previewLinePoints.has(mark.id))
      return 0;
    if (previewInfo == null)
      return 0;
    return previewInfo.get(mark.id).lineAlpha || 0;
  }
  function _getLineWidth(mark) {
    if (filter2.size > 0 && !filter2.has(mark.id))
      return 0;
    if (previewLinePoints.size > 0 && !previewLinePoints.has(mark.id))
      return 0;
    if (previewInfo == null)
      return 0;
    return previewInfo.get(mark.id).lineWidth || 0;
  }
  function _getLabelPriority(mark) {
    if (mark.id == hoveredID)
      return HoverTextPriority;
    else if (selectedIDs.includes(mark.id))
      return SelectionTextPriority;
    else if (highlightedPoints.has(mark.id))
      return NeighborTextPriority;
    return null;
  }
  let previousFrame = null;
  function setFrame2(oldFrame, newFrame, animated = true) {
    $$invalidate(2, previewProgress = 0);
    if (animated) {
      marks.forEach((mark) => {
        if (!oldFrame || !oldFrame.has(mark.id) && newFrame.has(mark.id)) {
          mark.attributes.x.compute();
          mark.attributes.y.compute();
          mark.attributes.fillStyle.compute();
        }
      });
      marks.setAll("visible", (mark) => !!newFrame && newFrame.has(mark.id) || false);
      marks.animateComputed("x", interpolateTo, frameDuration, easeInOut);
      marks.animateComputed("y", interpolateTo, frameDuration, easeInOut);
      marks.animateComputed("fillStyle", interpolateTo, frameDuration, easeInOut);
      marks.animateComputed("r", interpolateTo, frameDuration, easeInOut);
      marks.animateComputed("alpha", interpolateTo, frameDuration, easeInOut);
    }
    starGraphPool.getAllVisibleIDs().forEach((id2) => {
      updateStarGraph(id2, animated);
    });
  }
  function animateDatasetUpdate() {
    marks.animateComputed("x", interpolateTo, frameDuration, easeInOut);
    marks.animateComputed("y", interpolateTo, frameDuration, easeInOut);
    marks.animateComputed("r", interpolateTo, defaultDuration, easeInOut);
    marks.animateComputed("alpha", interpolateTo, defaultDuration, easeInOut);
    marks.animateComputed("fillStyle", interpolateTo, defaultDuration, easeInOut);
  }
  let oldPreviewProgress = 0;
  let oldPreviewFrame = null;
  function updateStrongestPreviewPoints(filterSet, prevInfo) {
    if (!prevInfo) {
      strongestPreviewPoints = [];
      return;
    }
    strongestPreviewPoints = prevInfo.getTopK(numPreviewPoints, filterSet.size > 0 ? filterSet : null);
  }
  function updatePreviewLines(filterSet, interestIDs, info) {
    if (!marks || !previewLinePool)
      return;
    if (interestIDs.size > 0)
      previewLinePoints = new Set(interestIDs);
    else {
      updateStrongestPreviewPoints(filterSet, info);
      previewLinePoints = new Set(strongestPreviewPoints);
    }
    if (!!info && showPreviewLines) {
      marks.forEach((mark) => {
        if (_getLineAlpha(mark) <= 0.01) {
          previewLinePool.hide(mark.id);
        } else {
          previewLinePool.show(mark.id);
        }
      });
      previewLinePool.getAllVisible().forEach((item) => {
        let dec = item.element;
        dec.animateToFrames(marks, frame2, previewFrame || frame2, previewAnimDuration);
        dec.updateLineAppearance(marks, previewAnimDuration);
      });
    } else {
      previewLinePool.getAllVisibleIDs().forEach((id2) => {
        previewLinePool.hide(id2);
      });
    }
  }
  let filter2 = /* @__PURE__ */ new Set();
  let prevFilter = null;
  var prevHoverID = null;
  var prevSelectedIDs = [];
  var prevAlignedIDs = [];
  var prevTentativeSelectedIDs = [];
  let starGraphPool;
  let previewLinePool;
  let selectionDecorationPool;
  let tentativeSelectionDecorationPool;
  let alignDecorationPool;
  let labelPool;
  function selectElement(element, multi) {
    if (!element) {
      $$invalidate(1, selectedIDs = []);
    } else if (element.type == "mark") {
      let selection2 = new Set(selectedIDs);
      if (multi) {
        if (selection2.has(element.id))
          selection2.delete(element.id);
        else
          selection2.add(element.id);
      } else {
        selection2 = /* @__PURE__ */ new Set([element.id]);
      }
      $$invalidate(1, selectedIDs = Array.from(selection2));
    } else if (element.type == "halo") {
      $$invalidate(1, selectedIDs = element.ids);
    }
    return selectedIDs;
  }
  function updateSelectionState(oldHoveredID, newHoveredID, oldSelectedIDs, newSelectedIDs, oldAlignedIDs, newAlignedIDs) {
    oldSelectedIDs.forEach((id2) => selectionDecorationPool.hide(id2));
    newSelectedIDs.forEach((id2) => selectionDecorationPool.show(id2));
    updateAlignmentDecorations();
    updateStarGraphVisibility();
    updateLabelVisibility();
  }
  let oldHighlightFocusedPoints = true;
  let oldShowPreviewLines = true;
  function setupDecorationPools() {
    $$invalidate(36, previewLinePool = new AnimationPool({
      create: (nodeID) => {
        let mark = marks.getMarkByID(nodeID);
        if (!mark)
          return null;
        let dec = new WideningLineDecoration(mark, frame2, _getLineWidth, _getLineAlpha);
        marks.addDecoration(dec);
        return dec;
      },
      show: (element) => {
        element.animateToFrames(marks, frame2, previewFrame || frame2, previewAnimDuration);
        element.updateLineAppearance(marks, previewAnimDuration);
        return new Promise((resolve2) => setTimeout(resolve2, previewAnimDuration));
      },
      hide: (element) => {
        element.animateToFrames(marks, frame2, frame2, previewAnimDuration);
        element.updateLineAppearance(marks, previewAnimDuration);
        return new Promise((resolve2) => setTimeout(resolve2, previewAnimDuration));
      },
      destroy: (element) => {
        marks.removeDecoration(element);
      }
    }));
    $$invalidate(35, starGraphPool = new AnimationPool(
      {
        create: (nodeID, info) => {
          let graph = new DecorationStarGraph(marks.getMarkByID(nodeID), info.linkedNodeIDs.map((id2) => marks.getMarkByID(id2)).filter((m) => !!m), SelectionOutlineZIndex, StarGraphZIndex);
          info.highlightedNodes = [nodeID, ...info.linkedNodeIDs];
          info.transient = info.transient || false;
          graph.getDecorations().forEach((d) => marks.addDecoration(d));
          return graph;
        },
        show: (element) => {
          element.enter(marks, decorationDuration);
          return new Promise((resolve2) => setTimeout(resolve2, decorationDuration));
        },
        hide: (element) => {
          element.exit(marks, decorationDuration);
          return new Promise((resolve2) => setTimeout(resolve2, decorationDuration));
        },
        destroy: (element) => {
          element.getDecorations().forEach((d) => marks.removeDecoration(d));
        }
      },
      true
    ));
    selectionDecorationPool = new AnimationPool(
      {
        create: (nodeID) => {
          let mark = marks.getMarkByID(nodeID);
          if (!mark)
            return null;
          return new Decoration(
            "outline",
            [mark],
            {
              r: { valueFn: () => mark.attr("r") + 3 },
              color: "007bff",
              lineWidth: 2,
              zIndex: SelectionOutlineZIndex
            }
          );
        },
        show: async (element) => marks.addDecoration(element),
        hide: async (element) => marks.removeDecoration(element),
        destroy: () => {
        }
      },
      true
    );
    tentativeSelectionDecorationPool = new AnimationPool(
      {
        create: (nodeID) => {
          let mark = marks.getMarkByID(nodeID);
          if (!mark)
            return null;
          return new Decoration(
            "outline",
            [mark],
            {
              r: { valueFn: () => mark.attr("r") + 3 },
              color: "007bff",
              lineWidth: 2,
              zIndex: SelectionOutlineZIndex,
              pulseDuration: 2
            }
          );
        },
        show: async (element) => marks.addDecoration(element),
        hide: async (element) => marks.removeDecoration(element),
        destroy: () => {
        }
      },
      true
    );
    alignDecorationPool = new AnimationPool(
      {
        create: (nodeID) => {
          let mark = marks.getMarkByID(nodeID);
          if (!mark)
            return null;
          return new Decoration(
            "outline",
            [mark],
            {
              r: { valueFn: () => mark.attr("r") + 3 },
              color: "#aaaaaa",
              lineWidth: 2,
              zIndex: SelectionOutlineZIndex
            }
          );
        },
        show: async (element) => marks.addDecoration(element),
        hide: async (element) => marks.removeDecoration(element),
        destroy: () => {
        }
      },
      true
    );
    labelPool = new AnimationPool(
      {
        create: (nodeID) => {
          let mark = marks.getMarkByID(nodeID);
          let dataItem = frame2.byID(nodeID);
          if (!mark || !dataItem || !dataItem.label)
            return null;
          if (!!dataItem.label.sheet) {
            return new Decoration(
              "image",
              [mark],
              {
                color: null,
                labelInfo: dataItem.label,
                priority: { valueFn: () => _getLabelPriority(mark) },
                alpha: 0,
                maxDim: 50
                // maximum width or height
              }
            );
          } else if (!!dataItem.label.text) {
            return new Decoration(
              "text",
              [mark],
              {
                color: "black",
                text: dataItem.label.text,
                priority: { valueFn: () => _getLabelPriority(mark) },
                textScale: 1,
                alpha: 0
              }
            );
          }
        },
        show: async (element) => marks.addDecoration(element),
        hide: async (element) => marks.removeDecoration(element),
        destroy: () => {
        }
      },
      true
    );
  }
  function setStarGraphTransient(nodeID, transient) {
    let info = starGraphPool.getInfo(nodeID);
    if (!!info)
      info.transient = transient;
  }
  let oldNeighbors = 0;
  function updateStarGraph(nodeID, animated = true) {
    let info = starGraphPool.getInfo(nodeID);
    let element = starGraphPool.getElement(nodeID);
    if (!element) {
      showStarGraph(nodeID);
      return;
    }
    let item = frame2.byID(nodeID);
    if (item) {
      let newNeighbors = (item.highlightIndexes || []).slice(0, numNeighbors);
      info.highlightedNodes = [info.highlightedNodes[0], ...newNeighbors];
      element.updateNeighborMarks(newNeighbors.map((id2) => marks.getMarkByID(id2)).filter((m) => !!m), marks, animated ? decorationDuration : 0);
    } else {
      starGraphPool.hide(nodeID);
    }
  }
  function showStarGraph(id2, transient = false) {
    setStarGraphTransient(id2, transient);
    starGraphPool.show(id2, () => {
      let item = frame2.byID(id2);
      if (!item)
        return;
      let neighbors = (item.highlightIndexes || []).slice(0, numNeighbors);
      return { linkedNodeIDs: neighbors, transient };
    });
  }
  function updateStarGraphVisibility() {
    if (!starGraphPool)
      return;
    let visibleGraphs = /* @__PURE__ */ new Set();
    let transientID = null;
    if (!!hoveredID) {
      visibleGraphs.add(hoveredID);
      transientID = hoveredID;
    }
    if (selectedIDs.length == 1) {
      let selected = selectedIDs[0];
      setStarGraphTransient(selected, false);
      visibleGraphs.add(selected);
      if (transientID == selected)
        transientID = null;
    }
    starGraphPool.getAllIDs().forEach((key) => {
      if (!visibleGraphs.has(key))
        starGraphPool.hide(key);
    });
    visibleGraphs.forEach((key) => {
      showStarGraph(key, key == transientID);
    });
  }
  function updateAlignmentDecorations() {
    let idsToShow = /* @__PURE__ */ new Set();
    alignedIDs.forEach((id2) => idsToShow.add(id2));
    selectedIDs.forEach((id2) => idsToShow.delete(id2));
    alignDecorationPool.getAllVisibleIDs().forEach((id2) => {
      alignDecorationPool.hide(id2);
    });
    idsToShow.forEach((id2) => alignDecorationPool.show(id2));
  }
  function updateLabelVisibility() {
    let labeledPoints;
    if (selectedIDs.length > 10) {
      labeledPoints = new Set(selectedIDs);
    } else {
      labeledPoints = new Set(highlightedPoints);
    }
    if (!!hoveredID)
      labeledPoints.add(hoveredID);
    labelPool.getAllIDs().forEach((key) => {
      if (!labeledPoints.has(key))
        labelPool.hide(key);
    });
    labeledPoints.forEach((id2) => labelPool.show(id2));
  }
  function updateTentativeSelectionVisibility(oldTentativeIDs, newTentativeIDs) {
    tentativeSelectionDecorationPool.getAllIDs().forEach((id2) => {
      tentativeSelectionDecorationPool.hide(id2);
    });
    newTentativeIDs.forEach((id2) => tentativeSelectionDecorationPool.show(id2));
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("colorScale" in $$props2)
      $$invalidate(4, colorScale = $$props2.colorScale);
    if ("xScale" in $$props2)
      $$invalidate(5, xScale = $$props2.xScale);
    if ("yScale" in $$props2)
      $$invalidate(6, yScale = $$props2.yScale);
    if ("pointRadius" in $$props2)
      $$invalidate(7, pointRadius = $$props2.pointRadius);
    if ("hoveredID" in $$props2)
      $$invalidate(8, hoveredID = $$props2.hoveredID);
    if ("selectedIDs" in $$props2)
      $$invalidate(1, selectedIDs = $$props2.selectedIDs);
    if ("alignedIDs" in $$props2)
      $$invalidate(9, alignedIDs = $$props2.alignedIDs);
    if ("tentativeSelectedIDs" in $$props2)
      $$invalidate(10, tentativeSelectedIDs = $$props2.tentativeSelectedIDs);
    if ("idsOfInterest" in $$props2)
      $$invalidate(11, idsOfInterest = $$props2.idsOfInterest);
    if ("frame" in $$props2)
      $$invalidate(12, frame2 = $$props2.frame);
    if ("previewFrame" in $$props2)
      $$invalidate(13, previewFrame = $$props2.previewFrame);
    if ("previewInfo" in $$props2)
      $$invalidate(14, previewInfo = $$props2.previewInfo);
    if ("previewProgress" in $$props2)
      $$invalidate(2, previewProgress = $$props2.previewProgress);
    if ("thumbnail" in $$props2)
      $$invalidate(15, thumbnail = $$props2.thumbnail);
    if ("marks" in $$props2)
      $$invalidate(3, marks = $$props2.marks);
    if ("colorMap" in $$props2)
      $$invalidate(16, colorMap = $$props2.colorMap);
    if ("filterIDs" in $$props2)
      $$invalidate(17, filterIDs = $$props2.filterIDs);
    if ("colorFormat" in $$props2)
      $$invalidate(18, colorFormat = $$props2.colorFormat);
    if ("numNeighbors" in $$props2)
      $$invalidate(19, numNeighbors = $$props2.numNeighbors);
    if ("highlightFocusedPoints" in $$props2)
      $$invalidate(20, highlightFocusedPoints = $$props2.highlightFocusedPoints);
    if ("showPreviewLines" in $$props2)
      $$invalidate(21, showPreviewLines = $$props2.showPreviewLines);
    if ("numPreviewPoints" in $$props2)
      $$invalidate(22, numPreviewPoints = $$props2.numPreviewPoints);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*data, colorScale, xScale, yScale, colorMap*/
    65649) {
      if (!!data && !!colorScale && !!xScale && !!yScale && !!colorMap) {
        initializeMarks();
      }
    }
    if ($$self.$$.dirty[0] & /*marks, colorScale, oldColorScale*/
    67108888) {
      if (!!marks && colorScale !== oldColorScale) {
        marks.forEach((mark) => mark.updateTransform("fillStyle"));
        $$invalidate(26, oldColorScale = colorScale);
      }
    }
    if ($$self.$$.dirty[0] & /*filterIDs*/
    131072) {
      $$invalidate(30, filter2 = new Set(filterIDs));
    }
    if ($$self.$$.dirty[0] & /*marks, previousFrame, frame, thumbnail, filter, idsOfInterest, previewInfo*/
    1208014856) {
      if (!!marks && previousFrame !== frame2) {
        setFrame2(previousFrame, frame2, !thumbnail && previousFrame != null);
        if (!thumbnail)
          updatePreviewLines(filter2, idsOfInterest, previewInfo);
        $$invalidate(27, previousFrame = frame2);
      }
    }
    if ($$self.$$.dirty[0] & /*oldPreviewFrame, previewFrame, previewProgress, marks*/
    536879116) {
      if (oldPreviewFrame !== previewFrame) {
        if (previewProgress != 0) {
          if (previewFrame == null)
            $$invalidate(2, previewProgress = 0);
          marks.animateComputed("x", interpolateTo, frameDuration, easeInOut);
          marks.animateComputed("y", interpolateTo, frameDuration, easeInOut);
          $$invalidate(28, oldPreviewProgress = previewProgress);
        }
        $$invalidate(29, oldPreviewFrame = previewFrame);
      }
    }
    if ($$self.$$.dirty[0] & /*previewFrame, frame, oldPreviewProgress, previewProgress, marks*/
    268447756) {
      if (previewFrame != null && previewFrame !== frame2 && oldPreviewProgress != previewProgress) {
        marks.updateComputed("x");
        marks.updateComputed("y");
        $$invalidate(28, oldPreviewProgress = previewProgress);
      }
    }
    if ($$self.$$.dirty[0] & /*data, marks, filter, idsOfInterest, previewInfo*/
    1073760265 | $$self.$$.dirty[1] & /*previewLinePool*/
    32) {
      if (!!data && !!marks && !!previewLinePool) {
        updatePreviewLines(filter2, idsOfInterest, previewInfo);
      }
    }
    if ($$self.$$.dirty[0] & /*filter, marks, highlightFocusedPoints, previewInfo, idsOfInterest*/
    1074808840 | $$self.$$.dirty[1] & /*prevFilter*/
    1) {
      if (prevFilter !== filter2) {
        if (prevFilter != null && !!marks) {
          marks.setVisibleMarks(filter2);
          if (highlightFocusedPoints) {
            marks.animateComputed("r", interpolateTo, defaultDuration);
            marks.animateComputed("alpha", interpolateTo, defaultDuration);
          } else {
            marks.updateComputed("x");
            marks.updateComputed("y");
            marks.updateComputed("r");
            marks.updateComputed("alpha");
            marks.updateComputed("fillStyle");
          }
        }
        if (previewInfo != null) {
          updatePreviewLines(filter2, idsOfInterest, previewInfo);
        }
        $$invalidate(31, prevFilter = filter2);
      }
    }
    if ($$self.$$.dirty[0] & /*marks, hoveredID, selectedIDs, alignedIDs*/
    778 | $$self.$$.dirty[1] & /*prevHoverID, prevSelectedIDs, prevAlignedIDs*/
    14) {
      if (!!marks && (prevHoverID !== hoveredID || prevSelectedIDs !== selectedIDs || prevAlignedIDs !== alignedIDs)) {
        updateSelectionState(prevHoverID, hoveredID, prevSelectedIDs, selectedIDs);
        $$invalidate(32, prevHoverID = hoveredID);
        $$invalidate(33, prevSelectedIDs = selectedIDs);
        $$invalidate(34, prevAlignedIDs = alignedIDs);
      }
    }
    if ($$self.$$.dirty[0] & /*marks, tentativeSelectedIDs*/
    1032) {
      if (!!marks && prevTentativeSelectedIDs != tentativeSelectedIDs) {
        updateTentativeSelectionVisibility(prevTentativeSelectedIDs, tentativeSelectedIDs);
      }
    }
    if ($$self.$$.dirty[0] & /*marks, selectedIDs, frame, numNeighbors, highlightFocusedPoints*/
    1576970) {
      if (!!marks) {
        highlightedPoints = new Set(selectedIDs.map((id2) => {
          return [id2, ...frame2.get(id2, "highlightIndexes").slice(0, numNeighbors)];
        }).flat());
        if (highlightFocusedPoints) {
          marks.animateComputed("r", interpolateTo, defaultDuration);
          marks.animateComputed("alpha", interpolateTo, defaultDuration);
        }
        updateLabelVisibility();
      }
    }
    if ($$self.$$.dirty[0] & /*highlightFocusedPoints, marks*/
    1048584 | $$self.$$.dirty[1] & /*oldHighlightFocusedPoints*/
    64) {
      if (oldHighlightFocusedPoints != highlightFocusedPoints) {
        if (!!marks) {
          marks.updateComputed("r");
          marks.updateComputed("alpha");
        }
        $$invalidate(37, oldHighlightFocusedPoints = highlightFocusedPoints);
      }
    }
    if ($$self.$$.dirty[0] & /*showPreviewLines, previewInfo, filter, idsOfInterest*/
    1075857408 | $$self.$$.dirty[1] & /*oldShowPreviewLines*/
    128) {
      if (oldShowPreviewLines != showPreviewLines && !!previewInfo) {
        updatePreviewLines(filter2, idsOfInterest, previewInfo);
        $$invalidate(38, oldShowPreviewLines = showPreviewLines);
      }
    }
    if ($$self.$$.dirty[0] & /*numNeighbors*/
    524288 | $$self.$$.dirty[1] & /*oldNeighbors, starGraphPool*/
    272) {
      if (oldNeighbors != numNeighbors) {
        if (!!starGraphPool) {
          starGraphPool.getAllVisibleIDs().forEach((id2) => {
            updateStarGraph(id2);
          });
        }
        $$invalidate(39, oldNeighbors = numNeighbors);
      }
    }
  };
  return [
    data,
    selectedIDs,
    previewProgress,
    marks,
    colorScale,
    xScale,
    yScale,
    pointRadius,
    hoveredID,
    alignedIDs,
    tentativeSelectedIDs,
    idsOfInterest,
    frame2,
    previewFrame,
    previewInfo,
    thumbnail,
    colorMap,
    filterIDs,
    colorFormat,
    numNeighbors,
    highlightFocusedPoints,
    showPreviewLines,
    numPreviewPoints,
    destroyMarks,
    animateDatasetUpdate,
    selectElement,
    oldColorScale,
    previousFrame,
    oldPreviewProgress,
    oldPreviewFrame,
    filter2,
    prevFilter,
    prevHoverID,
    prevSelectedIDs,
    prevAlignedIDs,
    starGraphPool,
    previewLinePool,
    oldHighlightFocusedPoints,
    oldShowPreviewLines,
    oldNeighbors
  ];
}
class ScatterplotState extends SvelteComponent {
  constructor(options) {
    super();
    init$2(
      this,
      options,
      instance$k,
      null,
      safe_not_equal,
      {
        data: 0,
        colorScale: 4,
        xScale: 5,
        yScale: 6,
        pointRadius: 7,
        hoveredID: 8,
        selectedIDs: 1,
        alignedIDs: 9,
        tentativeSelectedIDs: 10,
        idsOfInterest: 11,
        frame: 12,
        previewFrame: 13,
        previewInfo: 14,
        previewProgress: 2,
        thumbnail: 15,
        marks: 3,
        colorMap: 16,
        filterIDs: 17,
        colorFormat: 18,
        numNeighbors: 19,
        highlightFocusedPoints: 20,
        showPreviewLines: 21,
        numPreviewPoints: 22,
        destroyMarks: 23,
        animateDatasetUpdate: 24,
        selectElement: 25
      },
      null,
      [-1, -1, -1]
    );
  }
  get data() {
    return this.$$.ctx[0];
  }
  set data(data) {
    this.$$set({ data });
    flush();
  }
  get colorScale() {
    return this.$$.ctx[4];
  }
  set colorScale(colorScale) {
    this.$$set({ colorScale });
    flush();
  }
  get xScale() {
    return this.$$.ctx[5];
  }
  set xScale(xScale) {
    this.$$set({ xScale });
    flush();
  }
  get yScale() {
    return this.$$.ctx[6];
  }
  set yScale(yScale) {
    this.$$set({ yScale });
    flush();
  }
  get pointRadius() {
    return this.$$.ctx[7];
  }
  set pointRadius(pointRadius) {
    this.$$set({ pointRadius });
    flush();
  }
  get hoveredID() {
    return this.$$.ctx[8];
  }
  set hoveredID(hoveredID) {
    this.$$set({ hoveredID });
    flush();
  }
  get selectedIDs() {
    return this.$$.ctx[1];
  }
  set selectedIDs(selectedIDs) {
    this.$$set({ selectedIDs });
    flush();
  }
  get alignedIDs() {
    return this.$$.ctx[9];
  }
  set alignedIDs(alignedIDs) {
    this.$$set({ alignedIDs });
    flush();
  }
  get tentativeSelectedIDs() {
    return this.$$.ctx[10];
  }
  set tentativeSelectedIDs(tentativeSelectedIDs) {
    this.$$set({ tentativeSelectedIDs });
    flush();
  }
  get idsOfInterest() {
    return this.$$.ctx[11];
  }
  set idsOfInterest(idsOfInterest) {
    this.$$set({ idsOfInterest });
    flush();
  }
  get frame() {
    return this.$$.ctx[12];
  }
  set frame(frame2) {
    this.$$set({ frame: frame2 });
    flush();
  }
  get previewFrame() {
    return this.$$.ctx[13];
  }
  set previewFrame(previewFrame) {
    this.$$set({ previewFrame });
    flush();
  }
  get previewInfo() {
    return this.$$.ctx[14];
  }
  set previewInfo(previewInfo) {
    this.$$set({ previewInfo });
    flush();
  }
  get previewProgress() {
    return this.$$.ctx[2];
  }
  set previewProgress(previewProgress) {
    this.$$set({ previewProgress });
    flush();
  }
  get thumbnail() {
    return this.$$.ctx[15];
  }
  set thumbnail(thumbnail) {
    this.$$set({ thumbnail });
    flush();
  }
  get marks() {
    return this.$$.ctx[3];
  }
  set marks(marks) {
    this.$$set({ marks });
    flush();
  }
  get colorMap() {
    return this.$$.ctx[16];
  }
  set colorMap(colorMap) {
    this.$$set({ colorMap });
    flush();
  }
  get filterIDs() {
    return this.$$.ctx[17];
  }
  set filterIDs(filterIDs) {
    this.$$set({ filterIDs });
    flush();
  }
  get colorFormat() {
    return this.$$.ctx[18];
  }
  set colorFormat(colorFormat) {
    this.$$set({ colorFormat });
    flush();
  }
  get numNeighbors() {
    return this.$$.ctx[19];
  }
  set numNeighbors(numNeighbors) {
    this.$$set({ numNeighbors });
    flush();
  }
  get highlightFocusedPoints() {
    return this.$$.ctx[20];
  }
  set highlightFocusedPoints(highlightFocusedPoints) {
    this.$$set({ highlightFocusedPoints });
    flush();
  }
  get showPreviewLines() {
    return this.$$.ctx[21];
  }
  set showPreviewLines(showPreviewLines) {
    this.$$set({ showPreviewLines });
    flush();
  }
  get numPreviewPoints() {
    return this.$$.ctx[22];
  }
  set numPreviewPoints(numPreviewPoints) {
    this.$$set({ numPreviewPoints });
    flush();
  }
  get destroyMarks() {
    return this.$$.ctx[23];
  }
  get animateDatasetUpdate() {
    return this.$$.ctx[24];
  }
  get selectElement() {
    return this.$$.ctx[25];
  }
}
const ZoomAnimationDuration = 1e3;
const ZoomBoxPadding = 50;
function Scales(xDomain, yDomain, xRange, yRange, padding = 0.5, aspect = true) {
  if (aspect) {
    let xScale = (xRange[1] - xRange[0]) / (xDomain[1] - xDomain[0]);
    let yScale = (yRange[1] - yRange[0]) / (yDomain[1] - yDomain[0]);
    if (xScale < yScale) {
      let yMid = (yDomain[0] + yDomain[1]) * 0.5;
      let newWidth = (yRange[1] - yRange[0]) / xScale;
      yDomain = [yMid - newWidth * 0.5, yMid + newWidth * 0.5];
    } else {
      let xMid = (xDomain[0] + xDomain[1]) * 0.5;
      let newWidth = (xRange[1] - xRange[0]) / yScale;
      xDomain = [xMid - newWidth * 0.5, xMid + newWidth * 0.5];
    }
  }
  this.xDomain = padExtent(xDomain, padding);
  this.yDomain = padExtent(yDomain, padding);
  this.xDExtent = this.xDomain[1] - this.xDomain[0];
  this.yDExtent = this.yDomain[1] - this.yDomain[0];
  this.xRange = xRange;
  this.yRange = yRange;
  this.xRExtent = xRange[1] - xRange[0];
  this.yRExtent = yRange[1] - yRange[0];
  this.scaleFactor = new Attribute(1);
  this.translateX = new Attribute(0);
  this.translateY = new Attribute(0);
  this.translateX.label = "scaleFactor";
  this.minScale = 0.1;
  this.maxScale = 14;
  this._updatedNoAdvance = false;
  this.listeners = [];
  this.onUpdate = function(fn) {
    this.listeners.push(fn);
  };
  this.isNeutral = function() {
    return Math.abs(this.scaleFactor.get() - 1) <= 0.01 && Math.abs(this.translateX.get()) <= 5 && Math.abs(this.translateY.get()) <= 5;
  };
  this.advance = function(dt) {
    let a = this.scaleFactor.advance(dt);
    let b = this.translateX.advance(dt);
    let c2 = this.translateY.advance(dt);
    if (a || b || c2) {
      this._updatedNoAdvance = false;
      this.listeners.forEach((fn) => fn(this));
      return true;
    }
    if (!this._updatedNoAdvance) {
      this.listeners.forEach((fn) => fn(this));
      this._updatedNoAdvance = true;
    }
    return false;
  };
  this.scaleX = function(dataX) {
    let base = (dataX - this.xDomain[0]) * this.xRExtent / this.xDExtent + this.xRange[0];
    return base * this.scaleFactor.get() - this.translateX.get();
  };
  this.scaleY = function(dataY) {
    let base = (dataY - this.yDomain[0]) * this.yRExtent / this.yDExtent + this.yRange[0];
    return base * this.scaleFactor.get() - this.translateY.get();
  };
  this.getTransformInfo = function() {
    let baseScaleX = this.xRExtent / this.xDExtent;
    let baseScaleY = this.yRExtent / this.yDExtent;
    let scale = this.scaleFactor.get();
    return {
      x: {
        a: baseScaleX * scale,
        b: scale * (this.xRange[0] - baseScaleX * this.xDomain[0]) - this.translateX.get()
      },
      y: {
        a: baseScaleY * scale,
        b: scale * (this.yRange[0] - baseScaleY * this.yDomain[0]) - this.translateY.get()
      }
    };
  };
  this.getDataToUniformScaleFactor = function() {
    return Math.min(
      this.xRExtent / this.xDExtent,
      this.yRExtent / this.yDExtent
    );
  };
  this.scaleFactorForDistance = function(dataDistance, pixelDistance) {
    let baseScaleX = this.xRExtent / this.xDExtent;
    let baseScaleY = this.yRExtent / this.yDExtent;
    return pixelDistance / (Math.min(baseScaleX, baseScaleY) * dataDistance);
  };
  this.transform = function(scaleInfo, animated = false) {
    this.unfollow();
    if (animated) {
      if (scaleInfo.hasOwnProperty("scale"))
        this.scaleFactor.animate(
          new Animator(
            interpolateTo(scaleInfo.scale),
            ZoomAnimationDuration,
            easeInOut
          )
        );
      if (scaleInfo.hasOwnProperty("translateX"))
        this.translateX.animate(
          new Animator(
            interpolateTo(scaleInfo.translateX),
            ZoomAnimationDuration,
            easeInOut
          )
        );
      if (scaleInfo.hasOwnProperty("translateY"))
        this.translateY.animate(
          new Animator(
            interpolateTo(scaleInfo.translateY),
            ZoomAnimationDuration,
            easeInOut
          )
        );
    } else {
      if (scaleInfo.hasOwnProperty("scale"))
        this.scaleFactor.set(scaleInfo.scale);
      if (scaleInfo.hasOwnProperty("translateX"))
        this.translateX.set(scaleInfo.translateX);
      if (scaleInfo.hasOwnProperty("translateY"))
        this.translateY.set(scaleInfo.translateY);
    }
  };
  this.scaleBy = function(ds, centerPoint = null) {
    this.unfollow();
    let tx = this.translateX.get();
    let ty = this.translateY.get();
    let s = this.scaleFactor.get();
    if (!centerPoint) {
      centerPoint = [
        (this.xRange[0] + this.xRange[1]) * 0.5,
        (this.yRange[0] + this.yRange[1]) * 0.5
      ];
    } else {
      centerPoint = [(centerPoint[0] + tx) / s, (centerPoint[1] + ty) / s];
    }
    var newScaleFactor = s + ds;
    if (newScaleFactor > this.maxScale || newScaleFactor < this.minScale)
      return;
    this.scaleFactor.set(newScaleFactor);
    this.translateX.set(tx + ds * centerPoint[0]);
    this.translateY.set(ty + ds * centerPoint[1]);
  };
  this.translateBy = function(dx, dy) {
    this.unfollow();
    this.translateX.set(this.translateX.get() + dx);
    this.translateY.set(this.translateY.get() + dy);
  };
  this._computeZoomBox = function(points, fixedCenter = null, fixedScale = null) {
    let newCenterX, newCenterY, newScale;
    if (!!fixedScale) {
      newScale = fixedScale;
      if (!!fixedCenter) {
        newCenterX = fixedCenter.x;
        newCenterY = fixedCenter.y;
      } else {
        let { x: xExtent, y: yExtent } = boundingBox(points);
        newCenterX = (xExtent[0] + xExtent[1]) * 0.5;
        newCenterY = (yExtent[0] + yExtent[1]) * 0.5;
      }
    } else {
      let { x: xExtent, y: yExtent } = boundingBox(points);
      if (!!fixedCenter) {
        let xDist = Math.max(
          xExtent[1] - fixedCenter.x,
          fixedCenter.x - xExtent[0]
        );
        let yDist = Math.max(
          yExtent[1] - fixedCenter.y,
          fixedCenter.y - yExtent[0]
        );
        xExtent = [fixedCenter.x - xDist, fixedCenter.x + xDist];
        yExtent = [fixedCenter.y - yDist, fixedCenter.y + yDist];
      }
      let xScale = this.xRExtent / (xExtent[1] - xExtent[0]) / (this.xRExtent / this.xDExtent);
      let yScale = this.yRExtent / (yExtent[1] - yExtent[0]) / (this.yRExtent / this.yDExtent);
      xExtent = padExtent(
        xExtent,
        ZoomBoxPadding / (this.xRExtent / this.xDExtent * xScale)
      );
      yExtent = padExtent(
        yExtent,
        ZoomBoxPadding / (this.yRExtent / this.yDExtent * yScale)
      );
      xScale = this.xRExtent / (xExtent[1] - xExtent[0]) / (this.xRExtent / this.xDExtent);
      yScale = this.yRExtent / (yExtent[1] - yExtent[0]) / (this.yRExtent / this.yDExtent);
      newScale = Math.min(Math.min(xScale, yScale), this.maxScale);
      newCenterX = (xExtent[0] + xExtent[1]) * 0.5;
      newCenterY = (yExtent[0] + yExtent[1]) * 0.5;
    }
    newCenterX = (newCenterX - this.xDomain[0]) * this.xRExtent / this.xDExtent + this.xRange[0];
    newCenterY = (newCenterY - this.yDomain[0]) * this.yRExtent / this.yDExtent + this.yRange[0];
    let newTranslateX = newCenterX * newScale - (this.xRange[0] + this.xRange[1]) * 0.5;
    let newTranslateY = newCenterY * newScale - (this.yRange[0] + this.yRange[1]) * 0.5;
    return {
      scale: newScale,
      translateX: newTranslateX,
      translateY: newTranslateY
    };
  };
  this.zoomTo = function(marks, animated = true, xAttr = "x", yAttr = "y") {
    let points = marks.map((mark) => ({
      x: mark.attr(xAttr, false),
      y: mark.attr(yAttr, false)
    }));
    this.transform(this._computeZoomBox(points), animated);
  };
  this.followingMarks = [];
  this.centerMark = null;
  this._markBoxCache = null;
  this._markPointFn = null;
  this._fixedScale = null;
  this._computeMarkBox = function() {
    if (!!this._markBoxCache) {
      if (this._markBoxCache.time == this.scaleFactor.currentTime) {
        return this._markBoxCache.value;
      }
    }
    let value = this._computeZoomBox(
      this._markPointFn(this.followingMarks),
      !!this.centerMark ? this._markPointFn([this.centerMark])[0] : null,
      this._fixedScale
    );
    this._markBoxCache = {
      time: this.scaleFactor.currentTime,
      value
    };
    return value;
  };
  this.follow = function(marks, animated = true, xAttr = "x", yAttr = "y") {
    this.followingMarks = marks;
    this.centerMark = null;
    this._markPointFn = (m) => m.map((mark) => ({
      x: mark.attr(xAttr, false),
      y: mark.attr(yAttr, false)
    }));
    this._markBoxCache = null;
    this.scaleFactor.set(() => this._computeMarkBox().scale);
    this.translateX.set(() => this._computeMarkBox().translateX);
    this.translateY.set(() => this._computeMarkBox().translateY);
    if (animated) {
      this.scaleFactor.animate(
        new Animator(
          interpolateTo(this.scaleFactor.data()),
          ZoomAnimationDuration,
          easeInOut
        )
      );
      this.translateX.animate(
        new Animator(
          interpolateTo(this.translateX.data()),
          ZoomAnimationDuration,
          easeInOut
        )
      );
      this.translateY.animate(
        new Animator(
          interpolateTo(this.translateY.data()),
          ZoomAnimationDuration,
          easeInOut
        )
      );
    }
  };
  this.centerOn = function(mark, peripheralMarks, animated = true, xAttr = "x", yAttr = "y") {
    this.followingMarks = [mark, ...peripheralMarks];
    this.centerMark = mark;
    this._markPointFn = (m) => m.map((mark2) => ({
      x: mark2.attr(xAttr, false),
      y: mark2.attr(yAttr, false)
    }));
    this._markBoxCache = null;
    this._fixedScale = null;
    this.scaleFactor.set(() => this._computeMarkBox().scale);
    this.translateX.set(() => this._computeMarkBox().translateX);
    this.translateY.set(() => this._computeMarkBox().translateY);
    this._fixedScale = this.scaleFactor.data();
    if (animated) {
      this.scaleFactor.animate(
        new Animator(
          interpolateToFunction(() => this.scaleFactor.data()),
          ZoomAnimationDuration,
          easeInOut
        )
      );
      this.translateX.animate(
        new Animator(
          interpolateToFunction(() => this.translateX.data()),
          ZoomAnimationDuration,
          easeInOut
        )
      );
      this.translateY.animate(
        new Animator(
          interpolateToFunction(() => this.translateY.data()),
          ZoomAnimationDuration,
          easeInOut
        )
      );
    }
  };
  this.unfollow = function() {
    if (this.followingMarks.length > 0) {
      this.scaleFactor.set(this.scaleFactor.get());
      this.translateX.set(this.translateX.get());
      this.translateY.set(this.translateY.get());
      this.followingMarks = [];
      this.centerMark = null;
      this._markPointFn = null;
      this._markBoxCache = null;
    }
  };
  this.resetZoom = function(animated = true) {
    this.unfollow();
    this.transform({ scale: 1, translateX: 0, translateY: 0 }, animated);
  };
}
const MinPointPixelDistance = 50;
function instance$j($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { width = null } = $$props;
  let { height = null } = $$props;
  let { padding = 0.3 } = $$props;
  let { xExtent = null } = $$props;
  let { yExtent = null } = $$props;
  let { thumbnail = false } = $$props;
  let { pointRadius = 3 } = $$props;
  let { rFactor = 1 } = $$props;
  let { showPointBorders = true } = $$props;
  let { visibleIDs = [] } = $$props;
  let { data = null } = $$props;
  let scales = new Scales([0, 1], [0, 1], [0, 1], [0, 1], padding);
  let { scalesNeutral = true } = $$props;
  let { followingMarks = [] } = $$props;
  let oldVisibleIDs = [];
  let minPointDistance = null;
  let _defaultMinPointDistance = null;
  function updateScaleBounds(reset = false) {
    if (visibleIDs.length > 0) {
      minPointDistance = computeMinPointDistance(visibleIDs) || _defaultMinPointDistance;
    } else {
      if (_defaultMinPointDistance == null || reset) {
        _defaultMinPointDistance = computeMinPointDistance() || 1;
        $$invalidate(20, scales.maxScale = scales.scaleFactorForDistance(minPointDistance, MinPointPixelDistance), scales);
      }
      minPointDistance = _defaultMinPointDistance;
    }
  }
  function computeMinPointDistance(ids = null) {
    let collectedDistances = [];
    let neighborMembershipSet = ids != null ? new Set(ids) : null;
    data.frames.forEach((frame2) => {
      let idsToTest = ids != null ? ids : frame2.getIDs();
      idsToTest.forEach((id2) => {
        if (Math.random() < 100 / idsToTest.length) {
          let point = frame2.byID(id2);
          let neighbors = frame2.neighbors(id2, 25);
          if (neighborMembershipSet != null) {
            neighbors = neighbors.filter((n) => neighborMembershipSet.has(n));
          }
          if (neighbors.length == 0)
            return;
          let idx = Math.floor(Math.random() * neighbors.length);
          collectedDistances.push(euclideanDistance(point, frame2.byID(neighbors[idx])));
        }
      });
    });
    if (collectedDistances.length > 0) {
      collectedDistances.sort((a, b) => a - b);
      return collectedDistances[Math.round(collectedDistances.length * 0.1)];
    }
    return null;
  }
  function updatePointDisplay() {
    if (minPointDistance != null) {
      let scale = scales.getDataToUniformScaleFactor() * scales.scaleFactor.get();
      $$invalidate(0, rFactor = Math.max(Math.min(minPointDistance * 1.5 * scale / (2 * pointRadius), 1), 0.2));
      $$invalidate(1, showPointBorders = minPointDistance * scale >= 10);
    } else {
      let scale = scales.scaleFactor.get();
      $$invalidate(0, rFactor = Math.min(scale / 5, 1));
      $$invalidate(1, showPointBorders = scale >= 1);
    }
  }
  function advance(dt) {
    if (!scales)
      return false;
    return scales.advance(dt);
  }
  function resetAxisScales() {
    scales.resetZoom();
  }
  function scaleBy(ds, centerPoint) {
    scales.scaleBy(ds, centerPoint);
    dispatch2("update");
  }
  function translateBy(dx, dy) {
    scales.translateBy(dx, dy);
    dispatch2("update");
  }
  function scaleX(val) {
    return scales.scaleX(val);
  }
  function scaleY(val) {
    return scales.scaleY(val);
  }
  function getTransformInfo() {
    return scales.getTransformInfo();
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(3, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("padding" in $$props2)
      $$invalidate(5, padding = $$props2.padding);
    if ("xExtent" in $$props2)
      $$invalidate(6, xExtent = $$props2.xExtent);
    if ("yExtent" in $$props2)
      $$invalidate(7, yExtent = $$props2.yExtent);
    if ("thumbnail" in $$props2)
      $$invalidate(8, thumbnail = $$props2.thumbnail);
    if ("pointRadius" in $$props2)
      $$invalidate(9, pointRadius = $$props2.pointRadius);
    if ("rFactor" in $$props2)
      $$invalidate(0, rFactor = $$props2.rFactor);
    if ("showPointBorders" in $$props2)
      $$invalidate(1, showPointBorders = $$props2.showPointBorders);
    if ("visibleIDs" in $$props2)
      $$invalidate(10, visibleIDs = $$props2.visibleIDs);
    if ("data" in $$props2)
      $$invalidate(11, data = $$props2.data);
    if ("scalesNeutral" in $$props2)
      $$invalidate(2, scalesNeutral = $$props2.scalesNeutral);
    if ("followingMarks" in $$props2)
      $$invalidate(12, followingMarks = $$props2.followingMarks);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*width, height, xExtent, yExtent, padding*/
    248) {
      if (!!width && !!height && !!xExtent && !!yExtent) {
        $$invalidate(20, scales = new Scales(xExtent, yExtent, [0, width], [0, height], padding));
      }
    }
    if ($$self.$$.dirty & /*scales, data, thumbnail*/
    1050880) {
      if (!!scales && !!data && !thumbnail) {
        updateScaleBounds(true);
      }
    }
    if ($$self.$$.dirty & /*oldVisibleIDs, visibleIDs, scales, data*/
    3148800) {
      if (oldVisibleIDs !== visibleIDs) {
        if (!!scales && !!data) {
          updateScaleBounds();
        }
        $$invalidate(21, oldVisibleIDs = visibleIDs);
      }
    }
    if ($$self.$$.dirty & /*scales*/
    1048576) {
      if (!!scales) {
        scales.onUpdate(() => {
          $$invalidate(2, scalesNeutral = scales.isNeutral());
          updatePointDisplay();
          dispatch2("update");
        });
      }
    }
    if ($$self.$$.dirty & /*scales, followingMarks*/
    1052672) {
      if (!!scales) {
        if (followingMarks.length > 0) {
          scales.follow(followingMarks);
          dispatch2("update");
        } else {
          scales.unfollow();
        }
      }
    }
  };
  return [
    rFactor,
    showPointBorders,
    scalesNeutral,
    width,
    height,
    padding,
    xExtent,
    yExtent,
    thumbnail,
    pointRadius,
    visibleIDs,
    data,
    followingMarks,
    advance,
    resetAxisScales,
    scaleBy,
    translateBy,
    scaleX,
    scaleY,
    getTransformInfo,
    scales,
    oldVisibleIDs
  ];
}
class ScatterplotViewportState extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$j, null, safe_not_equal, {
      width: 3,
      height: 4,
      padding: 5,
      xExtent: 6,
      yExtent: 7,
      thumbnail: 8,
      pointRadius: 9,
      rFactor: 0,
      showPointBorders: 1,
      visibleIDs: 10,
      data: 11,
      scalesNeutral: 2,
      followingMarks: 12,
      advance: 13,
      resetAxisScales: 14,
      scaleBy: 15,
      translateBy: 16,
      scaleX: 17,
      scaleY: 18,
      getTransformInfo: 19
    });
  }
  get width() {
    return this.$$.ctx[3];
  }
  set width(width) {
    this.$$set({ width });
    flush();
  }
  get height() {
    return this.$$.ctx[4];
  }
  set height(height) {
    this.$$set({ height });
    flush();
  }
  get padding() {
    return this.$$.ctx[5];
  }
  set padding(padding) {
    this.$$set({ padding });
    flush();
  }
  get xExtent() {
    return this.$$.ctx[6];
  }
  set xExtent(xExtent) {
    this.$$set({ xExtent });
    flush();
  }
  get yExtent() {
    return this.$$.ctx[7];
  }
  set yExtent(yExtent) {
    this.$$set({ yExtent });
    flush();
  }
  get thumbnail() {
    return this.$$.ctx[8];
  }
  set thumbnail(thumbnail) {
    this.$$set({ thumbnail });
    flush();
  }
  get pointRadius() {
    return this.$$.ctx[9];
  }
  set pointRadius(pointRadius) {
    this.$$set({ pointRadius });
    flush();
  }
  get rFactor() {
    return this.$$.ctx[0];
  }
  set rFactor(rFactor) {
    this.$$set({ rFactor });
    flush();
  }
  get showPointBorders() {
    return this.$$.ctx[1];
  }
  set showPointBorders(showPointBorders) {
    this.$$set({ showPointBorders });
    flush();
  }
  get visibleIDs() {
    return this.$$.ctx[10];
  }
  set visibleIDs(visibleIDs) {
    this.$$set({ visibleIDs });
    flush();
  }
  get data() {
    return this.$$.ctx[11];
  }
  set data(data) {
    this.$$set({ data });
    flush();
  }
  get scalesNeutral() {
    return this.$$.ctx[2];
  }
  set scalesNeutral(scalesNeutral) {
    this.$$set({ scalesNeutral });
    flush();
  }
  get followingMarks() {
    return this.$$.ctx[12];
  }
  set followingMarks(followingMarks) {
    this.$$set({ followingMarks });
    flush();
  }
  get advance() {
    return this.$$.ctx[13];
  }
  get resetAxisScales() {
    return this.$$.ctx[14];
  }
  get scaleBy() {
    return this.$$.ctx[15];
  }
  get translateBy() {
    return this.$$.ctx[16];
  }
  get scaleX() {
    return this.$$.ctx[17];
  }
  get scaleY() {
    return this.$$.ctx[18];
  }
  get getTransformInfo() {
    return this.$$.ctx[19];
  }
}
class PixiLineDecoration extends Graphics {
  constructor(dec) {
    super();
    __publicField(this, "decoration", null);
    __publicField(this, "lastColor", null);
    __publicField(this, "colorHex", null);
    this.decoration = dec;
  }
  update() {
    let x = this.decoration.attr("x");
    let y = this.decoration.attr("y");
    let alpha = this.decoration.attr("alpha");
    let zIndex = this.decoration.attr("zIndex");
    let x2 = this.decoration.attr("x2");
    let y2 = this.decoration.attr("y2");
    let color2 = this.decoration.attr("color");
    if (this.lastColor != color2) {
      this.lastColor = color2;
      this.colorHex = string2hex(color2);
    }
    if (zIndex != this.zIndex) {
      this.zIndex = zIndex;
    }
    this.clear();
    this.lineStyle(this.decoration.attr("lineWidth"), this.colorHex, alpha);
    this.moveTo(x, y);
    this.lineTo(x2, y2);
  }
}
class PixiOutlineDecoration extends Graphics {
  constructor(dec) {
    super();
    __publicField(this, "decoration", null);
    __publicField(this, "lastColor", null);
    __publicField(this, "colorHex", null);
    __publicField(this, "rFactor", 1);
    this.decoration = dec;
  }
  update(currentTime) {
    let x = this.decoration.attr("x");
    let y = this.decoration.attr("y");
    let alpha = this.decoration.attr("alpha");
    let zIndex = this.decoration.attr("zIndex");
    let pulseDuration = this.decoration.attr("pulseDuration");
    if (!!pulseDuration) {
      alpha *= 0.5 * (1 + Math.sin(currentTime / (pulseDuration * 1e3) * 2 * Math.PI));
    }
    let color2 = this.decoration.attr("color");
    if (this.lastColor != color2) {
      this.lastColor = color2;
      this.colorHex = string2hex(color2);
    }
    if (zIndex != this.zIndex)
      this.zIndex = zIndex;
    this.clear();
    this.lineStyle(this.decoration.attr("lineWidth"), this.colorHex, alpha);
    this.drawCircle(x, y, this.decoration.attr("r") * this.rFactor);
  }
}
class PixiWideningLineDecoration extends Graphics {
  constructor(dec) {
    super();
    __publicField(this, "decoration", null);
    __publicField(this, "lastColor", null);
    __publicField(this, "colorHex", null);
    this.decoration = dec;
  }
  update() {
    let x = this.decoration.attr("x");
    let y = this.decoration.attr("y");
    let alpha = this.decoration.attr("alpha");
    let zIndex = this.decoration.attr("zIndex");
    let x2 = this.decoration.attr("x2");
    let y2 = this.decoration.attr("y2");
    let color2 = this.decoration.attr("color");
    let colorHex = Math.round(color2[0] * 255) * 256 * 256 + Math.round(color2[1] * 255) * 256 + Math.round(color2[2] * 255);
    if (zIndex != this.zIndex) {
      this.zIndex = zIndex;
    }
    this.clear();
    this.beginFill(colorHex, alpha);
    let start2 = [x, y];
    let end = [x2, y2];
    let startWidth = 1;
    let endWidth = this.decoration.attr("lineWidth");
    let path = [end[0] - start2[0], end[1] - start2[1]];
    let normal;
    if (path[1] > 0)
      normal = normalizeVector([path[1], -path[0]]);
    else
      normal = normalizeVector([-path[1], path[0]]);
    this.moveTo(
      start2[0] - normal[0] * startWidth / 2,
      start2[1] - normal[1] * startWidth / 2
    );
    this.lineTo(
      start2[0] + normal[0] * startWidth / 2,
      start2[1] + normal[1] * startWidth / 2
    );
    this.lineTo(
      end[0] + normal[0] * endWidth / 2,
      end[1] + normal[1] * endWidth / 2
    );
    this.lineTo(
      end[0] - normal[0] * endWidth / 2,
      end[1] - normal[1] * endWidth / 2
    );
    this.endFill();
  }
}
const ComponentsPerPixel = 4;
class PixiColorIDMap {
  /**
   * Builds the texture and prepares for queries.
   *
   * @param {PIXI.Renderer} renderer the renderer to use
   * @param {PIXI.RenderObject} element a drawable element to render
   * @param {PIXI.Rectangle} frame the rectangle in which to draw the element
   * @param {ColorIDMap | Array} colorID either a ColorIDMap defining values, or
   *  a single RGB (0-255) color array for a binary classification
   */
  constructor(renderer, element, frame2, colorID, persistent = false) {
    __publicField(this, "fbo");
    __publicField(this, "frame");
    __publicField(this, "binaryColor", null);
    __publicField(this, "colorIDs", null);
    __publicField(this, "persistent", false);
    __publicField(this, "renderTexture");
    __publicField(this, "renderer");
    this.renderer = renderer;
    this.frame = frame2;
    this.persistent = persistent;
    this.render(element);
    if (colorID instanceof Array) {
      this.binaryColor = colorID;
    } else {
      this.colorIDs = colorID;
    }
  }
  destroy() {
    if (this.persistent) {
      this.renderTexture.destroy(true);
      this.renderTexture = null;
    }
  }
  render(element) {
    if (!this.renderTexture) {
      this.renderTexture = this.renderer.generateTexture(
        element,
        SCALE_MODES.NEAREST,
        1,
        this.frame
      );
    } else {
      this.renderer.render(element, this.renderTexture);
    }
    this.fbo = this.renderer.extract.pixels(this.renderTexture);
    if (!this.persistent)
      this.destroy();
  }
  colorAt(x, y) {
    x = Math.round(x);
    y = Math.round(y);
    if (x < 0 || x >= this.frame.width || y < 0 || y >= this.frame.height)
      return [0, 0, 0];
    let startIndex = y * this.frame.width * ComponentsPerPixel + x * ComponentsPerPixel;
    let rgb2 = this.fbo.slice(startIndex, startIndex + 3);
    return rgb2;
  }
  // Only for binary classification maps - returns whether the region in the
  // map contains this point
  contains(x, y) {
    if (this.binaryColor == null) {
      console.warn("Attempting to use contains() on a non-binary color ID map");
      return false;
    }
    let color2 = this.colorAt(x, y);
    return color2[0] == this.binaryColor[0] && color2[1] == this.binaryColor[1] && color2[2] == this.binaryColor[2];
  }
  // Only for non-binary classification maps - returns the object in the
  // ColorIDMap at the given point, or null
  obj(x, y) {
    if (this.colorIDs == null) {
      console.warn("Attempting to use obj() on a binary color ID map");
      return null;
    }
    let color2;
    if (this.colorIDs.format == "hex") {
      let c2 = this.colorAt(x, y);
      color2 = (c2[0] << 16) + (c2[1] << 8) + c2[2];
    } else
      color2 = "rgb(" + this.colorAt(x, y).join(",") + ")";
    return this.colorIDs.obj(color2);
  }
}
const BaseFontSize = 10;
class PixiTextLabel extends Text {
  constructor(decoration, rFactor = 1, zIndexBase = 0) {
    super(decoration.attr("text") || "", {
      fontFamily: "Arial",
      fontSize: BaseFontSize,
      stroke: "white",
      strokeThickness: 3
    });
    __publicField(this, "decoration");
    __publicField(this, "rFactor", 1);
    __publicField(this, "renderBox", null);
    __publicField(this, "zIndexBase", 0);
    __publicField(this, "occluded", false);
    __publicField(this, "history", new ValueHistory());
    __publicField(this, "changed", false);
    this.resolution = window.devicePixelRatio;
    this.decoration = decoration;
    this.rFactor = rFactor;
    this.zIndexBase = zIndexBase;
    this.anchor.set(0.5, 1);
  }
  getBoundingBox() {
    let priority = this.decoration.attr("priority");
    let text2 = this.decoration.attr("text");
    if (priority == null || text2 == null || text2.length == 0) {
      return null;
    }
    let x = this.decoration.attr("x");
    let y = this.decoration.attr("y");
    let r = this.decoration.marks[0].attr("r") * this.rFactor;
    let bottom = y - r - 2;
    return [
      Math.round(x - this.width / 2),
      Math.round(bottom - this.height),
      Math.round(this.width),
      Math.round(this.height)
    ];
  }
  update() {
    let priority = this.decoration.attr("priority");
    let text2 = this.decoration.attr("text");
    if (priority == null || text2 == null || text2.length == 0 || this.occluded) {
      this.visible = false;
      this.changed = this.history.update({ priority, text: text2, x: null, y: null });
      return;
    }
    let x = this.decoration.attr("x");
    let y = this.decoration.attr("y");
    this.changed = this.history.update({ priority, text: text2, x, y });
    if (!!this.renderBox && (x < this.renderBox[0] || x > this.renderBox[1] || y < this.renderBox[2] || y > this.renderBox[3])) {
      this.visible = false;
      return;
    }
    this.visible = true;
    this.visible = true;
    if (priority + this.zIndexBase != this.zIndex) {
      this.zIndex = priority + this.zIndexBase;
    }
    let r = this.decoration.marks[0].attr("r") * this.rFactor;
    this.position.set(x, y - r - 2);
    this.text = text2;
    this.style.fill = this.decoration.attr("color") || "black";
    this.style.fontSize = BaseFontSize * (this.decoration.attr("textScale") || 1);
    this.alpha = this.decoration.attr("alpha") || 1;
    this.scale.set(this.decoration.attr("scale") || 1);
  }
}
class PixiImageLabel extends Sprite {
  constructor(decoration, texture, rFactor = 1, zIndexBase = 0) {
    super(texture);
    __publicField(this, "decoration");
    __publicField(this, "renderBox", null);
    __publicField(this, "rFactor", 1);
    __publicField(this, "zIndexBase", 0);
    __publicField(this, "outline", null);
    __publicField(this, "lastColor", null);
    __publicField(this, "colorHex", null);
    __publicField(this, "scaleFactor", 0);
    __publicField(this, "occluded", false);
    __publicField(this, "history", new ValueHistory());
    __publicField(this, "changed", false);
    this.decoration = decoration;
    this.rFactor = rFactor;
    this.zIndexBase = zIndexBase;
    this.anchor.set(0.5, 1);
    let maxDim = this.decoration.attr("maxDim");
    if (!!maxDim && (this.width > maxDim + 1e-3 || this.height > maxDim + 1e-3)) {
      this.scaleFactor = Math.min(maxDim / this.width, maxDim / this.height);
      this.width *= this.scaleFactor;
      this.height *= this.scaleFactor;
    } else {
      this.scaleFactor = 1;
    }
    this.outline = new Graphics();
    this.addChild(this.outline);
  }
  getBoundingBox() {
    let priority = this.decoration.attr("priority");
    if (priority == null) {
      return null;
    }
    let x = this.decoration.attr("x");
    let y = this.decoration.attr("y");
    let r = this.decoration.marks[0].attr("r") * this.rFactor;
    let bottom = y - r - 4;
    return [
      Math.round(x - this.width / 2),
      Math.round(bottom - this.height),
      Math.round(this.width),
      Math.round(this.height)
    ];
  }
  update() {
    let priority = this.decoration.attr("priority");
    if (priority == null || this.occluded) {
      this.visible = false;
      this.changed = this.history.update({ priority });
      return;
    }
    let x = this.decoration.attr("x");
    let y = this.decoration.attr("y");
    if (!!this.renderBox && (x < this.renderBox[0] || x > this.renderBox[1] || y < this.renderBox[2] || y > this.renderBox[3])) {
      this.visible = false;
      this.changed = this.history.update({ priority, x, y });
      return;
    }
    this.visible = true;
    if (priority + this.zIndexBase != this.zIndex) {
      this.zIndex = priority + this.zIndexBase;
    }
    let r = this.decoration.marks[0].attr("r") * this.rFactor;
    this.position.set(x, y - r - 4);
    this.alpha = this.decoration.attr("alpha") || 1;
    let color2 = this.decoration.attr("color") || "#FFFFFF";
    this.changed = this.history.update({ priority, x, y, color: color2 });
    if (this.lastColor != color2) {
      this.lastColor = color2;
      this.colorHex = string2hex(color2);
      this.outline.clear();
      this.outline.lineStyle(2, this.colorHex, 1);
      this.outline.drawRect(
        -this.width / 2 / this.scaleFactor,
        -this.height / this.scaleFactor,
        this.width / this.scaleFactor,
        this.height / this.scaleFactor
      );
    }
  }
}
const BBOX_PADDING = 2;
class PixiLabelContainer extends Container {
  constructor(renderer, frame2) {
    super();
    __publicField(this, "labels", []);
    __publicField(this, "bboxes", []);
    __publicField(this, "frame");
    __publicField(this, "renderer");
    __publicField(this, "blockContainer", new Container());
    __publicField(this, "colorIDs", null);
    __publicField(this, "colorIDMap", null);
    __publicField(this, "labelListChanged", false);
    this.renderer = renderer;
    this.frame = frame2;
  }
  _corners(bbox) {
    return [
      [bbox[0] + BBOX_PADDING, bbox[1] + BBOX_PADDING],
      [bbox[0] + bbox[2] - BBOX_PADDING, bbox[1] + BBOX_PADDING],
      [bbox[0] + BBOX_PADDING, bbox[1] + bbox[3] - BBOX_PADDING],
      [bbox[0] + bbox[2] - BBOX_PADDING, bbox[1] + bbox[3] - BBOX_PADDING]
    ];
  }
  update() {
    if (this.labels.length == 0) {
      return;
    } else if (this.labels.length == 1) {
      this.labels[0].occluded = false;
      return;
    }
    let anyChanged = false;
    for (var l of this.labels) {
      if (l.changed) {
        anyChanged = true;
        break;
      }
    }
    if (!anyChanged && !this.labelListChanged) {
      return;
    }
    this.labelListChanged = false;
    this.blockContainer.sortableChildren = true;
    if (!this.colorIDs)
      this.colorIDs = new ColorIDMap("hex");
    this.labels.forEach((label, i) => {
      let priority = label.decoration.attr("priority");
      if (priority == null)
        return;
      let bbox = label.getBoundingBox();
      let graphics = this.bboxes[i];
      graphics.clear();
      graphics.zIndex = priority;
      let color2 = this.colorIDs.id(i);
      graphics.beginFill(color2);
      graphics.drawRect(
        bbox[0] - BBOX_PADDING,
        bbox[1] - BBOX_PADDING,
        bbox[2] + BBOX_PADDING * 2,
        bbox[3] + BBOX_PADDING * 2
      );
      graphics.endFill();
    });
    this.blockContainer.sortChildren();
    if (!this.colorIDMap) {
      this.colorIDMap = new PixiColorIDMap(
        this.renderer,
        this.blockContainer,
        this.frame,
        this.colorIDs,
        true
      );
    } else {
      this.colorIDMap.render(this.blockContainer);
    }
    this.labels.forEach((label, i) => {
      let bbox = label.getBoundingBox();
      if (bbox == null)
        return;
      label.occluded = false;
      for (let corner of this._corners(bbox)) {
        let obj = this.colorIDMap.obj(corner[0], corner[1]);
        if (obj != null && obj != i) {
          label.occluded = true;
          break;
        }
      }
    });
  }
  addLabel(label) {
    this.labels.push(label);
    let bbox = new Graphics();
    this.bboxes.push(bbox);
    this.addChild(label);
    this.blockContainer.addChild(bbox);
    this.labelListChanged = true;
  }
  removeLabel(label) {
    let idx = this.labels.indexOf(label);
    if (idx >= 0) {
      this.labels.splice(idx, 1);
      this.blockContainer.removeChild(this.bboxes[idx]);
      this.bboxes[idx].destroy();
      this.bboxes.splice(idx, 1);
    }
    this.removeChild(label);
    this.labelListChanged = true;
  }
  destroy() {
    super.destroy();
    if (!!this.colorIDMap)
      this.colorIDMap.destroy();
  }
}
class PixiMultiselect extends Graphics {
  constructor(fillColor, strokeColor = null) {
    super();
    __publicField(this, "points", []);
    __publicField(this, "fillColor");
    __publicField(this, "strokeColor", null);
    __publicField(this, "hidden", false);
    this.fillColor = fillColor;
    this.strokeColor = strokeColor;
  }
  addPoint(x, y) {
    this.points.push([x, y]);
  }
  setPoints(points) {
    this.points = points;
  }
  _drawShape(dashed) {
    let dashPattern = [2, 4];
    let currentDashPosition = 0;
    let currentDashIndex = 0;
    let dashOn = true;
    this.moveTo(
      this.points[this.points.length - 1][0],
      this.points[this.points.length - 1][1]
    );
    this.points.slice().reverse().forEach((point) => {
      if (dashed) {
        if (currentDashPosition == dashPattern[currentDashIndex]) {
          currentDashIndex = (currentDashIndex + 1) % dashPattern.length;
          dashOn = !dashOn;
        }
        currentDashPosition = (currentDashPosition + 1) % (dashPattern[dashPattern.length - 1] + 1);
      }
      if (dashOn) {
        this.lineTo(point[0], point[1]);
      } else {
        this.moveTo(point[0], point[1]);
      }
    });
  }
  update() {
    this.clear();
    if (this.strokeColor != null) {
      this.lineStyle(2, this.strokeColor, 0.6);
      this._drawShape(true);
    }
    this.lineStyle(0, this.strokeColor, 0);
    this.beginFill(this.fillColor, this.hidden ? 1 : 0.25);
    this._drawShape(false);
    this.endFill();
  }
}
const v = 80;
class PixiRadiusSelect extends Graphics {
  constructor(centerID, centerX, centerY, radius, fillColor) {
    super();
    __publicField(this, "centerID");
    __publicField(this, "centerX");
    __publicField(this, "centerY");
    __publicField(this, "radius");
    __publicField(this, "fillColor");
    __publicField(this, "timeCounter");
    this.centerID = centerID;
    this.centerX = centerX;
    this.centerY = centerY;
    this.radius = radius;
    this.fillColor = fillColor;
    this.circle = new Circle(centerX, centerY, radius);
    this.timeCounter = 0;
  }
  _drawShape(dashed) {
    let points = [];
    let numDashes = Math.round(2 * this.radius * Math.PI / 2);
    for (let i = 0; i < numDashes; i++) {
      let theta = 2 * Math.PI / numDashes * i + this.timeCounter * (v / (this.radius * numDashes));
      points.push([
        this.centerX + this.radius * Math.cos(theta),
        this.centerY + this.radius * Math.sin(theta)
      ]);
    }
    let dashPattern = [2, 2];
    let currentDashPosition = 0;
    let currentDashIndex = 0;
    let dashOn = true;
    this.moveTo(points[points.length - 1][0], points[points.length - 1][1]);
    points.slice().reverse().forEach((point) => {
      if (dashed) {
        if (currentDashPosition == dashPattern[currentDashIndex]) {
          currentDashIndex = (currentDashIndex + 1) % dashPattern.length;
          dashOn = !dashOn;
        }
        currentDashPosition = (currentDashPosition + 1) % (dashPattern[dashPattern.length - 1] + 1);
      }
      if (dashOn) {
        this.lineTo(point[0], point[1]);
      } else {
        this.moveTo(point[0], point[1]);
      }
    });
  }
  update(centerX, centerY) {
    this.timeCounter += 1;
    this.centerX = centerX;
    this.centerY = centerY;
    this.circle = new Circle(this.centerX, this.centerY, this.radius);
    this.clear();
    this.lineStyle(2, this.fillColor, 0.6);
    this._drawShape(true);
    this.lineStyle(0, this.fillColor, 0);
    this.beginFill(this.fillColor, 0.25);
    this._drawShape(false);
    this.endFill();
  }
}
function _rgbStringToArray(rgb2) {
  let comps = rgb2.substring(4, rgb2.length - 1).split(",");
  return [
    parseInt(comps[0]) / 255,
    parseInt(comps[1]) / 255,
    parseInt(comps[2]) / 255
  ];
}
class PointSetGeometry extends Geometry {
  constructor(marks, rFactor, hidden) {
    super();
    __publicField(this, "marks");
    __publicField(this, "rFactor", 1);
    __publicField(this, "hidden", false);
    this.marks = marks;
    this.rFactor = rFactor;
    this.hidden = hidden;
    this.addAttribute("x", Buffer2.from(this.makeArray("x")), 4);
    this.addAttribute("y", Buffer2.from(this.makeArray("y")), 4);
    this.addAttribute("r", Buffer2.from(this.makeArray("r")), 4);
    this.addAttribute(
      "fillStyle",
      Buffer2.from(this.makeArray("fillStyle"))
    );
    this.addAttribute("alpha", Buffer2.from(this.makeArray("alpha")), 4);
  }
  // Creates a buffer for the given attribute (PIXI attributes, not Mark attributes).
  makeArray(attrName, currentTime = null) {
    let arr;
    if (attrName == "r") {
      arr = [];
      this.marks.forEach((mark) => {
        let anim = mark.attributes[attrName].getPreload(false, currentTime);
        arr.push(anim.start * this.rFactor * window.devicePixelRatio / 0.6);
        arr.push(anim.end * this.rFactor * window.devicePixelRatio / 0.6);
        arr.push(anim.startTime);
        arr.push(anim.endTime);
      });
    } else if (attrName == "fillStyle") {
      if (this.hidden) {
        arr = this.marks.map((mark) => _rgbStringToArray(mark.attr("colorID"))).flat();
      } else {
        arr = this.marks.map((mark) => mark.attr("fillStyle")).flat();
      }
    } else {
      arr = [];
      this.marks.forEach((mark) => {
        let anim = mark.attributes[attrName].getPreload(false, currentTime);
        arr.push(anim.start);
        arr.push(anim.end);
        arr.push(anim.startTime);
        arr.push(anim.endTime);
      });
    }
    return new Float32Array(arr);
  }
  update(currentTime) {
    this.getBuffer("x").update(this.makeArray("x", currentTime));
    this.getBuffer("y").update(this.makeArray("y", currentTime));
    this.getBuffer("r").update(this.makeArray("r", currentTime));
    this.getBuffer("fillStyle").update(
      this.makeArray("fillStyle", currentTime)
    );
    this.getBuffer("alpha").update(this.makeArray("alpha", currentTime));
  }
}
const VertexShader = `#version 300 es
    precision mediump float;

    in vec4 x;
    in vec4 y;
    in vec4 r;
    in vec3 fillStyle;
    in vec4 alpha;

    out vec3 vFillStyle;
    out float vAlpha;

    uniform mat3 translationMatrix;
    uniform mat3 projectionMatrix;

    uniform vec2 transformA;
    uniform vec2 transformB;
    uniform float rFactor;

    uniform float currentTime;
    
    void animate(in vec4 attrib, out float interpolatedValue) {
      float t = clamp(
        (attrib.w - attrib.z >= 0.001) ? (currentTime - attrib.z) / (attrib.w - attrib.z) : 0.0,
        0.0,
        1.0
      );
      t = t * t * (3.0 - 2.0 * t);
      interpolatedValue = attrib.y * t + attrib.x * (1.0 - t);
    }

    void main() {
      animate(alpha, vAlpha);
      vFillStyle = fillStyle;
      float animatedX, animatedY;
      animate(x, animatedX);
      animate(y, animatedY);
      vec2 transformedPosition = vec2(animatedX, animatedY) * transformA + transformB;
      gl_Position = vec4((projectionMatrix * translationMatrix * vec3(transformedPosition, 1.0)).xy, 0.0, 1.0);
      float animatedR;
      animate(r, animatedR);
      gl_PointSize = animatedR * 2.0 * rFactor;
    }
`;
const FragmentShader = `#version 300 es
    #ifdef GL_OES_standard_derivatives
    #extension GL_OES_standard_derivatives : enable
    #endif

    precision mediump float;

    uniform float showBorders;

    const float fillAlpha = 0.5; // for some reason this isn't perceptually consistent with other alphas
    const float strokeWidth = 0.3;
    const float inset = 0.6;

    in vec3 vFillStyle;
    in float vAlpha;
    out vec4 fragmentColor;

    void main () {
      float r = 0.0, delta = 0.0, alpha = vAlpha;
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      r = dot(cxy, cxy);
      if (showBorders > 0.5) {
        #ifdef GL_OES_standard_derivatives
          delta = fwidth(r);
          float strokeMinInner = inset - strokeWidth - delta;
          float strokeMinOuter = inset - strokeWidth + delta;
          float strokeMaxInner = inset - delta;
          float strokeMaxOuter = inset + delta;
          alpha *= fillAlpha * step(-strokeMinOuter, -r) * (1.0 - smoothstep(strokeMinInner, strokeMinOuter, r)) + 
            1.0 * step(strokeMinInner, r) * step(-strokeMaxInner, -r) * smoothstep(strokeMinInner, strokeMinOuter, r) + 
            1.0 * step(strokeMaxInner, r) * (1.0 - smoothstep(strokeMaxInner, strokeMaxOuter, r));
        #else
          float strokeMin = inset - strokeWidth;
          float strokeMax = inset;
          alpha *= fillAlpha * step(-strokeMin, -r) + 
            1.0 * step(strokeMin, r) * step(-strokeMax, -r);
        #endif
      } else {
        #ifdef GL_OES_standard_derivatives
          delta = fwidth(r);
          float borderInner = inset - delta;
          float borderOuter = inset + delta;
          if (r > inset + delta) {
            discard;
          }
          alpha *= fillAlpha * step(-borderOuter, -r) * (1.0 - smoothstep(borderInner, borderOuter, r));
        #else
          if (r > inset) {
            discard;
          }
          alpha *= fillAlpha;
        #endif
      }

      fragmentColor = vec4(vFillStyle * alpha, alpha);
    }
`;
const HiddenFragmentShader = `#version 300 es
    precision mediump float;

    in vec3 vFillStyle;
    in float vAlpha;

    out vec4 fragmentColor;

    void main () {
      float r = 0.0, delta = 0.0;
      if (vAlpha < 0.001) {
        discard;
      }
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      r = dot(cxy, cxy);
      if (r > 1.0) {
        discard;
      }

      fragmentColor = vec4(vFillStyle, 1.0);
    }
`;
class PixiPointSet extends Mesh {
  constructor(marks, transformInfo, rFactor = 1, renderBox = null, hidden = false) {
    let geometry = new PointSetGeometry(marks, rFactor, hidden);
    let uniforms = {
      transformA: { x: transformInfo.x.a, y: transformInfo.y.a },
      transformB: { x: transformInfo.x.b, y: transformInfo.y.b },
      currentTime: 0,
      rFactor
    };
    if (!hidden)
      uniforms.showBorders = 1;
    let shader = new Shader.from(
      VertexShader,
      hidden ? HiddenFragmentShader : FragmentShader,
      uniforms
    );
    super(geometry, shader, State.for2d(), DRAW_MODES.POINTS);
    __publicField(this, "marks");
    __publicField(this, "rFactor", 1);
    __publicField(this, "renderBox", null);
    __publicField(this, "hidden", false);
    __publicField(this, "showBorders", true);
    this.marks = marks;
    this.rFactor = rFactor;
    this.renderBox = renderBox;
  }
  updateCoordinateTransform(info) {
    this.shader.uniforms.transformA = { x: info.x.a, y: info.y.a };
    this.shader.uniforms.transformB = { x: info.x.b, y: info.y.b };
    if (!!info.rFactor) {
      this.rFactor = info.rFactor;
      this.shader.uniforms.rFactor = info.rFactor;
    }
  }
  update(currentTime, needsGeometryUpdate = false) {
    this.shader.uniforms.rFactor = this.rFactor;
    this.shader.uniforms.currentTime = currentTime;
    if (!this.hidden)
      this.shader.uniforms.showBorders = this.showBorders ? 1 : 0;
    if (needsGeometryUpdate)
      this.geometry.update(currentTime);
  }
}
const TextLabelZIndex = 1e3;
const HiddenRFactor = 1;
function PixiScatterplot(markSet, transformInfo, rFactor = 1) {
  this.marksContainer = new Container();
  this.marksContainer.zIndex = 1;
  this.marksContainer.sortableChildren = true;
  this.radiusselectContainer = new Container();
  this.radiusselectContainer.zIndex = 2;
  this.multiselectContainer = new Container();
  this.multiselectContainer.zIndex = 2;
  this.markSet = markSet;
  this.transformInfo = transformInfo;
  this.renderBox = null;
  this.size = null;
  this.ticker = null;
  this.currentTime = 0;
  this.showPointBorders = true;
  this.rFactor = rFactor;
  this.pointSet = new PixiPointSet(this.markSet, transformInfo, rFactor);
  this.marksContainer.addChild(this.pointSet);
  this.labelContainer = new PixiLabelContainer(null, null);
  this.labelContainer.zIndex = 1e3;
  this.marksContainer.addChild(this.labelContainer);
  this.getElements = function() {
    return [this.marksContainer];
  };
  this.addTo = function(container, ticker, renderer) {
    container.addChild(this.marksContainer);
    container.addChild(this.multiselectContainer);
    container.addChild(this.radiusselectContainer);
    this.labelContainer.renderer = renderer;
    ticker.add(this._tickerFn, this);
    this.ticker = ticker;
  };
  this._tickerFn = function() {
    let needsUpdate = this.markSet.marksChanged();
    this.markSet.advance(this.ticker.elapsedMS);
    this.currentTime += this.ticker.elapsedMS;
    if (this.markSet.marksAnimating()) {
      this._marksAnimating = true;
      this.interactionMap = null;
    } else {
      this._marksAnimating = false;
    }
    this.pointSet.showBorders = this.showPointBorders;
    this.pointSet.rFactor = this.rFactor;
    this.pointSet.update(this.currentTime, needsUpdate);
    this.labelContainer.update();
    this.updateDecorations();
    if (!!this.multiselect) {
      this.multiselect.update();
    }
    if (!!this.radiusselect) {
      this.radiusselect.update(
        this.markSet.getMarkByID(this.radiusselect.centerID).attr("x"),
        this.markSet.getMarkByID(this.radiusselect.centerID).attr("y")
      );
    }
  };
  this.destroy = function() {
    this.pointSet.destroy();
    this.pointSet = null;
    this.ticker.remove(this._tickerFn, this);
    this.ticker = null;
    this.labelContainer.destroy();
    this.labelContainer = null;
  };
  this.setRenderBox = function(box) {
    this.renderBox = box;
  };
  this.setSize = function(size2) {
    this.size = size2;
    this.labelContainer.frame = new Rectangle(
      0,
      0,
      this.size[0],
      this.size[1]
    );
  };
  this.decorations = /* @__PURE__ */ new Map();
  this.updateDecorations = function() {
    let currentDecorations = new Set(this.markSet.decorations);
    currentDecorations.forEach((dec2) => {
      if (!this.decorations.has(dec2)) {
        let pixiDec;
        if (dec2.type == "line") {
          pixiDec = new PixiLineDecoration(dec2);
        } else if (dec2.type == "wideningLine") {
          pixiDec = new PixiWideningLineDecoration(dec2);
        } else if (dec2.type == "outline") {
          pixiDec = new PixiOutlineDecoration(dec2);
        } else if (dec2.type == "text") {
          pixiDec = new PixiTextLabel(dec2, rFactor, TextLabelZIndex);
        } else if (dec2.type == "image" && !!this.textureLoader) {
          let info = dec2.attr("labelInfo");
          let spritesheet = this.textureLoader.resources[info.sheet];
          if (!!spritesheet) {
            let tex = spritesheet.textures[info.texture];
            if (!!tex) {
              pixiDec = new PixiImageLabel(dec2, tex, rFactor, TextLabelZIndex);
            }
          }
        }
        if (!!pixiDec) {
          if (dec2.type == "text" || dec2.type == "image") {
            this.labelContainer.addLabel(pixiDec);
          } else {
            this.marksContainer.addChild(pixiDec);
          }
          this.decorations.set(dec2, pixiDec);
        }
      }
      if (this.decorations.has(dec2)) {
        this.decorations.get(dec2).update(this.currentTime);
      }
    });
    for (var dec of this.decorations.keys()) {
      let graphicDec = this.decorations.get(dec);
      if (dec.type == "outline") {
        graphicDec.rFactor = this.rFactor;
      }
      if (!currentDecorations.has(dec)) {
        if (dec.type == "text" || dec.type == "image") {
          this.labelContainer.removeLabel(graphicDec);
        } else {
          this.marksContainer.removeChild(graphicDec);
        }
        this.decorations.delete(dec);
      }
    }
  };
  this.textureLoader = null;
  this.setTextureLoader = function(loader) {
    this.textureLoader = loader;
  };
  this.interactionEnabled = true;
  this._marksAnimating = false;
  this.interactionMap = null;
  this.setInteractionEnabled = function(flag) {
    this.interactionEnabled = flag;
  };
  this.updateTransform = function(transformInfo2) {
    if (approxEquals(transformInfo2.x.a, this.transformInfo.x.a) && approxEquals(transformInfo2.x.b, this.transformInfo.x.b) && approxEquals(transformInfo2.y.a, this.transformInfo.y.a) && approxEquals(transformInfo2.y.b, this.transformInfo.y.b))
      return;
    this.transformInfo = transformInfo2;
    this.pointSet.updateCoordinateTransform(transformInfo2);
    this.clearInteractionMap();
  };
  this.getInteractionMap = function(renderer, width, height, colorIDs) {
    if (!this.interactionEnabled || this._marksAnimating)
      return null;
    if (!this.interactionMap) {
      let hiddenPoints = new PixiPointSet(
        this.markSet,
        this.transformInfo,
        rFactor * HiddenRFactor,
        this.renderBox,
        true
      );
      this.interactionMap = new PixiColorIDMap(
        renderer,
        hiddenPoints,
        new Rectangle(0, 0, width, height),
        colorIDs
      );
    }
    return this.interactionMap;
  };
  this.clearInteractionMap = function() {
    this.interactionMap = null;
  };
  this.radiusselect = null;
  this.startRadiusSelect = function(centerID, radius) {
    if (!!this.radiusselect) {
      this.endRadiusSelect();
    }
    var centerX = this.markSet.getMarkByID(centerID).attr("x");
    var centerY = this.markSet.getMarkByID(centerID).attr("y");
    this.radiusselect = new PixiRadiusSelect(
      centerID,
      centerX,
      centerY,
      radius,
      3198460
    );
    this.radiusselectContainer.addChild(this.radiusselect);
  };
  this.endRadiusSelect = function() {
    if (!!this.radiusselect) {
      this.radiusselectContainer.removeChild(this.radiusselect);
      this.radiusselect = null;
    }
  };
  this.updateRadiusSelect = function(newRadius) {
    if (!!this.radiusselect) {
      this.radiusselect.radius = newRadius;
    }
  };
  this.multiselect = null;
  this.startMultiselect = function(initialPoint) {
    if (!!this.multiselect)
      this.endMultiselect();
    this.multiselect = new PixiMultiselect(3198460, 3198460);
    this.multiselect.addPoint(initialPoint[0], initialPoint[1]);
    this.multiselectContainer.addChild(this.multiselect);
  };
  this.updateMultiselect = function(newPoint) {
    this.multiselect.addPoint(newPoint[0], newPoint[1]);
  };
  this.endMultiselect = function() {
    if (!!this.multiselect) {
      this.multiselectContainer.removeChild(this.multiselect);
      this.multiselect = null;
    }
  };
  const HiddenMultiselectColor2 = 3158064;
  const HiddenMultiselectRGB = [48, 48, 48];
  this.makeMultiselectMap = function(renderer, width, height) {
    let hiddenMultiselect = new PixiMultiselect(HiddenMultiselectColor2);
    hiddenMultiselect.hidden = true;
    hiddenMultiselect.setPoints(this.multiselect.points);
    hiddenMultiselect.update();
    return new PixiColorIDMap(
      renderer,
      hiddenMultiselect,
      new Rectangle(0, 0, width, height),
      HiddenMultiselectRGB
    );
  };
}
class PixiInMemoryLoader {
  constructor() {
    __publicField(this, "resources", {});
  }
  /**
   * Adds a spritesheet with the given name, loading from the given spritesheet
   * spec JSON object and with the given binary image data.
   * @param {string} name the name of the spritesheet to save
   * @param {object} spritesheetSpec PIXI spritesheet-format JSON object
   * @param {string} imageData raw base-64 encoded image data
   * @param {string} imageFormat the encoding of the image data
   */
  add(name2, spritesheetSpec, imageData, imageFormat = "image/png") {
    let image = new Image();
    image.src = `data:${imageFormat};base64,${imageData}`;
    let baseTexture = new BaseTexture(image);
    let spritesheet = new Spritesheet(baseTexture, spritesheetSpec);
    this.resources[name2] = spritesheet;
    return new Promise((resolve2) => {
      spritesheet.parse(resolve2);
    });
  }
  destroy() {
    Object.values(this.resources).forEach((s) => {
      var baseTex;
      Object.keys(s.textures).forEach((t) => {
        Texture.removeFromCache(t);
        baseTex = s.textures[t].baseTexture;
      });
      BaseTexture.removeFromCache(baseTex);
      s.destroy(true);
    });
    this.resources = {};
  }
}
function create_fragment$i(ctx) {
  let div2;
  return {
    c() {
      div2 = element$2("div");
      set_style(
        div2,
        "background-color",
        /*backgroundColor*/
        ctx[0]
      );
      set_style(div2, "width", "100%");
      set_style(div2, "height", "100%");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      ctx[21](div2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*backgroundColor*/
      1) {
        set_style(
          div2,
          "background-color",
          /*backgroundColor*/
          ctx2[0]
        );
      }
    },
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      ctx[21](null);
    }
  };
}
const renderMargin$1 = 50;
const HiddenMultiselectColor = "rgb(200,200,200)";
function drawOblongHalo(context2, halo, normDistance) {
  normDistance = Math.min(normDistance, 0.95);
  let h = halo * (1 + normDistance);
  let j = (1 - normDistance) * Math.sqrt(h * h - halo * halo);
  let theta = Math.asin(halo / h);
  let s = j * Math.tan(theta);
  let sinTheta = Math.sin(theta);
  let cosTheta = Math.cos(theta);
  if (normDistance < 1e-3) {
    context2.ellipse(0, 0, halo, halo, 0, 2 * Math.PI, false);
  } else {
    context2.arc(0, 0, halo, theta, Math.PI - theta, 2 * Math.PI);
    context2.lineTo(-j * sinTheta, h - j * cosTheta);
    context2.arc(0, h - j * cosTheta - s * sinTheta, s, Math.PI - theta, theta, true);
    context2.lineTo(halo * cosTheta, halo * sinTheta);
  }
}
function instance$i($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let container;
  let { data = null } = $$props;
  let { width = 300 } = $$props;
  let { height = 300 } = $$props;
  let { hidden = false } = $$props;
  let { thumbnail = false } = $$props;
  let { backgroundColor = "white" } = $$props;
  let { pan = false } = $$props;
  let { zoom = false } = $$props;
  let { rFactor = 1 } = $$props;
  let { hiddenDim = 16 } = $$props;
  let { halosEnabled = true } = $$props;
  let { needsDraw = false } = $$props;
  let { frozen = false } = $$props;
  let drawCompletionHandlers = [];
  var canvas;
  function drawWideningLine(context2, x, y, x2, y2, startWidth, endWidth) {
    let start2 = [x, y];
    let end = [x2, y2];
    let path = [end[0] - start2[0], end[1] - start2[1]];
    let normal;
    if (path[1] > 0)
      normal = normalizeVector([path[1], -path[0]]);
    else
      normal = normalizeVector([-path[1], path[0]]);
    context2.moveTo(start2[0] - normal[0] * startWidth / 2, start2[1] - normal[1] * startWidth / 2);
    context2.lineTo(start2[0] + normal[0] * startWidth / 2, start2[1] + normal[1] * startWidth / 2);
    context2.lineTo(end[0] + normal[0] * endWidth / 2, end[1] + normal[1] * endWidth / 2);
    context2.lineTo(end[0] - normal[0] * endWidth / 2, end[1] - normal[1] * endWidth / 2);
  }
  function _draw() {
    $$invalidate(2, needsDraw = false);
    if (!data || !canvas || frozen) {
      return;
    }
    var context2 = canvas.node().getContext("2d");
    context2.clearRect(0, 0, width, height);
    if (hidden) {
      context2.imageSmoothingEnabled = false;
    }
    let haloDecorations = data.decorations.filter((d) => d.type == "halo");
    haloDecorations.sort((d1, d2) => d2.attr("r") - d1.attr("r"));
    haloDecorations.forEach((d, i) => {
      context2.save();
      if (!hidden) {
        let alpha = d.attr("alpha");
        context2.globalAlpha = alpha;
      }
      let x = d.attr("x");
      let y = d.attr("y");
      let r = d.attr("r");
      let lineWidth = d.attr("lineWidth") || 0;
      context2.beginPath();
      context2.ellipse(x, y, r, r, 0, 0, 2 * Math.PI);
      context2.fillStyle = hidden ? d.attr("colorID") : d.attr("color");
      context2.fill();
      if (!hidden && lineWidth > 1e-3) {
        context2.globalAlpha = 1;
        context2.lineWidth = lineWidth;
        context2.strokeStyle = context2.fillStyle;
        context2.stroke();
      }
      context2.restore();
    });
    data.forEach(function(d, i) {
      let x = d.attr("x");
      let y = d.attr("y");
      let halo = d.attr("halo");
      let r = d.attr("r") * rFactor;
      let alpha = d.attr("alpha");
      let x2, y2;
      let fillStyle;
      if (alpha <= 1e-3)
        return;
      if (x < -renderMargin$1 || x > width + renderMargin$1 || y < -renderMargin$1 || y > height + renderMargin$1) {
        if (hidden)
          return;
        x2 = d.attr("x2");
        y2 = d.attr("y2");
        if (Math.max(x, x2) < -renderMargin$1 || Math.min(x, x2) > width + renderMargin$1 || Math.max(y, y2) < -renderMargin$1 || Math.min(y, y2) > height + renderMargin$1)
          return;
      } else if (!hidden) {
        x2 = d.attr("x2");
        y2 = d.attr("y2");
      }
      if (!hidden) {
        context2.globalAlpha = alpha;
        fillStyle = d.attr("fillStyle");
      } else {
        fillStyle = d.attr("colorID");
      }
      if (!hidden) {
        let showDelta = Math.abs(x - x2) >= 0.1 && Math.abs(y - y2) >= 0.1;
        context2.fillStyle = fillStyle;
        let oldAlpha = context2.globalAlpha;
        if (!thumbnail && !!halo && halosEnabled) {
          context2.globalAlpha = 0.1;
          if (showDelta) {
            context2.translate(x, y);
            let haloAngle = Math.atan2(x - x2, y2 - y);
            context2.rotate(haloAngle);
            context2.beginPath();
            let extent = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y)) / (width * 0.7);
            drawOblongHalo(context2, halo, extent);
            context2.fill();
            context2.rotate(-haloAngle);
            context2.translate(-x, -y);
          } else if (halo > 1) {
            context2.beginPath();
            context2.ellipse(x, y, halo, halo, 0, 0, 2 * Math.PI);
            context2.fill();
          }
        } else if (!thumbnail && showDelta) {
          let lineAlpha = d.attr("lineAlpha");
          if (lineAlpha >= 1e-3) {
            context2.save();
            context2.globalAlpha = lineAlpha || 0.1;
            let previewPath = d.attr("previewPath");
            if (!!previewPath && previewPath.length > 0) {
              let previewStartIdx = Math.floor(d.attr("previewPathStart") * previewPath.length);
              let previewEndIdx = Math.floor(d.attr("previewPathEnd") * previewPath.length);
              context2.beginPath();
              let lineWidth = d.attr("lineWidth") * 0.3 || 2;
              context2.moveTo(previewPath[previewStartIdx][0], previewPath[previewStartIdx][1]);
              previewPath.slice(previewStartIdx, previewEndIdx).forEach((point) => context2.lineTo(point[0], point[1]));
              context2.strokeStyle = fillStyle;
              context2.lineWidth = lineWidth;
              context2.stroke();
            } else {
              context2.beginPath();
              let lineWidth = d.attr("lineWidth") * 0.3 || 2;
              drawWideningLine(context2, x, y, x2, y2, r * 0.3, lineWidth);
              context2.fillStyle = fillStyle;
              context2.fill();
            }
            context2.restore();
          }
        }
        context2.globalAlpha = oldAlpha;
      }
      context2.beginPath();
      if (hidden) {
        context2.rect(Math.round(x - hiddenDim / 2), Math.round(y - hiddenDim / 2), Math.round(hiddenDim), Math.round(hiddenDim));
        context2.fillStyle = fillStyle;
        context2.fill();
      } else {
        context2.ellipse(x, y, r, r, 0, 0, 2 * Math.PI);
        context2.globalAlpha *= 0.5;
        context2.fillStyle = fillStyle;
        context2.fill();
        context2.globalAlpha /= 0.5;
        context2.strokeStyle = fillStyle;
        context2.stroke();
      }
    });
    context2.globalAlpha = 1;
    if (!hidden) {
      data.decorations.forEach((d, i) => {
        context2.save();
        let alpha = d.attr("alpha");
        context2.globalAlpha = alpha;
        let x = d.attr("x");
        let y = d.attr("y");
        if (d.type == "outline") {
          let r = d.attr("r");
          context2.beginPath();
          context2.ellipse(x, y, r, r, 0, 0, 2 * Math.PI);
          context2.strokeStyle = d.attr("color");
          context2.lineWidth = d.attr("lineWidth");
          context2.stroke();
        } else if (d.type == "line") {
          let x2 = d.attr("x2");
          let y2 = d.attr("y2");
          context2.beginPath();
          context2.moveTo(x, y);
          context2.lineTo(x2, y2);
          context2.strokeStyle = d.attr("color");
          context2.lineWidth = d.attr("lineWidth");
          context2.lineCap = "round";
          context2.stroke();
        }
        context2.restore();
      });
    }
    if (isMultiselecting) {
      context2.save();
      if (hidden) {
        context2.fillStyle = HiddenMultiselectColor;
      } else {
        context2.fillStyle = "#30cdfc44";
        context2.strokeStyle = "#30cdfc99";
      }
      context2.beginPath();
      context2.moveTo(multiselectPath[multiselectPath.length - 1][0], multiselectPath[multiselectPath.length - 1][1]);
      multiselectPath.slice().reverse().forEach((point) => context2.lineTo(point[0], point[1]));
      context2.fill();
      if (!hidden) {
        context2.lineWidth = 2;
        context2.setLineDash([3, 3]);
        context2.stroke();
      }
      context2.restore();
    }
    context2.globalAlpha = 1;
    drawCompletionHandlers.forEach((d) => d());
    drawCompletionHandlers = [];
  }
  function draw(oncomplete = null) {
    if (!!oncomplete)
      drawCompletionHandlers.push(oncomplete);
    if (hidden)
      _draw();
    else
      $$invalidate(2, needsDraw = true);
  }
  function setFrozen(val) {
    $$invalidate(3, frozen = val);
    if (frozen && !!timer$1)
      timer$1.stop();
    else if (!frozen)
      setupTimer();
  }
  function getColorAtPoint(x, y) {
    var context2 = canvas.node().getContext("2d");
    return context2.getImageData(x * window.devicePixelRatio, y * window.devicePixelRatio, 1, 1).data;
  }
  function pointIsInMultiselect(x, y) {
    if (!hidden) {
      console.error("pointIsInMultiselect only works for hidden canvases");
      return false;
    }
    if (!isMultiselecting)
      return false;
    let color2 = getColorAtPoint(x, y);
    let colKey = "rgb(" + color2[0] + "," + color2[1] + "," + color2[2] + ")";
    return colKey == HiddenMultiselectColor;
  }
  var mouseDown = false;
  var mouseMoved = true;
  var lastX = 0;
  var lastY = 0;
  let { isMultiselecting = false } = $$props;
  let { multiselectPath = [] } = $$props;
  function handleMouseMove(event) {
    mouseMoved = true;
    var rect = event.target.getBoundingClientRect();
    var mouseX = event.clientX - rect.left;
    var mouseY = event.clientY - rect.top;
    if (mouseDown && (event.shiftKey || isMultiselecting)) {
      $$invalidate(4, isMultiselecting = true);
      multiselectPath.push([mouseX, mouseY]);
      draw();
    } else if (mouseDown && !!lastX && !!lastY) {
      var dx = mouseX - lastX;
      var dy = mouseY - lastY;
      dispatch2("translate", { x: -dx, y: -dy });
    }
    lastX = mouseX;
    lastY = mouseY;
  }
  function handleMouseWheel(event) {
    if (!zoom)
      return;
    var ds;
    if (!!event.wheelDelta) {
      ds = 0.01 * event.wheelDelta;
    } else if (!!event.detail) {
      ds = -0.01 * event.detail;
    }
    var rect = event.target.getBoundingClientRect();
    var mouseX = event.clientX - rect.left;
    var mouseY = event.clientY - rect.top;
    dispatch2("scale", { ds, centerPoint: [mouseX, mouseY] });
    event.preventDefault();
  }
  function initializeCanvas(selector2) {
    $$invalidate(20, canvas = select$1(selector2).append("canvas").style("background-color", "transparent").on("mousedown", (e) => {
      mouseDown = true;
      mouseMoved = false;
      dispatch2("mousedown", e);
    }).on("mouseup", (e) => {
      lastX = 0;
      lastY = 0;
      if (isMultiselecting) {
        dispatch2("multiselect", multiselectPath);
        $$invalidate(4, isMultiselecting = false);
        $$invalidate(5, multiselectPath = []);
        draw();
      } else if (!mouseMoved && mouseDown) {
        dispatch2("click", e);
      }
      mouseDown = false;
      setTimeout(() => mouseMoved = false);
      dispatch2("mouseup", e);
    }).on("mouseover", (e) => {
      dispatch2("mouseover", e);
    }).on("mouseout", (e) => {
      dispatch2("mouseout", e);
    }).on("mousemove", (e) => {
      if ((pan || zoom) && mouseDown) {
        handleMouseMove(e);
      } else {
        dispatch2("mousemove", e);
      }
    }).on("mousewheel", handleMouseWheel).on("DOMMouseScroll", handleMouseWheel).on("MozMousePixelScroll", (e) => e.preventDefault()));
    scaleCanvas(canvas, width, height);
    if (hidden) {
      canvas.style("display", "none");
    }
  }
  let timer$1;
  function setupTimer() {
    if (hidden)
      return;
    timer$1 = timer(() => {
      if (needsDraw)
        _draw();
    });
  }
  onMount(() => {
    initializeCanvas(container);
    setupTimer();
  });
  onDestroy(() => {
    if (!!timer$1)
      timer$1.stop();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(1, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(6, data = $$props2.data);
    if ("width" in $$props2)
      $$invalidate(7, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(8, height = $$props2.height);
    if ("hidden" in $$props2)
      $$invalidate(9, hidden = $$props2.hidden);
    if ("thumbnail" in $$props2)
      $$invalidate(10, thumbnail = $$props2.thumbnail);
    if ("backgroundColor" in $$props2)
      $$invalidate(0, backgroundColor = $$props2.backgroundColor);
    if ("pan" in $$props2)
      $$invalidate(11, pan = $$props2.pan);
    if ("zoom" in $$props2)
      $$invalidate(12, zoom = $$props2.zoom);
    if ("rFactor" in $$props2)
      $$invalidate(13, rFactor = $$props2.rFactor);
    if ("hiddenDim" in $$props2)
      $$invalidate(14, hiddenDim = $$props2.hiddenDim);
    if ("halosEnabled" in $$props2)
      $$invalidate(15, halosEnabled = $$props2.halosEnabled);
    if ("needsDraw" in $$props2)
      $$invalidate(2, needsDraw = $$props2.needsDraw);
    if ("frozen" in $$props2)
      $$invalidate(3, frozen = $$props2.frozen);
    if ("isMultiselecting" in $$props2)
      $$invalidate(4, isMultiselecting = $$props2.isMultiselecting);
    if ("multiselectPath" in $$props2)
      $$invalidate(5, multiselectPath = $$props2.multiselectPath);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*canvas, width, height*/
    1048960) {
      {
        if (!!canvas) {
          scaleCanvas(canvas, width, height);
          draw();
        }
      }
    }
    if ($$self.$$.dirty[0] & /*data*/
    64) {
      {
        if (!!data) {
          draw();
        }
      }
    }
    if ($$self.$$.dirty[0] & /*backgroundColor*/
    1) {
      {
        if (!!backgroundColor) {
          draw();
        }
      }
    }
  };
  return [
    backgroundColor,
    container,
    needsDraw,
    frozen,
    isMultiselecting,
    multiselectPath,
    data,
    width,
    height,
    hidden,
    thumbnail,
    pan,
    zoom,
    rFactor,
    hiddenDim,
    halosEnabled,
    draw,
    setFrozen,
    getColorAtPoint,
    pointIsInMultiselect,
    canvas,
    div_binding
  ];
}
class D3Canvas extends SvelteComponent {
  constructor(options) {
    super();
    init$2(
      this,
      options,
      instance$i,
      create_fragment$i,
      safe_not_equal,
      {
        data: 6,
        width: 7,
        height: 8,
        hidden: 9,
        thumbnail: 10,
        backgroundColor: 0,
        pan: 11,
        zoom: 12,
        rFactor: 13,
        hiddenDim: 14,
        halosEnabled: 15,
        needsDraw: 2,
        frozen: 3,
        draw: 16,
        setFrozen: 17,
        getColorAtPoint: 18,
        pointIsInMultiselect: 19,
        isMultiselecting: 4,
        multiselectPath: 5
      },
      null,
      [-1, -1]
    );
  }
  get data() {
    return this.$$.ctx[6];
  }
  set data(data) {
    this.$$set({ data });
    flush();
  }
  get width() {
    return this.$$.ctx[7];
  }
  set width(width) {
    this.$$set({ width });
    flush();
  }
  get height() {
    return this.$$.ctx[8];
  }
  set height(height) {
    this.$$set({ height });
    flush();
  }
  get hidden() {
    return this.$$.ctx[9];
  }
  set hidden(hidden) {
    this.$$set({ hidden });
    flush();
  }
  get thumbnail() {
    return this.$$.ctx[10];
  }
  set thumbnail(thumbnail) {
    this.$$set({ thumbnail });
    flush();
  }
  get backgroundColor() {
    return this.$$.ctx[0];
  }
  set backgroundColor(backgroundColor) {
    this.$$set({ backgroundColor });
    flush();
  }
  get pan() {
    return this.$$.ctx[11];
  }
  set pan(pan) {
    this.$$set({ pan });
    flush();
  }
  get zoom() {
    return this.$$.ctx[12];
  }
  set zoom(zoom) {
    this.$$set({ zoom });
    flush();
  }
  get rFactor() {
    return this.$$.ctx[13];
  }
  set rFactor(rFactor) {
    this.$$set({ rFactor });
    flush();
  }
  get hiddenDim() {
    return this.$$.ctx[14];
  }
  set hiddenDim(hiddenDim) {
    this.$$set({ hiddenDim });
    flush();
  }
  get halosEnabled() {
    return this.$$.ctx[15];
  }
  set halosEnabled(halosEnabled) {
    this.$$set({ halosEnabled });
    flush();
  }
  get needsDraw() {
    return this.$$.ctx[2];
  }
  set needsDraw(needsDraw) {
    this.$$set({ needsDraw });
    flush();
  }
  get frozen() {
    return this.$$.ctx[3];
  }
  set frozen(frozen) {
    this.$$set({ frozen });
    flush();
  }
  get draw() {
    return this.$$.ctx[16];
  }
  get setFrozen() {
    return this.$$.ctx[17];
  }
  get getColorAtPoint() {
    return this.$$.ctx[18];
  }
  get pointIsInMultiselect() {
    return this.$$.ctx[19];
  }
  get isMultiselecting() {
    return this.$$.ctx[4];
  }
  set isMultiselecting(isMultiselecting) {
    this.$$set({ isMultiselecting });
    flush();
  }
  get multiselectPath() {
    return this.$$.ctx[5];
  }
  set multiselectPath(multiselectPath) {
    this.$$set({ multiselectPath });
    flush();
  }
}
function create_fragment$h(ctx) {
  let div2;
  return {
    c() {
      div2 = element$2("div");
      set_style(
        div2,
        "background-color",
        /*backgroundColor*/
        ctx[0]
      );
      attr(div2, "id", "hover-text-canvas-container");
      attr(div2, "class", "svelte-gfivvs");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      ctx[7](div2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*backgroundColor*/
      1) {
        set_style(
          div2,
          "background-color",
          /*backgroundColor*/
          ctx2[0]
        );
      }
    },
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      ctx[7](null);
    }
  };
}
const renderMargin = 50;
function instance$h($$self, $$props, $$invalidate) {
  createEventDispatcher();
  let container;
  let { data = null } = $$props;
  let { width = 300 } = $$props;
  let { height = 300 } = $$props;
  let { backgroundColor = "transparent" } = $$props;
  var canvas;
  let needsDraw = false;
  let cachedPriorities = {};
  let decorationsMap = {};
  let drawOrder = [];
  function recomputeDrawOrder() {
    if (!data || data.marks.length == 0) {
      drawOrder = [];
      return;
    }
    drawOrder = Object.keys(cachedPriorities).filter((id2) => cachedPriorities[id2] != null);
    drawOrder.sort((id1, id2) => cachedPriorities[id2] - cachedPriorities[id1]);
    drawOrder = drawOrder.map((id2) => decorationsMap[id2]);
  }
  function hasTextAtPoint(x, y, debug = false) {
    var context2 = canvas.node().getContext("2d");
    let color2 = context2.getImageData(Math.round(x) * window.devicePixelRatio, Math.round(y) * window.devicePixelRatio, 1, 1).data;
    if (debug) {
      console.log(x, y, color2);
    }
    return color2[3] > 0;
  }
  function _draw() {
    needsDraw = false;
    if (!data || !canvas) {
      return;
    }
    var context2 = canvas.node().getContext("2d");
    context2.clearRect(0, 0, width, height);
    let changed = false;
    decorationsMap = {};
    let seenIDs = /* @__PURE__ */ new Set();
    let newPriorities = {};
    data.decorations.forEach((d) => {
      if (d.type != "text")
        return;
      let newValue = d.attr("priority");
      let mark = d.marks[0];
      decorationsMap[mark.id] = d;
      if (newValue != cachedPriorities[mark.id])
        changed = true;
      newPriorities[mark.id] = newValue;
      seenIDs.add(mark.id);
    });
    Object.keys(cachedPriorities).forEach((id2) => {
      if (!seenIDs.has(id2))
        changed = true;
    });
    cachedPriorities = newPriorities;
    if (changed)
      recomputeDrawOrder();
    drawOrder.forEach((d) => {
      let hoverText = d.attr("text");
      let x = d.attr("x");
      let y = d.attr("y");
      if (x < -renderMargin || x > width + renderMargin || y < -renderMargin || y > height + renderMargin)
        return;
      if (!hoverText)
        return;
      context2.save();
      context2.globalAlpha = 0.9;
      context2.fillStyle = "white";
      let textWidth = context2.measureText(hoverText).width;
      let fontSize = 9;
      let padding = 3;
      let startX = x - textWidth / 2 - padding;
      let startY = y - (10 + fontSize + padding);
      if (hasTextAtPoint(startX, startY) || hasTextAtPoint(startX + textWidth / 2 + padding, startY) || hasTextAtPoint(startX + textWidth + padding * 2, startY) || hasTextAtPoint(startX, startY + fontSize + padding * 2) || hasTextAtPoint(startX + textWidth / 2 + padding, startY + fontSize + padding * 2) || hasTextAtPoint(startX + textWidth + padding * 2, startY + fontSize + padding * 2)) {
        return;
      }
      context2.fillRect(startX, startY, textWidth + padding * 2, fontSize + padding * 2);
      context2.globalAlpha = 1;
      context2.font = `${fontSize * (d.attr("textScale") || 1)}pt Arial`;
      context2.textAlign = "center";
      context2.fillStyle = d.attr("color") || "black";
      context2.fillText(hoverText, x, y - 10);
      context2.restore();
    });
  }
  function draw() {
    needsDraw = true;
  }
  function initializeCanvas(selector2) {
    $$invalidate(6, canvas = select$1(selector2).append("canvas").style("pointer-events", "none"));
    scaleCanvas(canvas, width, height);
  }
  let timer$1;
  onMount(() => {
    initializeCanvas(container);
    timer$1 = timer(() => {
      if (needsDraw)
        _draw();
    });
  });
  onDestroy(() => {
    if (!!timer$1)
      timer$1.stop();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(1, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(2, data = $$props2.data);
    if ("width" in $$props2)
      $$invalidate(3, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("backgroundColor" in $$props2)
      $$invalidate(0, backgroundColor = $$props2.backgroundColor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*canvas, width, height*/
    88) {
      {
        if (!!canvas) {
          scaleCanvas(canvas, width, height);
          draw();
        }
      }
    }
    if ($$self.$$.dirty & /*data*/
    4) {
      {
        if (!!data) {
          draw();
        }
      }
    }
    if ($$self.$$.dirty & /*backgroundColor*/
    1) {
      {
        if (!!backgroundColor) {
          draw();
        }
      }
    }
  };
  return [backgroundColor, container, data, width, height, draw, canvas, div_binding];
}
class LabelCanvas extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$h, create_fragment$h, safe_not_equal, {
      data: 2,
      width: 3,
      height: 4,
      backgroundColor: 0,
      draw: 5
    });
  }
  get data() {
    return this.$$.ctx[2];
  }
  set data(data) {
    this.$$set({ data });
    flush();
  }
  get width() {
    return this.$$.ctx[3];
  }
  set width(width) {
    this.$$set({ width });
    flush();
  }
  get height() {
    return this.$$.ctx[4];
  }
  set height(height) {
    this.$$set({ height });
    flush();
  }
  get backgroundColor() {
    return this.$$.ctx[0];
  }
  set backgroundColor(backgroundColor) {
    this.$$set({ backgroundColor });
    flush();
  }
  get draw() {
    return this.$$.ctx[5];
  }
}
function create_if_block$8(ctx) {
  let d3canvas;
  let t;
  let labelcanvas;
  let current;
  let d3canvas_props = {
    width: (
      /*actualWidth*/
      ctx[20]
    ),
    height: (
      /*actualHeight*/
      ctx[21]
    ),
    data: (
      /*marks*/
      ctx[16]
    ),
    rFactor: (
      /*rFactor*/
      ctx[9]
    ),
    hidden: true
  };
  d3canvas = new D3Canvas({ props: d3canvas_props });
  ctx[58](d3canvas);
  let labelcanvas_props = {
    width: (
      /*actualWidth*/
      ctx[20]
    ),
    height: (
      /*actualHeight*/
      ctx[21]
    ),
    data: (
      /*marks*/
      ctx[16]
    )
  };
  labelcanvas = new LabelCanvas({ props: labelcanvas_props });
  ctx[59](labelcanvas);
  return {
    c() {
      create_component(d3canvas.$$.fragment);
      t = space();
      create_component(labelcanvas.$$.fragment);
    },
    m(target, anchor) {
      mount_component(d3canvas, target, anchor);
      insert(target, t, anchor);
      mount_component(labelcanvas, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const d3canvas_changes = {};
      if (dirty[0] & /*actualWidth*/
      1048576)
        d3canvas_changes.width = /*actualWidth*/
        ctx2[20];
      if (dirty[0] & /*actualHeight*/
      2097152)
        d3canvas_changes.height = /*actualHeight*/
        ctx2[21];
      if (dirty[0] & /*marks*/
      65536)
        d3canvas_changes.data = /*marks*/
        ctx2[16];
      if (dirty[0] & /*rFactor*/
      512)
        d3canvas_changes.rFactor = /*rFactor*/
        ctx2[9];
      d3canvas.$set(d3canvas_changes);
      const labelcanvas_changes = {};
      if (dirty[0] & /*actualWidth*/
      1048576)
        labelcanvas_changes.width = /*actualWidth*/
        ctx2[20];
      if (dirty[0] & /*actualHeight*/
      2097152)
        labelcanvas_changes.height = /*actualHeight*/
        ctx2[21];
      if (dirty[0] & /*marks*/
      65536)
        labelcanvas_changes.data = /*marks*/
        ctx2[16];
      labelcanvas.$set(labelcanvas_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(d3canvas.$$.fragment, local);
      transition_in(labelcanvas.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(d3canvas.$$.fragment, local);
      transition_out(labelcanvas.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      ctx[58](null);
      destroy_component(d3canvas, detaching);
      ctx[59](null);
      destroy_component(labelcanvas, detaching);
    }
  };
}
function create_fragment$g(ctx) {
  let div2;
  let scatterplotstate;
  let updating_marks;
  let updating_hoveredID;
  let updating_selectedIDs;
  let updating_alignedIDs;
  let updating_previewProgress;
  let t0;
  let scatterplotviewportstate;
  let t1;
  let d3canvas;
  let t2;
  let current;
  function scatterplotstate_marks_binding(value) {
    ctx[48](value);
  }
  function scatterplotstate_hoveredID_binding(value) {
    ctx[49](value);
  }
  function scatterplotstate_selectedIDs_binding(value) {
    ctx[50](value);
  }
  function scatterplotstate_alignedIDs_binding(value) {
    ctx[51](value);
  }
  function scatterplotstate_previewProgress_binding(value) {
    ctx[52](value);
  }
  let scatterplotstate_props = {
    thumbnail: (
      /*thumbnail*/
      ctx[8]
    ),
    data: (
      /*data*/
      ctx[14]
    ),
    colorMap: (
      /*colorMap*/
      ctx[25]
    ),
    frame: (
      /*frame*/
      ctx[11]
    ),
    previewFrame: (
      /*previewFrame*/
      ctx[12]
    ),
    previewInfo: (
      /*previewInfo*/
      ctx[13]
    ),
    colorScale: (
      /*func*/
      ctx[44]
    ),
    xScale: (
      /*func_1*/
      ctx[45]
    ),
    yScale: (
      /*func_2*/
      ctx[46]
    )
  };
  if (
    /*marks*/
    ctx[16] !== void 0
  ) {
    scatterplotstate_props.marks = /*marks*/
    ctx[16];
  }
  if (
    /*hoveredID*/
    ctx[1] !== void 0
  ) {
    scatterplotstate_props.hoveredID = /*hoveredID*/
    ctx[1];
  }
  if (
    /*clickedIDs*/
    ctx[2] !== void 0
  ) {
    scatterplotstate_props.selectedIDs = /*clickedIDs*/
    ctx[2];
  }
  if (
    /*alignedIDs*/
    ctx[3] !== void 0
  ) {
    scatterplotstate_props.alignedIDs = /*alignedIDs*/
    ctx[3];
  }
  if (
    /*previewProgress*/
    ctx[0] !== void 0
  ) {
    scatterplotstate_props.previewProgress = /*previewProgress*/
    ctx[0];
  }
  scatterplotstate = new ScatterplotState({ props: scatterplotstate_props });
  ctx[47](scatterplotstate);
  binding_callbacks.push(() => bind$4(scatterplotstate, "marks", scatterplotstate_marks_binding));
  binding_callbacks.push(() => bind$4(scatterplotstate, "hoveredID", scatterplotstate_hoveredID_binding));
  binding_callbacks.push(() => bind$4(scatterplotstate, "selectedIDs", scatterplotstate_selectedIDs_binding));
  binding_callbacks.push(() => bind$4(scatterplotstate, "alignedIDs", scatterplotstate_alignedIDs_binding));
  binding_callbacks.push(() => bind$4(scatterplotstate, "previewProgress", scatterplotstate_previewProgress_binding));
  let scatterplotviewportstate_props = {
    width: (
      /*actualWidth*/
      ctx[20]
    ),
    height: (
      /*actualHeight*/
      ctx[21]
    ),
    xExtent: !!/*data*/
    ctx[14] ? (
      /*data*/
      ctx[14].getXExtent()
    ) : null,
    yExtent: !!/*data*/
    ctx[14] ? (
      /*data*/
      ctx[14].getYExtent()
    ) : null,
    padding: (
      /*padding*/
      ctx[4]
    ),
    followingMarks: (
      /*followingMarks*/
      ctx[22]
    ),
    thumbnail: (
      /*thumbnail*/
      ctx[8]
    )
  };
  scatterplotviewportstate = new ScatterplotViewportState({ props: scatterplotviewportstate_props });
  ctx[53](scatterplotviewportstate);
  scatterplotviewportstate.$on(
    "update",
    /*rescale*/
    ctx[33]
  );
  let d3canvas_props = {
    thumbnail: (
      /*thumbnail*/
      ctx[8]
    ),
    width: (
      /*actualWidth*/
      ctx[20]
    ),
    height: (
      /*actualHeight*/
      ctx[21]
    ),
    data: (
      /*marks*/
      ctx[16]
    ),
    pan: !/*thumbnail*/
    ctx[8],
    zoom: !/*thumbnail*/
    ctx[8],
    rFactor: (
      /*rFactor*/
      ctx[9]
    ),
    backgroundColor: "transparent"
  };
  d3canvas = new D3Canvas({ props: d3canvas_props });
  ctx[54](d3canvas);
  d3canvas.$on(
    "click",
    /*click_handler*/
    ctx[55]
  );
  d3canvas.$on(
    "mousemove",
    /*onMousemove*/
    ctx[30]
  );
  d3canvas.$on(
    "mouseover",
    /*onMouseover*/
    ctx[26]
  );
  d3canvas.$on(
    "mousedown",
    /*onMousedown*/
    ctx[27]
  );
  d3canvas.$on(
    "mouseup",
    /*onMouseup*/
    ctx[28]
  );
  d3canvas.$on(
    "mouseout",
    /*onMouseout*/
    ctx[29]
  );
  d3canvas.$on(
    "click",
    /*onClick*/
    ctx[31]
  );
  d3canvas.$on(
    "multiselect",
    /*onMultiselect*/
    ctx[32]
  );
  d3canvas.$on(
    "scale",
    /*scale_handler*/
    ctx[56]
  );
  d3canvas.$on(
    "translate",
    /*translate_handler*/
    ctx[57]
  );
  let if_block = (
    /*hoverable*/
    ctx[7] && create_if_block$8(ctx)
  );
  return {
    c() {
      div2 = element$2("div");
      create_component(scatterplotstate.$$.fragment);
      t0 = space();
      create_component(scatterplotviewportstate.$$.fragment);
      t1 = space();
      create_component(d3canvas.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      set_style(
        div2,
        "width",
        /*width*/
        ctx[5] != null ? `${/*width*/
        ctx[5]}px` : "100%"
      );
      set_style(
        div2,
        "height",
        /*height*/
        ctx[6] != null ? `${/*height*/
        ctx[6]}px` : "100%"
      );
      attr(div2, "id", "container");
      attr(div2, "class", "svelte-3e4cq4");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(scatterplotstate, div2, null);
      append(div2, t0);
      mount_component(scatterplotviewportstate, div2, null);
      append(div2, t1);
      mount_component(d3canvas, div2, null);
      append(div2, t2);
      if (if_block)
        if_block.m(div2, null);
      ctx[60](div2);
      current = true;
    },
    p(ctx2, dirty) {
      const scatterplotstate_changes = {};
      if (dirty[0] & /*thumbnail*/
      256)
        scatterplotstate_changes.thumbnail = /*thumbnail*/
        ctx2[8];
      if (dirty[0] & /*data*/
      16384)
        scatterplotstate_changes.data = /*data*/
        ctx2[14];
      if (dirty[0] & /*frame*/
      2048)
        scatterplotstate_changes.frame = /*frame*/
        ctx2[11];
      if (dirty[0] & /*previewFrame*/
      4096)
        scatterplotstate_changes.previewFrame = /*previewFrame*/
        ctx2[12];
      if (dirty[0] & /*previewInfo*/
      8192)
        scatterplotstate_changes.previewInfo = /*previewInfo*/
        ctx2[13];
      if (dirty[0] & /*colorScale*/
      1024)
        scatterplotstate_changes.colorScale = /*func*/
        ctx2[44];
      if (dirty[0] & /*viewportManager*/
      8388608)
        scatterplotstate_changes.xScale = /*func_1*/
        ctx2[45];
      if (dirty[0] & /*viewportManager*/
      8388608)
        scatterplotstate_changes.yScale = /*func_2*/
        ctx2[46];
      if (!updating_marks && dirty[0] & /*marks*/
      65536) {
        updating_marks = true;
        scatterplotstate_changes.marks = /*marks*/
        ctx2[16];
        add_flush_callback(() => updating_marks = false);
      }
      if (!updating_hoveredID && dirty[0] & /*hoveredID*/
      2) {
        updating_hoveredID = true;
        scatterplotstate_changes.hoveredID = /*hoveredID*/
        ctx2[1];
        add_flush_callback(() => updating_hoveredID = false);
      }
      if (!updating_selectedIDs && dirty[0] & /*clickedIDs*/
      4) {
        updating_selectedIDs = true;
        scatterplotstate_changes.selectedIDs = /*clickedIDs*/
        ctx2[2];
        add_flush_callback(() => updating_selectedIDs = false);
      }
      if (!updating_alignedIDs && dirty[0] & /*alignedIDs*/
      8) {
        updating_alignedIDs = true;
        scatterplotstate_changes.alignedIDs = /*alignedIDs*/
        ctx2[3];
        add_flush_callback(() => updating_alignedIDs = false);
      }
      if (!updating_previewProgress && dirty[0] & /*previewProgress*/
      1) {
        updating_previewProgress = true;
        scatterplotstate_changes.previewProgress = /*previewProgress*/
        ctx2[0];
        add_flush_callback(() => updating_previewProgress = false);
      }
      scatterplotstate.$set(scatterplotstate_changes);
      const scatterplotviewportstate_changes = {};
      if (dirty[0] & /*actualWidth*/
      1048576)
        scatterplotviewportstate_changes.width = /*actualWidth*/
        ctx2[20];
      if (dirty[0] & /*actualHeight*/
      2097152)
        scatterplotviewportstate_changes.height = /*actualHeight*/
        ctx2[21];
      if (dirty[0] & /*data*/
      16384)
        scatterplotviewportstate_changes.xExtent = !!/*data*/
        ctx2[14] ? (
          /*data*/
          ctx2[14].getXExtent()
        ) : null;
      if (dirty[0] & /*data*/
      16384)
        scatterplotviewportstate_changes.yExtent = !!/*data*/
        ctx2[14] ? (
          /*data*/
          ctx2[14].getYExtent()
        ) : null;
      if (dirty[0] & /*padding*/
      16)
        scatterplotviewportstate_changes.padding = /*padding*/
        ctx2[4];
      if (dirty[0] & /*followingMarks*/
      4194304)
        scatterplotviewportstate_changes.followingMarks = /*followingMarks*/
        ctx2[22];
      if (dirty[0] & /*thumbnail*/
      256)
        scatterplotviewportstate_changes.thumbnail = /*thumbnail*/
        ctx2[8];
      scatterplotviewportstate.$set(scatterplotviewportstate_changes);
      const d3canvas_changes = {};
      if (dirty[0] & /*thumbnail*/
      256)
        d3canvas_changes.thumbnail = /*thumbnail*/
        ctx2[8];
      if (dirty[0] & /*actualWidth*/
      1048576)
        d3canvas_changes.width = /*actualWidth*/
        ctx2[20];
      if (dirty[0] & /*actualHeight*/
      2097152)
        d3canvas_changes.height = /*actualHeight*/
        ctx2[21];
      if (dirty[0] & /*marks*/
      65536)
        d3canvas_changes.data = /*marks*/
        ctx2[16];
      if (dirty[0] & /*thumbnail*/
      256)
        d3canvas_changes.pan = !/*thumbnail*/
        ctx2[8];
      if (dirty[0] & /*thumbnail*/
      256)
        d3canvas_changes.zoom = !/*thumbnail*/
        ctx2[8];
      if (dirty[0] & /*rFactor*/
      512)
        d3canvas_changes.rFactor = /*rFactor*/
        ctx2[9];
      d3canvas.$set(d3canvas_changes);
      if (
        /*hoverable*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*hoverable*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*width*/
      32) {
        set_style(
          div2,
          "width",
          /*width*/
          ctx2[5] != null ? `${/*width*/
          ctx2[5]}px` : "100%"
        );
      }
      if (!current || dirty[0] & /*height*/
      64) {
        set_style(
          div2,
          "height",
          /*height*/
          ctx2[6] != null ? `${/*height*/
          ctx2[6]}px` : "100%"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(scatterplotstate.$$.fragment, local);
      transition_in(scatterplotviewportstate.$$.fragment, local);
      transition_in(d3canvas.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(scatterplotstate.$$.fragment, local);
      transition_out(scatterplotviewportstate.$$.fragment, local);
      transition_out(d3canvas.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      ctx[47](null);
      destroy_component(scatterplotstate);
      ctx[53](null);
      destroy_component(scatterplotviewportstate);
      ctx[54](null);
      destroy_component(d3canvas);
      if (if_block)
        if_block.d();
      ctx[60](null);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { padding = 0.3 } = $$props;
  let { width = null } = $$props;
  let { height = null } = $$props;
  let { hoverable = false } = $$props;
  let { thumbnail = false } = $$props;
  let { rFactor = 1 } = $$props;
  let { colorScale = (c2) => c2 } = $$props;
  let { frame: frame2 = null } = $$props;
  let { previewFrame = null } = $$props;
  let { previewInfo = null } = $$props;
  let { previewProgress = 0 } = $$props;
  let { hoveredID = null } = $$props;
  let { clickedIDs = [] } = $$props;
  let { alignedIDs = [] } = $$props;
  let { filter: filter2 = /* @__PURE__ */ new Set() } = $$props;
  let { followingIDs = [] } = $$props;
  let { data = null } = $$props;
  let { animateTransitions = false } = $$props;
  let { scalesNeutral = true } = $$props;
  let { thumbnailsURL = null } = $$props;
  const dispatch2 = createEventDispatcher();
  let container;
  let actualWidth = null;
  let actualHeight = null;
  let colorMap = new ColorIDMap();
  let followingMarks = [];
  var marks = null;
  let stateManager;
  let viewportManager;
  let timer$1;
  let currentTime = 0;
  let oldData = null;
  let oldColorScale = null;
  onMount(() => {
    if (animateTransitions) {
      timer$1 = timer((elapsed) => {
        let dt = elapsed - currentTime;
        currentTime = elapsed;
        let update2 = !!viewportManager ? viewportManager.advance(dt) : false;
        update2 = !!marks && marks.advance(dt) || update2;
        if (update2) {
          canvas.draw();
          if (!!labelCanvas)
            labelCanvas.draw();
        }
      });
    }
    window.addEventListener("resize", handleResize);
  });
  onDestroy(() => {
    if (!!timer$1) {
      timer$1.stop();
      timer$1 = null;
    }
  });
  var canvas;
  var hiddenCanvas;
  var labelCanvas;
  function onMouseover() {
    dispatch2("mouseover");
  }
  function onMousedown() {
    dispatch2("mousedown");
  }
  function onMouseup() {
    dispatch2("mouseup");
  }
  function onMouseout() {
    if (thumbnail) {
      dispatch2("mouseout");
    } else if (hoveredID != null) {
      $$invalidate(1, hoveredID = null);
      dispatch2("datahover", hoveredID);
    }
  }
  function getElementAtPoint(x, y) {
    if (!colorMap)
      return null;
    var color2 = hiddenCanvas.getColorAtPoint(x, y);
    var colKey = "rgb(" + color2[0] + "," + color2[1] + "," + color2[2] + ")";
    return colorMap.obj(colKey);
  }
  function selectPoint(pointID, multi = false) {
    if (!stateManager)
      return;
    stateManager.selectElement({ type: "mark", id: pointID }, multi);
  }
  function onMousemove(info) {
    if (!hoverable)
      return;
    hiddenCanvas.draw();
    var e = info.detail;
    var rect = e.target.getBoundingClientRect();
    var mouseX = e.clientX - rect.left;
    var mouseY = e.clientY - rect.top;
    var hoveredElement = getElementAtPoint(mouseX, mouseY);
    let newHoveredID = !!hoveredElement && hoveredElement.type == "mark" ? hoveredElement.id : null;
    if (newHoveredID != hoveredID) {
      $$invalidate(1, hoveredID = newHoveredID);
      dispatch2("datahover", hoveredID);
    }
  }
  function onClick(info) {
    if (!hoverable)
      return;
    var e = info.detail;
    var rect = e.target.getBoundingClientRect();
    var mouseX = e.clientX - rect.left;
    var mouseY = e.clientY - rect.top;
    var el = getElementAtPoint(mouseX, mouseY);
    stateManager.selectElement(el, e.shiftKey);
  }
  function onMultiselect(info) {
    if (!hoverable)
      return;
    var points = info.detail;
    $$invalidate(24, hiddenCanvas.isMultiselecting = true, hiddenCanvas);
    $$invalidate(24, hiddenCanvas.multiselectPath = points, hiddenCanvas);
    hiddenCanvas.draw();
    $$invalidate(2, clickedIDs = marks.filter((mark) => {
      if (mark.attr("alpha") < 0.01)
        return false;
      let x = Math.round(mark.attr("x"));
      let y = Math.round(mark.attr("y"));
      return hiddenCanvas.pointIsInMultiselect(x, y);
    }).map((mark) => mark.id));
    dispatch2("dataclick", clickedIDs);
    $$invalidate(24, hiddenCanvas.isMultiselecting = false, hiddenCanvas);
    $$invalidate(24, hiddenCanvas.multiselectPath = [], hiddenCanvas);
    hiddenCanvas.draw();
  }
  function animateDatasetUpdate() {
    stateManager.animateDatasetUpdate();
  }
  function rescale() {
    $$invalidate(34, scalesNeutral = viewportManager.scalesNeutral);
    if (!!canvas)
      canvas.draw();
    if (!!hiddenCanvas)
      hiddenCanvas.draw();
  }
  function reset() {
    viewportManager.resetAxisScales();
  }
  function handleResize() {
    if (!container)
      return;
    $$invalidate(20, actualWidth = container.clientWidth);
    $$invalidate(21, actualHeight = container.clientHeight);
  }
  const func2 = (c2) => colorScale(c2);
  const func_1 = (x) => viewportManager.scaleX(x);
  const func_2 = (y) => viewportManager.scaleY(y);
  function scatterplotstate_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      stateManager = $$value;
      $$invalidate(17, stateManager);
    });
  }
  function scatterplotstate_marks_binding(value) {
    marks = value;
    $$invalidate(16, marks);
  }
  function scatterplotstate_hoveredID_binding(value) {
    hoveredID = value;
    $$invalidate(1, hoveredID);
  }
  function scatterplotstate_selectedIDs_binding(value) {
    clickedIDs = value;
    $$invalidate(2, clickedIDs);
  }
  function scatterplotstate_alignedIDs_binding(value) {
    alignedIDs = value;
    $$invalidate(3, alignedIDs);
  }
  function scatterplotstate_previewProgress_binding(value) {
    previewProgress = value;
    $$invalidate(0, previewProgress);
  }
  function scatterplotviewportstate_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      viewportManager = $$value;
      $$invalidate(23, viewportManager);
    });
  }
  function d3canvas_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      canvas = $$value;
      $$invalidate(18, canvas);
    });
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  const scale_handler = (e) => {
    viewportManager.scaleBy(e.detail.ds, e.detail.centerPoint);
  };
  const translate_handler = (e) => {
    viewportManager.translateBy(e.detail.x, e.detail.y);
  };
  function d3canvas_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      hiddenCanvas = $$value;
      $$invalidate(24, hiddenCanvas);
    });
  }
  function labelcanvas_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      labelCanvas = $$value;
      $$invalidate(19, labelCanvas);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(15, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("padding" in $$props2)
      $$invalidate(4, padding = $$props2.padding);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(6, height = $$props2.height);
    if ("hoverable" in $$props2)
      $$invalidate(7, hoverable = $$props2.hoverable);
    if ("thumbnail" in $$props2)
      $$invalidate(8, thumbnail = $$props2.thumbnail);
    if ("rFactor" in $$props2)
      $$invalidate(9, rFactor = $$props2.rFactor);
    if ("colorScale" in $$props2)
      $$invalidate(10, colorScale = $$props2.colorScale);
    if ("frame" in $$props2)
      $$invalidate(11, frame2 = $$props2.frame);
    if ("previewFrame" in $$props2)
      $$invalidate(12, previewFrame = $$props2.previewFrame);
    if ("previewInfo" in $$props2)
      $$invalidate(13, previewInfo = $$props2.previewInfo);
    if ("previewProgress" in $$props2)
      $$invalidate(0, previewProgress = $$props2.previewProgress);
    if ("hoveredID" in $$props2)
      $$invalidate(1, hoveredID = $$props2.hoveredID);
    if ("clickedIDs" in $$props2)
      $$invalidate(2, clickedIDs = $$props2.clickedIDs);
    if ("alignedIDs" in $$props2)
      $$invalidate(3, alignedIDs = $$props2.alignedIDs);
    if ("filter" in $$props2)
      $$invalidate(35, filter2 = $$props2.filter);
    if ("followingIDs" in $$props2)
      $$invalidate(36, followingIDs = $$props2.followingIDs);
    if ("data" in $$props2)
      $$invalidate(14, data = $$props2.data);
    if ("animateTransitions" in $$props2)
      $$invalidate(37, animateTransitions = $$props2.animateTransitions);
    if ("scalesNeutral" in $$props2)
      $$invalidate(34, scalesNeutral = $$props2.scalesNeutral);
    if ("thumbnailsURL" in $$props2)
      $$invalidate(38, thumbnailsURL = $$props2.thumbnailsURL);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*width, container*/
    32800) {
      if (!!width)
        $$invalidate(20, actualWidth = width);
      else if (!!container)
        $$invalidate(20, actualWidth = container.clientWidth);
    }
    if ($$self.$$.dirty[0] & /*height, container*/
    32832) {
      if (!!height)
        $$invalidate(21, actualHeight = height);
      else if (!!container)
        $$invalidate(21, actualHeight = container.clientHeight);
    }
    if ($$self.$$.dirty[0] & /*canvas, data, colorScale*/
    279552 | $$self.$$.dirty[1] & /*oldData, oldColorScale*/
    6144) {
      if (!!canvas && (oldData != data || oldColorScale != colorScale)) {
        $$invalidate(42, oldData = data);
        $$invalidate(43, oldColorScale = colorScale);
        canvas.setFrozen(false);
      }
    }
    if ($$self.$$.dirty[0] & /*thumbnail, marks, canvas, stateManager*/
    459008) {
      if (thumbnail && !!marks && !canvas.frozen) {
        canvas.draw(() => {
          stateManager.destroyMarks();
          canvas.setFrozen(true);
        });
      }
    }
    if ($$self.$$.dirty[0] & /*previewFrame, frame, previewProgress, canvas, labelCanvas*/
    792577) {
      if (previewFrame != null && previewFrame !== frame2 && previewProgress != null) {
        if (!!canvas)
          canvas.draw();
        if (!!labelCanvas)
          labelCanvas.draw();
      }
    }
    if ($$self.$$.dirty[0] & /*marks*/
    65536 | $$self.$$.dirty[1] & /*followingIDs*/
    32) {
      {
        $$invalidate(22, followingMarks = followingIDs.map((id2) => marks.getMarkByID(id2)));
      }
    }
  };
  return [
    previewProgress,
    hoveredID,
    clickedIDs,
    alignedIDs,
    padding,
    width,
    height,
    hoverable,
    thumbnail,
    rFactor,
    colorScale,
    frame2,
    previewFrame,
    previewInfo,
    data,
    container,
    marks,
    stateManager,
    canvas,
    labelCanvas,
    actualWidth,
    actualHeight,
    followingMarks,
    viewportManager,
    hiddenCanvas,
    colorMap,
    onMouseover,
    onMousedown,
    onMouseup,
    onMouseout,
    onMousemove,
    onClick,
    onMultiselect,
    rescale,
    scalesNeutral,
    filter2,
    followingIDs,
    animateTransitions,
    thumbnailsURL,
    selectPoint,
    animateDatasetUpdate,
    reset,
    oldData,
    oldColorScale,
    func2,
    func_1,
    func_2,
    scatterplotstate_binding,
    scatterplotstate_marks_binding,
    scatterplotstate_hoveredID_binding,
    scatterplotstate_selectedIDs_binding,
    scatterplotstate_alignedIDs_binding,
    scatterplotstate_previewProgress_binding,
    scatterplotviewportstate_binding,
    d3canvas_binding,
    click_handler,
    scale_handler,
    translate_handler,
    d3canvas_binding_1,
    labelcanvas_binding,
    div_binding
  ];
}
class Scatterplot extends SvelteComponent {
  constructor(options) {
    super();
    init$2(
      this,
      options,
      instance$g,
      create_fragment$g,
      safe_not_equal,
      {
        padding: 4,
        width: 5,
        height: 6,
        hoverable: 7,
        thumbnail: 8,
        rFactor: 9,
        colorScale: 10,
        frame: 11,
        previewFrame: 12,
        previewInfo: 13,
        previewProgress: 0,
        hoveredID: 1,
        clickedIDs: 2,
        alignedIDs: 3,
        filter: 35,
        followingIDs: 36,
        data: 14,
        animateTransitions: 37,
        scalesNeutral: 34,
        thumbnailsURL: 38,
        selectPoint: 39,
        animateDatasetUpdate: 40,
        reset: 41
      },
      null,
      [-1, -1, -1]
    );
  }
  get padding() {
    return this.$$.ctx[4];
  }
  set padding(padding) {
    this.$$set({ padding });
    flush();
  }
  get width() {
    return this.$$.ctx[5];
  }
  set width(width) {
    this.$$set({ width });
    flush();
  }
  get height() {
    return this.$$.ctx[6];
  }
  set height(height) {
    this.$$set({ height });
    flush();
  }
  get hoverable() {
    return this.$$.ctx[7];
  }
  set hoverable(hoverable) {
    this.$$set({ hoverable });
    flush();
  }
  get thumbnail() {
    return this.$$.ctx[8];
  }
  set thumbnail(thumbnail) {
    this.$$set({ thumbnail });
    flush();
  }
  get rFactor() {
    return this.$$.ctx[9];
  }
  set rFactor(rFactor) {
    this.$$set({ rFactor });
    flush();
  }
  get colorScale() {
    return this.$$.ctx[10];
  }
  set colorScale(colorScale) {
    this.$$set({ colorScale });
    flush();
  }
  get frame() {
    return this.$$.ctx[11];
  }
  set frame(frame2) {
    this.$$set({ frame: frame2 });
    flush();
  }
  get previewFrame() {
    return this.$$.ctx[12];
  }
  set previewFrame(previewFrame) {
    this.$$set({ previewFrame });
    flush();
  }
  get previewInfo() {
    return this.$$.ctx[13];
  }
  set previewInfo(previewInfo) {
    this.$$set({ previewInfo });
    flush();
  }
  get previewProgress() {
    return this.$$.ctx[0];
  }
  set previewProgress(previewProgress) {
    this.$$set({ previewProgress });
    flush();
  }
  get hoveredID() {
    return this.$$.ctx[1];
  }
  set hoveredID(hoveredID) {
    this.$$set({ hoveredID });
    flush();
  }
  get clickedIDs() {
    return this.$$.ctx[2];
  }
  set clickedIDs(clickedIDs) {
    this.$$set({ clickedIDs });
    flush();
  }
  get alignedIDs() {
    return this.$$.ctx[3];
  }
  set alignedIDs(alignedIDs) {
    this.$$set({ alignedIDs });
    flush();
  }
  get filter() {
    return this.$$.ctx[35];
  }
  set filter(filter2) {
    this.$$set({ filter: filter2 });
    flush();
  }
  get followingIDs() {
    return this.$$.ctx[36];
  }
  set followingIDs(followingIDs) {
    this.$$set({ followingIDs });
    flush();
  }
  get data() {
    return this.$$.ctx[14];
  }
  set data(data) {
    this.$$set({ data });
    flush();
  }
  get animateTransitions() {
    return this.$$.ctx[37];
  }
  set animateTransitions(animateTransitions) {
    this.$$set({ animateTransitions });
    flush();
  }
  get scalesNeutral() {
    return this.$$.ctx[34];
  }
  set scalesNeutral(scalesNeutral) {
    this.$$set({ scalesNeutral });
    flush();
  }
  get thumbnailsURL() {
    return this.$$.ctx[38];
  }
  set thumbnailsURL(thumbnailsURL) {
    this.$$set({ thumbnailsURL });
    flush();
  }
  get selectPoint() {
    return this.$$.ctx[39];
  }
  get animateDatasetUpdate() {
    return this.$$.ctx[40];
  }
  get reset() {
    return this.$$.ctx[41];
  }
}
function create_fragment$f(ctx) {
  let div2;
  let scatterplotstate;
  let updating_marks;
  let updating_filterIDs;
  let updating_hoveredID;
  let updating_selectedIDs;
  let updating_tentativeSelectedIDs;
  let updating_alignedIDs;
  let updating_previewProgress;
  let t;
  let scatterplotviewportstate;
  let updating_rFactor;
  let updating_showPointBorders;
  let current;
  function scatterplotstate_marks_binding(value) {
    ctx[61](value);
  }
  function scatterplotstate_filterIDs_binding(value) {
    ctx[62](value);
  }
  function scatterplotstate_hoveredID_binding(value) {
    ctx[63](value);
  }
  function scatterplotstate_selectedIDs_binding(value) {
    ctx[64](value);
  }
  function scatterplotstate_tentativeSelectedIDs_binding(value) {
    ctx[65](value);
  }
  function scatterplotstate_alignedIDs_binding(value) {
    ctx[66](value);
  }
  function scatterplotstate_previewProgress_binding(value) {
    ctx[67](value);
  }
  let scatterplotstate_props = {
    thumbnail: (
      /*thumbnail*/
      ctx[9]
    ),
    data: (
      /*data*/
      ctx[16]
    ),
    colorMap: (
      /*colorMap*/
      ctx[28]
    ),
    frame: (
      /*frame*/
      ctx[12]
    ),
    previewFrame: (
      /*previewFrame*/
      ctx[13]
    ),
    previewInfo: (
      /*previewInfo*/
      ctx[14]
    ),
    numNeighbors: (
      /*numNeighbors*/
      ctx[18]
    ),
    idsOfInterest: (
      /*idsOfInterest*/
      ctx[15]
    ),
    pointRadius: (
      /*pointRadius*/
      ctx[10]
    ),
    colorScale: (
      /*func*/
      ctx[57]
    ),
    colorFormat: "rgbArray",
    xScale: !!/*viewportManager*/
    ctx[24] ? (
      /*func_1*/
      ctx[58]
    ) : null,
    yScale: !!/*viewportManager*/
    ctx[24] ? (
      /*func_2*/
      ctx[59]
    ) : null,
    highlightFocusedPoints: !/*performanceMode*/
    ctx[17]
  };
  if (
    /*marks*/
    ctx[25] !== void 0
  ) {
    scatterplotstate_props.marks = /*marks*/
    ctx[25];
  }
  if (
    /*filterIDs*/
    ctx[1] !== void 0
  ) {
    scatterplotstate_props.filterIDs = /*filterIDs*/
    ctx[1];
  }
  if (
    /*hoveredID*/
    ctx[3] !== void 0
  ) {
    scatterplotstate_props.hoveredID = /*hoveredID*/
    ctx[3];
  }
  if (
    /*clickedIDs*/
    ctx[0] !== void 0
  ) {
    scatterplotstate_props.selectedIDs = /*clickedIDs*/
    ctx[0];
  }
  if (
    /*tentativeSelectedIDs*/
    ctx[5] !== void 0
  ) {
    scatterplotstate_props.tentativeSelectedIDs = /*tentativeSelectedIDs*/
    ctx[5];
  }
  if (
    /*alignedIDs*/
    ctx[4] !== void 0
  ) {
    scatterplotstate_props.alignedIDs = /*alignedIDs*/
    ctx[4];
  }
  if (
    /*previewProgress*/
    ctx[2] !== void 0
  ) {
    scatterplotstate_props.previewProgress = /*previewProgress*/
    ctx[2];
  }
  scatterplotstate = new ScatterplotState({ props: scatterplotstate_props });
  ctx[60](scatterplotstate);
  binding_callbacks.push(() => bind$4(scatterplotstate, "marks", scatterplotstate_marks_binding));
  binding_callbacks.push(() => bind$4(scatterplotstate, "filterIDs", scatterplotstate_filterIDs_binding));
  binding_callbacks.push(() => bind$4(scatterplotstate, "hoveredID", scatterplotstate_hoveredID_binding));
  binding_callbacks.push(() => bind$4(scatterplotstate, "selectedIDs", scatterplotstate_selectedIDs_binding));
  binding_callbacks.push(() => bind$4(scatterplotstate, "tentativeSelectedIDs", scatterplotstate_tentativeSelectedIDs_binding));
  binding_callbacks.push(() => bind$4(scatterplotstate, "alignedIDs", scatterplotstate_alignedIDs_binding));
  binding_callbacks.push(() => bind$4(scatterplotstate, "previewProgress", scatterplotstate_previewProgress_binding));
  scatterplotstate.$on(
    "logEvent",
    /*logEvent_handler*/
    ctx[68]
  );
  function scatterplotviewportstate_rFactor_binding(value) {
    ctx[70](value);
  }
  function scatterplotviewportstate_showPointBorders_binding(value) {
    ctx[71](value);
  }
  let scatterplotviewportstate_props = {
    data: (
      /*data*/
      ctx[16]
    ),
    width: (
      /*actualWidth*/
      ctx[22]
    ),
    height: (
      /*actualHeight*/
      ctx[23]
    ),
    xExtent: !!/*data*/
    ctx[16] ? (
      /*data*/
      ctx[16].getXExtent()
    ) : null,
    yExtent: !!/*data*/
    ctx[16] ? (
      /*data*/
      ctx[16].getYExtent()
    ) : null,
    padding: (
      /*padding*/
      ctx[6]
    ),
    thumbnail: (
      /*thumbnail*/
      ctx[9]
    ),
    followingMarks: (
      /*followingMarks*/
      ctx[27]
    ),
    visibleIDs: (
      /*filterIDs*/
      ctx[1]
    ),
    pointRadius: (
      /*pointRadius*/
      ctx[10]
    )
  };
  if (
    /*rFactor*/
    ctx[19] !== void 0
  ) {
    scatterplotviewportstate_props.rFactor = /*rFactor*/
    ctx[19];
  }
  if (
    /*showPointBorders*/
    ctx[20] !== void 0
  ) {
    scatterplotviewportstate_props.showPointBorders = /*showPointBorders*/
    ctx[20];
  }
  scatterplotviewportstate = new ScatterplotViewportState({ props: scatterplotviewportstate_props });
  ctx[69](scatterplotviewportstate);
  binding_callbacks.push(() => bind$4(scatterplotviewportstate, "rFactor", scatterplotviewportstate_rFactor_binding));
  binding_callbacks.push(() => bind$4(scatterplotviewportstate, "showPointBorders", scatterplotviewportstate_showPointBorders_binding));
  scatterplotviewportstate.$on(
    "update",
    /*rescale*/
    ctx[29]
  );
  return {
    c() {
      div2 = element$2("div");
      create_component(scatterplotstate.$$.fragment);
      t = space();
      create_component(scatterplotviewportstate.$$.fragment);
      set_style(
        div2,
        "width",
        /*width*/
        ctx[7] != null ? `${/*width*/
        ctx[7]}px` : "100%"
      );
      set_style(
        div2,
        "height",
        /*height*/
        ctx[8] != null ? `${/*height*/
        ctx[8]}px` : "100%"
      );
      attr(div2, "id", "container");
      attr(div2, "class", "svelte-gnaw3r");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(scatterplotstate, div2, null);
      append(div2, t);
      mount_component(scatterplotviewportstate, div2, null);
      ctx[72](div2);
      current = true;
    },
    p(ctx2, dirty) {
      const scatterplotstate_changes = {};
      if (dirty[0] & /*thumbnail*/
      512)
        scatterplotstate_changes.thumbnail = /*thumbnail*/
        ctx2[9];
      if (dirty[0] & /*data*/
      65536)
        scatterplotstate_changes.data = /*data*/
        ctx2[16];
      if (dirty[0] & /*frame*/
      4096)
        scatterplotstate_changes.frame = /*frame*/
        ctx2[12];
      if (dirty[0] & /*previewFrame*/
      8192)
        scatterplotstate_changes.previewFrame = /*previewFrame*/
        ctx2[13];
      if (dirty[0] & /*previewInfo*/
      16384)
        scatterplotstate_changes.previewInfo = /*previewInfo*/
        ctx2[14];
      if (dirty[0] & /*numNeighbors*/
      262144)
        scatterplotstate_changes.numNeighbors = /*numNeighbors*/
        ctx2[18];
      if (dirty[0] & /*idsOfInterest*/
      32768)
        scatterplotstate_changes.idsOfInterest = /*idsOfInterest*/
        ctx2[15];
      if (dirty[0] & /*pointRadius*/
      1024)
        scatterplotstate_changes.pointRadius = /*pointRadius*/
        ctx2[10];
      if (dirty[0] & /*colorScale*/
      2048)
        scatterplotstate_changes.colorScale = /*func*/
        ctx2[57];
      if (dirty[0] & /*viewportManager*/
      16777216)
        scatterplotstate_changes.xScale = !!/*viewportManager*/
        ctx2[24] ? (
          /*func_1*/
          ctx2[58]
        ) : null;
      if (dirty[0] & /*viewportManager*/
      16777216)
        scatterplotstate_changes.yScale = !!/*viewportManager*/
        ctx2[24] ? (
          /*func_2*/
          ctx2[59]
        ) : null;
      if (dirty[0] & /*performanceMode*/
      131072)
        scatterplotstate_changes.highlightFocusedPoints = !/*performanceMode*/
        ctx2[17];
      if (!updating_marks && dirty[0] & /*marks*/
      33554432) {
        updating_marks = true;
        scatterplotstate_changes.marks = /*marks*/
        ctx2[25];
        add_flush_callback(() => updating_marks = false);
      }
      if (!updating_filterIDs && dirty[0] & /*filterIDs*/
      2) {
        updating_filterIDs = true;
        scatterplotstate_changes.filterIDs = /*filterIDs*/
        ctx2[1];
        add_flush_callback(() => updating_filterIDs = false);
      }
      if (!updating_hoveredID && dirty[0] & /*hoveredID*/
      8) {
        updating_hoveredID = true;
        scatterplotstate_changes.hoveredID = /*hoveredID*/
        ctx2[3];
        add_flush_callback(() => updating_hoveredID = false);
      }
      if (!updating_selectedIDs && dirty[0] & /*clickedIDs*/
      1) {
        updating_selectedIDs = true;
        scatterplotstate_changes.selectedIDs = /*clickedIDs*/
        ctx2[0];
        add_flush_callback(() => updating_selectedIDs = false);
      }
      if (!updating_tentativeSelectedIDs && dirty[0] & /*tentativeSelectedIDs*/
      32) {
        updating_tentativeSelectedIDs = true;
        scatterplotstate_changes.tentativeSelectedIDs = /*tentativeSelectedIDs*/
        ctx2[5];
        add_flush_callback(() => updating_tentativeSelectedIDs = false);
      }
      if (!updating_alignedIDs && dirty[0] & /*alignedIDs*/
      16) {
        updating_alignedIDs = true;
        scatterplotstate_changes.alignedIDs = /*alignedIDs*/
        ctx2[4];
        add_flush_callback(() => updating_alignedIDs = false);
      }
      if (!updating_previewProgress && dirty[0] & /*previewProgress*/
      4) {
        updating_previewProgress = true;
        scatterplotstate_changes.previewProgress = /*previewProgress*/
        ctx2[2];
        add_flush_callback(() => updating_previewProgress = false);
      }
      scatterplotstate.$set(scatterplotstate_changes);
      const scatterplotviewportstate_changes = {};
      if (dirty[0] & /*data*/
      65536)
        scatterplotviewportstate_changes.data = /*data*/
        ctx2[16];
      if (dirty[0] & /*actualWidth*/
      4194304)
        scatterplotviewportstate_changes.width = /*actualWidth*/
        ctx2[22];
      if (dirty[0] & /*actualHeight*/
      8388608)
        scatterplotviewportstate_changes.height = /*actualHeight*/
        ctx2[23];
      if (dirty[0] & /*data*/
      65536)
        scatterplotviewportstate_changes.xExtent = !!/*data*/
        ctx2[16] ? (
          /*data*/
          ctx2[16].getXExtent()
        ) : null;
      if (dirty[0] & /*data*/
      65536)
        scatterplotviewportstate_changes.yExtent = !!/*data*/
        ctx2[16] ? (
          /*data*/
          ctx2[16].getYExtent()
        ) : null;
      if (dirty[0] & /*padding*/
      64)
        scatterplotviewportstate_changes.padding = /*padding*/
        ctx2[6];
      if (dirty[0] & /*thumbnail*/
      512)
        scatterplotviewportstate_changes.thumbnail = /*thumbnail*/
        ctx2[9];
      if (dirty[0] & /*followingMarks*/
      134217728)
        scatterplotviewportstate_changes.followingMarks = /*followingMarks*/
        ctx2[27];
      if (dirty[0] & /*filterIDs*/
      2)
        scatterplotviewportstate_changes.visibleIDs = /*filterIDs*/
        ctx2[1];
      if (dirty[0] & /*pointRadius*/
      1024)
        scatterplotviewportstate_changes.pointRadius = /*pointRadius*/
        ctx2[10];
      if (!updating_rFactor && dirty[0] & /*rFactor*/
      524288) {
        updating_rFactor = true;
        scatterplotviewportstate_changes.rFactor = /*rFactor*/
        ctx2[19];
        add_flush_callback(() => updating_rFactor = false);
      }
      if (!updating_showPointBorders && dirty[0] & /*showPointBorders*/
      1048576) {
        updating_showPointBorders = true;
        scatterplotviewportstate_changes.showPointBorders = /*showPointBorders*/
        ctx2[20];
        add_flush_callback(() => updating_showPointBorders = false);
      }
      scatterplotviewportstate.$set(scatterplotviewportstate_changes);
      if (!current || dirty[0] & /*width*/
      128) {
        set_style(
          div2,
          "width",
          /*width*/
          ctx2[7] != null ? `${/*width*/
          ctx2[7]}px` : "100%"
        );
      }
      if (!current || dirty[0] & /*height*/
      256) {
        set_style(
          div2,
          "height",
          /*height*/
          ctx2[8] != null ? `${/*height*/
          ctx2[8]}px` : "100%"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(scatterplotstate.$$.fragment, local);
      transition_in(scatterplotviewportstate.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scatterplotstate.$$.fragment, local);
      transition_out(scatterplotviewportstate.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      ctx[60](null);
      destroy_component(scatterplotstate);
      ctx[69](null);
      destroy_component(scatterplotviewportstate);
      ctx[72](null);
    }
  };
}
const HoveringDelayInterval = 200;
const SelectionRadiusPadding = 10;
const ViewportUpdateInterval = 500;
function instance$f($$self, $$props, $$invalidate) {
  let { padding = 0.3 } = $$props;
  let { width = null } = $$props;
  let { height = null } = $$props;
  let { hoverable = false } = $$props;
  let { thumbnail = false } = $$props;
  let { pointRadius = 3 } = $$props;
  let rFactor = 1;
  let { colorScale = (c2) => c2 } = $$props;
  let { frame: frame2 = null } = $$props;
  let { previewFrame = null } = $$props;
  let { previewInfo = null } = $$props;
  let { previewProgress = 0 } = $$props;
  let { hoveredID = null } = $$props;
  let { clickedIDs = [] } = $$props;
  let { alignedIDs = [] } = $$props;
  let { tentativeSelectedIDs = [] } = $$props;
  let { filterIDs = [] } = $$props;
  let { followingIDs = [] } = $$props;
  let { idsOfInterest = [] } = $$props;
  let { data = null } = $$props;
  let { animateTransitions = false } = $$props;
  let { scalesNeutral = true } = $$props;
  let { performanceMode = true } = $$props;
  let showPointBorders = true;
  let { thumbnailsURL = null } = $$props;
  let { numNeighbors = 10 } = $$props;
  const dispatch2 = createEventDispatcher();
  let container;
  let actualWidth = null;
  let actualHeight = null;
  let stateManager;
  let viewportManager;
  let colorMap = new ColorIDMap();
  let followingMarks = [];
  var marks = null;
  let pixiApp;
  let loader;
  let scatterplot;
  let { inRadiusselect = false } = $$props;
  let { selectionRadius = defaultRadius } = $$props;
  let { selectionUnit = "pixels" } = $$props;
  let { selectionOrderFn = null } = $$props;
  let { selectionMin = 0 } = $$props;
  let { selectionMax = 0 } = $$props;
  let { selectionStep = 1 } = $$props;
  let selectionOrder = null;
  onMount(() => {
    settings.FILTER_RESOLUTION = window.devicePixelRatio;
    console.log("on scatteprlot mount");
    $$invalidate(48, pixiApp = new Application({
      antialias: true,
      transparent: true,
      width,
      height,
      resolution: window.devicePixelRatio,
      sharedTicker: true
    }));
    pixiApp.renderer.gl.getExtension("OES_standard_derivatives");
    let view = pixiApp.view;
    container.appendChild(view);
    initializeMouseHandlers(view);
    setTimeout(
      () => {
        $$invalidate(22, actualWidth = container.clientWidth);
        $$invalidate(23, actualHeight = container.clientHeight);
      },
      0
    );
    window.addEventListener("resize", handleResize);
  });
  onDestroy(() => {
    if (!!scatterplot) {
      scatterplot.destroy();
      $$invalidate(49, scatterplot = null);
    }
    if (!!loader) {
      loader.destroy();
      loader = null;
    }
  });
  let oldMarks = null;
  function setupTicker() {
    pixiApp.ticker.add(() => {
      let dt = pixiApp.ticker.elapsedMS;
      if (!!viewportManager) {
        $$invalidate(55, viewportAnimating = viewportManager.advance(dt));
        if (!!scatterplot)
          scatterplot.updateTransform(viewportManager.getTransformInfo());
      }
    });
  }
  function setupScatterplot() {
    if (!!scatterplot) {
      scatterplot.getElements().forEach((el) => pixiApp.stage.removeChild(el));
      scatterplot.destroy();
    }
    $$invalidate(49, scatterplot = new PixiScatterplot(marks, viewportManager.getTransformInfo(), rFactor));
    $$invalidate(49, scatterplot.showPointBorders = showPointBorders, scatterplot);
    scatterplot.addTo(pixiApp.stage, pixiApp.ticker, pixiApp.renderer);
    let renderMargin2 = 50;
    scatterplot.setRenderBox([
      -renderMargin2,
      actualWidth + renderMargin2,
      -renderMargin2,
      actualHeight + renderMargin2
    ]);
    scatterplot.setSize([actualWidth, actualHeight]);
  }
  function handleResize() {
    if (!container)
      return;
    $$invalidate(22, actualWidth = container.clientWidth);
    $$invalidate(23, actualHeight = container.clientHeight);
  }
  function getViewport() {
    let transformInfo = viewportManager.getTransformInfo();
    return [
      -transformInfo.x.b / transformInfo.x.a,
      (actualWidth - transformInfo.x.b) / transformInfo.x.a,
      -transformInfo.y.b / transformInfo.y.a,
      (actualHeight - transformInfo.y.b) / transformInfo.y.a
    ];
  }
  function updateThumbnails() {
    if (!scatterplot || !data)
      return;
    loadSpritesheets();
  }
  let oldScatterplot;
  function loadSpritesheets() {
    if (!!loader) {
      loader.destroy();
      scatterplot.setTextureLoader(null);
    }
    if (!data || !data.spritesheets)
      return;
    loader = new PixiInMemoryLoader();
    let content = data.spritesheets;
    Promise.all(Object.keys(content).map((name2) => {
      loader.add(name2, content[name2].spec, content[name2].image, content[name2].imageFormat || "image/png");
    })).then(() => {
      if (!!loader)
        console.log(`Loaded ${Object.keys(content).length} spritesheets in-memory`);
    }).catch((e) => {
      console.error("error loading spritesheets:", e);
    });
    scatterplot.setTextureLoader(loader);
  }
  var mouseDown = false;
  var mouseMoved = true;
  var hoveringDelayPassed = false;
  var hoveringDelayTimeout = null;
  var lastX = 0;
  var lastY = 0;
  function initializeMouseHandlers(view) {
    select$1(view).on("mousedown", (e) => {
      $$invalidate(53, mouseDown = true);
      $$invalidate(54, mouseMoved = false);
      dispatch2("mousedown", e);
    }).on("mouseup", (e) => {
      $$invalidate(53, mouseDown = false);
      lastX = 0;
      lastY = 0;
      if (!mouseMoved) {
        handleClick(e);
        dispatch2("click", e);
      } else if (!!scatterplot.multiselect) {
        onMultiselect();
      }
      setTimeout(() => $$invalidate(54, mouseMoved = false));
      dispatch2("mouseup", e);
    }).on("mousemove", (e) => {
      if (!thumbnail) {
        handleMouseMove(e);
      } else {
        dispatch2("mousemove", e);
      }
    }).on("mouseout", () => {
      if (hoveredID != null) {
        $$invalidate(3, hoveredID = null);
        dispatch2("datahover", hoveredID);
      }
    }).on("mouseenter", () => {
      hoveringDelayTimeout = setTimeout(() => hoveringDelayPassed = true, HoveringDelayInterval);
    }).on("mouseleave", () => {
      hoveringDelayPassed = false;
      if (!!hoveringDelayTimeout)
        clearTimeout(hoveringDelayTimeout);
    }).on("mousewheel", handleMouseWheel).on("DOMMouseScroll", handleMouseWheel).on("MozMousePixelScroll", (e) => e.preventDefault());
  }
  function getElementAtPoint(x, y) {
    if (!pixiApp)
      return null;
    let interactionMap = scatterplot.getInteractionMap(pixiApp.renderer, actualWidth, actualHeight, colorMap);
    if (!interactionMap)
      return null;
    return interactionMap.obj(x, y);
  }
  function handleMouseMove(event) {
    $$invalidate(54, mouseMoved = true);
    var rect = event.target.getBoundingClientRect();
    var mouseX = event.clientX - rect.left;
    var mouseY = event.clientY - rect.top;
    if (mouseDown && !!lastX && !!lastY) {
      if (event.metaKey || event.ctrlKey || !!scatterplot.multiselect) {
        if (!scatterplot.multiselect) {
          scatterplot.startMultiselect([mouseX, mouseY]);
        } else {
          scatterplot.updateMultiselect([mouseX, mouseY]);
        }
      } else {
        var dx = mouseX - lastX;
        var dy = mouseY - lastY;
        viewportManager.translateBy(-dx, -dy);
      }
    } else if (!mouseDown && hoveringDelayPassed) {
      let hoveredItem = getElementAtPoint(mouseX, mouseY);
      if (!!hoveredItem && hoveredItem.type == "mark") {
        $$invalidate(3, hoveredID = hoveredItem.id);
        dispatch2("datahover", hoveredID);
      } else {
        $$invalidate(
          3,
          hoveredID = null
        );
        dispatch2("datahover", hoveredID);
      }
    }
    lastX = mouseX;
    lastY = mouseY;
  }
  function handleMouseWheel(event) {
    if (thumbnail)
      return;
    var ds;
    if (!!event.wheelDelta) {
      ds = 0.01 * event.wheelDelta;
    } else if (!!event.detail) {
      ds = -0.01 * event.detail;
    }
    var rect = event.target.getBoundingClientRect();
    var mouseX = event.clientX - rect.left;
    var mouseY = event.clientY - rect.top;
    viewportManager.scaleBy(ds, [mouseX, mouseY]);
    event.preventDefault();
  }
  function handleClick(event) {
    if (thumbnail)
      return;
    if (inRadiusselect) {
      cancelRadiusSelect();
    }
    scatterplot.clearInteractionMap();
    var rect = event.target.getBoundingClientRect();
    var mouseX = event.clientX - rect.left;
    var mouseY = event.clientY - rect.top;
    var el = getElementAtPoint(mouseX, mouseY);
    let newSelection = stateManager.selectElement(el, event.metaKey || event.ctrlKey);
    if (newSelection.length > 0)
      dispatch2("logEvent", { type: "selection", source: "click" });
    else
      dispatch2("logEvent", { type: "deselection", source: "click" });
  }
  function selectPoint(pointID, multi = false) {
    if (!stateManager)
      return;
    stateManager.selectElement({ type: "mark", id: pointID }, multi);
  }
  function onMultiselect(event) {
    if (!hoverable) {
      return;
    }
    let map2 = scatterplot.makeMultiselectMap(pixiApp.renderer, actualWidth, actualHeight);
    $$invalidate(0, clickedIDs = marks.filter((mark) => {
      if (mark.attr("alpha") < 0.01)
        return false;
      let x = Math.round(mark.attr("x"));
      let y = Math.round(mark.attr("y"));
      return map2.contains(x, y);
    }).map((mark) => mark.id));
    dispatch2("dataclick", clickedIDs);
    dispatch2("logEvent", { type: "selection", source: "lasso" });
    scatterplot.endMultiselect();
  }
  function animateDatasetUpdate() {
    stateManager.animateDatasetUpdate();
  }
  function cancelRadiusSelect() {
    $$invalidate(30, inRadiusselect = false);
    $$invalidate(5, tentativeSelectedIDs = []);
    scatterplot.endRadiusSelect();
  }
  let viewportAnimating = false;
  async function updateSelectionOrder(unit2) {
    if (unit2 == "pixels") {
      if (!!selectionOrder && selectionOrder.length > 0 && tentativeSelectedIDs.length > 0) {
        let centerMark = marks.getMarkByID(clickedIDs[0]);
        let centerLoc = {
          x: centerMark.attr("x"),
          y: centerMark.attr("y")
        };
        $$invalidate(31, selectionRadius = tentativeSelectedIDs.reduce(
          (curr, id2) => {
            let mark = marks.getMarkByID(id2);
            return Math.max(curr, euclideanDistance(centerLoc, { x: mark.attr("x"), y: mark.attr("y") }));
          },
          0
        ) + SelectionRadiusPadding);
      }
      $$invalidate(50, selectionOrder = []);
    } else {
      $$invalidate(50, selectionOrder = await selectionOrderFn(clickedIDs[0], selectionUnit));
      if (selectionOrder.length > 0 && tentativeSelectedIDs.length > 1) {
        let centerMark = marks.getMarkByID(clickedIDs[0]);
        for (let i = 0; i < selectionOrder.length; i++) {
          let mark = marks.getMarkByID(selectionOrder[i][0]);
          let dist = euclideanDistance(
            {
              x: centerMark.attr("x"),
              y: centerMark.attr("y")
            },
            { x: mark.attr("x"), y: mark.attr("y") }
          );
          if (dist > selectionRadius) {
            $$invalidate(31, selectionRadius = selectionOrder[Math.max(i - 1, 1)][1]);
            break;
          }
        }
      }
    }
    $$invalidate(5, tentativeSelectedIDs = idsWithinSelectionRadius(selectionUnit));
  }
  function idsWithinSelectionRadius(unit2) {
    if (!scatterplot || !scatterplot.radiusselect)
      return [];
    if (unit2 == "pixels") {
      return marks.filter((mark) => {
        if (mark.attr("alpha") < 0.01)
          return false;
        let x = Math.round(mark.attr("x"));
        let y = Math.round(mark.attr("y"));
        return scatterplot.radiusselect.circle.contains(x, y);
      }).map((mark) => mark.id);
    } else if (selectionOrder.length > 0) {
      let selection2 = [];
      for (let i = 0; i < selectionOrder.length; i++) {
        if (selectionOrder[i][1] > selectionRadius)
          break;
        selection2.push(selectionOrder[i][0]);
      }
      return selection2;
    }
    return [];
  }
  function endRadiusSelect() {
    $$invalidate(0, clickedIDs = idsWithinSelectionRadius(selectionUnit));
    dispatch2("dataclick", clickedIDs);
    dispatch2("logEvent", {
      type: "selection",
      source: "radiusselect"
    });
    scatterplot.endRadiusSelect();
    $$invalidate(5, tentativeSelectedIDs = []);
  }
  function autosizeRadiusSelect() {
    if (selectionUnit == "pixels")
      return;
    let centerMark = marks.getMarkByID(clickedIDs[0]);
    let centerLoc = {
      x: centerMark.attr("x"),
      y: centerMark.attr("y")
    };
    let maxDistance = tentativeSelectedIDs.reduce(
      (curr, id2) => {
        let mark = marks.getMarkByID(id2);
        return Math.max(curr, euclideanDistance(centerLoc, { x: mark.attr("x"), y: mark.attr("y") }));
      },
      0
    );
    scatterplot.updateRadiusSelect(maxDistance + SelectionRadiusPadding);
  }
  let prevFilterIDs = null;
  let viewportUpdateTimeout = null;
  function rescale() {
    $$invalidate(34, scalesNeutral = viewportManager.scalesNeutral);
    if (inRadiusselect && !!scatterplot.radiusselect)
      autosizeRadiusSelect();
    if (!!viewportUpdateTimeout)
      clearTimeout(viewportUpdateTimeout);
    viewportUpdateTimeout = setTimeout(
      () => {
        dispatch2("viewportChanged", getViewport());
        viewportUpdateTimeout = null;
      },
      ViewportUpdateInterval
    );
  }
  function reset() {
    viewportManager.resetAxisScales();
  }
  const func2 = (c2) => colorScale(c2);
  const func_1 = (x) => viewportManager.scaleX(x);
  const func_2 = (y) => viewportManager.scaleY(y);
  function scatterplotstate_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      stateManager = $$value;
      $$invalidate(26, stateManager);
    });
  }
  function scatterplotstate_marks_binding(value) {
    marks = value;
    $$invalidate(25, marks);
  }
  function scatterplotstate_filterIDs_binding(value) {
    filterIDs = value;
    $$invalidate(1, filterIDs);
  }
  function scatterplotstate_hoveredID_binding(value) {
    hoveredID = value;
    $$invalidate(3, hoveredID);
  }
  function scatterplotstate_selectedIDs_binding(value) {
    clickedIDs = value;
    $$invalidate(0, clickedIDs);
  }
  function scatterplotstate_tentativeSelectedIDs_binding(value) {
    tentativeSelectedIDs = value;
    $$invalidate(5, tentativeSelectedIDs), $$invalidate(49, scatterplot), $$invalidate(30, inRadiusselect), $$invalidate(0, clickedIDs), $$invalidate(31, selectionRadius), $$invalidate(40, selectionUnit), $$invalidate(50, selectionOrder), $$invalidate(20, showPointBorders), $$invalidate(19, rFactor);
  }
  function scatterplotstate_alignedIDs_binding(value) {
    alignedIDs = value;
    $$invalidate(4, alignedIDs);
  }
  function scatterplotstate_previewProgress_binding(value) {
    previewProgress = value;
    $$invalidate(2, previewProgress);
  }
  function logEvent_handler(event) {
    bubble.call(this, $$self, event);
  }
  function scatterplotviewportstate_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      viewportManager = $$value;
      $$invalidate(24, viewportManager);
    });
  }
  function scatterplotviewportstate_rFactor_binding(value) {
    rFactor = value;
    $$invalidate(19, rFactor);
  }
  function scatterplotviewportstate_showPointBorders_binding(value) {
    showPointBorders = value;
    $$invalidate(20, showPointBorders);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(21, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("padding" in $$props2)
      $$invalidate(6, padding = $$props2.padding);
    if ("width" in $$props2)
      $$invalidate(7, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(8, height = $$props2.height);
    if ("hoverable" in $$props2)
      $$invalidate(36, hoverable = $$props2.hoverable);
    if ("thumbnail" in $$props2)
      $$invalidate(9, thumbnail = $$props2.thumbnail);
    if ("pointRadius" in $$props2)
      $$invalidate(10, pointRadius = $$props2.pointRadius);
    if ("colorScale" in $$props2)
      $$invalidate(11, colorScale = $$props2.colorScale);
    if ("frame" in $$props2)
      $$invalidate(12, frame2 = $$props2.frame);
    if ("previewFrame" in $$props2)
      $$invalidate(13, previewFrame = $$props2.previewFrame);
    if ("previewInfo" in $$props2)
      $$invalidate(14, previewInfo = $$props2.previewInfo);
    if ("previewProgress" in $$props2)
      $$invalidate(2, previewProgress = $$props2.previewProgress);
    if ("hoveredID" in $$props2)
      $$invalidate(3, hoveredID = $$props2.hoveredID);
    if ("clickedIDs" in $$props2)
      $$invalidate(0, clickedIDs = $$props2.clickedIDs);
    if ("alignedIDs" in $$props2)
      $$invalidate(4, alignedIDs = $$props2.alignedIDs);
    if ("tentativeSelectedIDs" in $$props2)
      $$invalidate(5, tentativeSelectedIDs = $$props2.tentativeSelectedIDs);
    if ("filterIDs" in $$props2)
      $$invalidate(1, filterIDs = $$props2.filterIDs);
    if ("followingIDs" in $$props2)
      $$invalidate(37, followingIDs = $$props2.followingIDs);
    if ("idsOfInterest" in $$props2)
      $$invalidate(15, idsOfInterest = $$props2.idsOfInterest);
    if ("data" in $$props2)
      $$invalidate(16, data = $$props2.data);
    if ("animateTransitions" in $$props2)
      $$invalidate(38, animateTransitions = $$props2.animateTransitions);
    if ("scalesNeutral" in $$props2)
      $$invalidate(34, scalesNeutral = $$props2.scalesNeutral);
    if ("performanceMode" in $$props2)
      $$invalidate(17, performanceMode = $$props2.performanceMode);
    if ("thumbnailsURL" in $$props2)
      $$invalidate(39, thumbnailsURL = $$props2.thumbnailsURL);
    if ("numNeighbors" in $$props2)
      $$invalidate(18, numNeighbors = $$props2.numNeighbors);
    if ("inRadiusselect" in $$props2)
      $$invalidate(30, inRadiusselect = $$props2.inRadiusselect);
    if ("selectionRadius" in $$props2)
      $$invalidate(31, selectionRadius = $$props2.selectionRadius);
    if ("selectionUnit" in $$props2)
      $$invalidate(40, selectionUnit = $$props2.selectionUnit);
    if ("selectionOrderFn" in $$props2)
      $$invalidate(41, selectionOrderFn = $$props2.selectionOrderFn);
    if ("selectionMin" in $$props2)
      $$invalidate(32, selectionMin = $$props2.selectionMin);
    if ("selectionMax" in $$props2)
      $$invalidate(33, selectionMax = $$props2.selectionMax);
    if ("selectionStep" in $$props2)
      $$invalidate(35, selectionStep = $$props2.selectionStep);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*width, container*/
    2097280) {
      if (!!width)
        $$invalidate(22, actualWidth = width);
      else if (!!container)
        $$invalidate(22, actualWidth = container.clientWidth);
    }
    if ($$self.$$.dirty[0] & /*height, container*/
    2097408) {
      if (!!height)
        $$invalidate(23, actualHeight = height);
      else if (!!container)
        $$invalidate(23, actualHeight = container.clientHeight);
    }
    if ($$self.$$.dirty[0] & /*actualWidth, actualHeight*/
    12582912 | $$self.$$.dirty[1] & /*pixiApp*/
    131072) {
      if (!!actualWidth && !!actualHeight && !!pixiApp && !!pixiApp.view) {
        select$1(pixiApp.view).attr("width", actualWidth * window.devicePixelRatio + "px").attr("height", actualHeight * window.devicePixelRatio + "px").style("width", actualWidth + "px").style("height", actualHeight + "px");
        pixiApp.renderer.resize(actualWidth, actualHeight);
      }
    }
    if ($$self.$$.dirty[0] & /*showPointBorders*/
    1048576 | $$self.$$.dirty[1] & /*scatterplot*/
    262144) {
      if (!!scatterplot)
        $$invalidate(49, scatterplot.showPointBorders = showPointBorders, scatterplot);
    }
    if ($$self.$$.dirty[0] & /*rFactor*/
    524288 | $$self.$$.dirty[1] & /*scatterplot*/
    262144) {
      if (!!scatterplot)
        $$invalidate(49, scatterplot.rFactor = rFactor, scatterplot);
    }
    if ($$self.$$.dirty[1] & /*scatterplot, selectionUnit*/
    262656) {
      if (!!scatterplot && !!scatterplot.radiusselect)
        $$invalidate(49, scatterplot.radiusselect.visible = selectionUnit == "pixels", scatterplot);
    }
    if ($$self.$$.dirty[0] & /*actualWidth, actualHeight*/
    12582912 | $$self.$$.dirty[1] & /*scatterplot*/
    262144) {
      if (!!actualWidth && !!actualHeight && !!scatterplot) {
        scatterplot.setSize([actualWidth, actualHeight]);
      }
    }
    if ($$self.$$.dirty[0] & /*marks*/
    33554432 | $$self.$$.dirty[1] & /*oldMarks*/
    1048576) {
      if (!!marks && marks !== oldMarks) {
        $$invalidate(51, oldMarks = marks);
        setupScatterplot();
      }
    }
    if ($$self.$$.dirty[0] & /*viewportManager*/
    16777216 | $$self.$$.dirty[1] & /*pixiApp*/
    131072) {
      if (!!viewportManager && !!pixiApp) {
        setupTicker();
      }
    }
    if ($$self.$$.dirty[1] & /*scatterplot, oldScatterplot*/
    2359296) {
      if (!!scatterplot && scatterplot !== oldScatterplot) {
        console.log("scatterplot updating thumbnails");
        $$invalidate(52, oldScatterplot = scatterplot);
        loadSpritesheets();
      }
    }
    if ($$self.$$.dirty[1] & /*scatterplot, viewportAnimating, mouseDown, mouseMoved*/
    29622272) {
      if (!!scatterplot) {
        scatterplot.setInteractionEnabled(!viewportAnimating && !(mouseDown && mouseMoved));
      }
    }
    if ($$self.$$.dirty[0] & /*inRadiusselect*/
    1073741824 | $$self.$$.dirty[1] & /*selectionUnit*/
    512) {
      if (inRadiusselect) {
        console.log("updating selection order");
        updateSelectionOrder(selectionUnit);
      }
    }
    if ($$self.$$.dirty[1] & /*selectionUnit, selectionOrder, selectionMax, selectionMin*/
    524806) {
      if (selectionUnit != "pixels" && selectionOrder.length > 0) {
        $$invalidate(32, selectionMin = selectionOrder[1][1]);
        $$invalidate(33, selectionMax = selectionOrder[selectionOrder.length - 1][1]);
        let step = Math.min(1, (selectionMax - selectionMin) / 100);
        $$invalidate(32, selectionMin = Math.floor(selectionMin / step) * step);
        $$invalidate(33, selectionMax = Math.ceil(selectionMax / step) * step);
        $$invalidate(35, selectionStep = Math.min(1, (selectionMax - selectionMin) / 100));
      } else {
        $$invalidate(32, selectionMin = 10);
        $$invalidate(33, selectionMax = 250);
        $$invalidate(35, selectionStep = 1);
      }
    }
    if ($$self.$$.dirty[0] & /*inRadiusselect, clickedIDs*/
    1073741825 | $$self.$$.dirty[1] & /*scatterplot, selectionRadius, selectionUnit*/
    262657) {
      if (!!scatterplot) {
        if (inRadiusselect) {
          if (!scatterplot.radiusselect && clickedIDs.length == 1) {
            scatterplot.startRadiusSelect(clickedIDs[0], selectionRadius);
            $$invalidate(5, tentativeSelectedIDs = idsWithinSelectionRadius(selectionUnit));
          }
        } else {
          if (!!scatterplot.radiusselect) {
            endRadiusSelect();
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & /*inRadiusselect*/
    1073741824 | $$self.$$.dirty[1] & /*scatterplot, selectionUnit, selectionRadius, selectionOrder*/
    786945) {
      if (!!scatterplot) {
        if (inRadiusselect && !!scatterplot.radiusselect) {
          if (selectionUnit == "pixels") {
            scatterplot.updateRadiusSelect(selectionRadius);
            $$invalidate(5, tentativeSelectedIDs = idsWithinSelectionRadius(selectionUnit));
          } else if (selectionOrder.length > 0) {
            $$invalidate(5, tentativeSelectedIDs = idsWithinSelectionRadius(selectionUnit));
            autosizeRadiusSelect();
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & /*filterIDs*/
    2 | $$self.$$.dirty[1] & /*prevFilterIDs, scatterplot*/
    33816576) {
      if (prevFilterIDs !== filterIDs) {
        if (!!scatterplot)
          scatterplot.clearInteractionMap();
        $$invalidate(56, prevFilterIDs = filterIDs);
      }
    }
    if ($$self.$$.dirty[0] & /*marks*/
    33554432 | $$self.$$.dirty[1] & /*followingIDs*/
    64) {
      if (!!marks) {
        $$invalidate(27, followingMarks = followingIDs.map((id2) => marks.getMarkByID(id2)));
      }
    }
  };
  return [
    clickedIDs,
    filterIDs,
    previewProgress,
    hoveredID,
    alignedIDs,
    tentativeSelectedIDs,
    padding,
    width,
    height,
    thumbnail,
    pointRadius,
    colorScale,
    frame2,
    previewFrame,
    previewInfo,
    idsOfInterest,
    data,
    performanceMode,
    numNeighbors,
    rFactor,
    showPointBorders,
    container,
    actualWidth,
    actualHeight,
    viewportManager,
    marks,
    stateManager,
    followingMarks,
    colorMap,
    rescale,
    inRadiusselect,
    selectionRadius,
    selectionMin,
    selectionMax,
    scalesNeutral,
    selectionStep,
    hoverable,
    followingIDs,
    animateTransitions,
    thumbnailsURL,
    selectionUnit,
    selectionOrderFn,
    getViewport,
    updateThumbnails,
    selectPoint,
    animateDatasetUpdate,
    cancelRadiusSelect,
    reset,
    pixiApp,
    scatterplot,
    selectionOrder,
    oldMarks,
    oldScatterplot,
    mouseDown,
    mouseMoved,
    viewportAnimating,
    prevFilterIDs,
    func2,
    func_1,
    func_2,
    scatterplotstate_binding,
    scatterplotstate_marks_binding,
    scatterplotstate_filterIDs_binding,
    scatterplotstate_hoveredID_binding,
    scatterplotstate_selectedIDs_binding,
    scatterplotstate_tentativeSelectedIDs_binding,
    scatterplotstate_alignedIDs_binding,
    scatterplotstate_previewProgress_binding,
    logEvent_handler,
    scatterplotviewportstate_binding,
    scatterplotviewportstate_rFactor_binding,
    scatterplotviewportstate_showPointBorders_binding,
    div_binding
  ];
}
class Scatterplot_1 extends SvelteComponent {
  constructor(options) {
    super();
    init$2(
      this,
      options,
      instance$f,
      create_fragment$f,
      safe_not_equal,
      {
        padding: 6,
        width: 7,
        height: 8,
        hoverable: 36,
        thumbnail: 9,
        pointRadius: 10,
        colorScale: 11,
        frame: 12,
        previewFrame: 13,
        previewInfo: 14,
        previewProgress: 2,
        hoveredID: 3,
        clickedIDs: 0,
        alignedIDs: 4,
        tentativeSelectedIDs: 5,
        filterIDs: 1,
        followingIDs: 37,
        idsOfInterest: 15,
        data: 16,
        animateTransitions: 38,
        scalesNeutral: 34,
        performanceMode: 17,
        thumbnailsURL: 39,
        numNeighbors: 18,
        inRadiusselect: 30,
        selectionRadius: 31,
        selectionUnit: 40,
        selectionOrderFn: 41,
        selectionMin: 32,
        selectionMax: 33,
        selectionStep: 35,
        getViewport: 42,
        updateThumbnails: 43,
        selectPoint: 44,
        animateDatasetUpdate: 45,
        cancelRadiusSelect: 46,
        reset: 47
      },
      null,
      [-1, -1, -1, -1]
    );
  }
  get padding() {
    return this.$$.ctx[6];
  }
  set padding(padding) {
    this.$$set({ padding });
    flush();
  }
  get width() {
    return this.$$.ctx[7];
  }
  set width(width) {
    this.$$set({ width });
    flush();
  }
  get height() {
    return this.$$.ctx[8];
  }
  set height(height) {
    this.$$set({ height });
    flush();
  }
  get hoverable() {
    return this.$$.ctx[36];
  }
  set hoverable(hoverable) {
    this.$$set({ hoverable });
    flush();
  }
  get thumbnail() {
    return this.$$.ctx[9];
  }
  set thumbnail(thumbnail) {
    this.$$set({ thumbnail });
    flush();
  }
  get pointRadius() {
    return this.$$.ctx[10];
  }
  set pointRadius(pointRadius) {
    this.$$set({ pointRadius });
    flush();
  }
  get colorScale() {
    return this.$$.ctx[11];
  }
  set colorScale(colorScale) {
    this.$$set({ colorScale });
    flush();
  }
  get frame() {
    return this.$$.ctx[12];
  }
  set frame(frame2) {
    this.$$set({ frame: frame2 });
    flush();
  }
  get previewFrame() {
    return this.$$.ctx[13];
  }
  set previewFrame(previewFrame) {
    this.$$set({ previewFrame });
    flush();
  }
  get previewInfo() {
    return this.$$.ctx[14];
  }
  set previewInfo(previewInfo) {
    this.$$set({ previewInfo });
    flush();
  }
  get previewProgress() {
    return this.$$.ctx[2];
  }
  set previewProgress(previewProgress) {
    this.$$set({ previewProgress });
    flush();
  }
  get hoveredID() {
    return this.$$.ctx[3];
  }
  set hoveredID(hoveredID) {
    this.$$set({ hoveredID });
    flush();
  }
  get clickedIDs() {
    return this.$$.ctx[0];
  }
  set clickedIDs(clickedIDs) {
    this.$$set({ clickedIDs });
    flush();
  }
  get alignedIDs() {
    return this.$$.ctx[4];
  }
  set alignedIDs(alignedIDs) {
    this.$$set({ alignedIDs });
    flush();
  }
  get tentativeSelectedIDs() {
    return this.$$.ctx[5];
  }
  set tentativeSelectedIDs(tentativeSelectedIDs) {
    this.$$set({ tentativeSelectedIDs });
    flush();
  }
  get filterIDs() {
    return this.$$.ctx[1];
  }
  set filterIDs(filterIDs) {
    this.$$set({ filterIDs });
    flush();
  }
  get followingIDs() {
    return this.$$.ctx[37];
  }
  set followingIDs(followingIDs) {
    this.$$set({ followingIDs });
    flush();
  }
  get idsOfInterest() {
    return this.$$.ctx[15];
  }
  set idsOfInterest(idsOfInterest) {
    this.$$set({ idsOfInterest });
    flush();
  }
  get data() {
    return this.$$.ctx[16];
  }
  set data(data) {
    this.$$set({ data });
    flush();
  }
  get animateTransitions() {
    return this.$$.ctx[38];
  }
  set animateTransitions(animateTransitions) {
    this.$$set({ animateTransitions });
    flush();
  }
  get scalesNeutral() {
    return this.$$.ctx[34];
  }
  set scalesNeutral(scalesNeutral) {
    this.$$set({ scalesNeutral });
    flush();
  }
  get performanceMode() {
    return this.$$.ctx[17];
  }
  set performanceMode(performanceMode) {
    this.$$set({ performanceMode });
    flush();
  }
  get thumbnailsURL() {
    return this.$$.ctx[39];
  }
  set thumbnailsURL(thumbnailsURL) {
    this.$$set({ thumbnailsURL });
    flush();
  }
  get numNeighbors() {
    return this.$$.ctx[18];
  }
  set numNeighbors(numNeighbors) {
    this.$$set({ numNeighbors });
    flush();
  }
  get inRadiusselect() {
    return this.$$.ctx[30];
  }
  set inRadiusselect(inRadiusselect) {
    this.$$set({ inRadiusselect });
    flush();
  }
  get selectionRadius() {
    return this.$$.ctx[31];
  }
  set selectionRadius(selectionRadius) {
    this.$$set({ selectionRadius });
    flush();
  }
  get selectionUnit() {
    return this.$$.ctx[40];
  }
  set selectionUnit(selectionUnit) {
    this.$$set({ selectionUnit });
    flush();
  }
  get selectionOrderFn() {
    return this.$$.ctx[41];
  }
  set selectionOrderFn(selectionOrderFn) {
    this.$$set({ selectionOrderFn });
    flush();
  }
  get selectionMin() {
    return this.$$.ctx[32];
  }
  set selectionMin(selectionMin) {
    this.$$set({ selectionMin });
    flush();
  }
  get selectionMax() {
    return this.$$.ctx[33];
  }
  set selectionMax(selectionMax) {
    this.$$set({ selectionMax });
    flush();
  }
  get selectionStep() {
    return this.$$.ctx[35];
  }
  set selectionStep(selectionStep) {
    this.$$set({ selectionStep });
    flush();
  }
  get getViewport() {
    return this.$$.ctx[42];
  }
  get updateThumbnails() {
    return this.$$.ctx[43];
  }
  get selectPoint() {
    return this.$$.ctx[44];
  }
  get animateDatasetUpdate() {
    return this.$$.ctx[45];
  }
  get cancelRadiusSelect() {
    return this.$$.ctx[46];
  }
  get reset() {
    return this.$$.ctx[47];
  }
}
const { window: window_1 } = globals;
function create_fragment$e(ctx) {
  let canvas_1;
  let canvas_1_width_value;
  let canvas_1_height_value;
  let mounted;
  let dispose;
  return {
    c() {
      canvas_1 = element$2("canvas");
      attr(canvas_1, "width", canvas_1_width_value = /*width*/
      ctx[0] * window.devicePixelRatio);
      attr(canvas_1, "height", canvas_1_height_value = /*height*/
      ctx[1] * window.devicePixelRatio);
      set_style(
        canvas_1,
        "width",
        /*width*/
        ctx[0] + "px"
      );
      set_style(
        canvas_1,
        "height",
        /*height*/
        ctx[1] + "px"
      );
    },
    m(target, anchor) {
      insert(target, canvas_1, anchor);
      ctx[19](canvas_1);
      if (!mounted) {
        dispose = [
          listen(
            window_1,
            "mouseup",
            /*onMouseup*/
            ctx[7]
          ),
          listen(
            window_1,
            "mousemove",
            /*mousemove_handler*/
            ctx[18]
          ),
          listen(
            canvas_1,
            "mousedown",
            /*onMousedown*/
            ctx[4]
          ),
          listen(
            canvas_1,
            "mousemove",
            /*onMousemove*/
            ctx[6]
          ),
          listen(
            canvas_1,
            "mouseup",
            /*onMouseup*/
            ctx[7]
          ),
          listen(
            canvas_1,
            "mouseover",
            /*onMouseover*/
            ctx[5]
          ),
          listen(
            canvas_1,
            "mouseout",
            /*onMouseout*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*width*/
      1 && canvas_1_width_value !== (canvas_1_width_value = /*width*/
      ctx2[0] * window.devicePixelRatio)) {
        attr(canvas_1, "width", canvas_1_width_value);
      }
      if (dirty & /*height*/
      2 && canvas_1_height_value !== (canvas_1_height_value = /*height*/
      ctx2[1] * window.devicePixelRatio)) {
        attr(canvas_1, "height", canvas_1_height_value);
      }
      if (dirty & /*width*/
      1) {
        set_style(
          canvas_1,
          "width",
          /*width*/
          ctx2[0] + "px"
        );
      }
      if (dirty & /*height*/
      2) {
        set_style(
          canvas_1,
          "height",
          /*height*/
          ctx2[1] + "px"
        );
      }
    },
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(canvas_1);
      }
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const AnimDuration = 2e3;
let margin = 3;
function instance$e($$self, $$props, $$invalidate) {
  let { width = 200 } = $$props;
  let { height = 28 } = $$props;
  let { progress = 0 } = $$props;
  let { snapToEndpoints = false } = $$props;
  let { progressAttr = new Attribute(0) } = $$props;
  let { knobColor = new Attribute({
    value: 1,
    transform: (val) => {
      let intVal = Math.round(val * 255);
      return `rgb(${intVal},${intVal},${intVal})`;
    },
    cache: true
  }) } = $$props;
  let timer$1;
  let canvas;
  let radius = 0;
  let isHovering = false;
  let oldHovering = false;
  let isClicking = false;
  let oldClicking = false;
  function draw(w, h) {
    if (!canvas)
      return;
    var context2 = canvas.getContext("2d");
    context2.clearRect(0, 0, canvas.width, canvas.height);
    context2.strokeStyle = "darkgray";
    context2.lineWidth = 2;
    context2.save();
    context2.fillStyle = "lightgray";
    context2.beginPath();
    context2.moveTo(margin + radius, margin);
    context2.lineTo(width - (margin + radius), margin);
    context2.arc(width - (margin + radius), height / 2, radius, -Math.PI * 0.5, Math.PI * 0.5);
    context2.lineTo(margin + radius, height - margin);
    context2.arc(margin + radius, height / 2, radius, Math.PI * 0.5, Math.PI * 1.5);
    context2.closePath();
    context2.fill();
    context2.stroke();
    context2.restore();
    context2.save();
    context2.fillStyle = knobColor.get();
    context2.beginPath();
    context2.ellipse(margin + radius + (width - margin * 2 - radius * 2) * progressAttr.get(), height / 2, radius, radius, 0, 0, 2 * Math.PI);
    context2.closePath();
    context2.fill();
    context2.stroke();
    context2.restore();
  }
  let mouseDown = false;
  let clickX = 0;
  function locationWithinKnob(x, y) {
    let knobX = margin + radius + (width - margin * 2 - radius * 2) * progressAttr.get();
    return x >= knobX - radius && x <= knobX + radius;
  }
  function onMousedown(e) {
    mouseDown = true;
    var rect = e.target.getBoundingClientRect();
    var mouseX = e.clientX - rect.left;
    e.clientY - rect.top;
    $$invalidate(3, isClicking = locationWithinKnob(mouseX));
    if (isClicking)
      clickX = mouseX;
  }
  function onMouseover(e) {
    var rect = e.target.getBoundingClientRect();
    var mouseX = e.clientX - rect.left;
    e.clientY - rect.top;
    $$invalidate(14, isHovering = locationWithinKnob(mouseX));
  }
  function onMousemove(e) {
    var rect = canvas.getBoundingClientRect();
    var mouseX = e.clientX - rect.left;
    e.clientY - rect.top;
    if (mouseDown && isClicking) {
      let newProgress = progressAttr.get() + (mouseX - clickX) / (width - margin * 2 - radius * 2);
      progressAttr.set(Math.max(0, Math.min(1, newProgress)));
      clickX = mouseX;
    }
    $$invalidate(14, isHovering = locationWithinKnob(mouseX));
  }
  let isSnapping = false;
  function onMouseup() {
    if (isClicking && snapToEndpoints) {
      $$invalidate(17, isSnapping = true);
      let newProgress = Math.round(progress);
      newProgress = Math.max(0, Math.min(1, newProgress));
      let duration = Math.abs(newProgress - progress) * AnimDuration;
      progressAttr.animate(new Animator(interpolateTo(newProgress), duration, easeInOut));
    }
    mouseDown = false;
    $$invalidate(3, isClicking = false);
  }
  function onMouseout() {
    $$invalidate(14, isHovering = false);
  }
  let currentTime = 0;
  function setupTimer() {
    timer$1 = timer((elapsed) => {
      let dt = elapsed - currentTime;
      currentTime = elapsed;
      let a = progressAttr.advance(dt);
      let b = knobColor.advance(dt);
      if (a || b) {
        draw();
      }
      if (!a && isSnapping) {
        $$invalidate(17, isSnapping = false);
      }
      if (Math.abs(progressAttr.get() - progress) >= 5e-3) {
        $$invalidate(9, progress = progressAttr.get());
      }
    });
  }
  onMount(() => {
    var context2 = canvas.getContext("2d");
    context2.scale(window.devicePixelRatio, window.devicePixelRatio);
    setupTimer();
  });
  onDestroy(() => {
    timer$1.stop();
    timer$1 = null;
  });
  const mousemove_handler = (e) => {
    if (isClicking) {
      onMousemove(e);
    }
  };
  function canvas_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      canvas = $$value;
      $$invalidate(2, canvas);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("progress" in $$props2)
      $$invalidate(9, progress = $$props2.progress);
    if ("snapToEndpoints" in $$props2)
      $$invalidate(10, snapToEndpoints = $$props2.snapToEndpoints);
    if ("progressAttr" in $$props2)
      $$invalidate(11, progressAttr = $$props2.progressAttr);
    if ("knobColor" in $$props2)
      $$invalidate(12, knobColor = $$props2.knobColor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*height*/
    2) {
      radius = (height - margin * 2) / 2;
    }
    if ($$self.$$.dirty & /*canvas, width, height*/
    7) {
      if (!!canvas)
        draw();
    }
    if ($$self.$$.dirty & /*oldHovering, isHovering, oldClicking, isClicking, knobColor*/
    118792) {
      if (oldHovering != isHovering || oldClicking != isClicking) {
        let newColor = isClicking ? 0.5 : isHovering ? 0.8 : 1;
        knobColor.animate(new Animator(interpolateTo(newColor), 200));
        $$invalidate(15, oldHovering = isHovering);
        $$invalidate(16, oldClicking = isClicking);
      }
    }
    if ($$self.$$.dirty & /*progress, progressAttr, isSnapping*/
    133632) {
      if (progress != progressAttr.data() && !isSnapping) {
        let duration = Math.abs(progress - progressAttr.data()) * AnimDuration;
        progressAttr.animate(new Animator(interpolateTo(progress), duration, easeInOut));
      }
    }
  };
  return [
    width,
    height,
    canvas,
    isClicking,
    onMousedown,
    onMouseover,
    onMousemove,
    onMouseup,
    onMouseout,
    progress,
    snapToEndpoints,
    progressAttr,
    knobColor,
    draw,
    isHovering,
    oldHovering,
    oldClicking,
    isSnapping,
    mousemove_handler,
    canvas_1_binding
  ];
}
class PreviewSlider extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$e, create_fragment$e, safe_not_equal, {
      width: 0,
      height: 1,
      progress: 9,
      snapToEndpoints: 10,
      progressAttr: 11,
      knobColor: 12,
      draw: 13
    });
  }
  get draw() {
    return this.$$.ctx[13];
  }
}
const subscriber_queue = [];
function writable(value, start2 = noop$3) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(value));
  }
  function subscribe2(run2, invalidate = noop$3) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set2, update2) || noop$3;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe: subscribe2 };
}
const helpMessagesVisible = writable(false);
var faInfoCircle = {};
var faCircleInfo = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "circle-info";
  var width = 512;
  var height = 512;
  var aliases = ["info-circle"];
  var unicode = "f05a";
  var svgPathData = "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336l24 0 0-64-24 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0c13.3 0 24 10.7 24 24l0 88 8 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z";
  exports.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      aliases,
      unicode,
      svgPathData
    ]
  };
  exports.faCircleInfo = exports.definition;
  exports.prefix = prefix2;
  exports.iconName = iconName;
  exports.width = width;
  exports.height = height;
  exports.ligatures = aliases;
  exports.unicode = unicode;
  exports.svgPathData = svgPathData;
  exports.aliases = aliases;
})(faCircleInfo);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var source = faCircleInfo;
  exports.definition = {
    prefix: source.prefix,
    iconName: source.iconName,
    icon: [
      source.width,
      source.height,
      source.aliases,
      source.unicode,
      source.svgPathData
    ]
  };
  exports.faInfoCircle = exports.definition;
  exports.prefix = source.prefix;
  exports.iconName = source.iconName;
  exports.width = source.width;
  exports.height = source.height;
  exports.ligatures = source.aliases;
  exports.unicode = source.unicode;
  exports.svgPathData = source.svgPathData;
  exports.aliases = source.aliases;
})(faInfoCircle);
function create_else_block$5(ctx) {
  let button;
  let fa;
  let current;
  let mounted;
  let dispose;
  fa = new Fa({ props: { icon: faInfoCircle.faInfoCircle } });
  return {
    c() {
      button = element$2("button");
      create_component(fa.$$.fragment);
      attr(button, "class", "btn btn-link text-muted help-button bp3-button bp3-minimal jp-ToolbarButtonComponent minimal jp-Button svelte-1n8e4h4");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(fa, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p: noop$3,
    i(local) {
      if (current)
        return;
      transition_in(fa.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fa.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(fa);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$7(ctx) {
  let div2;
  let button;
  let t1;
  let p;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      div2 = element$2("div");
      button = element$2("button");
      button.textContent = "✕";
      t1 = space();
      p = element$2("p");
      if (default_slot)
        default_slot.c();
      attr(button, "class", "btn btn-link text-muted help-button bp3-button bp3-minimal jp-ToolbarButtonComponent minimal jp-Button svelte-1n8e4h4");
      attr(p, "class", "help-message-text svelte-1n8e4h4");
      attr(div2, "class", "help-message svelte-1n8e4h4");
      set_style(
        div2,
        "width",
        /*width*/
        ctx[0] + "px"
      );
      toggle_class(
        div2,
        "anchor-upper",
        /*anchor*/
        ctx[2].includes("upper")
      );
      toggle_class(
        div2,
        "anchor-lower",
        /*anchor*/
        ctx[2].includes("lower")
      );
      toggle_class(
        div2,
        "anchor-left",
        /*anchor*/
        ctx[2].includes("left")
      );
      toggle_class(
        div2,
        "anchor-right",
        /*anchor*/
        ctx[2].includes("right")
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, button);
      append(div2, t1);
      append(div2, p);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*width*/
      1) {
        set_style(
          div2,
          "width",
          /*width*/
          ctx2[0] + "px"
        );
      }
      if (!current || dirty & /*anchor*/
      4) {
        toggle_class(
          div2,
          "anchor-upper",
          /*anchor*/
          ctx2[2].includes("upper")
        );
      }
      if (!current || dirty & /*anchor*/
      4) {
        toggle_class(
          div2,
          "anchor-lower",
          /*anchor*/
          ctx2[2].includes("lower")
        );
      }
      if (!current || dirty & /*anchor*/
      4) {
        toggle_class(
          div2,
          "anchor-left",
          /*anchor*/
          ctx2[2].includes("left")
        );
      }
      if (!current || dirty & /*anchor*/
      4) {
        toggle_class(
          div2,
          "anchor-right",
          /*anchor*/
          ctx2[2].includes("right")
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$d(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$7, create_else_block$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*messageVisible*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element$2("div");
      div0 = element$2("div");
      if_block.c();
      attr(div0, "class", "help-message-wrapper svelte-1n8e4h4");
      attr(div1, "class", "help-message-container svelte-1n8e4h4");
      toggle_class(
        div1,
        "help-message-padded",
        /*pad*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
      if (!current || dirty & /*pad*/
      2) {
        toggle_class(
          div1,
          "help-message-padded",
          /*pad*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let messageVisible = false;
  let { width = 200 } = $$props;
  let { pad = true } = $$props;
  let { anchor = "upper left" } = $$props;
  const click_handler = () => $$invalidate(3, messageVisible = false);
  const click_handler_1 = () => $$invalidate(3, messageVisible = true);
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("pad" in $$props2)
      $$invalidate(1, pad = $$props2.pad);
    if ("anchor" in $$props2)
      $$invalidate(2, anchor = $$props2.anchor);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [
    width,
    pad,
    anchor,
    messageVisible,
    $$scope,
    slots,
    click_handler,
    click_handler_1
  ];
}
class HelpMessage extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$d, create_fragment$d, safe_not_equal, { width: 0, pad: 1, anchor: 2 });
  }
}
function get_each_context$8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[101] = list[i];
  return child_ctx;
}
function create_if_block$6(ctx) {
  let div0;
  let t0;
  let t1;
  let t2;
  let t3;
  let div1;
  let t4;
  let t5;
  let t6;
  let if_block7_anchor;
  let current;
  function select_block_type(ctx2, dirty) {
    if (
      /*showRadiusselectButton*/
      ctx2[34] && !/*inRadiusselect*/
      ctx2[7]
    )
      return create_if_block_14$1;
    if (
      /*showRadiusselectButton*/
      ctx2[34] && /*inRadiusselect*/
      ctx2[7]
    )
      return create_if_block_15$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type && current_block_type(ctx);
  let if_block1 = (
    /*showFilterButton*/
    ctx[33] && !/*inRadiusselect*/
    ctx[7] && create_if_block_12$1(ctx)
  );
  let if_block2 = (
    /*showAlignmentButton*/
    ctx[40] && !/*inRadiusselect*/
    ctx[7] && create_if_block_10$2(ctx)
  );
  let if_block3 = (
    /*showResetButton*/
    ctx[39] && !/*inRadiusselect*/
    ctx[7] && create_if_block_9$2(ctx)
  );
  let if_block4 = (
    /*$helpMessagesVisible*/
    ctx[42] && create_if_block_5$4(ctx)
  );
  let if_block5 = !!/*alignmentText*/
  ctx[41] && create_if_block_3$4(ctx);
  let if_block6 = warningMessage.length > 0 && create_if_block_2$5();
  let if_block7 = (
    /*showPreviewControls*/
    ctx[20] && /*previewFrame*/
    ctx[19] != /*frame*/
    ctx[18] && /*previewFrame*/
    ctx[19] != -1 && create_if_block_1$5(ctx)
  );
  return {
    c() {
      div0 = element$2("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      div1 = element$2("div");
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      t5 = space();
      if (if_block6)
        if_block6.c();
      t6 = space();
      if (if_block7)
        if_block7.c();
      if_block7_anchor = empty$2();
      attr(div0, "id", "button-panel");
      attr(div0, "class", "svelte-617l8a");
      attr(div1, "id", "message-panel");
      attr(div1, "class", "svelte-617l8a");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      append(div0, t2);
      if (if_block3)
        if_block3.m(div0, null);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      if (if_block4)
        if_block4.m(div1, null);
      append(div1, t4);
      if (if_block5)
        if_block5.m(div1, null);
      insert(target, t5, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert(target, t6, anchor);
      if (if_block7)
        if_block7.m(target, anchor);
      insert(target, if_block7_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if (if_block0)
          if_block0.d(1);
        if_block0 = current_block_type && current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, t0);
        }
      }
      if (
        /*showFilterButton*/
        ctx2[33] && !/*inRadiusselect*/
        ctx2[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_12$1(ctx2);
          if_block1.c();
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*showAlignmentButton*/
        ctx2[40] && !/*inRadiusselect*/
        ctx2[7]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_10$2(ctx2);
          if_block2.c();
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*showResetButton*/
        ctx2[39] && !/*inRadiusselect*/
        ctx2[7]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_9$2(ctx2);
          if_block3.c();
          if_block3.m(div0, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*$helpMessagesVisible*/
        ctx2[42]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*$helpMessagesVisible*/
          2048) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_5$4(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div1, t4);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (!!/*alignmentText*/
      ctx2[41]) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_3$4(ctx2);
          if_block5.c();
          if_block5.m(div1, null);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (warningMessage.length > 0)
        if_block6.p(ctx2, dirty);
      if (
        /*showPreviewControls*/
        ctx2[20] && /*previewFrame*/
        ctx2[19] != /*frame*/
        ctx2[18] && /*previewFrame*/
        ctx2[19] != -1
      ) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty[0] & /*showPreviewControls, previewFrame, frame*/
          1835008) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block_1$5(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(if_block7_anchor.parentNode, if_block7_anchor);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block4);
      transition_in(if_block6);
      transition_in(if_block7);
      current = true;
    },
    o(local) {
      transition_out(if_block4);
      transition_out(if_block6);
      transition_out(if_block7);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t3);
        detach(div1);
        detach(t5);
        detach(t6);
        detach(if_block7_anchor);
      }
      if (if_block0) {
        if_block0.d();
      }
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d(detaching);
      if (if_block7)
        if_block7.d(detaching);
    }
  };
}
function create_if_block_15$1(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*selectionOrderLoading*/
      ctx2[38]
    )
      return create_if_block_16;
    return create_else_block_2$2;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty$2();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_if_block_14$1(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element$2("button");
      button.textContent = "Start Radius Select";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-primary btn-sm jp-Dialog-button jp-mod-reject jp-mod-styled svelte-617l8a");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(
          /*click_handler_1*/
          ctx[84]
        ));
        mounted = true;
      }
    },
    p: noop$3,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_2$2(ctx) {
  let input;
  let t0;
  let t1_value = Math.round(
    /*selectionRadius*/
    ctx[8] * 100
  ) / 100 + "";
  let t1;
  let t2;
  let select2;
  let t3;
  let button0;
  let t5;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*selectionUnits*/
    ctx[24]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
  }
  return {
    c() {
      input = element$2("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      select2 = element$2("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      button0 = element$2("button");
      button0.textContent = "Cancel";
      t5 = space();
      button1 = element$2("button");
      button1.textContent = "Select";
      attr(input, "type", "range");
      attr(
        input,
        "min",
        /*selectionMin*/
        ctx[35]
      );
      attr(
        input,
        "max",
        /*selectionMax*/
        ctx[36]
      );
      attr(
        input,
        "step",
        /*selectionStep*/
        ctx[37]
      );
      if (
        /*selectionUnit*/
        ctx[9] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[86].call(select2)
        ));
      attr(button0, "type", "button");
      attr(button0, "class", "btn btn-secondary btn-sm jp-Dialog-button jp-mod-reject jp-mod-styled svelte-617l8a");
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-primary btn-sm jp-Dialog-button jp-mod-accept jp-mod-styled svelte-617l8a");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*selectionRadius*/
        ctx[8]
      );
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, select2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select2, null);
        }
      }
      select_option(
        select2,
        /*selectionUnit*/
        ctx[9],
        true
      );
      insert(target, t3, anchor);
      insert(target, button0, anchor);
      insert(target, t5, anchor);
      insert(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[85]
          ),
          listen(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[85]
          ),
          listen(
            select2,
            "change",
            /*select_change_handler*/
            ctx[86]
          ),
          listen(button0, "click", prevent_default(
            /*click_handler_2*/
            ctx[87]
          )),
          listen(button1, "click", prevent_default(
            /*click_handler_3*/
            ctx[88]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[1] & /*selectionMin*/
      16) {
        attr(
          input,
          "min",
          /*selectionMin*/
          ctx2[35]
        );
      }
      if (dirty[1] & /*selectionMax*/
      32) {
        attr(
          input,
          "max",
          /*selectionMax*/
          ctx2[36]
        );
      }
      if (dirty[1] & /*selectionStep*/
      64) {
        attr(
          input,
          "step",
          /*selectionStep*/
          ctx2[37]
        );
      }
      if (dirty[0] & /*selectionRadius*/
      256) {
        set_input_value(
          input,
          /*selectionRadius*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*selectionRadius*/
      256 && t1_value !== (t1_value = Math.round(
        /*selectionRadius*/
        ctx2[8] * 100
      ) / 100 + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*selectionUnits*/
      16777216) {
        each_value = ensure_array_like(
          /*selectionUnits*/
          ctx2[24]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$8(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select2, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty[0] & /*selectionUnit, selectionUnits*/
      16777728) {
        select_option(
          select2,
          /*selectionUnit*/
          ctx2[9]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
        detach(t0);
        detach(t1);
        detach(t2);
        detach(select2);
        detach(t3);
        detach(button0);
        detach(t5);
        detach(button1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_16(ctx) {
  let t;
  return {
    c() {
      t = text("Loading selection metric...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$3,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_each_block$8(ctx) {
  let option;
  let t_value = (
    /*unit*/
    ctx[101] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element$2("option");
      t = text(t_value);
      option.__value = option_value_value = /*unit*/
      ctx[101];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*selectionUnits*/
      16777216 && t_value !== (t_value = /*unit*/
      ctx2[101] + ""))
        set_data(t, t_value);
      if (dirty[0] & /*selectionUnits*/
      16777216 && option_value_value !== (option_value_value = /*unit*/
      ctx2[101])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_if_block_12$1(ctx) {
  let button;
  let mounted;
  let dispose;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*filterIDs*/
      ctx2[3].length > 0
    )
      return create_if_block_13$1;
    return create_else_block_1$2;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      button = element$2("button");
      if_block.c();
      attr(button, "type", "button");
      attr(button, "class", "btn btn-success btn-sm jp-Dialog-button jp-mod-reject jp-mod-styled svelte-617l8a");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(function() {
          if (is_function(
            /*filterIDs*/
            ctx[3].length > 0 ? (
              /*clearFilter*/
              ctx[46]
            ) : (
              /*click_handler_4*/
              ctx[89]
            )
          ))
            /*filterIDs*/
            (ctx[3].length > 0 ? (
              /*clearFilter*/
              ctx[46]
            ) : (
              /*click_handler_4*/
              ctx[89]
            )).apply(this, arguments);
        }));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type !== (current_block_type = select_block_type_2(ctx))) {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_1$2(ctx) {
  let t;
  return {
    c() {
      t = text("Isolate");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_13$1(ctx) {
  let t;
  return {
    c() {
      t = text("Show All");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_10$2(ctx) {
  let if_block_anchor;
  function select_block_type_3(ctx2, dirty) {
    if (
      /*clickedIDs*/
      ctx2[0].length == 0 || /*alignedToSelection*/
      ctx2[27]
    )
      return create_if_block_11$1;
    return create_else_block$4;
  }
  let current_block_type = select_block_type_3(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty$2();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_3(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_else_block$4(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element$2("button");
      button.textContent = "Align";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-primary btn-sm jp-Dialog-button jp-mod-reject jp-mod-styled svelte-617l8a");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(function() {
          if (is_function(
            /*clickedIDs*/
            ctx[0].length >= minSelection ? (
              /*click_handler_6*/
              ctx[91]
            ) : (
              /*click_handler_7*/
              ctx[92]
            )
          ))
            /*clickedIDs*/
            (ctx[0].length >= minSelection ? (
              /*click_handler_6*/
              ctx[91]
            ) : (
              /*click_handler_7*/
              ctx[92]
            )).apply(this, arguments);
        }));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_11$1(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element$2("button");
      button.textContent = "Unalign";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-primary btn-sm jp-Dialog-button jp-mod-reject jp-mod-styled svelte-617l8a");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(
          /*click_handler_5*/
          ctx[90]
        ));
        mounted = true;
      }
    },
    p: noop$3,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_9$2(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element$2("button");
      button.textContent = "Reset";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-dark btn-sm jp-Dialog-button jp-mod-warn jp-mod-styled svelte-617l8a");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(
          /*click_handler_8*/
          ctx[93]
        ));
        mounted = true;
      }
    },
    p: noop$3,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_6$4, create_if_block_7$3, create_if_block_8$3];
  const if_blocks = [];
  function select_block_type_4(ctx2, dirty) {
    if (
      /*previewFrame*/
      ctx2[19] >= 0 && /*previewFrame*/
      ctx2[19] != /*frame*/
      ctx2[18]
    )
      return 0;
    if (
      /*alignedIDs*/
      ctx2[1].length > 0
    )
      return 1;
    if (
      /*filterIDs*/
      ctx2[3].length > 0
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_4(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty$2();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function create_if_block_8$3(ctx) {
  let helpmessage;
  let current;
  helpmessage = new HelpMessage({
    props: {
      anchor: "lower left",
      width: 300,
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(helpmessage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helpmessage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const helpmessage_changes = {};
      if (dirty[0] & /*filterIDs*/
      8 | dirty[3] & /*$$scope*/
      2048) {
        helpmessage_changes.$$scope = { dirty, ctx: ctx2 };
      }
      helpmessage.$set(helpmessage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(helpmessage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpmessage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helpmessage, detaching);
    }
  };
}
function create_if_block_7$3(ctx) {
  let helpmessage;
  let current;
  helpmessage = new HelpMessage({
    props: {
      anchor: "lower left",
      width: 300,
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(helpmessage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helpmessage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const helpmessage_changes = {};
      if (dirty[0] & /*alignedIDs*/
      2 | dirty[3] & /*$$scope*/
      2048) {
        helpmessage_changes.$$scope = { dirty, ctx: ctx2 };
      }
      helpmessage.$set(helpmessage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(helpmessage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpmessage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helpmessage, detaching);
    }
  };
}
function create_if_block_6$4(ctx) {
  let helpmessage;
  let current;
  helpmessage = new HelpMessage({
    props: {
      anchor: "lower left",
      width: 300,
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(helpmessage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helpmessage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const helpmessage_changes = {};
      if (dirty[0] & /*data, previewFrame, frame*/
      786448 | dirty[3] & /*$$scope*/
      2048) {
        helpmessage_changes.$$scope = { dirty, ctx: ctx2 };
      }
      helpmessage.$set(helpmessage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(helpmessage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpmessage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helpmessage, detaching);
    }
  };
}
function create_default_slot_2$2(ctx) {
  let t0;
  let strong;
  let t2;
  let t3_value = (
    /*filterIDs*/
    ctx[3].length + ""
  );
  let t3;
  let t4;
  return {
    c() {
      t0 = text("The view is currently ");
      strong = element$2("strong");
      strong.textContent = "filtered";
      t2 = text(" to a group of ");
      t3 = text(t3_value);
      t4 = text("\n            points. Click Show All to remove the filter.");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, strong, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*filterIDs*/
      8 && t3_value !== (t3_value = /*filterIDs*/
      ctx2[3].length + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(strong);
        detach(t2);
        detach(t3);
        detach(t4);
      }
    }
  };
}
function create_default_slot_1$2(ctx) {
  let t0;
  let strong;
  let t2;
  let t3_value = (
    /*alignedIDs*/
    ctx[1].length + ""
  );
  let t3;
  let t4;
  return {
    c() {
      t0 = text("The view is currently ");
      strong = element$2("strong");
      strong.textContent = "aligned";
      t2 = text(" to a group of ");
      t3 = text(t3_value);
      t4 = text("\n            points. The motion for these points will be minimized as you transition\n            between frames.");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, strong, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*alignedIDs*/
      2 && t3_value !== (t3_value = /*alignedIDs*/
      ctx2[1].length + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(strong);
        detach(t2);
        detach(t3);
        detach(t4);
      }
    }
  };
}
function create_default_slot$3(ctx) {
  let t0;
  let strong0;
  let t2;
  let t3_value = (
    /*data*/
    ctx[4].frameLabels[
      /*frame*/
      ctx[18]
    ] + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*data*/
    ctx[4].frameLabels[
      /*previewFrame*/
      ctx[19]
    ] + ""
  );
  let t5;
  let t6;
  let strong1;
  let t8;
  return {
    c() {
      t0 = text("You are viewing a ");
      strong0 = element$2("strong");
      strong0.textContent = "comparison";
      t2 = text(" between frames '");
      t3 = text(t3_value);
      t4 = text("' and '");
      t5 = text(t5_value);
      t6 = text("'. The\n            widening lines (called ");
      strong1 = element$2("strong");
      strong1.textContent = "star trails";
      t8 = text(") highlight\n            points whose neighbors change the most between the two frames. Drag\n            the slider in the bottom-right or click one of the frame thumbnails\n            to transition between the two frames.");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, strong0, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
      insert(target, t5, anchor);
      insert(target, t6, anchor);
      insert(target, strong1, anchor);
      insert(target, t8, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*data, frame*/
      262160 && t3_value !== (t3_value = /*data*/
      ctx2[4].frameLabels[
        /*frame*/
        ctx2[18]
      ] + ""))
        set_data(t3, t3_value);
      if (dirty[0] & /*data, previewFrame*/
      524304 && t5_value !== (t5_value = /*data*/
      ctx2[4].frameLabels[
        /*previewFrame*/
        ctx2[19]
      ] + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(strong0);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(strong1);
        detach(t8);
      }
    }
  };
}
function create_if_block_3$4(ctx) {
  let html_tag;
  let t;
  let if_block_anchor;
  let if_block = (
    /*alignedIDs*/
    ctx[1].length > 0 && !/*alignedToSelection*/
    ctx[27] && create_if_block_4$4(ctx)
  );
  return {
    c() {
      html_tag = new HtmlTag(false);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty$2();
      html_tag.a = t;
    },
    m(target, anchor) {
      html_tag.m(
        /*alignmentText*/
        ctx[41],
        target,
        anchor
      );
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[1] & /*alignmentText*/
      1024)
        html_tag.p(
          /*alignmentText*/
          ctx2[41]
        );
      if (
        /*alignedIDs*/
        ctx2[1].length > 0 && !/*alignedToSelection*/
        ctx2[27]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        html_tag.d();
        detach(t);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_4$4(ctx) {
  let t0;
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      t0 = text("- ");
      a = element$2("a");
      a.textContent = "Select alignment anchors";
      attr(a, "href", "#");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(
          /*click_handler_9*/
          ctx[94]
        ));
        mounted = true;
      }
    },
    p: noop$3,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(a);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$5(ctx) {
  let div2;
  let fa;
  let t0;
  let t1;
  let current;
  fa = new Fa({ props: { icon: faExclamationTriangle.faExclamationTriangle } });
  return {
    c() {
      div2 = element$2("div");
      create_component(fa.$$.fragment);
      t0 = space();
      t1 = text(warningMessage);
      attr(div2, "id", "warning-panel");
      attr(div2, "class", "svelte-617l8a");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(fa, div2, null);
      append(div2, t0);
      append(div2, t1);
      current = true;
    },
    p: noop$3,
    i(local) {
      if (current)
        return;
      transition_in(fa.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fa.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(fa);
    }
  };
}
function create_if_block_1$5(ctx) {
  let div2;
  let previewslider;
  let updating_progress;
  let current;
  function previewslider_progress_binding(value) {
    ctx[95](value);
  }
  let previewslider_props = { width: 240 };
  if (
    /*previewProgress*/
    ctx[5] !== void 0
  ) {
    previewslider_props.progress = /*previewProgress*/
    ctx[5];
  }
  previewslider = new PreviewSlider({ props: previewslider_props });
  binding_callbacks.push(() => bind$4(previewslider, "progress", previewslider_progress_binding));
  return {
    c() {
      div2 = element$2("div");
      create_component(previewslider.$$.fragment);
      attr(div2, "id", "preview-panel");
      attr(div2, "class", "svelte-617l8a");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(previewslider, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const previewslider_changes = {};
      if (!updating_progress && dirty[0] & /*previewProgress*/
      32) {
        updating_progress = true;
        previewslider_changes.progress = /*previewProgress*/
        ctx2[5];
        add_flush_callback(() => updating_progress = false);
      }
      previewslider.$set(previewslider_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(previewslider.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(previewslider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(previewslider);
    }
  };
}
function create_fragment$c(ctx) {
  let div2;
  let scatterplot_1;
  let updating_previewProgress;
  let updating_clickedIDs;
  let updating_hoveredID;
  let updating_alignedIDs;
  let updating_tentativeSelectedIDs;
  let updating_followingIDs;
  let updating_filterIDs;
  let updating_data;
  let updating_scalesNeutral;
  let updating_inRadiusselect;
  let updating_selectionRadius;
  let updating_selectionUnit;
  let updating_selectionMin;
  let updating_selectionMax;
  let updating_selectionStep;
  let t;
  let current;
  function scatterplot_1_previewProgress_binding(value) {
    ctx[60](value);
  }
  function scatterplot_1_clickedIDs_binding(value) {
    ctx[61](value);
  }
  function scatterplot_1_hoveredID_binding(value) {
    ctx[62](value);
  }
  function scatterplot_1_alignedIDs_binding(value) {
    ctx[63](value);
  }
  function scatterplot_1_tentativeSelectedIDs_binding(value) {
    ctx[64](value);
  }
  function scatterplot_1_followingIDs_binding(value) {
    ctx[65](value);
  }
  function scatterplot_1_filterIDs_binding(value) {
    ctx[66](value);
  }
  function scatterplot_1_data_binding(value) {
    ctx[67](value);
  }
  function scatterplot_1_scalesNeutral_binding(value) {
    ctx[68](value);
  }
  function scatterplot_1_inRadiusselect_binding(value) {
    ctx[69](value);
  }
  function scatterplot_1_selectionRadius_binding(value) {
    ctx[70](value);
  }
  function scatterplot_1_selectionUnit_binding(value) {
    ctx[71](value);
  }
  function scatterplot_1_selectionMin_binding(value) {
    ctx[72](value);
  }
  function scatterplot_1_selectionMax_binding(value) {
    ctx[73](value);
  }
  function scatterplot_1_selectionStep_binding(value) {
    ctx[74](value);
  }
  let scatterplot_1_props = {
    padding: (
      /*padding*/
      ctx[13]
    ),
    width: (
      /*width*/
      ctx[11]
    ),
    height: (
      /*height*/
      ctx[12]
    ),
    hoverable: (
      /*hoverable*/
      ctx[16]
    ),
    thumbnail: (
      /*thumbnail*/
      ctx[17]
    ),
    pointRadius: (
      /*pointRadius*/
      ctx[14]
    ),
    performanceMode: (
      /*performanceMode*/
      ctx[32]
    ),
    colorScale: (
      /*colorScale*/
      ctx[31]
    ),
    animateTransitions: (
      /*animateTransitions*/
      ctx[15]
    ),
    thumbnailsURL: (
      /*thumbnailsURL*/
      ctx[21]
    ),
    numNeighbors: (
      /*numNeighbors*/
      ctx[22]
    ),
    frame: !!/*data*/
    ctx[4] ? (
      /*data*/
      ctx[4].frame(
        /*frame*/
        ctx[18]
      )
    ) : null,
    previewFrame: !!/*data*/
    ctx[4] && /*previewFrame*/
    ctx[19] >= 0 && /*previewFrame*/
    ctx[19] != /*frame*/
    ctx[18] ? (
      /*data*/
      ctx[4].frame(
        /*previewFrame*/
        ctx[19]
      )
    ) : null,
    previewInfo: !!/*data*/
    ctx[4] && /*previewFrame*/
    ctx[19] >= 0 && /*previewFrame*/
    ctx[19] != /*frame*/
    ctx[18] ? (
      /*data*/
      ctx[4].previewInfo(
        /*frame*/
        ctx[18],
        /*previewFrame*/
        ctx[19]
      )
    ) : null,
    idsOfInterest: (
      /*alignedIDs*/
      ctx[1].length > 0 ? (
        /*getFilterPoints*/
        ctx[45](
          /*alignedIDs*/
          ctx[1]
        )
      ) : (
        /*clickedIDs*/
        ctx[0].length > 0 ? (
          /*getFilterPoints*/
          ctx[45](
            /*clickedIDs*/
            ctx[0]
          )
        ) : []
      )
    ),
    selectionOrderFn: !!/*selectionOrderFn*/
    ctx[23] ? (
      /*func*/
      ctx[58]
    ) : null
  };
  if (
    /*previewProgress*/
    ctx[5] !== void 0
  ) {
    scatterplot_1_props.previewProgress = /*previewProgress*/
    ctx[5];
  }
  if (
    /*clickedIDs*/
    ctx[0] !== void 0
  ) {
    scatterplot_1_props.clickedIDs = /*clickedIDs*/
    ctx[0];
  }
  if (
    /*hoveredID*/
    ctx[6] !== void 0
  ) {
    scatterplot_1_props.hoveredID = /*hoveredID*/
    ctx[6];
  }
  if (
    /*alignedIDs*/
    ctx[1] !== void 0
  ) {
    scatterplot_1_props.alignedIDs = /*alignedIDs*/
    ctx[1];
  }
  if (
    /*tentativeSelectedIDs*/
    ctx[2] !== void 0
  ) {
    scatterplot_1_props.tentativeSelectedIDs = /*tentativeSelectedIDs*/
    ctx[2];
  }
  if (
    /*followingIDs*/
    ctx[29] !== void 0
  ) {
    scatterplot_1_props.followingIDs = /*followingIDs*/
    ctx[29];
  }
  if (
    /*filterIDs*/
    ctx[3] !== void 0
  ) {
    scatterplot_1_props.filterIDs = /*filterIDs*/
    ctx[3];
  }
  if (
    /*data*/
    ctx[4] !== void 0
  ) {
    scatterplot_1_props.data = /*data*/
    ctx[4];
  }
  if (
    /*scalesNeutral*/
    ctx[26] !== void 0
  ) {
    scatterplot_1_props.scalesNeutral = /*scalesNeutral*/
    ctx[26];
  }
  if (
    /*inRadiusselect*/
    ctx[7] !== void 0
  ) {
    scatterplot_1_props.inRadiusselect = /*inRadiusselect*/
    ctx[7];
  }
  if (
    /*selectionRadius*/
    ctx[8] !== void 0
  ) {
    scatterplot_1_props.selectionRadius = /*selectionRadius*/
    ctx[8];
  }
  if (
    /*selectionUnit*/
    ctx[9] !== void 0
  ) {
    scatterplot_1_props.selectionUnit = /*selectionUnit*/
    ctx[9];
  }
  if (
    /*selectionMin*/
    ctx[35] !== void 0
  ) {
    scatterplot_1_props.selectionMin = /*selectionMin*/
    ctx[35];
  }
  if (
    /*selectionMax*/
    ctx[36] !== void 0
  ) {
    scatterplot_1_props.selectionMax = /*selectionMax*/
    ctx[36];
  }
  if (
    /*selectionStep*/
    ctx[37] !== void 0
  ) {
    scatterplot_1_props.selectionStep = /*selectionStep*/
    ctx[37];
  }
  scatterplot_1 = new Scatterplot_1({ props: scatterplot_1_props });
  ctx[59](scatterplot_1);
  binding_callbacks.push(() => bind$4(scatterplot_1, "previewProgress", scatterplot_1_previewProgress_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "clickedIDs", scatterplot_1_clickedIDs_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "hoveredID", scatterplot_1_hoveredID_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "alignedIDs", scatterplot_1_alignedIDs_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "tentativeSelectedIDs", scatterplot_1_tentativeSelectedIDs_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "followingIDs", scatterplot_1_followingIDs_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "filterIDs", scatterplot_1_filterIDs_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "data", scatterplot_1_data_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "scalesNeutral", scatterplot_1_scalesNeutral_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "inRadiusselect", scatterplot_1_inRadiusselect_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "selectionRadius", scatterplot_1_selectionRadius_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "selectionUnit", scatterplot_1_selectionUnit_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "selectionMin", scatterplot_1_selectionMin_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "selectionMax", scatterplot_1_selectionMax_binding));
  binding_callbacks.push(() => bind$4(scatterplot_1, "selectionStep", scatterplot_1_selectionStep_binding));
  scatterplot_1.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[75]
  );
  scatterplot_1.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[76]
  );
  scatterplot_1.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[77]
  );
  scatterplot_1.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[78]
  );
  scatterplot_1.$on(
    "datahover",
    /*datahover_handler*/
    ctx[79]
  );
  scatterplot_1.$on(
    "dataclick",
    /*dataclick_handler*/
    ctx[80]
  );
  scatterplot_1.$on(
    "click",
    /*click_handler*/
    ctx[81]
  );
  scatterplot_1.$on(
    "viewportChanged",
    /*viewportChanged_handler*/
    ctx[82]
  );
  scatterplot_1.$on(
    "logEvent",
    /*logEvent_handler*/
    ctx[83]
  );
  let if_block = !/*thumbnail*/
  ctx[17] && create_if_block$6(ctx);
  return {
    c() {
      div2 = element$2("div");
      create_component(scatterplot_1.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      set_style(
        div2,
        "width",
        /*width*/
        ctx[11] != null ? `${/*width*/
        ctx[11]}px` : "100%"
      );
      set_style(
        div2,
        "height",
        /*height*/
        ctx[12] != null ? `${/*height*/
        ctx[12]}px` : "100%"
      );
      set_style(
        div2,
        "background-color",
        /*backgroundColor*/
        ctx[10]
      );
      attr(div2, "id", "container");
      attr(div2, "class", "svelte-617l8a");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(scatterplot_1, div2, null);
      append(div2, t);
      if (if_block)
        if_block.m(div2, null);
      ctx[96](div2);
      current = true;
    },
    p(ctx2, dirty) {
      const scatterplot_1_changes = {};
      if (dirty[0] & /*padding*/
      8192)
        scatterplot_1_changes.padding = /*padding*/
        ctx2[13];
      if (dirty[0] & /*width*/
      2048)
        scatterplot_1_changes.width = /*width*/
        ctx2[11];
      if (dirty[0] & /*height*/
      4096)
        scatterplot_1_changes.height = /*height*/
        ctx2[12];
      if (dirty[0] & /*hoverable*/
      65536)
        scatterplot_1_changes.hoverable = /*hoverable*/
        ctx2[16];
      if (dirty[0] & /*thumbnail*/
      131072)
        scatterplot_1_changes.thumbnail = /*thumbnail*/
        ctx2[17];
      if (dirty[0] & /*pointRadius*/
      16384)
        scatterplot_1_changes.pointRadius = /*pointRadius*/
        ctx2[14];
      if (dirty[1] & /*performanceMode*/
      2)
        scatterplot_1_changes.performanceMode = /*performanceMode*/
        ctx2[32];
      if (dirty[1] & /*colorScale*/
      1)
        scatterplot_1_changes.colorScale = /*colorScale*/
        ctx2[31];
      if (dirty[0] & /*animateTransitions*/
      32768)
        scatterplot_1_changes.animateTransitions = /*animateTransitions*/
        ctx2[15];
      if (dirty[0] & /*thumbnailsURL*/
      2097152)
        scatterplot_1_changes.thumbnailsURL = /*thumbnailsURL*/
        ctx2[21];
      if (dirty[0] & /*numNeighbors*/
      4194304)
        scatterplot_1_changes.numNeighbors = /*numNeighbors*/
        ctx2[22];
      if (dirty[0] & /*data, frame*/
      262160)
        scatterplot_1_changes.frame = !!/*data*/
        ctx2[4] ? (
          /*data*/
          ctx2[4].frame(
            /*frame*/
            ctx2[18]
          )
        ) : null;
      if (dirty[0] & /*data, previewFrame, frame*/
      786448)
        scatterplot_1_changes.previewFrame = !!/*data*/
        ctx2[4] && /*previewFrame*/
        ctx2[19] >= 0 && /*previewFrame*/
        ctx2[19] != /*frame*/
        ctx2[18] ? (
          /*data*/
          ctx2[4].frame(
            /*previewFrame*/
            ctx2[19]
          )
        ) : null;
      if (dirty[0] & /*data, previewFrame, frame*/
      786448)
        scatterplot_1_changes.previewInfo = !!/*data*/
        ctx2[4] && /*previewFrame*/
        ctx2[19] >= 0 && /*previewFrame*/
        ctx2[19] != /*frame*/
        ctx2[18] ? (
          /*data*/
          ctx2[4].previewInfo(
            /*frame*/
            ctx2[18],
            /*previewFrame*/
            ctx2[19]
          )
        ) : null;
      if (dirty[0] & /*alignedIDs, clickedIDs*/
      3)
        scatterplot_1_changes.idsOfInterest = /*alignedIDs*/
        ctx2[1].length > 0 ? (
          /*getFilterPoints*/
          ctx2[45](
            /*alignedIDs*/
            ctx2[1]
          )
        ) : (
          /*clickedIDs*/
          ctx2[0].length > 0 ? (
            /*getFilterPoints*/
            ctx2[45](
              /*clickedIDs*/
              ctx2[0]
            )
          ) : []
        );
      if (dirty[0] & /*selectionOrderFn*/
      8388608 | dirty[1] & /*selectionOrderLoading*/
      128)
        scatterplot_1_changes.selectionOrderFn = !!/*selectionOrderFn*/
        ctx2[23] ? (
          /*func*/
          ctx2[58]
        ) : null;
      if (!updating_previewProgress && dirty[0] & /*previewProgress*/
      32) {
        updating_previewProgress = true;
        scatterplot_1_changes.previewProgress = /*previewProgress*/
        ctx2[5];
        add_flush_callback(() => updating_previewProgress = false);
      }
      if (!updating_clickedIDs && dirty[0] & /*clickedIDs*/
      1) {
        updating_clickedIDs = true;
        scatterplot_1_changes.clickedIDs = /*clickedIDs*/
        ctx2[0];
        add_flush_callback(() => updating_clickedIDs = false);
      }
      if (!updating_hoveredID && dirty[0] & /*hoveredID*/
      64) {
        updating_hoveredID = true;
        scatterplot_1_changes.hoveredID = /*hoveredID*/
        ctx2[6];
        add_flush_callback(() => updating_hoveredID = false);
      }
      if (!updating_alignedIDs && dirty[0] & /*alignedIDs*/
      2) {
        updating_alignedIDs = true;
        scatterplot_1_changes.alignedIDs = /*alignedIDs*/
        ctx2[1];
        add_flush_callback(() => updating_alignedIDs = false);
      }
      if (!updating_tentativeSelectedIDs && dirty[0] & /*tentativeSelectedIDs*/
      4) {
        updating_tentativeSelectedIDs = true;
        scatterplot_1_changes.tentativeSelectedIDs = /*tentativeSelectedIDs*/
        ctx2[2];
        add_flush_callback(() => updating_tentativeSelectedIDs = false);
      }
      if (!updating_followingIDs && dirty[0] & /*followingIDs*/
      536870912) {
        updating_followingIDs = true;
        scatterplot_1_changes.followingIDs = /*followingIDs*/
        ctx2[29];
        add_flush_callback(() => updating_followingIDs = false);
      }
      if (!updating_filterIDs && dirty[0] & /*filterIDs*/
      8) {
        updating_filterIDs = true;
        scatterplot_1_changes.filterIDs = /*filterIDs*/
        ctx2[3];
        add_flush_callback(() => updating_filterIDs = false);
      }
      if (!updating_data && dirty[0] & /*data*/
      16) {
        updating_data = true;
        scatterplot_1_changes.data = /*data*/
        ctx2[4];
        add_flush_callback(() => updating_data = false);
      }
      if (!updating_scalesNeutral && dirty[0] & /*scalesNeutral*/
      67108864) {
        updating_scalesNeutral = true;
        scatterplot_1_changes.scalesNeutral = /*scalesNeutral*/
        ctx2[26];
        add_flush_callback(() => updating_scalesNeutral = false);
      }
      if (!updating_inRadiusselect && dirty[0] & /*inRadiusselect*/
      128) {
        updating_inRadiusselect = true;
        scatterplot_1_changes.inRadiusselect = /*inRadiusselect*/
        ctx2[7];
        add_flush_callback(() => updating_inRadiusselect = false);
      }
      if (!updating_selectionRadius && dirty[0] & /*selectionRadius*/
      256) {
        updating_selectionRadius = true;
        scatterplot_1_changes.selectionRadius = /*selectionRadius*/
        ctx2[8];
        add_flush_callback(() => updating_selectionRadius = false);
      }
      if (!updating_selectionUnit && dirty[0] & /*selectionUnit*/
      512) {
        updating_selectionUnit = true;
        scatterplot_1_changes.selectionUnit = /*selectionUnit*/
        ctx2[9];
        add_flush_callback(() => updating_selectionUnit = false);
      }
      if (!updating_selectionMin && dirty[1] & /*selectionMin*/
      16) {
        updating_selectionMin = true;
        scatterplot_1_changes.selectionMin = /*selectionMin*/
        ctx2[35];
        add_flush_callback(() => updating_selectionMin = false);
      }
      if (!updating_selectionMax && dirty[1] & /*selectionMax*/
      32) {
        updating_selectionMax = true;
        scatterplot_1_changes.selectionMax = /*selectionMax*/
        ctx2[36];
        add_flush_callback(() => updating_selectionMax = false);
      }
      if (!updating_selectionStep && dirty[1] & /*selectionStep*/
      64) {
        updating_selectionStep = true;
        scatterplot_1_changes.selectionStep = /*selectionStep*/
        ctx2[37];
        add_flush_callback(() => updating_selectionStep = false);
      }
      scatterplot_1.$set(scatterplot_1_changes);
      if (!/*thumbnail*/
      ctx2[17]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*thumbnail*/
          131072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*width*/
      2048) {
        set_style(
          div2,
          "width",
          /*width*/
          ctx2[11] != null ? `${/*width*/
          ctx2[11]}px` : "100%"
        );
      }
      if (!current || dirty[0] & /*height*/
      4096) {
        set_style(
          div2,
          "height",
          /*height*/
          ctx2[12] != null ? `${/*height*/
          ctx2[12]}px` : "100%"
        );
      }
      if (!current || dirty[0] & /*backgroundColor*/
      1024) {
        set_style(
          div2,
          "background-color",
          /*backgroundColor*/
          ctx2[10]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(scatterplot_1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(scatterplot_1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      ctx[59](null);
      destroy_component(scatterplot_1);
      if (if_block)
        if_block.d();
      ctx[96](null);
    }
  };
}
const minSelection = 3;
let warningMessage = "";
const DefaultSelectionRadius = 30;
function _othersMessage(pointIDs) {
  return pointIDs.length > 1 ? ` and ${pointIDs.length - 1} others` : "";
}
function instance$c($$self, $$props, $$invalidate) {
  let $helpMessagesVisible;
  component_subscribe($$self, helpMessagesVisible, ($$value) => $$invalidate(42, $helpMessagesVisible = $$value));
  const dispatch2 = createEventDispatcher();
  let container;
  let { backgroundColor = "white" } = $$props;
  let { width = null } = $$props;
  let { height = null } = $$props;
  let { padding = 0.3 } = $$props;
  let { pointRadius = 3 } = $$props;
  let { colorScheme = { value: turbo } } = $$props;
  let { animateTransitions = false } = $$props;
  let { performanceModeThreshold = 2e3 } = $$props;
  let { hoverable = false } = $$props;
  let { thumbnail = false } = $$props;
  let { frame: frame2 = 0 } = $$props;
  let { previewFrame = -1 } = $$props;
  let { showPreviewControls = false } = $$props;
  let { previewProgress = 0 } = $$props;
  let scalesNeutral = true;
  let { hoveredID = null } = $$props;
  let { clickedIDs = [] } = $$props;
  let { alignedIDs = [] } = $$props;
  let { tentativeSelectedIDs = [] } = $$props;
  let { filterIDs = [] } = $$props;
  let followingIDs = [];
  let { data = null } = $$props;
  let { thumbnailsURL = null } = $$props;
  let { numNeighbors = 10 } = $$props;
  let scatterplot;
  let colorScale = (c2) => c2;
  let performanceMode = false;
  function getViewport() {
    return scatterplot.getViewport();
  }
  var prevClickedIDs = null;
  function updateSelection() {
    if (clickedIDs.length > 0) {
      if (clickedIDs.length == 1)
        showVicinityOfClickedPoint();
      if (filterIDs.length > 0)
        filterToSelection(true);
    } else {
      $$invalidate(29, followingIDs = []);
    }
  }
  function selectPoint(pointID, multi = false) {
    if (!scatterplot)
      return;
    scatterplot.selectPoint(pointID, multi);
  }
  var prevAlignedIDs = null;
  let showFilterButton = false;
  function filterToSelection(append2 = false) {
    let newFilter = getFilterPoints(clickedIDs);
    if (append2) {
      filterIDs.forEach((id2) => newFilter.add(id2));
    }
    $$invalidate(3, filterIDs = Array.from(newFilter));
  }
  function getFilterPoints(selection2) {
    let filteredPoints = /* @__PURE__ */ new Set();
    selection2.forEach((clickedID) => {
      filteredPoints.add(clickedID);
      data.frames.forEach((frame3) => {
        let neighbors = frame3.neighbors(clickedID, 10);
        neighbors.forEach((n) => filteredPoints.add(n));
        let highlight = frame3.get(clickedID, "highlightIndexes").slice(0, numNeighbors);
        if (!!highlight) {
          highlight.forEach((n) => filteredPoints.add(n));
        }
      });
    });
    return filteredPoints;
  }
  function clearFilter() {
    $$invalidate(3, filterIDs = []);
  }
  let showRadiusselectButton = false;
  let { inRadiusselect = false } = $$props;
  let { selectionRadius = DefaultSelectionRadius } = $$props;
  let { selectionOrderFn = null } = $$props;
  let { selectionUnit = "pixels" } = $$props;
  let { selectionUnits = ["pixels", "cosine"] } = $$props;
  let selectionMin = 0;
  let selectionMax = 0;
  let selectionStep = 1;
  let selectionOrderLoading = false;
  let showResetButton = false;
  let { allowAlignment = true } = $$props;
  let showAlignmentButton = false;
  let alignedToSelection = false;
  let alignmentText = "";
  function _describePoint(pointID) {
    let datapt = data.byID(pointID);
    if (!datapt)
      return "";
    let detailMessage = null;
    let labels = datapt.label;
    if (!!labels) {
      if (!!labels[frame2])
        detailMessage = labels[frame2].text || null;
      else if (Object.keys(labels).length > 0 && !!labels[Object.keys(labels)[0]])
        detailMessage = labels[Object.keys(labels)[0]].text || null;
      else
        detailMessage = null;
    }
    if (!!detailMessage)
      detailMessage = " - " + detailMessage;
    else
      detailMessage = "";
    return `${pointID}${detailMessage}`;
  }
  function getAlignmentText(alignPoints, clickPoints, tentativePoints, alignedToSelectedPoints) {
    if (alignPoints.length == 0 && clickPoints.length == 0 && tentativePoints.length == 0 || thumbnail) {
      return "";
    }
    if (tentativePoints.length > 0) {
      return `Selecting ${tentativePoints.length} points`;
    }
    if (clickPoints.length == 0 && alignPoints.length > 0) {
      return `Aligned to <strong>${_describePoint(alignPoints[0])}</strong>${_othersMessage(alignPoints)}`;
    } else if (clickPoints.length > 0 && alignPoints.length == 0) {
      return `<strong>${_describePoint(clickPoints[0])}</strong>${_othersMessage(clickPoints)} selected`;
    }
    let selectionBase = `<strong>${_describePoint(clickPoints[0])}</strong>${_othersMessage(clickPoints)} selected`;
    if (alignedToSelectedPoints)
      return selectionBase + " (aligned)";
    return selectionBase + `, aligned to ${alignPoints.length} point${alignPoints.length > 1 ? "s" : ""}`;
  }
  function animateDatasetUpdate() {
    scatterplot.animateDatasetUpdate();
  }
  function updateThumbnails() {
    if (!!scatterplot.updateThumbnails)
      scatterplot.updateThumbnails();
  }
  function reset() {
    $$invalidate(0, clickedIDs = []);
    $$invalidate(1, alignedIDs = []);
    $$invalidate(29, followingIDs = []);
    $$invalidate(3, filterIDs = []);
    scatterplot.reset();
  }
  function getVicinityOfPoints(pointIDs) {
    let vicinity;
    if (pointIDs.length >= 3) {
      vicinity = pointIDs;
    } else {
      let filteredPoints = new Set(pointIDs);
      pointIDs.forEach((id2) => {
        let highlightIndexes = data.byID(id2).highlightIndexes;
        let allNeighbors = new Set(Object.values(highlightIndexes).map((v2) => v2.slice(0, numNeighbors)).flat());
        allNeighbors.forEach((n) => filteredPoints.add(n));
      });
      vicinity = Array.from(filteredPoints);
    }
    return vicinity;
  }
  function showVicinityOfClickedPoint() {
    $$invalidate(29, followingIDs = getVicinityOfPoints(clickedIDs));
    console.log("showing vicinity:", clickedIDs, followingIDs);
  }
  const func2 = async (id2, metric) => {
    $$invalidate(38, selectionOrderLoading = true);
    let result = await selectionOrderFn(id2, metric);
    $$invalidate(38, selectionOrderLoading = false);
    return result;
  };
  function scatterplot_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scatterplot = $$value;
      $$invalidate(30, scatterplot);
    });
  }
  function scatterplot_1_previewProgress_binding(value) {
    previewProgress = value;
    $$invalidate(5, previewProgress);
  }
  function scatterplot_1_clickedIDs_binding(value) {
    clickedIDs = value;
    $$invalidate(0, clickedIDs);
  }
  function scatterplot_1_hoveredID_binding(value) {
    hoveredID = value;
    $$invalidate(6, hoveredID);
  }
  function scatterplot_1_alignedIDs_binding(value) {
    alignedIDs = value;
    $$invalidate(1, alignedIDs);
  }
  function scatterplot_1_tentativeSelectedIDs_binding(value) {
    tentativeSelectedIDs = value;
    $$invalidate(2, tentativeSelectedIDs);
  }
  function scatterplot_1_followingIDs_binding(value) {
    followingIDs = value;
    $$invalidate(29, followingIDs);
  }
  function scatterplot_1_filterIDs_binding(value) {
    filterIDs = value;
    $$invalidate(3, filterIDs);
  }
  function scatterplot_1_data_binding(value) {
    data = value;
    $$invalidate(4, data);
  }
  function scatterplot_1_scalesNeutral_binding(value) {
    scalesNeutral = value;
    $$invalidate(26, scalesNeutral);
  }
  function scatterplot_1_inRadiusselect_binding(value) {
    inRadiusselect = value;
    $$invalidate(7, inRadiusselect);
  }
  function scatterplot_1_selectionRadius_binding(value) {
    selectionRadius = value;
    $$invalidate(8, selectionRadius);
  }
  function scatterplot_1_selectionUnit_binding(value) {
    selectionUnit = value;
    $$invalidate(9, selectionUnit);
  }
  function scatterplot_1_selectionMin_binding(value) {
    selectionMin = value;
    $$invalidate(35, selectionMin);
  }
  function scatterplot_1_selectionMax_binding(value) {
    selectionMax = value;
    $$invalidate(36, selectionMax);
  }
  function scatterplot_1_selectionStep_binding(value) {
    selectionStep = value;
    $$invalidate(37, selectionStep);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function datahover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function dataclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportChanged_handler(event) {
    bubble.call(this, $$self, event);
  }
  function logEvent_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler_1 = () => {
    $$invalidate(7, inRadiusselect = true);
    $$invalidate(8, selectionRadius = DefaultSelectionRadius);
  };
  function input_change_input_handler() {
    selectionRadius = to_number(this.value);
    $$invalidate(8, selectionRadius);
  }
  function select_change_handler() {
    selectionUnit = select_value(this);
    $$invalidate(9, selectionUnit);
    $$invalidate(24, selectionUnits);
  }
  const click_handler_2 = () => scatterplot.cancelRadiusSelect();
  const click_handler_3 = () => $$invalidate(7, inRadiusselect = false);
  const click_handler_4 = () => filterToSelection();
  const click_handler_5 = () => $$invalidate(1, alignedIDs = []);
  const click_handler_6 = () => $$invalidate(1, alignedIDs = getVicinityOfPoints(clickedIDs));
  const click_handler_7 = () => alert(`You must select at least ${minSelection} points to align.`);
  const click_handler_8 = (e) => {
    reset();
    dispatch2("reset");
  };
  const click_handler_9 = () => $$invalidate(0, clickedIDs = alignedIDs);
  function previewslider_progress_binding(value) {
    previewProgress = value;
    $$invalidate(5, previewProgress);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(28, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("backgroundColor" in $$props2)
      $$invalidate(10, backgroundColor = $$props2.backgroundColor);
    if ("width" in $$props2)
      $$invalidate(11, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(12, height = $$props2.height);
    if ("padding" in $$props2)
      $$invalidate(13, padding = $$props2.padding);
    if ("pointRadius" in $$props2)
      $$invalidate(14, pointRadius = $$props2.pointRadius);
    if ("colorScheme" in $$props2)
      $$invalidate(48, colorScheme = $$props2.colorScheme);
    if ("animateTransitions" in $$props2)
      $$invalidate(15, animateTransitions = $$props2.animateTransitions);
    if ("performanceModeThreshold" in $$props2)
      $$invalidate(49, performanceModeThreshold = $$props2.performanceModeThreshold);
    if ("hoverable" in $$props2)
      $$invalidate(16, hoverable = $$props2.hoverable);
    if ("thumbnail" in $$props2)
      $$invalidate(17, thumbnail = $$props2.thumbnail);
    if ("frame" in $$props2)
      $$invalidate(18, frame2 = $$props2.frame);
    if ("previewFrame" in $$props2)
      $$invalidate(19, previewFrame = $$props2.previewFrame);
    if ("showPreviewControls" in $$props2)
      $$invalidate(20, showPreviewControls = $$props2.showPreviewControls);
    if ("previewProgress" in $$props2)
      $$invalidate(5, previewProgress = $$props2.previewProgress);
    if ("hoveredID" in $$props2)
      $$invalidate(6, hoveredID = $$props2.hoveredID);
    if ("clickedIDs" in $$props2)
      $$invalidate(0, clickedIDs = $$props2.clickedIDs);
    if ("alignedIDs" in $$props2)
      $$invalidate(1, alignedIDs = $$props2.alignedIDs);
    if ("tentativeSelectedIDs" in $$props2)
      $$invalidate(2, tentativeSelectedIDs = $$props2.tentativeSelectedIDs);
    if ("filterIDs" in $$props2)
      $$invalidate(3, filterIDs = $$props2.filterIDs);
    if ("data" in $$props2)
      $$invalidate(4, data = $$props2.data);
    if ("thumbnailsURL" in $$props2)
      $$invalidate(21, thumbnailsURL = $$props2.thumbnailsURL);
    if ("numNeighbors" in $$props2)
      $$invalidate(22, numNeighbors = $$props2.numNeighbors);
    if ("inRadiusselect" in $$props2)
      $$invalidate(7, inRadiusselect = $$props2.inRadiusselect);
    if ("selectionRadius" in $$props2)
      $$invalidate(8, selectionRadius = $$props2.selectionRadius);
    if ("selectionOrderFn" in $$props2)
      $$invalidate(23, selectionOrderFn = $$props2.selectionOrderFn);
    if ("selectionUnit" in $$props2)
      $$invalidate(9, selectionUnit = $$props2.selectionUnit);
    if ("selectionUnits" in $$props2)
      $$invalidate(24, selectionUnits = $$props2.selectionUnits);
    if ("allowAlignment" in $$props2)
      $$invalidate(52, allowAlignment = $$props2.allowAlignment);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*data*/
    16 | $$self.$$.dirty[1] & /*colorScheme*/
    131072) {
      if (!!data) {
        $$invalidate(31, colorScale = data.colorScale(colorScheme));
      }
    }
    if ($$self.$$.dirty[0] & /*data, filterIDs*/
    24 | $$self.$$.dirty[1] & /*performanceModeThreshold*/
    262144) {
      if (!!data) {
        $$invalidate(32, performanceMode = (filterIDs == null || filterIDs.length == 0 || filterIDs.length > performanceModeThreshold) && data.frame(0).length > performanceModeThreshold);
      }
    }
    if ($$self.$$.dirty[0] & /*clickedIDs, data*/
    17 | $$self.$$.dirty[1] & /*prevClickedIDs*/
    33554432) {
      if (prevClickedIDs != clickedIDs && !!data) {
        updateSelection();
        $$invalidate(56, prevClickedIDs = clickedIDs);
        dispatch2("dataclick", clickedIDs);
      }
    }
    if ($$self.$$.dirty[0] & /*alignedIDs, data, frame*/
    262162 | $$self.$$.dirty[1] & /*prevAlignedIDs*/
    67108864) {
      if (prevAlignedIDs != alignedIDs && !!data) {
        dispatch2("align", { alignedIDs, baseFrame: frame2 });
        $$invalidate(57, prevAlignedIDs = alignedIDs);
      }
    }
    if ($$self.$$.dirty[0] & /*clickedIDs, filterIDs*/
    9) {
      $$invalidate(33, showFilterButton = clickedIDs.length > 0 || filterIDs.length > 0);
    }
    if ($$self.$$.dirty[0] & /*clickedIDs, filterIDs*/
    9) {
      $$invalidate(34, showRadiusselectButton = clickedIDs.length == 1 && filterIDs.length == 0);
    }
    if ($$self.$$.dirty[0] & /*scalesNeutral, clickedIDs, alignedIDs*/
    67108867) {
      $$invalidate(39, showResetButton = !scalesNeutral || clickedIDs.length > 0 || alignedIDs.length > 0);
    }
    if ($$self.$$.dirty[0] & /*clickedIDs, alignedIDs*/
    3 | $$self.$$.dirty[1] & /*allowAlignment*/
    2097152) {
      $$invalidate(40, showAlignmentButton = allowAlignment && (clickedIDs.length > 0 || alignedIDs.length > 0));
    }
    if ($$self.$$.dirty[0] & /*alignedIDs, clickedIDs*/
    3) {
      $$invalidate(27, alignedToSelection = alignedIDs.length > 0 && JSON.stringify(alignedIDs) == JSON.stringify(getVicinityOfPoints(clickedIDs)));
    }
    if ($$self.$$.dirty[0] & /*alignedIDs, clickedIDs, tentativeSelectedIDs, alignedToSelection*/
    134217735) {
      $$invalidate(41, alignmentText = getAlignmentText(alignedIDs, clickedIDs, tentativeSelectedIDs, alignedToSelection));
    }
  };
  return [
    clickedIDs,
    alignedIDs,
    tentativeSelectedIDs,
    filterIDs,
    data,
    previewProgress,
    hoveredID,
    inRadiusselect,
    selectionRadius,
    selectionUnit,
    backgroundColor,
    width,
    height,
    padding,
    pointRadius,
    animateTransitions,
    hoverable,
    thumbnail,
    frame2,
    previewFrame,
    showPreviewControls,
    thumbnailsURL,
    numNeighbors,
    selectionOrderFn,
    selectionUnits,
    reset,
    scalesNeutral,
    alignedToSelection,
    container,
    followingIDs,
    scatterplot,
    colorScale,
    performanceMode,
    showFilterButton,
    showRadiusselectButton,
    selectionMin,
    selectionMax,
    selectionStep,
    selectionOrderLoading,
    showResetButton,
    showAlignmentButton,
    alignmentText,
    $helpMessagesVisible,
    dispatch2,
    filterToSelection,
    getFilterPoints,
    clearFilter,
    getVicinityOfPoints,
    colorScheme,
    performanceModeThreshold,
    getViewport,
    selectPoint,
    allowAlignment,
    animateDatasetUpdate,
    updateThumbnails,
    showVicinityOfClickedPoint,
    prevClickedIDs,
    prevAlignedIDs,
    func2,
    scatterplot_1_binding,
    scatterplot_1_previewProgress_binding,
    scatterplot_1_clickedIDs_binding,
    scatterplot_1_hoveredID_binding,
    scatterplot_1_alignedIDs_binding,
    scatterplot_1_tentativeSelectedIDs_binding,
    scatterplot_1_followingIDs_binding,
    scatterplot_1_filterIDs_binding,
    scatterplot_1_data_binding,
    scatterplot_1_scalesNeutral_binding,
    scatterplot_1_inRadiusselect_binding,
    scatterplot_1_selectionRadius_binding,
    scatterplot_1_selectionUnit_binding,
    scatterplot_1_selectionMin_binding,
    scatterplot_1_selectionMax_binding,
    scatterplot_1_selectionStep_binding,
    mouseover_handler,
    mouseout_handler,
    mousedown_handler,
    mouseup_handler,
    datahover_handler,
    dataclick_handler,
    click_handler,
    viewportChanged_handler,
    logEvent_handler,
    click_handler_1,
    input_change_input_handler,
    select_change_handler,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    click_handler_7,
    click_handler_8,
    click_handler_9,
    previewslider_progress_binding,
    div_binding
  ];
}
class SynchronizedScatterplot extends SvelteComponent {
  constructor(options) {
    super();
    init$2(
      this,
      options,
      instance$c,
      create_fragment$c,
      safe_not_equal,
      {
        backgroundColor: 10,
        width: 11,
        height: 12,
        padding: 13,
        pointRadius: 14,
        colorScheme: 48,
        animateTransitions: 15,
        performanceModeThreshold: 49,
        hoverable: 16,
        thumbnail: 17,
        frame: 18,
        previewFrame: 19,
        showPreviewControls: 20,
        previewProgress: 5,
        hoveredID: 6,
        clickedIDs: 0,
        alignedIDs: 1,
        tentativeSelectedIDs: 2,
        filterIDs: 3,
        data: 4,
        thumbnailsURL: 21,
        numNeighbors: 22,
        getViewport: 50,
        selectPoint: 51,
        inRadiusselect: 7,
        selectionRadius: 8,
        selectionOrderFn: 23,
        selectionUnit: 9,
        selectionUnits: 24,
        allowAlignment: 52,
        animateDatasetUpdate: 53,
        updateThumbnails: 54,
        reset: 25,
        showVicinityOfClickedPoint: 55
      },
      null,
      [-1, -1, -1, -1]
    );
  }
  get backgroundColor() {
    return this.$$.ctx[10];
  }
  set backgroundColor(backgroundColor) {
    this.$$set({ backgroundColor });
    flush();
  }
  get width() {
    return this.$$.ctx[11];
  }
  set width(width) {
    this.$$set({ width });
    flush();
  }
  get height() {
    return this.$$.ctx[12];
  }
  set height(height) {
    this.$$set({ height });
    flush();
  }
  get padding() {
    return this.$$.ctx[13];
  }
  set padding(padding) {
    this.$$set({ padding });
    flush();
  }
  get pointRadius() {
    return this.$$.ctx[14];
  }
  set pointRadius(pointRadius) {
    this.$$set({ pointRadius });
    flush();
  }
  get colorScheme() {
    return this.$$.ctx[48];
  }
  set colorScheme(colorScheme) {
    this.$$set({ colorScheme });
    flush();
  }
  get animateTransitions() {
    return this.$$.ctx[15];
  }
  set animateTransitions(animateTransitions) {
    this.$$set({ animateTransitions });
    flush();
  }
  get performanceModeThreshold() {
    return this.$$.ctx[49];
  }
  set performanceModeThreshold(performanceModeThreshold) {
    this.$$set({ performanceModeThreshold });
    flush();
  }
  get hoverable() {
    return this.$$.ctx[16];
  }
  set hoverable(hoverable) {
    this.$$set({ hoverable });
    flush();
  }
  get thumbnail() {
    return this.$$.ctx[17];
  }
  set thumbnail(thumbnail) {
    this.$$set({ thumbnail });
    flush();
  }
  get frame() {
    return this.$$.ctx[18];
  }
  set frame(frame2) {
    this.$$set({ frame: frame2 });
    flush();
  }
  get previewFrame() {
    return this.$$.ctx[19];
  }
  set previewFrame(previewFrame) {
    this.$$set({ previewFrame });
    flush();
  }
  get showPreviewControls() {
    return this.$$.ctx[20];
  }
  set showPreviewControls(showPreviewControls) {
    this.$$set({ showPreviewControls });
    flush();
  }
  get previewProgress() {
    return this.$$.ctx[5];
  }
  set previewProgress(previewProgress) {
    this.$$set({ previewProgress });
    flush();
  }
  get hoveredID() {
    return this.$$.ctx[6];
  }
  set hoveredID(hoveredID) {
    this.$$set({ hoveredID });
    flush();
  }
  get clickedIDs() {
    return this.$$.ctx[0];
  }
  set clickedIDs(clickedIDs) {
    this.$$set({ clickedIDs });
    flush();
  }
  get alignedIDs() {
    return this.$$.ctx[1];
  }
  set alignedIDs(alignedIDs) {
    this.$$set({ alignedIDs });
    flush();
  }
  get tentativeSelectedIDs() {
    return this.$$.ctx[2];
  }
  set tentativeSelectedIDs(tentativeSelectedIDs) {
    this.$$set({ tentativeSelectedIDs });
    flush();
  }
  get filterIDs() {
    return this.$$.ctx[3];
  }
  set filterIDs(filterIDs) {
    this.$$set({ filterIDs });
    flush();
  }
  get data() {
    return this.$$.ctx[4];
  }
  set data(data) {
    this.$$set({ data });
    flush();
  }
  get thumbnailsURL() {
    return this.$$.ctx[21];
  }
  set thumbnailsURL(thumbnailsURL) {
    this.$$set({ thumbnailsURL });
    flush();
  }
  get numNeighbors() {
    return this.$$.ctx[22];
  }
  set numNeighbors(numNeighbors) {
    this.$$set({ numNeighbors });
    flush();
  }
  get getViewport() {
    return this.$$.ctx[50];
  }
  get selectPoint() {
    return this.$$.ctx[51];
  }
  get inRadiusselect() {
    return this.$$.ctx[7];
  }
  set inRadiusselect(inRadiusselect) {
    this.$$set({ inRadiusselect });
    flush();
  }
  get selectionRadius() {
    return this.$$.ctx[8];
  }
  set selectionRadius(selectionRadius) {
    this.$$set({ selectionRadius });
    flush();
  }
  get selectionOrderFn() {
    return this.$$.ctx[23];
  }
  set selectionOrderFn(selectionOrderFn) {
    this.$$set({ selectionOrderFn });
    flush();
  }
  get selectionUnit() {
    return this.$$.ctx[9];
  }
  set selectionUnit(selectionUnit) {
    this.$$set({ selectionUnit });
    flush();
  }
  get selectionUnits() {
    return this.$$.ctx[24];
  }
  set selectionUnits(selectionUnits) {
    this.$$set({ selectionUnits });
    flush();
  }
  get allowAlignment() {
    return this.$$.ctx[52];
  }
  set allowAlignment(allowAlignment) {
    this.$$set({ allowAlignment });
    flush();
  }
  get animateDatasetUpdate() {
    return this.$$.ctx[53];
  }
  get updateThumbnails() {
    return this.$$.ctx[54];
  }
  get reset() {
    return this.$$.ctx[25];
  }
  get showVicinityOfClickedPoint() {
    return this.$$.ctx[55];
  }
}
function create_fragment$b(ctx) {
  let div2;
  let scatterplot;
  let t0;
  let p;
  let t1_value = (
    /*frame*/
    ctx[2].title + ""
  );
  let t1;
  let div_style_value;
  let current;
  let mounted;
  let dispose;
  scatterplot = new Scatterplot({
    props: {
      thumbnail: true,
      colorScale: (
        /*colorScale*/
        ctx[0]
      ),
      data: (
        /*data*/
        ctx[1]
      ),
      width: 54,
      height: 54,
      frame: (
        /*frame*/
        ctx[2]
      ),
      rFactor: 0.1,
      padding: 1
    }
  });
  return {
    c() {
      div2 = element$2("div");
      create_component(scatterplot.$$.fragment);
      t0 = space();
      p = element$2("p");
      t1 = text(t1_value);
      attr(p, "class", "thumbnail-name svelte-18lgzmp");
      attr(div2, "class", "thumbnail-container svelte-18lgzmp");
      attr(div2, "style", div_style_value = "background-color: " + /*canvasBG*/
      ctx[5] + "; " + (!!/*accentColor*/
      ctx[4] ? `border-right: 6px solid hsl(${/*accentColor*/
      ctx[4][0]}, ${/*accentColor*/
      ctx[4][1]}%, ${/*accentColor*/
      ctx[4][2]}%);` : "border-right: 6px solid #bbb;"));
      toggle_class(
        div2,
        "preview-frame",
        /*isPreviewing*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(scatterplot, div2, null);
      append(div2, t0);
      append(div2, p);
      append(p, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div2,
            "mouseover",
            /*onMouseover*/
            ctx[6]
          ),
          listen(
            div2,
            "mousedown",
            /*onMousedown*/
            ctx[7]
          ),
          listen(
            div2,
            "mouseup",
            /*onMouseup*/
            ctx[8]
          ),
          listen(
            div2,
            "mouseout",
            /*onMouseout*/
            ctx[9]
          ),
          listen(
            div2,
            "click",
            /*click_handler*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const scatterplot_changes = {};
      if (dirty & /*colorScale*/
      1)
        scatterplot_changes.colorScale = /*colorScale*/
        ctx2[0];
      if (dirty & /*data*/
      2)
        scatterplot_changes.data = /*data*/
        ctx2[1];
      if (dirty & /*frame*/
      4)
        scatterplot_changes.frame = /*frame*/
        ctx2[2];
      scatterplot.$set(scatterplot_changes);
      if ((!current || dirty & /*frame*/
      4) && t1_value !== (t1_value = /*frame*/
      ctx2[2].title + ""))
        set_data(t1, t1_value);
      if (!current || dirty & /*canvasBG, accentColor*/
      48 && div_style_value !== (div_style_value = "background-color: " + /*canvasBG*/
      ctx2[5] + "; " + (!!/*accentColor*/
      ctx2[4] ? `border-right: 6px solid hsl(${/*accentColor*/
      ctx2[4][0]}, ${/*accentColor*/
      ctx2[4][1]}%, ${/*accentColor*/
      ctx2[4][2]}%);` : "border-right: 6px solid #bbb;"))) {
        attr(div2, "style", div_style_value);
      }
      if (!current || dirty & /*isPreviewing*/
      8) {
        toggle_class(
          div2,
          "preview-frame",
          /*isPreviewing*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(scatterplot.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scatterplot.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(scatterplot);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { colorScale } = $$props;
  let { data } = $$props;
  let { frame: frame2 } = $$props;
  let { isSelected = false } = $$props;
  let { isPreviewing = false } = $$props;
  let { accentColor = null } = $$props;
  let canvasBG = "white";
  let isHovering = false;
  let isClicking = false;
  function onMouseover(obj) {
    $$invalidate(11, isHovering = true);
    dispatch2("mouseover");
  }
  function onMousedown(obj) {
    $$invalidate(12, isClicking = true);
  }
  function onMouseup(obj) {
    $$invalidate(12, isClicking = false);
  }
  function onMouseout(obj) {
    $$invalidate(11, isHovering = false);
    dispatch2("mouseout");
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("colorScale" in $$props2)
      $$invalidate(0, colorScale = $$props2.colorScale);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
    if ("frame" in $$props2)
      $$invalidate(2, frame2 = $$props2.frame);
    if ("isSelected" in $$props2)
      $$invalidate(10, isSelected = $$props2.isSelected);
    if ("isPreviewing" in $$props2)
      $$invalidate(3, isPreviewing = $$props2.isPreviewing);
    if ("accentColor" in $$props2)
      $$invalidate(4, accentColor = $$props2.accentColor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*accentColor, isClicking, isHovering, isSelected*/
    7184) {
      {
        if (!!accentColor) {
          let alpha = 0.4;
          if (isClicking) {
            alpha = 0.5;
          } else if (isHovering) {
            alpha = isSelected ? 0.7 : 0.4;
          } else {
            alpha = isSelected ? 0.7 : 0;
          }
          $$invalidate(5, canvasBG = `hsla(${accentColor[0]}, ${accentColor[1]}%, ${accentColor[2]}%, ${alpha})`);
        } else {
          if (isClicking) {
            $$invalidate(5, canvasBG = "skyblue");
          } else if (isHovering) {
            $$invalidate(5, canvasBG = isSelected ? "deepskyblue" : "skyblue");
          } else {
            $$invalidate(5, canvasBG = isSelected ? "deepskyblue" : "white");
          }
        }
      }
    }
  };
  return [
    colorScale,
    data,
    frame2,
    isPreviewing,
    accentColor,
    canvasBG,
    onMouseover,
    onMousedown,
    onMouseup,
    onMouseout,
    isSelected,
    isHovering,
    isClicking,
    click_handler
  ];
}
class ScatterplotThumbnail extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$b, create_fragment$b, safe_not_equal, {
      colorScale: 0,
      data: 1,
      frame: 2,
      isSelected: 10,
      isPreviewing: 3,
      accentColor: 4
    });
  }
}
class ColorScheme {
  constructor(name2, value, type2 = "continuous") {
    __publicField(this, "name");
    __publicField(this, "value");
    __publicField(this, "type");
    this.name = name2;
    this.value = value;
    this.type = type2;
  }
}
let colorSchemes = [
  new ColorScheme("turbo", turbo),
  new ColorScheme("tableau", Tableau10, "categorical"),
  new ColorScheme("dark2", Dark2, "categorical"),
  new ColorScheme("paired", Paired, "categorical"),
  new ColorScheme("set1", Set1, "categorical"),
  new ColorScheme("set2", Set2, "categorical"),
  new ColorScheme("set3", Set3, "categorical"),
  new ColorScheme("plasma", plasma),
  new ColorScheme("magma", magma),
  new ColorScheme("viridis", viridis),
  new ColorScheme("RdBu", RdBu),
  new ColorScheme("Blues", Blues),
  new ColorScheme("Greens", Greens),
  new ColorScheme("Reds", Reds),
  new ColorScheme("rainbow", rainbow)
];
function getColorScheme(name2) {
  return colorSchemes.find((item) => item.name == name2);
}
const ColorSchemes = {
  getColorScheme,
  defaultColorScheme(dataType) {
    if (dataType == "categorical")
      return getColorScheme("tableau");
    return getColorScheme("plasma");
  },
  allColorSchemes: colorSchemes.map((v2) => v2)
};
function traitlet(model, name_, defaultVal) {
  const name2 = name_;
  const curVal = writable(model.get(name2) || defaultVal);
  model.on("change:" + name2, (model2, val) => curVal.set(val), null);
  if (!!model.onAttach)
    model.onAttach(async () => {
      let v2 = await model.fetch(name2);
      curVal.set(v2);
    });
  return {
    set: (v2) => {
      curVal.set(v2);
      model.set(name2, v2);
      model.save_changes();
    },
    subscribe: curVal.subscribe,
    update: (func2) => {
      curVal.update((v2) => {
        let out = func2(v2);
        model.set(name2, out);
        model.save_changes();
        return out;
      });
    }
  };
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
var DEFAULT_CONFIG = {
  // minimum relative difference between two compared values,
  // used by all comparison functions
  epsilon: 1e-12,
  // type of default matrix output. Choose 'matrix' (default) or 'array'
  matrix: "Matrix",
  // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
  number: "number",
  // number of significant digits in BigNumbers
  precision: 64,
  // predictable output type of functions. When true, output type depends only
  // on the input types. When false (default), output type can vary depending
  // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
  // predictable is false, and returns `NaN` when true.
  predictable: false,
  // random seed for seeded pseudo random number generation
  // null = randomly seed
  randomSeed: null
};
function isNumber(x) {
  return typeof x === "number";
}
function isBigNumber(x) {
  if (!x || typeof x !== "object" || typeof x.constructor !== "function") {
    return false;
  }
  if (x.isBigNumber === true && typeof x.constructor.prototype === "object" && x.constructor.prototype.isBigNumber === true) {
    return true;
  }
  if (typeof x.constructor.isDecimal === "function" && x.constructor.isDecimal(x) === true) {
    return true;
  }
  return false;
}
function isComplex(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
}
function isFraction(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
}
function isUnit(x) {
  return x && x.constructor.prototype.isUnit === true || false;
}
function isString(x) {
  return typeof x === "string";
}
var isArray = Array.isArray;
function isMatrix(x) {
  return x && x.constructor.prototype.isMatrix === true || false;
}
function isCollection(x) {
  return Array.isArray(x) || isMatrix(x);
}
function isDenseMatrix(x) {
  return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isSparseMatrix(x) {
  return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isRange(x) {
  return x && x.constructor.prototype.isRange === true || false;
}
function isIndex(x) {
  return x && x.constructor.prototype.isIndex === true || false;
}
function isBoolean(x) {
  return typeof x === "boolean";
}
function isResultSet(x) {
  return x && x.constructor.prototype.isResultSet === true || false;
}
function isHelp(x) {
  return x && x.constructor.prototype.isHelp === true || false;
}
function isFunction(x) {
  return typeof x === "function";
}
function isDate(x) {
  return x instanceof Date;
}
function isRegExp2(x) {
  return x instanceof RegExp;
}
function isObject(x) {
  return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
}
function isNull(x) {
  return x === null;
}
function isUndefined(x) {
  return x === void 0;
}
function isAccessorNode(x) {
  return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
}
function isArrayNode(x) {
  return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
}
function isAssignmentNode(x) {
  return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isBlockNode(x) {
  return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
}
function isConditionalNode(x) {
  return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
}
function isConstantNode(x) {
  return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
}
function isFunctionAssignmentNode(x) {
  return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isFunctionNode(x) {
  return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
}
function isIndexNode(x) {
  return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
}
function isNode(x) {
  return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
}
function isObjectNode(x) {
  return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
}
function isOperatorNode(x) {
  return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
}
function isParenthesisNode(x) {
  return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
}
function isRangeNode(x) {
  return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
}
function isSymbolNode(x) {
  return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
}
function isChain(x) {
  return x && x.constructor.prototype.isChain === true || false;
}
function typeOf(x) {
  var t = typeof x;
  if (t === "object") {
    if (x === null)
      return "null";
    if (Array.isArray(x))
      return "Array";
    if (x instanceof Date)
      return "Date";
    if (x instanceof RegExp)
      return "RegExp";
    if (isBigNumber(x))
      return "BigNumber";
    if (isComplex(x))
      return "Complex";
    if (isFraction(x))
      return "Fraction";
    if (isMatrix(x))
      return "Matrix";
    if (isUnit(x))
      return "Unit";
    if (isIndex(x))
      return "Index";
    if (isRange(x))
      return "Range";
    if (isResultSet(x))
      return "ResultSet";
    if (isNode(x))
      return x.type;
    if (isChain(x))
      return "Chain";
    if (isHelp(x))
      return "Help";
    return "Object";
  }
  if (t === "function")
    return "Function";
  return t;
}
function clone$1(x) {
  var type2 = typeof x;
  if (type2 === "number" || type2 === "string" || type2 === "boolean" || x === null || x === void 0) {
    return x;
  }
  if (typeof x.clone === "function") {
    return x.clone();
  }
  if (Array.isArray(x)) {
    return x.map(function(value) {
      return clone$1(value);
    });
  }
  if (x instanceof Date)
    return new Date(x.valueOf());
  if (isBigNumber(x))
    return x;
  if (x instanceof RegExp)
    throw new TypeError("Cannot clone " + x);
  return mapObject(x, clone$1);
}
function mapObject(object2, callback) {
  var clone2 = {};
  for (var key in object2) {
    if (hasOwnProperty(object2, key)) {
      clone2[key] = callback(object2[key]);
    }
  }
  return clone2;
}
function extend$1(a, b) {
  for (var prop in b) {
    if (hasOwnProperty(b, prop)) {
      a[prop] = b[prop];
    }
  }
  return a;
}
function deepStrictEqual(a, b) {
  var prop, i, len;
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (i = 0, len = a.length; i < len; i++) {
      if (!deepStrictEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  } else if (typeof a === "function") {
    return a === b;
  } else if (a instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }
    for (prop in a) {
      if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
        return false;
      }
    }
    for (prop in b) {
      if (!(prop in a)) {
        return false;
      }
    }
    return true;
  } else {
    return a === b;
  }
}
function hasOwnProperty(object2, property) {
  return object2 && Object.hasOwnProperty.call(object2, property);
}
function pickShallow(object2, properties) {
  var copy2 = {};
  for (var i = 0; i < properties.length; i++) {
    var key = properties[i];
    var value = object2[key];
    if (value !== void 0) {
      copy2[key] = value;
    }
  }
  return copy2;
}
var MATRIX_OPTIONS = ["Matrix", "Array"];
var NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];
var config$1 = function config(options) {
  if (options) {
    throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");
  }
  return Object.freeze(DEFAULT_CONFIG);
};
_extends(config$1, DEFAULT_CONFIG, {
  MATRIX_OPTIONS,
  NUMBER_OPTIONS
});
var typedFunction$1 = { exports: {} };
(function(module, exports) {
  (function(root2, factory2) {
    {
      module.exports = factory2();
    }
  })(commonjsGlobal, function() {
    function ok() {
      return true;
    }
    function notOk() {
      return false;
    }
    function undef() {
      return void 0;
    }
    function create2() {
      var _types = [
        { name: "number", test: function(x) {
          return typeof x === "number";
        } },
        { name: "string", test: function(x) {
          return typeof x === "string";
        } },
        { name: "boolean", test: function(x) {
          return typeof x === "boolean";
        } },
        { name: "Function", test: function(x) {
          return typeof x === "function";
        } },
        { name: "Array", test: Array.isArray },
        { name: "Date", test: function(x) {
          return x instanceof Date;
        } },
        { name: "RegExp", test: function(x) {
          return x instanceof RegExp;
        } },
        { name: "Object", test: function(x) {
          return typeof x === "object" && x !== null && x.constructor === Object;
        } },
        { name: "null", test: function(x) {
          return x === null;
        } },
        { name: "undefined", test: function(x) {
          return x === void 0;
        } }
      ];
      var anyType = {
        name: "any",
        test: ok
      };
      var _ignore = [];
      var _conversions = [];
      var typed2 = {
        types: _types,
        conversions: _conversions,
        ignore: _ignore
      };
      function findTypeByName(typeName) {
        var entry = findInArray(typed2.types, function(entry2) {
          return entry2.name === typeName;
        });
        if (entry) {
          return entry;
        }
        if (typeName === "any") {
          return anyType;
        }
        var hint = findInArray(typed2.types, function(entry2) {
          return entry2.name.toLowerCase() === typeName.toLowerCase();
        });
        throw new TypeError('Unknown type "' + typeName + '"' + (hint ? '. Did you mean "' + hint.name + '"?' : ""));
      }
      function findTypeIndex(type2) {
        if (type2 === anyType) {
          return 999;
        }
        return typed2.types.indexOf(type2);
      }
      function findTypeName(value) {
        var entry = findInArray(typed2.types, function(entry2) {
          return entry2.test(value);
        });
        if (entry) {
          return entry.name;
        }
        throw new TypeError("Value has unknown type. Value: " + value);
      }
      function find2(fn, signature) {
        if (!fn.signatures) {
          throw new TypeError("Function is no typed-function");
        }
        var arr;
        if (typeof signature === "string") {
          arr = signature.split(",");
          for (var i = 0; i < arr.length; i++) {
            arr[i] = arr[i].trim();
          }
        } else if (Array.isArray(signature)) {
          arr = signature;
        } else {
          throw new TypeError("String array or a comma separated string expected");
        }
        var str = arr.join(",");
        var match = fn.signatures[str];
        if (match) {
          return match;
        }
        throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + arr.join(", ") + "))");
      }
      function convert(value, type2) {
        var from = findTypeName(value);
        if (type2 === from) {
          return value;
        }
        for (var i = 0; i < typed2.conversions.length; i++) {
          var conversion = typed2.conversions[i];
          if (conversion.from === from && conversion.to === type2) {
            return conversion.convert(value);
          }
        }
        throw new Error("Cannot convert from " + from + " to " + type2);
      }
      function stringifyParams(params) {
        return params.map(function(param) {
          var typeNames = param.types.map(getTypeName);
          return (param.restParam ? "..." : "") + typeNames.join("|");
        }).join(",");
      }
      function parseParam(param, conversions) {
        var restParam = param.indexOf("...") === 0;
        var types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
        var typeNames = types.split("|").map(trim).filter(notEmpty).filter(notIgnore);
        var matchingConversions = filterConversions(conversions, typeNames);
        var exactTypes = typeNames.map(function(typeName) {
          var type2 = findTypeByName(typeName);
          return {
            name: typeName,
            typeIndex: findTypeIndex(type2),
            test: type2.test,
            conversion: null,
            conversionIndex: -1
          };
        });
        var convertibleTypes = matchingConversions.map(function(conversion) {
          var type2 = findTypeByName(conversion.from);
          return {
            name: conversion.from,
            typeIndex: findTypeIndex(type2),
            test: type2.test,
            conversion,
            conversionIndex: conversions.indexOf(conversion)
          };
        });
        return {
          types: exactTypes.concat(convertibleTypes),
          restParam
        };
      }
      function parseSignature(signature, fn, conversions) {
        var params = [];
        if (signature.trim() !== "") {
          params = signature.split(",").map(trim).map(function(param, index, array2) {
            var parsedParam = parseParam(param, conversions);
            if (parsedParam.restParam && index !== array2.length - 1) {
              throw new SyntaxError('Unexpected rest parameter "' + param + '": only allowed for the last parameter');
            }
            return parsedParam;
          });
        }
        if (params.some(isInvalidParam)) {
          return null;
        }
        return {
          params,
          fn
        };
      }
      function hasRestParam(params) {
        var param = last(params);
        return param ? param.restParam : false;
      }
      function hasConversions(param) {
        return param.types.some(function(type2) {
          return type2.conversion != null;
        });
      }
      function compileTest(param) {
        if (!param || param.types.length === 0) {
          return ok;
        } else if (param.types.length === 1) {
          return findTypeByName(param.types[0].name).test;
        } else if (param.types.length === 2) {
          var test0 = findTypeByName(param.types[0].name).test;
          var test1 = findTypeByName(param.types[1].name).test;
          return function or(x) {
            return test0(x) || test1(x);
          };
        } else {
          var tests = param.types.map(function(type2) {
            return findTypeByName(type2.name).test;
          });
          return function or(x) {
            for (var i = 0; i < tests.length; i++) {
              if (tests[i](x)) {
                return true;
              }
            }
            return false;
          };
        }
      }
      function compileTests(params) {
        var tests, test0, test1;
        if (hasRestParam(params)) {
          tests = initial(params).map(compileTest);
          var varIndex = tests.length;
          var lastTest = compileTest(last(params));
          var testRestParam = function(args) {
            for (var i = varIndex; i < args.length; i++) {
              if (!lastTest(args[i])) {
                return false;
              }
            }
            return true;
          };
          return function testArgs(args) {
            for (var i = 0; i < tests.length; i++) {
              if (!tests[i](args[i])) {
                return false;
              }
            }
            return testRestParam(args) && args.length >= varIndex + 1;
          };
        } else {
          if (params.length === 0) {
            return function testArgs(args) {
              return args.length === 0;
            };
          } else if (params.length === 1) {
            test0 = compileTest(params[0]);
            return function testArgs(args) {
              return test0(args[0]) && args.length === 1;
            };
          } else if (params.length === 2) {
            test0 = compileTest(params[0]);
            test1 = compileTest(params[1]);
            return function testArgs(args) {
              return test0(args[0]) && test1(args[1]) && args.length === 2;
            };
          } else {
            tests = params.map(compileTest);
            return function testArgs(args) {
              for (var i = 0; i < tests.length; i++) {
                if (!tests[i](args[i])) {
                  return false;
                }
              }
              return args.length === tests.length;
            };
          }
        }
      }
      function getParamAtIndex(signature, index) {
        return index < signature.params.length ? signature.params[index] : hasRestParam(signature.params) ? last(signature.params) : null;
      }
      function getExpectedTypeNames(signature, index, excludeConversions) {
        var param = getParamAtIndex(signature, index);
        var types = param ? excludeConversions ? param.types.filter(isExactType) : param.types : [];
        return types.map(getTypeName);
      }
      function getTypeName(type2) {
        return type2.name;
      }
      function isExactType(type2) {
        return type2.conversion === null || type2.conversion === void 0;
      }
      function mergeExpectedParams(signatures, index) {
        var typeNames = uniq(flatMap(signatures, function(signature) {
          return getExpectedTypeNames(signature, index, false);
        }));
        return typeNames.indexOf("any") !== -1 ? ["any"] : typeNames;
      }
      function createError(name2, args, signatures) {
        var err, expected;
        var _name = name2 || "unnamed";
        var matchingSignatures = signatures;
        var index;
        for (index = 0; index < args.length; index++) {
          var nextMatchingDefs = matchingSignatures.filter(function(signature) {
            var test = compileTest(getParamAtIndex(signature, index));
            return (index < signature.params.length || hasRestParam(signature.params)) && test(args[index]);
          });
          if (nextMatchingDefs.length === 0) {
            expected = mergeExpectedParams(matchingSignatures, index);
            if (expected.length > 0) {
              var actualType = findTypeName(args[index]);
              err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualType + ", index: " + index + ")");
              err.data = {
                category: "wrongType",
                fn: _name,
                index,
                actual: actualType,
                expected
              };
              return err;
            }
          } else {
            matchingSignatures = nextMatchingDefs;
          }
        }
        var lengths = matchingSignatures.map(function(signature) {
          return hasRestParam(signature.params) ? Infinity : signature.params.length;
        });
        if (args.length < Math.min.apply(null, lengths)) {
          expected = mergeExpectedParams(matchingSignatures, index);
          err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
          err.data = {
            category: "tooFewArgs",
            fn: _name,
            index: args.length,
            expected
          };
          return err;
        }
        var maxLength = Math.max.apply(null, lengths);
        if (args.length > maxLength) {
          err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
          err.data = {
            category: "tooManyArgs",
            fn: _name,
            index: args.length,
            expectedLength: maxLength
          };
          return err;
        }
        err = new TypeError('Arguments of type "' + args.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
        err.data = {
          category: "mismatch",
          actual: args.map(findTypeName)
        };
        return err;
      }
      function getLowestTypeIndex(param) {
        var min2 = 999;
        for (var i = 0; i < param.types.length; i++) {
          if (isExactType(param.types[i])) {
            min2 = Math.min(min2, param.types[i].typeIndex);
          }
        }
        return min2;
      }
      function getLowestConversionIndex(param) {
        var min2 = 999;
        for (var i = 0; i < param.types.length; i++) {
          if (!isExactType(param.types[i])) {
            min2 = Math.min(min2, param.types[i].conversionIndex);
          }
        }
        return min2;
      }
      function compareParams(param1, param2) {
        var c2;
        c2 = param1.restParam - param2.restParam;
        if (c2 !== 0) {
          return c2;
        }
        c2 = hasConversions(param1) - hasConversions(param2);
        if (c2 !== 0) {
          return c2;
        }
        c2 = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
        if (c2 !== 0) {
          return c2;
        }
        return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
      }
      function compareSignatures(signature1, signature2) {
        var len = Math.min(signature1.params.length, signature2.params.length);
        var i;
        var c2;
        c2 = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);
        if (c2 !== 0) {
          return c2;
        }
        for (i = 0; i < len; i++) {
          c2 = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);
          if (c2 !== 0) {
            return c2;
          }
        }
        for (i = 0; i < len; i++) {
          c2 = compareParams(signature1.params[i], signature2.params[i]);
          if (c2 !== 0) {
            return c2;
          }
        }
        return signature1.params.length - signature2.params.length;
      }
      function filterConversions(conversions, typeNames) {
        var matches = {};
        conversions.forEach(function(conversion) {
          if (typeNames.indexOf(conversion.from) === -1 && typeNames.indexOf(conversion.to) !== -1 && !matches[conversion.from]) {
            matches[conversion.from] = conversion;
          }
        });
        return Object.keys(matches).map(function(from) {
          return matches[from];
        });
      }
      function compileArgsPreprocessing(params, fn) {
        var fnConvert = fn;
        if (params.some(hasConversions)) {
          var restParam = hasRestParam(params);
          var compiledConversions = params.map(compileArgConversion);
          fnConvert = function convertArgs() {
            var args = [];
            var last2 = restParam ? arguments.length - 1 : arguments.length;
            for (var i = 0; i < last2; i++) {
              args[i] = compiledConversions[i](arguments[i]);
            }
            if (restParam) {
              args[last2] = arguments[last2].map(compiledConversions[last2]);
            }
            return fn.apply(this, args);
          };
        }
        var fnPreprocess = fnConvert;
        if (hasRestParam(params)) {
          var offset = params.length - 1;
          fnPreprocess = function preprocessRestParams() {
            return fnConvert.apply(
              this,
              slice2(arguments, 0, offset).concat([slice2(arguments, offset)])
            );
          };
        }
        return fnPreprocess;
      }
      function compileArgConversion(param) {
        var test0, test1, conversion0, conversion1;
        var tests = [];
        var conversions = [];
        param.types.forEach(function(type2) {
          if (type2.conversion) {
            tests.push(findTypeByName(type2.conversion.from).test);
            conversions.push(type2.conversion.convert);
          }
        });
        switch (conversions.length) {
          case 0:
            return function convertArg(arg) {
              return arg;
            };
          case 1:
            test0 = tests[0];
            conversion0 = conversions[0];
            return function convertArg(arg) {
              if (test0(arg)) {
                return conversion0(arg);
              }
              return arg;
            };
          case 2:
            test0 = tests[0];
            test1 = tests[1];
            conversion0 = conversions[0];
            conversion1 = conversions[1];
            return function convertArg(arg) {
              if (test0(arg)) {
                return conversion0(arg);
              }
              if (test1(arg)) {
                return conversion1(arg);
              }
              return arg;
            };
          default:
            return function convertArg(arg) {
              for (var i = 0; i < conversions.length; i++) {
                if (tests[i](arg)) {
                  return conversions[i](arg);
                }
              }
              return arg;
            };
        }
      }
      function createSignaturesMap(signatures) {
        var signaturesMap = {};
        signatures.forEach(function(signature) {
          if (!signature.params.some(hasConversions)) {
            splitParams(signature.params, true).forEach(function(params) {
              signaturesMap[stringifyParams(params)] = signature.fn;
            });
          }
        });
        return signaturesMap;
      }
      function splitParams(params, ignoreConversionTypes) {
        function _splitParams(params2, index, types) {
          if (index < params2.length) {
            var param = params2[index];
            var filteredTypes = ignoreConversionTypes ? param.types.filter(isExactType) : param.types;
            var typeGroups;
            if (param.restParam) {
              var exactTypes = filteredTypes.filter(isExactType);
              typeGroups = exactTypes.length < filteredTypes.length ? [exactTypes, filteredTypes] : [filteredTypes];
            } else {
              typeGroups = filteredTypes.map(function(type2) {
                return [type2];
              });
            }
            return flatMap(typeGroups, function(typeGroup) {
              return _splitParams(params2, index + 1, types.concat([typeGroup]));
            });
          } else {
            var splittedParams = types.map(function(type2, typeIndex) {
              return {
                types: type2,
                restParam: typeIndex === params2.length - 1 && hasRestParam(params2)
              };
            });
            return [splittedParams];
          }
        }
        return _splitParams(params, 0, []);
      }
      function hasConflictingParams(signature1, signature2) {
        var ii = Math.max(signature1.params.length, signature2.params.length);
        for (var i = 0; i < ii; i++) {
          var typesNames1 = getExpectedTypeNames(signature1, i, true);
          var typesNames2 = getExpectedTypeNames(signature2, i, true);
          if (!hasOverlap(typesNames1, typesNames2)) {
            return false;
          }
        }
        var len1 = signature1.params.length;
        var len2 = signature2.params.length;
        var restParam1 = hasRestParam(signature1.params);
        var restParam2 = hasRestParam(signature2.params);
        return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
      }
      function createTypedFunction(name2, signaturesMap) {
        if (Object.keys(signaturesMap).length === 0) {
          throw new SyntaxError("No signatures provided");
        }
        var parsedSignatures = [];
        Object.keys(signaturesMap).map(function(signature) {
          return parseSignature(signature, signaturesMap[signature], typed2.conversions);
        }).filter(notNull).forEach(function(parsedSignature) {
          var conflictingSignature = findInArray(parsedSignatures, function(s) {
            return hasConflictingParams(s, parsedSignature);
          });
          if (conflictingSignature) {
            throw new TypeError('Conflicting signatures "' + stringifyParams(conflictingSignature.params) + '" and "' + stringifyParams(parsedSignature.params) + '".');
          }
          parsedSignatures.push(parsedSignature);
        });
        var signatures = flatMap(parsedSignatures, function(parsedSignature) {
          var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];
          return params.map(function(params2) {
            return {
              params: params2,
              fn: parsedSignature.fn
            };
          });
        }).filter(notNull);
        signatures.sort(compareSignatures);
        var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
        var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
        var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
        var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
        var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
        var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
        var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
        var tests = signatures.map(function(signature) {
          return compileTests(signature.params);
        });
        var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
        var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
        var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
        var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
        var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
        var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
        var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
        var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
        var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
        var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
        var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
        var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
        var fns = signatures.map(function(signature) {
          return compileArgsPreprocessing(signature.params, signature.fn);
        });
        var fn0 = ok0 ? fns[0] : undef;
        var fn1 = ok1 ? fns[1] : undef;
        var fn2 = ok2 ? fns[2] : undef;
        var fn3 = ok3 ? fns[3] : undef;
        var fn4 = ok4 ? fns[4] : undef;
        var fn5 = ok5 ? fns[5] : undef;
        var len0 = ok0 ? signatures[0].params.length : -1;
        var len1 = ok1 ? signatures[1].params.length : -1;
        var len2 = ok2 ? signatures[2].params.length : -1;
        var len3 = ok3 ? signatures[3].params.length : -1;
        var len4 = ok4 ? signatures[4].params.length : -1;
        var len5 = ok5 ? signatures[5].params.length : -1;
        var iStart = allOk ? 6 : 0;
        var iEnd = signatures.length;
        var generic = function generic2() {
          for (var i = iStart; i < iEnd; i++) {
            if (tests[i](arguments)) {
              return fns[i].apply(this, arguments);
            }
          }
          return typed2.onMismatch(name2, arguments, signatures);
        };
        var fn = function fn6(arg0, arg1) {
          if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
            return fn0.apply(fn6, arguments);
          }
          if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
            return fn1.apply(fn6, arguments);
          }
          if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
            return fn2.apply(fn6, arguments);
          }
          if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
            return fn3.apply(fn6, arguments);
          }
          if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
            return fn4.apply(fn6, arguments);
          }
          if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
            return fn5.apply(fn6, arguments);
          }
          return generic.apply(fn6, arguments);
        };
        try {
          Object.defineProperty(fn, "name", { value: name2 });
        } catch (err) {
        }
        fn.signatures = createSignaturesMap(signatures);
        return fn;
      }
      function _onMismatch(name2, args, signatures) {
        throw createError(name2, args, signatures);
      }
      function notIgnore(typeName) {
        return typed2.ignore.indexOf(typeName) === -1;
      }
      function trim(str) {
        return str.trim();
      }
      function notEmpty(str) {
        return !!str;
      }
      function notNull(value) {
        return value !== null;
      }
      function isInvalidParam(param) {
        return param.types.length === 0;
      }
      function initial(arr) {
        return arr.slice(0, arr.length - 1);
      }
      function last(arr) {
        return arr[arr.length - 1];
      }
      function slice2(arr, start2, end) {
        return Array.prototype.slice.call(arr, start2, end);
      }
      function contains(array2, item) {
        return array2.indexOf(item) !== -1;
      }
      function hasOverlap(array1, array2) {
        for (var i = 0; i < array1.length; i++) {
          if (contains(array2, array1[i])) {
            return true;
          }
        }
        return false;
      }
      function findInArray(arr, test) {
        for (var i = 0; i < arr.length; i++) {
          if (test(arr[i])) {
            return arr[i];
          }
        }
        return void 0;
      }
      function uniq(arr) {
        var entries = {};
        for (var i = 0; i < arr.length; i++) {
          entries[arr[i]] = true;
        }
        return Object.keys(entries);
      }
      function flatMap(arr, callback) {
        return Array.prototype.concat.apply([], arr.map(callback));
      }
      function getName(fns) {
        var name2 = "";
        for (var i = 0; i < fns.length; i++) {
          var fn = fns[i];
          if ((typeof fn.signatures === "object" || typeof fn.signature === "string") && fn.name !== "") {
            if (name2 === "") {
              name2 = fn.name;
            } else if (name2 !== fn.name) {
              var err = new Error("Function names do not match (expected: " + name2 + ", actual: " + fn.name + ")");
              err.data = {
                actual: fn.name,
                expected: name2
              };
              throw err;
            }
          }
        }
        return name2;
      }
      function extractSignatures(fns) {
        var err;
        var signaturesMap = {};
        function validateUnique(_signature, _fn) {
          if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {
            err = new Error('Signature "' + _signature + '" is defined twice');
            err.data = { signature: _signature };
            throw err;
          }
        }
        for (var i = 0; i < fns.length; i++) {
          var fn = fns[i];
          if (typeof fn.signatures === "object") {
            for (var signature in fn.signatures) {
              if (fn.signatures.hasOwnProperty(signature)) {
                validateUnique(signature, fn.signatures[signature]);
                signaturesMap[signature] = fn.signatures[signature];
              }
            }
          } else if (typeof fn.signature === "string") {
            validateUnique(fn.signature, fn);
            signaturesMap[fn.signature] = fn;
          } else {
            err = new TypeError("Function is no typed-function (index: " + i + ")");
            err.data = { index: i };
            throw err;
          }
        }
        return signaturesMap;
      }
      typed2 = createTypedFunction("typed", {
        "string, Object": createTypedFunction,
        "Object": function(signaturesMap) {
          var fns = [];
          for (var signature in signaturesMap) {
            if (signaturesMap.hasOwnProperty(signature)) {
              fns.push(signaturesMap[signature]);
            }
          }
          var name2 = getName(fns);
          return createTypedFunction(name2, signaturesMap);
        },
        "...Function": function(fns) {
          return createTypedFunction(getName(fns), extractSignatures(fns));
        },
        "string, ...Function": function(name2, fns) {
          return createTypedFunction(name2, extractSignatures(fns));
        }
      });
      typed2.create = create2;
      typed2.types = _types;
      typed2.conversions = _conversions;
      typed2.ignore = _ignore;
      typed2.onMismatch = _onMismatch;
      typed2.throwMismatchError = _onMismatch;
      typed2.createError = createError;
      typed2.convert = convert;
      typed2.find = find2;
      typed2.addType = function(type2, beforeObjectTest) {
        if (!type2 || typeof type2.name !== "string" || typeof type2.test !== "function") {
          throw new TypeError("Object with properties {name: string, test: function} expected");
        }
        if (beforeObjectTest !== false) {
          for (var i = 0; i < typed2.types.length; i++) {
            if (typed2.types[i].name === "Object") {
              typed2.types.splice(i, 0, type2);
              return;
            }
          }
        }
        typed2.types.push(type2);
      };
      typed2.addConversion = function(conversion) {
        if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
          throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
        }
        typed2.conversions.push(conversion);
      };
      return typed2;
    }
    return create2();
  });
})(typedFunction$1);
var typedFunctionExports = typedFunction$1.exports;
const typedFunction = /* @__PURE__ */ getDefaultExportFromCjs(typedFunctionExports);
function isInteger(value) {
  if (typeof value === "boolean") {
    return true;
  }
  return isFinite(value) ? value === Math.round(value) : false;
}
function formatNumberToBase(n, base, size2) {
  var prefixes2 = {
    2: "0b",
    8: "0o",
    16: "0x"
  };
  var prefix2 = prefixes2[base];
  var suffix = "";
  if (size2) {
    if (size2 < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size2)) {
      throw new Error("size must be an integer");
    }
    if (n > 2 ** (size2 - 1) - 1 || n < -(2 ** (size2 - 1))) {
      throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
    }
    if (!isInteger(n)) {
      throw new Error("Value must be an integer");
    }
    if (n < 0) {
      n = n + 2 ** size2;
    }
    suffix = "i".concat(size2);
  }
  var sign3 = "";
  if (n < 0) {
    n = -n;
    sign3 = "-";
  }
  return "".concat(sign3).concat(prefix2).concat(n.toString(base)).concat(suffix);
}
function format$3(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (value === Infinity) {
    return "Infinity";
  } else if (value === -Infinity) {
    return "-Infinity";
  } else if (isNaN(value)) {
    return "NaN";
  }
  var notation = "auto";
  var precision;
  var wordSize;
  if (options) {
    if (options.notation) {
      notation = options.notation;
    }
    if (isNumber(options)) {
      precision = options;
    } else if (isNumber(options.precision)) {
      precision = options.precision;
    }
    if (options.wordSize) {
      wordSize = options.wordSize;
      if (typeof wordSize !== "number") {
        throw new Error('Option "wordSize" must be a number');
      }
    }
  }
  switch (notation) {
    case "fixed":
      return toFixed$1(value, precision);
    case "exponential":
      return toExponential$1(value, precision);
    case "engineering":
      return toEngineering$1(value, precision);
    case "bin":
      return formatNumberToBase(value, 2, wordSize);
    case "oct":
      return formatNumberToBase(value, 8, wordSize);
    case "hex":
      return formatNumberToBase(value, 16, wordSize);
    case "auto":
      return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e = arguments[4];
        return digits2 !== "." ? digits2 + e : e;
      });
    default:
      throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function splitNumber(value) {
  var match = String(value).toLowerCase().match(/^0*?(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!match) {
    throw new SyntaxError("Invalid number " + value);
  }
  var sign3 = match[1];
  var digits2 = match[2];
  var exponent2 = parseFloat(match[4] || "0");
  var dot2 = digits2.indexOf(".");
  exponent2 += dot2 !== -1 ? dot2 - 1 : digits2.length - 1;
  var coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros2) {
    exponent2 -= zeros2.length;
    return "";
  }).replace(/0*$/, "").split("").map(function(d) {
    return parseInt(d);
  });
  if (coefficients.length === 0) {
    coefficients.push(0);
    exponent2++;
  }
  return {
    sign: sign3,
    coefficients,
    exponent: exponent2
  };
}
function toEngineering$1(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = roundDigits(split, precision);
  var e = rounded.exponent;
  var c2 = rounded.coefficients;
  var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
  if (isNumber(precision)) {
    while (precision > c2.length || e - newExp + 1 > c2.length) {
      c2.push(0);
    }
  } else {
    var missingZeros = Math.abs(e - newExp) - (c2.length - 1);
    for (var i = 0; i < missingZeros; i++) {
      c2.push(0);
    }
  }
  var expDiff = Math.abs(e - newExp);
  var decimalIdx = 1;
  while (expDiff > 0) {
    decimalIdx++;
    expDiff--;
  }
  var decimals = c2.slice(decimalIdx).join("");
  var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
  var str = c2.slice(0, decimalIdx).join("") + decimalVal + "e" + (e >= 0 ? "+" : "") + newExp.toString();
  return rounded.sign + str;
}
function toFixed$1(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var splitValue = splitNumber(value);
  var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
  var c2 = rounded.coefficients;
  var p = rounded.exponent + 1;
  var pp = p + (precision || 0);
  if (c2.length < pp) {
    c2 = c2.concat(zeros(pp - c2.length));
  }
  if (p < 0) {
    c2 = zeros(-p + 1).concat(c2);
    p = 1;
  }
  if (p < c2.length) {
    c2.splice(p, 0, p === 0 ? "0." : ".");
  }
  return rounded.sign + c2.join("");
}
function toExponential$1(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  var c2 = rounded.coefficients;
  var e = rounded.exponent;
  if (c2.length < precision) {
    c2 = c2.concat(zeros(precision - c2.length));
  }
  var first = c2.shift();
  return rounded.sign + first + (c2.length > 0 ? "." + c2.join("") : "") + "e" + (e >= 0 ? "+" : "") + e;
}
function toPrecision(value, precision, options) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
  var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
    return toExponential$1(value, precision);
  } else {
    var c2 = rounded.coefficients;
    var e = rounded.exponent;
    if (c2.length < precision) {
      c2 = c2.concat(zeros(precision - c2.length));
    }
    c2 = c2.concat(zeros(e - c2.length + 1 + (c2.length < precision ? precision - c2.length : 0)));
    c2 = zeros(-e).concat(c2);
    var dot2 = e > 0 ? e : 0;
    if (dot2 < c2.length - 1) {
      c2.splice(dot2 + 1, 0, ".");
    }
    return rounded.sign + c2.join("");
  }
}
function roundDigits(split, precision) {
  var rounded = {
    sign: split.sign,
    coefficients: split.coefficients,
    exponent: split.exponent
  };
  var c2 = rounded.coefficients;
  while (precision <= 0) {
    c2.unshift(0);
    rounded.exponent++;
    precision++;
  }
  if (c2.length > precision) {
    var removed = c2.splice(precision, c2.length - precision);
    if (removed[0] >= 5) {
      var i = precision - 1;
      c2[i]++;
      while (c2[i] === 10) {
        c2.pop();
        if (i === 0) {
          c2.unshift(0);
          rounded.exponent++;
          i++;
        }
        i--;
        c2[i]++;
      }
    }
  }
  return rounded;
}
function zeros(length) {
  var arr = [];
  for (var i = 0; i < length; i++) {
    arr.push(0);
  }
  return arr;
}
function digits(value) {
  return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
}
var DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
function nearlyEqual$1(x, y, epsilon) {
  if (epsilon === null || epsilon === void 0) {
    return x === y;
  }
  if (x === y) {
    return true;
  }
  if (isNaN(x) || isNaN(y)) {
    return false;
  }
  if (isFinite(x) && isFinite(y)) {
    var diff = Math.abs(x - y);
    if (diff < DBL_EPSILON) {
      return true;
    } else {
      return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
    }
  }
  return false;
}
function formatBigNumberToBase(n, base, size2) {
  var BigNumberCtor = n.constructor;
  var big2 = new BigNumberCtor(2);
  var suffix = "";
  if (size2) {
    if (size2 < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size2)) {
      throw new Error("size must be an integer");
    }
    if (n.greaterThan(big2.pow(size2 - 1).sub(1)) || n.lessThan(big2.pow(size2 - 1).mul(-1))) {
      throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
    }
    if (!n.isInteger()) {
      throw new Error("Value must be an integer");
    }
    if (n.lessThan(0)) {
      n = n.add(big2.pow(size2));
    }
    suffix = "i".concat(size2);
  }
  switch (base) {
    case 2:
      return "".concat(n.toBinary()).concat(suffix);
    case 8:
      return "".concat(n.toOctal()).concat(suffix);
    case 16:
      return "".concat(n.toHexadecimal()).concat(suffix);
    default:
      throw new Error("Base ".concat(base, " not supported "));
  }
}
function format$2(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (!value.isFinite()) {
    return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
  }
  var notation = "auto";
  var precision;
  var wordSize;
  if (options !== void 0) {
    if (options.notation) {
      notation = options.notation;
    }
    if (typeof options === "number") {
      precision = options;
    } else if (options.precision) {
      precision = options.precision;
    }
    if (options.wordSize) {
      wordSize = options.wordSize;
      if (typeof wordSize !== "number") {
        throw new Error('Option "wordSize" must be a number');
      }
    }
  }
  switch (notation) {
    case "fixed":
      return toFixed(value, precision);
    case "exponential":
      return toExponential(value, precision);
    case "engineering":
      return toEngineering(value, precision);
    case "bin":
      return formatBigNumberToBase(value, 2, wordSize);
    case "oct":
      return formatBigNumberToBase(value, 8, wordSize);
    case "hex":
      return formatBigNumberToBase(value, 16, wordSize);
    case "auto": {
      var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
      var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
      if (value.isZero())
        return "0";
      var str;
      var rounded = value.toSignificantDigits(precision);
      var exp2 = rounded.e;
      if (exp2 >= lowerExp && exp2 < upperExp) {
        str = rounded.toFixed();
      } else {
        str = toExponential(value, precision);
      }
      return str.replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e = arguments[4];
        return digits2 !== "." ? digits2 + e : e;
      });
    }
    default:
      throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function toEngineering(value, precision) {
  var e = value.e;
  var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
  var valueWithoutExp = value.mul(Math.pow(10, -newExp));
  var valueStr = valueWithoutExp.toPrecision(precision);
  if (valueStr.indexOf("e") !== -1) {
    valueStr = valueWithoutExp.toString();
  }
  return valueStr + "e" + (e >= 0 ? "+" : "") + newExp.toString();
}
function toExponential(value, precision) {
  if (precision !== void 0) {
    return value.toExponential(precision - 1);
  } else {
    return value.toExponential();
  }
}
function toFixed(value, precision) {
  return value.toFixed(precision);
}
function format$1(value, options) {
  if (typeof value === "number") {
    return format$3(value, options);
  }
  if (isBigNumber(value)) {
    return format$2(value, options);
  }
  if (looksLikeFraction(value)) {
    if (!options || options.fraction !== "decimal") {
      return value.s * value.n + "/" + value.d;
    } else {
      return value.toString();
    }
  }
  if (Array.isArray(value)) {
    return formatArray(value, options);
  }
  if (isString(value)) {
    return '"' + value + '"';
  }
  if (typeof value === "function") {
    return value.syntax ? String(value.syntax) : "function";
  }
  if (value && typeof value === "object") {
    if (typeof value.format === "function") {
      return value.format(options);
    } else if (value && value.toString(options) !== {}.toString()) {
      return value.toString(options);
    } else {
      var entries = Object.keys(value).map((key) => {
        return '"' + key + '": ' + format$1(value[key], options);
      });
      return "{" + entries.join(", ") + "}";
    }
  }
  return String(value);
}
function formatArray(array2, options) {
  if (Array.isArray(array2)) {
    var str = "[";
    var len = array2.length;
    for (var i = 0; i < len; i++) {
      if (i !== 0) {
        str += ", ";
      }
      str += formatArray(array2[i], options);
    }
    str += "]";
    return str;
  } else {
    return format$1(array2, options);
  }
}
function looksLikeFraction(value) {
  return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
}
function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.actual = actual;
  this.expected = expected;
  this.relation = relation;
  this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
  this.stack = new Error().stack;
}
DimensionError.prototype = new RangeError();
DimensionError.prototype.constructor = RangeError;
DimensionError.prototype.name = "DimensionError";
DimensionError.prototype.isDimensionError = true;
function IndexError(index, min2, max2) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.index = index;
  if (arguments.length < 3) {
    this.min = 0;
    this.max = min2;
  } else {
    this.min = min2;
    this.max = max2;
  }
  if (this.min !== void 0 && this.index < this.min) {
    this.message = "Index out of range (" + this.index + " < " + this.min + ")";
  } else if (this.max !== void 0 && this.index >= this.max) {
    this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
  } else {
    this.message = "Index out of range (" + this.index + ")";
  }
  this.stack = new Error().stack;
}
IndexError.prototype = new RangeError();
IndexError.prototype.constructor = RangeError;
IndexError.prototype.name = "IndexError";
IndexError.prototype.isIndexError = true;
function arraySize(x) {
  var s = [];
  while (Array.isArray(x)) {
    s.push(x.length);
    x = x[0];
  }
  return s;
}
function _validate(array2, size2, dim) {
  var i;
  var len = array2.length;
  if (len !== size2[dim]) {
    throw new DimensionError(len, size2[dim]);
  }
  if (dim < size2.length - 1) {
    var dimNext = dim + 1;
    for (i = 0; i < len; i++) {
      var child = array2[i];
      if (!Array.isArray(child)) {
        throw new DimensionError(size2.length - 1, size2.length, "<");
      }
      _validate(array2[i], size2, dimNext);
    }
  } else {
    for (i = 0; i < len; i++) {
      if (Array.isArray(array2[i])) {
        throw new DimensionError(size2.length + 1, size2.length, ">");
      }
    }
  }
}
function validate(array2, size2) {
  var isScalar = size2.length === 0;
  if (isScalar) {
    if (Array.isArray(array2)) {
      throw new DimensionError(array2.length, 0);
    }
  } else {
    _validate(array2, size2, 0);
  }
}
function validateIndex(index, length) {
  if (!isNumber(index) || !isInteger(index)) {
    throw new TypeError("Index must be an integer (value: " + index + ")");
  }
  if (index < 0 || typeof length === "number" && index >= length) {
    throw new IndexError(index, length);
  }
}
function resize(array2, size2, defaultValue2) {
  if (!Array.isArray(array2) || !Array.isArray(size2)) {
    throw new TypeError("Array expected");
  }
  if (size2.length === 0) {
    throw new Error("Resizing to scalar is not supported");
  }
  size2.forEach(function(value) {
    if (!isNumber(value) || !isInteger(value) || value < 0) {
      throw new TypeError("Invalid size, must contain positive integers (size: " + format$1(size2) + ")");
    }
  });
  var _defaultValue = defaultValue2 !== void 0 ? defaultValue2 : 0;
  _resize(array2, size2, 0, _defaultValue);
  return array2;
}
function _resize(array2, size2, dim, defaultValue2) {
  var i;
  var elem;
  var oldLen = array2.length;
  var newLen = size2[dim];
  var minLen = Math.min(oldLen, newLen);
  array2.length = newLen;
  if (dim < size2.length - 1) {
    var dimNext = dim + 1;
    for (i = 0; i < minLen; i++) {
      elem = array2[i];
      if (!Array.isArray(elem)) {
        elem = [elem];
        array2[i] = elem;
      }
      _resize(elem, size2, dimNext, defaultValue2);
    }
    for (i = minLen; i < newLen; i++) {
      elem = [];
      array2[i] = elem;
      _resize(elem, size2, dimNext, defaultValue2);
    }
  } else {
    for (i = 0; i < minLen; i++) {
      while (Array.isArray(array2[i])) {
        array2[i] = array2[i][0];
      }
    }
    for (i = minLen; i < newLen; i++) {
      array2[i] = defaultValue2;
    }
  }
}
function reshape(array2, sizes) {
  var flatArray = flatten(array2);
  var currentLength = flatArray.length;
  if (!Array.isArray(array2) || !Array.isArray(sizes)) {
    throw new TypeError("Array expected");
  }
  if (sizes.length === 0) {
    throw new DimensionError(0, currentLength, "!=");
  }
  sizes = processSizesWildcard(sizes, currentLength);
  var newLength = product(sizes);
  if (currentLength !== newLength) {
    throw new DimensionError(newLength, currentLength, "!=");
  }
  try {
    return _reshape(flatArray, sizes);
  } catch (e) {
    if (e instanceof DimensionError) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    throw e;
  }
}
function processSizesWildcard(sizes, currentLength) {
  var newLength = product(sizes);
  var processedSizes = sizes.slice();
  var WILDCARD = -1;
  var wildCardIndex = sizes.indexOf(WILDCARD);
  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
  if (isMoreThanOneWildcard) {
    throw new Error("More than one wildcard in sizes");
  }
  var hasWildcard = wildCardIndex >= 0;
  var canReplaceWildcard = currentLength % newLength === 0;
  if (hasWildcard) {
    if (canReplaceWildcard) {
      processedSizes[wildCardIndex] = -currentLength / newLength;
    } else {
      throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
    }
  }
  return processedSizes;
}
function product(array2) {
  return array2.reduce((prev, curr) => prev * curr, 1);
}
function _reshape(array2, sizes) {
  var tmpArray = array2;
  var tmpArray2;
  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
    var size2 = sizes[sizeIndex];
    tmpArray2 = [];
    var length = tmpArray.length / size2;
    for (var i = 0; i < length; i++) {
      tmpArray2.push(tmpArray.slice(i * size2, (i + 1) * size2));
    }
    tmpArray = tmpArray2;
  }
  return tmpArray;
}
function unsqueeze(array2, dims, outer, size2) {
  var s = size2 || arraySize(array2);
  if (outer) {
    for (var i = 0; i < outer; i++) {
      array2 = [array2];
      s.unshift(1);
    }
  }
  array2 = _unsqueeze(array2, dims, 0);
  while (s.length < dims) {
    s.push(1);
  }
  return array2;
}
function _unsqueeze(array2, dims, dim) {
  var i, ii;
  if (Array.isArray(array2)) {
    var next = dim + 1;
    for (i = 0, ii = array2.length; i < ii; i++) {
      array2[i] = _unsqueeze(array2[i], dims, next);
    }
  } else {
    for (var d = dim; d < dims; d++) {
      array2 = [array2];
    }
  }
  return array2;
}
function flatten(array2) {
  if (!Array.isArray(array2)) {
    return array2;
  }
  var flat = [];
  array2.forEach(function callback(value) {
    if (Array.isArray(value)) {
      value.forEach(callback);
    } else {
      flat.push(value);
    }
  });
  return flat;
}
function getArrayDataType(array2, typeOf2) {
  var type2;
  var length = 0;
  for (var i = 0; i < array2.length; i++) {
    var item = array2[i];
    var isArray2 = Array.isArray(item);
    if (i === 0 && isArray2) {
      length = item.length;
    }
    if (isArray2 && item.length !== length) {
      return void 0;
    }
    var itemType = isArray2 ? getArrayDataType(item, typeOf2) : typeOf2(item);
    if (type2 === void 0) {
      type2 = itemType;
    } else if (type2 !== itemType) {
      return "mixed";
    } else
      ;
  }
  return type2;
}
function factory(name2, dependencies2, create2, meta) {
  function assertAndCreate(scope) {
    var deps = pickShallow(scope, dependencies2.map(stripOptionalNotation));
    assertDependencies(name2, dependencies2, scope);
    return create2(deps);
  }
  assertAndCreate.isFactory = true;
  assertAndCreate.fn = name2;
  assertAndCreate.dependencies = dependencies2.slice().sort();
  if (meta) {
    assertAndCreate.meta = meta;
  }
  return assertAndCreate;
}
function assertDependencies(name2, dependencies2, scope) {
  var allDefined = dependencies2.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
  if (!allDefined) {
    var missingDependencies = dependencies2.filter((dependency) => scope[dependency] === void 0);
    throw new Error('Cannot create function "'.concat(name2, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d) => '"'.concat(d, '"')).join(", "), "."));
  }
}
function isOptionalDependency(dependency) {
  return dependency && dependency[0] === "?";
}
function stripOptionalNotation(dependency) {
  return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
}
function getSafeProperty(object2, prop) {
  if (isPlainObject(object2) && isSafeProperty(object2, prop)) {
    return object2[prop];
  }
  if (typeof object2[prop] === "function" && isSafeMethod(object2, prop)) {
    throw new Error('Cannot access method "' + prop + '" as a property');
  }
  throw new Error('No access to property "' + prop + '"');
}
function setSafeProperty(object2, prop, value) {
  if (isPlainObject(object2) && isSafeProperty(object2, prop)) {
    object2[prop] = value;
    return value;
  }
  throw new Error('No access to property "' + prop + '"');
}
function hasSafeProperty(object2, prop) {
  return prop in object2;
}
function isSafeProperty(object2, prop) {
  if (!object2 || typeof object2 !== "object") {
    return false;
  }
  if (hasOwnProperty(safeNativeProperties, prop)) {
    return true;
  }
  if (prop in Object.prototype) {
    return false;
  }
  if (prop in Function.prototype) {
    return false;
  }
  return true;
}
function isSafeMethod(object2, method) {
  if (object2 === null || object2 === void 0 || typeof object2[method] !== "function") {
    return false;
  }
  if (hasOwnProperty(object2, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object2)) {
    return false;
  }
  if (hasOwnProperty(safeNativeMethods, method)) {
    return true;
  }
  if (method in Object.prototype) {
    return false;
  }
  if (method in Function.prototype) {
    return false;
  }
  return true;
}
function isPlainObject(object2) {
  return typeof object2 === "object" && object2 && object2.constructor === Object;
}
var safeNativeProperties = {
  length: true,
  name: true
};
var safeNativeMethods = {
  toString: true,
  valueOf: true,
  toLocaleString: true
};
class ObjectWrappingMap {
  constructor(object2) {
    this.wrappedObject = object2;
  }
  keys() {
    return Object.keys(this.wrappedObject);
  }
  get(key) {
    return getSafeProperty(this.wrappedObject, key);
  }
  set(key, value) {
    setSafeProperty(this.wrappedObject, key, value);
    return this;
  }
  has(key) {
    return hasSafeProperty(this.wrappedObject, key);
  }
}
function isMap(object2) {
  if (!object2) {
    return false;
  }
  return object2 instanceof Map || object2 instanceof ObjectWrappingMap || typeof object2.set === "function" && typeof object2.get === "function" && typeof object2.keys === "function" && typeof object2.has === "function";
}
var _createTyped2 = function _createTyped() {
  _createTyped2 = typedFunction.create;
  return typedFunction;
};
var dependencies$D = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
var createTyped = /* @__PURE__ */ factory("typed", dependencies$D, function createTyped2(_ref) {
  var {
    BigNumber: BigNumber2,
    Complex: Complex2,
    DenseMatrix: DenseMatrix2,
    Fraction: Fraction2
  } = _ref;
  var typed2 = _createTyped2();
  typed2.types = [
    {
      name: "number",
      test: isNumber
    },
    {
      name: "Complex",
      test: isComplex
    },
    {
      name: "BigNumber",
      test: isBigNumber
    },
    {
      name: "Fraction",
      test: isFraction
    },
    {
      name: "Unit",
      test: isUnit
    },
    {
      name: "string",
      test: isString
    },
    {
      name: "Chain",
      test: isChain
    },
    {
      name: "Array",
      test: isArray
    },
    {
      name: "Matrix",
      test: isMatrix
    },
    {
      name: "DenseMatrix",
      test: isDenseMatrix
    },
    {
      name: "SparseMatrix",
      test: isSparseMatrix
    },
    {
      name: "Range",
      test: isRange
    },
    {
      name: "Index",
      test: isIndex
    },
    {
      name: "boolean",
      test: isBoolean
    },
    {
      name: "ResultSet",
      test: isResultSet
    },
    {
      name: "Help",
      test: isHelp
    },
    {
      name: "function",
      test: isFunction
    },
    {
      name: "Date",
      test: isDate
    },
    {
      name: "RegExp",
      test: isRegExp2
    },
    {
      name: "null",
      test: isNull
    },
    {
      name: "undefined",
      test: isUndefined
    },
    {
      name: "AccessorNode",
      test: isAccessorNode
    },
    {
      name: "ArrayNode",
      test: isArrayNode
    },
    {
      name: "AssignmentNode",
      test: isAssignmentNode
    },
    {
      name: "BlockNode",
      test: isBlockNode
    },
    {
      name: "ConditionalNode",
      test: isConditionalNode
    },
    {
      name: "ConstantNode",
      test: isConstantNode
    },
    {
      name: "FunctionNode",
      test: isFunctionNode
    },
    {
      name: "FunctionAssignmentNode",
      test: isFunctionAssignmentNode
    },
    {
      name: "IndexNode",
      test: isIndexNode
    },
    {
      name: "Node",
      test: isNode
    },
    {
      name: "ObjectNode",
      test: isObjectNode
    },
    {
      name: "OperatorNode",
      test: isOperatorNode
    },
    {
      name: "ParenthesisNode",
      test: isParenthesisNode
    },
    {
      name: "RangeNode",
      test: isRangeNode
    },
    {
      name: "SymbolNode",
      test: isSymbolNode
    },
    {
      name: "Map",
      test: isMap
    },
    {
      name: "Object",
      test: isObject
    }
    // order 'Object' last, it matches on other classes too
  ];
  typed2.conversions = [{
    from: "number",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      if (digits(x) > 15) {
        throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x + "). Use function bignumber(x) to convert to BigNumber.");
      }
      return new BigNumber2(x);
    }
  }, {
    from: "number",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex2) {
        throwNoComplex(x);
      }
      return new Complex2(x, 0);
    }
  }, {
    from: "number",
    to: "string",
    convert: function convert(x) {
      return x + "";
    }
  }, {
    from: "BigNumber",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex2) {
        throwNoComplex(x);
      }
      return new Complex2(x.toNumber(), 0);
    }
  }, {
    from: "Fraction",
    to: "BigNumber",
    convert: function convert(x) {
      throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
    }
  }, {
    from: "Fraction",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex2) {
        throwNoComplex(x);
      }
      return new Complex2(x.valueOf(), 0);
    }
  }, {
    from: "number",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction2) {
        throwNoFraction(x);
      }
      var f = new Fraction2(x);
      if (f.valueOf() !== x) {
        throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x + "). Use function fraction(x) to convert to Fraction.");
      }
      return f;
    }
  }, {
    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
    //  from: 'Fraction',
    //  to: 'number',
    //  convert: function (x) {
    //    return x.valueOf()
    //  }
    // }, {
    from: "string",
    to: "number",
    convert: function convert(x) {
      var n = Number(x);
      if (isNaN(n)) {
        throw new Error('Cannot convert "' + x + '" to a number');
      }
      return n;
    }
  }, {
    from: "string",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      try {
        return new BigNumber2(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to BigNumber');
      }
    }
  }, {
    from: "string",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction2) {
        throwNoFraction(x);
      }
      try {
        return new Fraction2(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to Fraction');
      }
    }
  }, {
    from: "string",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex2) {
        throwNoComplex(x);
      }
      try {
        return new Complex2(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to Complex');
      }
    }
  }, {
    from: "boolean",
    to: "number",
    convert: function convert(x) {
      return +x;
    }
  }, {
    from: "boolean",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      return new BigNumber2(+x);
    }
  }, {
    from: "boolean",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction2) {
        throwNoFraction(x);
      }
      return new Fraction2(+x);
    }
  }, {
    from: "boolean",
    to: "string",
    convert: function convert(x) {
      return String(x);
    }
  }, {
    from: "Array",
    to: "Matrix",
    convert: function convert(array2) {
      if (!DenseMatrix2) {
        throwNoMatrix();
      }
      return new DenseMatrix2(array2);
    }
  }, {
    from: "Matrix",
    to: "Array",
    convert: function convert(matrix2) {
      return matrix2.valueOf();
    }
  }];
  return typed2;
});
function throwNoBignumber(x) {
  throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
}
function throwNoComplex(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
}
function throwNoMatrix() {
  throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
}
function throwNoFraction(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
}
/*!
 *  decimal.js v10.5.0
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
}, inexact, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P$2 = { toStringTag: tag };
P$2.absoluteValue = P$2.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P$2.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P$2.clampedTo = P$2.clamp = function(min2, max2) {
  var k, x = this, Ctor = x.constructor;
  min2 = new Ctor(min2);
  max2 = new Ctor(max2);
  if (!min2.s || !max2.s)
    return new Ctor(NaN);
  if (min2.gt(max2))
    throw Error(invalidArgument + max2);
  k = x.cmp(min2);
  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
};
P$2.comparedTo = P$2.cmp = function(y) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y.e)
    return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i])
      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P$2.cosine = P$2.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P$2.cubeRoot = P$2.cbrt = function() {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;
    if (s = (e - n.length + 1) % 3)
      n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P$2.decimalPlaces = P$2.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w)
      for (; w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P$2.dividedBy = P$2.div = function(y) {
  return divide(this, new this.constructor(y));
};
P$2.dividedToIntegerBy = P$2.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P$2.equals = P$2.eq = function(y) {
  return this.cmp(y) === 0;
};
P$2.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P$2.greaterThan = P$2.gt = function(y) {
  return this.cmp(y) > 0;
};
P$2.greaterThanOrEqualTo = P$2.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P$2.hyperbolicCosine = P$2.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one2 = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one2;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (; i--; ) {
    cosh2_x = x.times(x);
    x = one2.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P$2.hyperbolicSine = P$2.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P$2.hyperbolicTangent = P$2.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P$2.inverseCosine = P$2.acos = function() {
  var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P$2.inverseHyperbolicCosine = P$2.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P$2.inverseHyperbolicSine = P$2.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P$2.inverseHyperbolicTangent = P$2.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P$2.inverseSine = P$2.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P$2.inverseTangent = P$2.atan = function() {
  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k; i; --i)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (; i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== void 0)
      for (i = j; r.d[i] === t.d[i] && i--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P$2.isFinite = function() {
  return !!this.d;
};
P$2.isInteger = P$2.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P$2.isNaN = function() {
  return !this.s;
};
P$2.isNegative = P$2.isNeg = function() {
  return this.s < 0;
};
P$2.isPositive = P$2.isPos = function() {
  return this.s > 0;
};
P$2.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P$2.lessThan = P$2.lt = function(y) {
  return this.cmp(y) < 0;
};
P$2.lessThanOrEqualTo = P$2.lte = function(y) {
  return this.cmp(y) < 1;
};
P$2.logarithm = P$2.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P$2.minus = P$2.sub = function(y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (x.d)
      y.s = -y.s;
    else
      y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y.s = -y.s;
    else if (xd[0])
      y = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k; i--; )
      d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P$2.modulo = P$2.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0])
    return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P$2.naturalExponential = P$2.exp = function() {
  return naturalExponential(this);
};
P$2.naturalLogarithm = P$2.ln = function() {
  return naturalLogarithm(this);
};
P$2.negated = P$2.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P$2.plus = P$2.add = function(y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (!x.d)
      y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P$2.precision = P$2.sd = function(z) {
  var k, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P$2.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P$2.sine = P$2.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P$2.squareRoot = P$2.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P$2.tangent = P$2.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P$2.times = P$2.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; )
    r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k = xdL + i; k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (; !r[--rL]; )
    r.pop();
  if (carry)
    ++e;
  else
    r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P$2.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P$2.toDecimalPlaces = P$2.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P$2.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P$2.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P$2.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k, n, n0, n12, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n12 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d : n12;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n12))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e > 0 ? d : n12 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n12;
    n12 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n12));
  d0 = d0.plus(d2.times(d1));
  n0.s = n12.s = x.s;
  r = divide(n12, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n12, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P$2.toHexadecimal = P$2.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P$2.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d)
      return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y.s ? x : y;
    if (!y.d) {
      if (y.s)
        y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P$2.toNumber = function() {
  return +this;
};
P$2.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P$2.toPower = P$2.pow = function(y) {
  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1))
    return finalise(x, pr, rm);
  e = mathfloor(y.e / LOG_BASE);
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e < y.d.length - 1)
      return new Ctor(NaN);
    if ((y.d[e] & 1) == 0)
      s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
    return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P$2.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P$2.toSignificantDigits = P$2.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P$2.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P$2.truncated = P$2.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P$2.valueOf = P$2.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; )
    w /= 10;
  return str + w;
}
function checkInt32(i, min2, max2) {
  if (i !== ~~i || i < min2 || i > max2) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0]; k >= 10; k /= 10)
    --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0)
        rd = rd / 100 | 0;
      else if (i == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0)
        rd = rd / 1e3 | 0;
      else if (i == 1)
        rd = rd / 100 | 0;
      else if (i == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero())
    return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k; i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide = /* @__PURE__ */ function() {
  function multiplyInteger(x, k, base) {
    var temp2, carry = 0, i = x.length;
    for (x = x.slice(); i--; ) {
      temp2 = x[i] * k + carry;
      x[i] = temp2 % base | 0;
      carry = temp2 / base | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract2(a, b, aL, base) {
    var i = 0;
    for (; aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign3 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        // Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign3 * 0 : sign3 / 0
        )
      );
    }
    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign3);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); i++)
      ;
    if (yd[i] > (xd[i] || 0))
      e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base)
                k = base - 1;
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract2(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract2(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract2(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0]; k >= 10; k /= 10)
        i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits2, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits2 = 1, k = xd[0]; k >= 10; k /= 10)
        digits2++;
      i = sd - digits2;
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits2 - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (; k++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits2 = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits2 = 1; k >= 10; k /= 10)
            digits2++;
          i %= LOG_BASE;
          j = i - LOG_BASE + digits2;
          rd = j < 0 ? 0 : w / mathpow(10, digits2 - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits2 - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (i > 0 ? j > 0 ? w / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i = 1, j = xd[0]; j >= 10; j /= 10)
              i++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10)
              k++;
            if (i != k) {
              x.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i = xd.length; xd[--i] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
function getBase10Exponent(digits2, e) {
  var w = digits2[0];
  for (e *= LOG_BASE; w >= 10; w /= 10)
    e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits2) {
  var w = digits2.length - 1, len = w * LOG_BASE + 1;
  w = digits2[w];
  if (w) {
    for (; w % 10 == 0; w /= 10)
      len--;
    for (w = digits2[0]; w >= 10; w /= 10)
      len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (; k--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, n) {
  var k, y, x = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    }
    k = x.cmp(y);
    if (k === n || k === 0 && x.s === n) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = finalise(pow2.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum2.plus(divide(pow2, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow2 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
  }
}
function naturalLogarithm(y, sd) {
  var c2, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c2 = digitsToString(xd);
  c0 = c2.charAt(0);
  if (Math.abs(e = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
      x = x.times(y);
      c2 = digitsToString(x.d);
      c0 = c2.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c2);
      e++;
    } else {
      x = new Ctor(c0 + "." + c2.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e !== 0)
        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum2 = divide(sum2, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; i++)
    ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; )
        x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; )
      str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i = xe; xd[i] === 0; --i)
    xd.pop();
  if (i < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide(x, divisor, len * 4);
  if (p)
    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (; ; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e) {
  var n = b;
  while (--e)
    n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base);
    e = len = xd.length;
    for (; xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len)
        ;
      for (i = 0, str = ""; i < len; i++)
        str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++)
              str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i = 1, str = "1."; i < len; i++)
              str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (; ++e; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len)
          for (e -= len; e--; )
            str += "0";
        else if (e < len)
          str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs$1(x) {
  return new this(x).abs();
}
function acos(x) {
  return new this(x).acos();
}
function acosh(x) {
  return new this(x).acosh();
}
function add2(x, y) {
  return new this(x).plus(y);
}
function asin(x) {
  return new this(x).asin();
}
function asinh(x) {
  return new this(x).asinh();
}
function atan(x) {
  return new this(x).atan();
}
function atanh(x) {
  return new this(x).atanh();
}
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
}
function cbrt(x) {
  return new this(x).cbrt();
}
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min2, max2) {
  return new this(x).clamp(min2, max2);
}
function config2(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i, p, v2, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v2 = obj[p]) !== void 0) {
      if (mathfloor(v2) === v2 && v2 >= ps[i + 1] && v2 <= ps[i + 2])
        this[p] = v2;
      else
        throw Error(invalidArgument + p + ": " + v2);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v2 = obj[p]) !== void 0) {
    if (v2 === true || v2 === false || v2 === 0 || v2 === 1) {
      if (v2) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v2);
    }
  }
  return this;
}
function cos(x) {
  return new this(x).cos();
}
function cosh$1(x) {
  return new this(x).cosh();
}
function clone(obj) {
  var i, p, ps;
  function Decimal2(v2) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal2))
      return new Decimal2(v2);
    x.constructor = Decimal2;
    if (isDecimalInstance(v2)) {
      x.s = v2.s;
      if (external) {
        if (!v2.d || v2.e > Decimal2.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v2.e < Decimal2.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v2.e;
          x.d = v2.d.slice();
        }
      } else {
        x.e = v2.e;
        x.d = v2.d ? v2.d.slice() : v2.d;
      }
      return;
    }
    t = typeof v2;
    if (t === "number") {
      if (v2 === 0) {
        x.s = 1 / v2 < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v2 < 0) {
        v2 = -v2;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v2 === ~~v2 && v2 < 1e7) {
        for (e = 0, i2 = v2; i2 >= 10; i2 /= 10)
          e++;
        if (external) {
          if (e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v2];
          }
        } else {
          x.e = e;
          x.d = [v2];
        }
        return;
      }
      if (v2 * 0 !== 0) {
        if (!v2)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v2.toString());
    }
    if (t === "string") {
      if ((i2 = v2.charCodeAt(0)) === 45) {
        v2 = v2.slice(1);
        x.s = -1;
      } else {
        if (i2 === 43)
          v2 = v2.slice(1);
        x.s = 1;
      }
      return isDecimal.test(v2) ? parseDecimal(x, v2) : parseOther(x, v2);
    }
    if (t === "bigint") {
      if (v2 < 0) {
        v2 = -v2;
        x.s = -1;
      } else {
        x.s = 1;
      }
      return parseDecimal(x, v2.toString());
    }
    throw Error(invalidArgument + v2);
  }
  Decimal2.prototype = P$2;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config2;
  Decimal2.clone = clone;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs$1;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh;
  Decimal2.add = add2;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh;
  Decimal2.atan2 = atan2;
  Decimal2.cbrt = cbrt;
  Decimal2.ceil = ceil;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos;
  Decimal2.cosh = cosh$1;
  Decimal2.div = div;
  Decimal2.exp = exp;
  Decimal2.floor = floor;
  Decimal2.hypot = hypot$1;
  Decimal2.ln = ln;
  Decimal2.log = log;
  Decimal2.log10 = log10;
  Decimal2.log2 = log2;
  Decimal2.max = max;
  Decimal2.min = min;
  Decimal2.mod = mod;
  Decimal2.mul = mul;
  Decimal2.pow = pow;
  Decimal2.random = random;
  Decimal2.round = round;
  Decimal2.sign = sign2;
  Decimal2.sin = sin;
  Decimal2.sinh = sinh$1;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub;
  Decimal2.sum = sum$1;
  Decimal2.tan = tan;
  Decimal2.tanh = tanh;
  Decimal2.trunc = trunc;
  if (obj === void 0)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i++]))
          obj[p] = this[p];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div(x, y) {
  return new this(x).div(y);
}
function exp(x) {
  return new this(x).exp();
}
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot$1() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0; i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log(x, y) {
  return new this(x).log(y);
}
function log2(x) {
  return new this(x).log(2);
}
function log10(x) {
  return new this(x).log(10);
}
function max() {
  return maxOrMin(this, arguments, -1);
}
function min() {
  return maxOrMin(this, arguments, 1);
}
function mod(x, y) {
  return new this(x).mod(y);
}
function mul(x, y) {
  return new this(x).mul(y);
}
function pow(x, y) {
  return new this(x).pow(y);
}
function random(sd) {
  var d, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === void 0)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i < k; )
      rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (; i < k; ) {
      n = d[i];
      if (n >= 429e7) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (; i < k; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (; rd[i] === 0; i--)
    rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (; rd[0] === 0; e -= LOG_BASE)
      rd.shift();
    for (k = 1, n = rd[0]; n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE)
      e -= LOG_BASE - k;
  }
  r.e = e;
  r.d = rd;
  return r;
}
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign2(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin(x) {
  return new this(x).sin();
}
function sinh$1(x) {
  return new this(x).sinh();
}
function sqrt(x) {
  return new this(x).sqrt();
}
function sub(x, y) {
  return new this(x).sub(y);
}
function sum$1() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (; x.s && ++i < args.length; )
    x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan(x) {
  return new this(x).tan();
}
function tanh(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P$2[Symbol.for("nodejs.util.inspect.custom")] = P$2.toString;
P$2[Symbol.toStringTag] = "Decimal";
var Decimal = P$2.constructor = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var name$C = "BigNumber";
var dependencies$C = ["?on", "config"];
var createBigNumberClass = /* @__PURE__ */ factory(name$C, dependencies$C, (_ref) => {
  var {
    on,
    config: config3
  } = _ref;
  var BigNumber2 = Decimal.clone({
    precision: config3.precision,
    modulo: Decimal.EUCLID
  });
  BigNumber2.prototype = Object.create(BigNumber2.prototype);
  BigNumber2.prototype.type = "BigNumber";
  BigNumber2.prototype.isBigNumber = true;
  BigNumber2.prototype.toJSON = function() {
    return {
      mathjs: "BigNumber",
      value: this.toString()
    };
  };
  BigNumber2.fromJSON = function(json) {
    return new BigNumber2(json.value);
  };
  if (on) {
    on("config", function(curr, prev) {
      if (curr.precision !== prev.precision) {
        BigNumber2.config({
          precision: curr.precision
        });
      }
    });
  }
  return BigNumber2;
}, {
  isClass: true
});
const cosh = Math.cosh || function(x) {
  return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
};
const sinh = Math.sinh || function(x) {
  return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
};
const cosm1 = function(x) {
  const b = Math.PI / 4;
  if (-b > x || x > b) {
    return Math.cos(x) - 1;
  }
  const xx = x * x;
  return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
};
const hypot = function(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  if (x < y)
    [x, y] = [y, x];
  if (x < 1e8)
    return Math.sqrt(x * x + y * y);
  y /= x;
  return x * Math.sqrt(1 + y * y);
};
const parser_exit = function() {
  throw SyntaxError("Invalid Param");
};
function logHypot(a, b) {
  const _a2 = Math.abs(a);
  const _b2 = Math.abs(b);
  if (a === 0) {
    return Math.log(_b2);
  }
  if (b === 0) {
    return Math.log(_a2);
  }
  if (_a2 < 3e3 && _b2 < 3e3) {
    return Math.log(a * a + b * b) * 0.5;
  }
  a = a * 0.5;
  b = b * 0.5;
  return 0.5 * Math.log(a * a + b * b) + Math.LN2;
}
const P$1 = { "re": 0, "im": 0 };
const parse$1 = function(a, b) {
  const z = P$1;
  if (a === void 0 || a === null) {
    z["re"] = z["im"] = 0;
  } else if (b !== void 0) {
    z["re"] = a;
    z["im"] = b;
  } else
    switch (typeof a) {
      case "object":
        if ("im" in a && "re" in a) {
          z["re"] = a["re"];
          z["im"] = a["im"];
        } else if ("abs" in a && "arg" in a) {
          if (!isFinite(a["abs"]) && isFinite(a["arg"])) {
            return Complex$1["INFINITY"];
          }
          z["re"] = a["abs"] * Math.cos(a["arg"]);
          z["im"] = a["abs"] * Math.sin(a["arg"]);
        } else if ("r" in a && "phi" in a) {
          if (!isFinite(a["r"]) && isFinite(a["phi"])) {
            return Complex$1["INFINITY"];
          }
          z["re"] = a["r"] * Math.cos(a["phi"]);
          z["im"] = a["r"] * Math.sin(a["phi"]);
        } else if (a.length === 2) {
          z["re"] = a[0];
          z["im"] = a[1];
        } else {
          parser_exit();
        }
        break;
      case "string":
        z["im"] = /* void */
        z["re"] = 0;
        const tokens = a.replace(/_/g, "").match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
        let plus = 1;
        let minus = 0;
        if (tokens === null) {
          parser_exit();
        }
        for (let i = 0; i < tokens.length; i++) {
          const c2 = tokens[i];
          if (c2 === " " || c2 === "	" || c2 === "\n")
            ;
          else if (c2 === "+") {
            plus++;
          } else if (c2 === "-") {
            minus++;
          } else if (c2 === "i" || c2 === "I") {
            if (plus + minus === 0) {
              parser_exit();
            }
            if (tokens[i + 1] !== " " && !isNaN(tokens[i + 1])) {
              z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i + 1]);
              i++;
            } else {
              z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
            }
            plus = minus = 0;
          } else {
            if (plus + minus === 0 || isNaN(c2)) {
              parser_exit();
            }
            if (tokens[i + 1] === "i" || tokens[i + 1] === "I") {
              z["im"] += parseFloat((minus % 2 ? "-" : "") + c2);
              i++;
            } else {
              z["re"] += parseFloat((minus % 2 ? "-" : "") + c2);
            }
            plus = minus = 0;
          }
        }
        if (plus + minus > 0) {
          parser_exit();
        }
        break;
      case "number":
        z["im"] = 0;
        z["re"] = a;
        break;
      default:
        parser_exit();
    }
  if (isNaN(z["re"]) || isNaN(z["im"]))
    ;
  return z;
};
function Complex$1(a, b) {
  if (!(this instanceof Complex$1)) {
    return new Complex$1(a, b);
  }
  const z = parse$1(a, b);
  this["re"] = z["re"];
  this["im"] = z["im"];
}
Complex$1.prototype = {
  "re": 0,
  "im": 0,
  /**
   * Calculates the sign of a complex number, which is a normalized complex
   *
   * @returns {Complex}
   */
  "sign": function() {
    const abs2 = hypot(this["re"], this["im"]);
    return new Complex$1(
      this["re"] / abs2,
      this["im"] / abs2
    );
  },
  /**
   * Adds two complex numbers
   *
   * @returns {Complex}
   */
  "add": function(a, b) {
    const z = parse$1(a, b);
    const tInfin = this["isInfinite"]();
    const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
    if (tInfin || zInfin) {
      if (tInfin && zInfin) {
        return Complex$1["NAN"];
      }
      return Complex$1["INFINITY"];
    }
    return new Complex$1(
      this["re"] + z["re"],
      this["im"] + z["im"]
    );
  },
  /**
   * Subtracts two complex numbers
   *
   * @returns {Complex}
   */
  "sub": function(a, b) {
    const z = parse$1(a, b);
    const tInfin = this["isInfinite"]();
    const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
    if (tInfin || zInfin) {
      if (tInfin && zInfin) {
        return Complex$1["NAN"];
      }
      return Complex$1["INFINITY"];
    }
    return new Complex$1(
      this["re"] - z["re"],
      this["im"] - z["im"]
    );
  },
  /**
   * Multiplies two complex numbers
   *
   * @returns {Complex}
   */
  "mul": function(a, b) {
    const z = parse$1(a, b);
    const tInfin = this["isInfinite"]();
    const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
    const tIsZero = this["re"] === 0 && this["im"] === 0;
    const zIsZero = z["re"] === 0 && z["im"] === 0;
    if (tInfin && zIsZero || zInfin && tIsZero) {
      return Complex$1["NAN"];
    }
    if (tInfin || zInfin) {
      return Complex$1["INFINITY"];
    }
    if (z["im"] === 0 && this["im"] === 0) {
      return new Complex$1(this["re"] * z["re"], 0);
    }
    return new Complex$1(
      this["re"] * z["re"] - this["im"] * z["im"],
      this["re"] * z["im"] + this["im"] * z["re"]
    );
  },
  /**
   * Divides two complex numbers
   *
   * @returns {Complex}
   */
  "div": function(a, b) {
    const z = parse$1(a, b);
    const tInfin = this["isInfinite"]();
    const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
    const tIsZero = this["re"] === 0 && this["im"] === 0;
    const zIsZero = z["re"] === 0 && z["im"] === 0;
    if (tIsZero && zIsZero || tInfin && zInfin) {
      return Complex$1["NAN"];
    }
    if (zIsZero || tInfin) {
      return Complex$1["INFINITY"];
    }
    if (tIsZero || zInfin) {
      return Complex$1["ZERO"];
    }
    if (0 === z["im"]) {
      return new Complex$1(this["re"] / z["re"], this["im"] / z["re"]);
    }
    if (Math.abs(z["re"]) < Math.abs(z["im"])) {
      const x = z["re"] / z["im"];
      const t = z["re"] * x + z["im"];
      return new Complex$1(
        (this["re"] * x + this["im"]) / t,
        (this["im"] * x - this["re"]) / t
      );
    } else {
      const x = z["im"] / z["re"];
      const t = z["im"] * x + z["re"];
      return new Complex$1(
        (this["re"] + this["im"] * x) / t,
        (this["im"] - this["re"] * x) / t
      );
    }
  },
  /**
   * Calculate the power of two complex numbers
   *
   * @returns {Complex}
   */
  "pow": function(a, b) {
    const z = parse$1(a, b);
    const tIsZero = this["re"] === 0 && this["im"] === 0;
    const zIsZero = z["re"] === 0 && z["im"] === 0;
    if (zIsZero) {
      return Complex$1["ONE"];
    }
    if (z["im"] === 0) {
      if (this["im"] === 0 && this["re"] > 0) {
        return new Complex$1(Math.pow(this["re"], z["re"]), 0);
      } else if (this["re"] === 0) {
        switch ((z["re"] % 4 + 4) % 4) {
          case 0:
            return new Complex$1(Math.pow(this["im"], z["re"]), 0);
          case 1:
            return new Complex$1(0, Math.pow(this["im"], z["re"]));
          case 2:
            return new Complex$1(-Math.pow(this["im"], z["re"]), 0);
          case 3:
            return new Complex$1(0, -Math.pow(this["im"], z["re"]));
        }
      }
    }
    if (tIsZero && z["re"] > 0) {
      return Complex$1["ZERO"];
    }
    const arg = Math.atan2(this["im"], this["re"]);
    const loh = logHypot(this["re"], this["im"]);
    let re2 = Math.exp(z["re"] * loh - z["im"] * arg);
    let im = z["im"] * loh + z["re"] * arg;
    return new Complex$1(
      re2 * Math.cos(im),
      re2 * Math.sin(im)
    );
  },
  /**
   * Calculate the complex square root
   *
   * @returns {Complex}
   */
  "sqrt": function() {
    const a = this["re"];
    const b = this["im"];
    if (b === 0) {
      if (a >= 0) {
        return new Complex$1(Math.sqrt(a), 0);
      } else {
        return new Complex$1(0, Math.sqrt(-a));
      }
    }
    const r = hypot(a, b);
    let re2 = Math.sqrt(0.5 * (r + Math.abs(a)));
    let im = Math.abs(b) / (2 * re2);
    if (a >= 0) {
      return new Complex$1(re2, b < 0 ? -im : im);
    } else {
      return new Complex$1(im, b < 0 ? -re2 : re2);
    }
  },
  /**
   * Calculate the complex exponent
   *
   * @returns {Complex}
   */
  "exp": function() {
    const er = Math.exp(this["re"]);
    if (this["im"] === 0) {
      return new Complex$1(er, 0);
    }
    return new Complex$1(
      er * Math.cos(this["im"]),
      er * Math.sin(this["im"])
    );
  },
  /**
   * Calculate the complex exponent and subtracts one.
   *
   * This may be more accurate than `Complex(x).exp().sub(1)` if
   * `x` is small.
   *
   * @returns {Complex}
   */
  "expm1": function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex$1(
      Math.expm1(a) * Math.cos(b) + cosm1(b),
      Math.exp(a) * Math.sin(b)
    );
  },
  /**
   * Calculate the natural log
   *
   * @returns {Complex}
   */
  "log": function() {
    const a = this["re"];
    const b = this["im"];
    if (b === 0 && a > 0) {
      return new Complex$1(Math.log(a), 0);
    }
    return new Complex$1(
      logHypot(a, b),
      Math.atan2(b, a)
    );
  },
  /**
   * Calculate the magnitude of the complex number
   *
   * @returns {number}
   */
  "abs": function() {
    return hypot(this["re"], this["im"]);
  },
  /**
   * Calculate the angle of the complex number
   *
   * @returns {number}
   */
  "arg": function() {
    return Math.atan2(this["im"], this["re"]);
  },
  /**
   * Calculate the sine of the complex number
   *
   * @returns {Complex}
   */
  "sin": function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex$1(
      Math.sin(a) * cosh(b),
      Math.cos(a) * sinh(b)
    );
  },
  /**
   * Calculate the cosine
   *
   * @returns {Complex}
   */
  "cos": function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex$1(
      Math.cos(a) * cosh(b),
      -Math.sin(a) * sinh(b)
    );
  },
  /**
   * Calculate the tangent
   *
   * @returns {Complex}
   */
  "tan": function() {
    const a = 2 * this["re"];
    const b = 2 * this["im"];
    const d = Math.cos(a) + cosh(b);
    return new Complex$1(
      Math.sin(a) / d,
      sinh(b) / d
    );
  },
  /**
   * Calculate the cotangent
   *
   * @returns {Complex}
   */
  "cot": function() {
    const a = 2 * this["re"];
    const b = 2 * this["im"];
    const d = Math.cos(a) - cosh(b);
    return new Complex$1(
      -Math.sin(a) / d,
      sinh(b) / d
    );
  },
  /**
   * Calculate the secant
   *
   * @returns {Complex}
   */
  "sec": function() {
    const a = this["re"];
    const b = this["im"];
    const d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);
    return new Complex$1(
      Math.cos(a) * cosh(b) / d,
      Math.sin(a) * sinh(b) / d
    );
  },
  /**
   * Calculate the cosecans
   *
   * @returns {Complex}
   */
  "csc": function() {
    const a = this["re"];
    const b = this["im"];
    const d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);
    return new Complex$1(
      Math.sin(a) * cosh(b) / d,
      -Math.cos(a) * sinh(b) / d
    );
  },
  /**
   * Calculate the complex arcus sinus
   *
   * @returns {Complex}
   */
  "asin": function() {
    const a = this["re"];
    const b = this["im"];
    const t1 = new Complex$1(
      b * b - a * a + 1,
      -2 * a * b
    )["sqrt"]();
    const t2 = new Complex$1(
      t1["re"] - b,
      t1["im"] + a
    )["log"]();
    return new Complex$1(t2["im"], -t2["re"]);
  },
  /**
   * Calculate the complex arcus cosinus
   *
   * @returns {Complex}
   */
  "acos": function() {
    const a = this["re"];
    const b = this["im"];
    const t1 = new Complex$1(
      b * b - a * a + 1,
      -2 * a * b
    )["sqrt"]();
    const t2 = new Complex$1(
      t1["re"] - b,
      t1["im"] + a
    )["log"]();
    return new Complex$1(Math.PI / 2 - t2["im"], t2["re"]);
  },
  /**
   * Calculate the complex arcus tangent
   *
   * @returns {Complex}
   */
  "atan": function() {
    const a = this["re"];
    const b = this["im"];
    if (a === 0) {
      if (b === 1) {
        return new Complex$1(0, Infinity);
      }
      if (b === -1) {
        return new Complex$1(0, -Infinity);
      }
    }
    const d = a * a + (1 - b) * (1 - b);
    const t1 = new Complex$1(
      (1 - b * b - a * a) / d,
      -2 * a / d
    ).log();
    return new Complex$1(-0.5 * t1["im"], 0.5 * t1["re"]);
  },
  /**
   * Calculate the complex arcus cotangent
   *
   * @returns {Complex}
   */
  "acot": function() {
    const a = this["re"];
    const b = this["im"];
    if (b === 0) {
      return new Complex$1(Math.atan2(1, a), 0);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex$1(
      a / d,
      -b / d
    ).atan() : new Complex$1(
      a !== 0 ? a / 0 : 0,
      b !== 0 ? -b / 0 : 0
    ).atan();
  },
  /**
   * Calculate the complex arcus secant
   *
   * @returns {Complex}
   */
  "asec": function() {
    const a = this["re"];
    const b = this["im"];
    if (a === 0 && b === 0) {
      return new Complex$1(0, Infinity);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex$1(
      a / d,
      -b / d
    ).acos() : new Complex$1(
      a !== 0 ? a / 0 : 0,
      b !== 0 ? -b / 0 : 0
    ).acos();
  },
  /**
   * Calculate the complex arcus cosecans
   *
   * @returns {Complex}
   */
  "acsc": function() {
    const a = this["re"];
    const b = this["im"];
    if (a === 0 && b === 0) {
      return new Complex$1(Math.PI / 2, Infinity);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex$1(
      a / d,
      -b / d
    ).asin() : new Complex$1(
      a !== 0 ? a / 0 : 0,
      b !== 0 ? -b / 0 : 0
    ).asin();
  },
  /**
   * Calculate the complex sinh
   *
   * @returns {Complex}
   */
  "sinh": function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex$1(
      sinh(a) * Math.cos(b),
      cosh(a) * Math.sin(b)
    );
  },
  /**
   * Calculate the complex cosh
   *
   * @returns {Complex}
   */
  "cosh": function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex$1(
      cosh(a) * Math.cos(b),
      sinh(a) * Math.sin(b)
    );
  },
  /**
   * Calculate the complex tanh
   *
   * @returns {Complex}
   */
  "tanh": function() {
    const a = 2 * this["re"];
    const b = 2 * this["im"];
    const d = cosh(a) + Math.cos(b);
    return new Complex$1(
      sinh(a) / d,
      Math.sin(b) / d
    );
  },
  /**
   * Calculate the complex coth
   *
   * @returns {Complex}
   */
  "coth": function() {
    const a = 2 * this["re"];
    const b = 2 * this["im"];
    const d = cosh(a) - Math.cos(b);
    return new Complex$1(
      sinh(a) / d,
      -Math.sin(b) / d
    );
  },
  /**
   * Calculate the complex coth
   *
   * @returns {Complex}
   */
  "csch": function() {
    const a = this["re"];
    const b = this["im"];
    const d = Math.cos(2 * b) - cosh(2 * a);
    return new Complex$1(
      -2 * sinh(a) * Math.cos(b) / d,
      2 * cosh(a) * Math.sin(b) / d
    );
  },
  /**
   * Calculate the complex sech
   *
   * @returns {Complex}
   */
  "sech": function() {
    const a = this["re"];
    const b = this["im"];
    const d = Math.cos(2 * b) + cosh(2 * a);
    return new Complex$1(
      2 * cosh(a) * Math.cos(b) / d,
      -2 * sinh(a) * Math.sin(b) / d
    );
  },
  /**
   * Calculate the complex asinh
   *
   * @returns {Complex}
   */
  "asinh": function() {
    let tmp = this["im"];
    this["im"] = -this["re"];
    this["re"] = tmp;
    const res = this["asin"]();
    this["re"] = -this["im"];
    this["im"] = tmp;
    tmp = res["re"];
    res["re"] = -res["im"];
    res["im"] = tmp;
    return res;
  },
  /**
   * Calculate the complex acosh
   *
   * @returns {Complex}
   */
  "acosh": function() {
    const res = this["acos"]();
    if (res["im"] <= 0) {
      const tmp = res["re"];
      res["re"] = -res["im"];
      res["im"] = tmp;
    } else {
      const tmp = res["im"];
      res["im"] = -res["re"];
      res["re"] = tmp;
    }
    return res;
  },
  /**
   * Calculate the complex atanh
   *
   * @returns {Complex}
   */
  "atanh": function() {
    const a = this["re"];
    const b = this["im"];
    const noIM = a > 1 && b === 0;
    const oneMinus = 1 - a;
    const onePlus = 1 + a;
    const d = oneMinus * oneMinus + b * b;
    const x = d !== 0 ? new Complex$1(
      (onePlus * oneMinus - b * b) / d,
      (b * oneMinus + onePlus * b) / d
    ) : new Complex$1(
      a !== -1 ? a / 0 : 0,
      b !== 0 ? b / 0 : 0
    );
    const temp2 = x["re"];
    x["re"] = logHypot(x["re"], x["im"]) / 2;
    x["im"] = Math.atan2(x["im"], temp2) / 2;
    if (noIM) {
      x["im"] = -x["im"];
    }
    return x;
  },
  /**
   * Calculate the complex acoth
   *
   * @returns {Complex}
   */
  "acoth": function() {
    const a = this["re"];
    const b = this["im"];
    if (a === 0 && b === 0) {
      return new Complex$1(0, Math.PI / 2);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex$1(
      a / d,
      -b / d
    ).atanh() : new Complex$1(
      a !== 0 ? a / 0 : 0,
      b !== 0 ? -b / 0 : 0
    ).atanh();
  },
  /**
   * Calculate the complex acsch
   *
   * @returns {Complex}
   */
  "acsch": function() {
    const a = this["re"];
    const b = this["im"];
    if (b === 0) {
      return new Complex$1(
        a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity,
        0
      );
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex$1(
      a / d,
      -b / d
    ).asinh() : new Complex$1(
      a !== 0 ? a / 0 : 0,
      b !== 0 ? -b / 0 : 0
    ).asinh();
  },
  /**
   * Calculate the complex asech
   *
   * @returns {Complex}
   */
  "asech": function() {
    const a = this["re"];
    const b = this["im"];
    if (this["isZero"]()) {
      return Complex$1["INFINITY"];
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex$1(
      a / d,
      -b / d
    ).acosh() : new Complex$1(
      a !== 0 ? a / 0 : 0,
      b !== 0 ? -b / 0 : 0
    ).acosh();
  },
  /**
   * Calculate the complex inverse 1/z
   *
   * @returns {Complex}
   */
  "inverse": function() {
    if (this["isZero"]()) {
      return Complex$1["INFINITY"];
    }
    if (this["isInfinite"]()) {
      return Complex$1["ZERO"];
    }
    const a = this["re"];
    const b = this["im"];
    const d = a * a + b * b;
    return new Complex$1(a / d, -b / d);
  },
  /**
   * Returns the complex conjugate
   *
   * @returns {Complex}
   */
  "conjugate": function() {
    return new Complex$1(this["re"], -this["im"]);
  },
  /**
   * Gets the negated complex number
   *
   * @returns {Complex}
   */
  "neg": function() {
    return new Complex$1(-this["re"], -this["im"]);
  },
  /**
   * Ceils the actual complex number
   *
   * @returns {Complex}
   */
  "ceil": function(places) {
    places = Math.pow(10, places || 0);
    return new Complex$1(
      Math.ceil(this["re"] * places) / places,
      Math.ceil(this["im"] * places) / places
    );
  },
  /**
   * Floors the actual complex number
   *
   * @returns {Complex}
   */
  "floor": function(places) {
    places = Math.pow(10, places || 0);
    return new Complex$1(
      Math.floor(this["re"] * places) / places,
      Math.floor(this["im"] * places) / places
    );
  },
  /**
   * Ceils the actual complex number
   *
   * @returns {Complex}
   */
  "round": function(places) {
    places = Math.pow(10, places || 0);
    return new Complex$1(
      Math.round(this["re"] * places) / places,
      Math.round(this["im"] * places) / places
    );
  },
  /**
   * Compares two complex numbers
   *
   * **Note:** new Complex(Infinity).equals(Infinity) === false
   *
   * @returns {boolean}
   */
  "equals": function(a, b) {
    const z = parse$1(a, b);
    return Math.abs(z["re"] - this["re"]) <= Complex$1["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex$1["EPSILON"];
  },
  /**
   * Clones the actual object
   *
   * @returns {Complex}
   */
  "clone": function() {
    return new Complex$1(this["re"], this["im"]);
  },
  /**
   * Gets a string of the actual complex number
   *
   * @returns {string}
   */
  "toString": function() {
    let a = this["re"];
    let b = this["im"];
    let ret = "";
    if (this["isNaN"]()) {
      return "NaN";
    }
    if (this["isInfinite"]()) {
      return "Infinity";
    }
    if (Math.abs(a) < Complex$1["EPSILON"]) {
      a = 0;
    }
    if (Math.abs(b) < Complex$1["EPSILON"]) {
      b = 0;
    }
    if (b === 0) {
      return ret + a;
    }
    if (a !== 0) {
      ret += a;
      ret += " ";
      if (b < 0) {
        b = -b;
        ret += "-";
      } else {
        ret += "+";
      }
      ret += " ";
    } else if (b < 0) {
      b = -b;
      ret += "-";
    }
    if (1 !== b) {
      ret += b;
    }
    return ret + "i";
  },
  /**
   * Returns the actual number as a vector
   *
   * @returns {Array}
   */
  "toVector": function() {
    return [this["re"], this["im"]];
  },
  /**
   * Returns the actual real value of the current object
   *
   * @returns {number|null}
   */
  "valueOf": function() {
    if (this["im"] === 0) {
      return this["re"];
    }
    return null;
  },
  /**
   * Determines whether a complex number is not on the Riemann sphere.
   *
   * @returns {boolean}
   */
  "isNaN": function() {
    return isNaN(this["re"]) || isNaN(this["im"]);
  },
  /**
   * Determines whether or not a complex number is at the zero pole of the
   * Riemann sphere.
   *
   * @returns {boolean}
   */
  "isZero": function() {
    return this["im"] === 0 && this["re"] === 0;
  },
  /**
   * Determines whether a complex number is not at the infinity pole of the
   * Riemann sphere.
   *
   * @returns {boolean}
   */
  "isFinite": function() {
    return isFinite(this["re"]) && isFinite(this["im"]);
  },
  /**
   * Determines whether or not a complex number is at the infinity pole of the
   * Riemann sphere.
   *
   * @returns {boolean}
   */
  "isInfinite": function() {
    return !this["isFinite"]();
  }
};
Complex$1["ZERO"] = new Complex$1(0, 0);
Complex$1["ONE"] = new Complex$1(1, 0);
Complex$1["I"] = new Complex$1(0, 1);
Complex$1["PI"] = new Complex$1(Math.PI, 0);
Complex$1["E"] = new Complex$1(Math.E, 0);
Complex$1["INFINITY"] = new Complex$1(Infinity, Infinity);
Complex$1["NAN"] = new Complex$1(NaN, NaN);
Complex$1["EPSILON"] = 1e-15;
var name$B = "Complex";
var dependencies$B = [];
var createComplexClass = /* @__PURE__ */ factory(name$B, dependencies$B, () => {
  Complex$1.prototype.type = "Complex";
  Complex$1.prototype.isComplex = true;
  Complex$1.prototype.toJSON = function() {
    return {
      mathjs: "Complex",
      re: this.re,
      im: this.im
    };
  };
  Complex$1.prototype.toPolar = function() {
    return {
      r: this.abs(),
      phi: this.arg()
    };
  };
  Complex$1.prototype.format = function(options) {
    var str = "";
    var im = this.im;
    var re2 = this.re;
    var strRe = format$3(this.re, options);
    var strIm = format$3(this.im, options);
    var precision = isNumber(options) ? options : options ? options.precision : null;
    if (precision !== null) {
      var epsilon = Math.pow(10, -precision);
      if (Math.abs(re2 / im) < epsilon) {
        re2 = 0;
      }
      if (Math.abs(im / re2) < epsilon) {
        im = 0;
      }
    }
    if (im === 0) {
      str = strRe;
    } else if (re2 === 0) {
      if (im === 1) {
        str = "i";
      } else if (im === -1) {
        str = "-i";
      } else {
        str = strIm + "i";
      }
    } else {
      if (im < 0) {
        if (im === -1) {
          str = strRe + " - i";
        } else {
          str = strRe + " - " + strIm.substring(1) + "i";
        }
      } else {
        if (im === 1) {
          str = strRe + " + i";
        } else {
          str = strRe + " + " + strIm + "i";
        }
      }
    }
    return str;
  };
  Complex$1.fromPolar = function(args) {
    switch (arguments.length) {
      case 1: {
        var arg = arguments[0];
        if (typeof arg === "object") {
          return Complex$1(arg);
        } else {
          throw new TypeError("Input has to be an object with r and phi keys.");
        }
      }
      case 2: {
        var r = arguments[0];
        var phi = arguments[1];
        if (isNumber(r)) {
          if (isUnit(phi) && phi.hasBase("ANGLE")) {
            phi = phi.toNumber("rad");
          }
          if (isNumber(phi)) {
            return new Complex$1({
              r,
              phi
            });
          }
          throw new TypeError("Phi is not a number nor an angle unit.");
        } else {
          throw new TypeError("Radius r is not a number.");
        }
      }
      default:
        throw new SyntaxError("Wrong number of arguments in function fromPolar");
    }
  };
  Complex$1.prototype.valueOf = Complex$1.prototype.toString;
  Complex$1.fromJSON = function(json) {
    return new Complex$1(json);
  };
  Complex$1.compare = function(a, b) {
    if (a.re > b.re) {
      return 1;
    }
    if (a.re < b.re) {
      return -1;
    }
    if (a.im > b.im) {
      return 1;
    }
    if (a.im < b.im) {
      return -1;
    }
    return 0;
  };
  return Complex$1;
}, {
  isClass: true
});
/**
 * @license Fraction.js v4.3.7 31/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
var MAX_CYCLE_LEN = 2e3;
var P = {
  "s": 1,
  "n": 0,
  "d": 1
};
function assign(n, s) {
  if (isNaN(n = parseInt(n, 10))) {
    throw InvalidParameter();
  }
  return n * s;
}
function newFraction(n, d) {
  if (d === 0) {
    throw DivisionByZero();
  }
  var f = Object.create(Fraction$1.prototype);
  f["s"] = n < 0 ? -1 : 1;
  n = n < 0 ? -n : n;
  var a = gcd(n, d);
  f["n"] = n / a;
  f["d"] = d / a;
  return f;
}
function factorize(num) {
  var factors = {};
  var n = num;
  var i = 2;
  var s = 4;
  while (s <= n) {
    while (n % i === 0) {
      n /= i;
      factors[i] = (factors[i] || 0) + 1;
    }
    s += 1 + 2 * i++;
  }
  if (n !== num) {
    if (n > 1)
      factors[n] = (factors[n] || 0) + 1;
  } else {
    factors[num] = (factors[num] || 0) + 1;
  }
  return factors;
}
var parse = function(p1, p2) {
  var n = 0, d = 1, s = 1;
  var v2 = 0, w = 0, x = 0, y = 1, z = 1;
  var A2 = 0, B2 = 1;
  var C2 = 1, D2 = 1;
  var N = 1e7;
  var M;
  if (p1 === void 0 || p1 === null)
    ;
  else if (p2 !== void 0) {
    n = p1;
    d = p2;
    s = n * d;
    if (n % 1 !== 0 || d % 1 !== 0) {
      throw NonIntegerParameter();
    }
  } else
    switch (typeof p1) {
      case "object": {
        if ("d" in p1 && "n" in p1) {
          n = p1["n"];
          d = p1["d"];
          if ("s" in p1)
            n *= p1["s"];
        } else if (0 in p1) {
          n = p1[0];
          if (1 in p1)
            d = p1[1];
        } else {
          throw InvalidParameter();
        }
        s = n * d;
        break;
      }
      case "number": {
        if (p1 < 0) {
          s = p1;
          p1 = -p1;
        }
        if (p1 % 1 === 0) {
          n = p1;
        } else if (p1 > 0) {
          if (p1 >= 1) {
            z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
            p1 /= z;
          }
          while (B2 <= N && D2 <= N) {
            M = (A2 + C2) / (B2 + D2);
            if (p1 === M) {
              if (B2 + D2 <= N) {
                n = A2 + C2;
                d = B2 + D2;
              } else if (D2 > B2) {
                n = C2;
                d = D2;
              } else {
                n = A2;
                d = B2;
              }
              break;
            } else {
              if (p1 > M) {
                A2 += C2;
                B2 += D2;
              } else {
                C2 += A2;
                D2 += B2;
              }
              if (B2 > N) {
                n = C2;
                d = D2;
              } else {
                n = A2;
                d = B2;
              }
            }
          }
          n *= z;
        } else if (isNaN(p1) || isNaN(p2)) {
          d = n = NaN;
        }
        break;
      }
      case "string": {
        B2 = p1.match(/\d+|./g);
        if (B2 === null)
          throw InvalidParameter();
        if (B2[A2] === "-") {
          s = -1;
          A2++;
        } else if (B2[A2] === "+") {
          A2++;
        }
        if (B2.length === A2 + 1) {
          w = assign(B2[A2++], s);
        } else if (B2[A2 + 1] === "." || B2[A2] === ".") {
          if (B2[A2] !== ".") {
            v2 = assign(B2[A2++], s);
          }
          A2++;
          if (A2 + 1 === B2.length || B2[A2 + 1] === "(" && B2[A2 + 3] === ")" || B2[A2 + 1] === "'" && B2[A2 + 3] === "'") {
            w = assign(B2[A2], s);
            y = Math.pow(10, B2[A2].length);
            A2++;
          }
          if (B2[A2] === "(" && B2[A2 + 2] === ")" || B2[A2] === "'" && B2[A2 + 2] === "'") {
            x = assign(B2[A2 + 1], s);
            z = Math.pow(10, B2[A2 + 1].length) - 1;
            A2 += 3;
          }
        } else if (B2[A2 + 1] === "/" || B2[A2 + 1] === ":") {
          w = assign(B2[A2], s);
          y = assign(B2[A2 + 2], 1);
          A2 += 3;
        } else if (B2[A2 + 3] === "/" && B2[A2 + 1] === " ") {
          v2 = assign(B2[A2], s);
          w = assign(B2[A2 + 2], s);
          y = assign(B2[A2 + 4], 1);
          A2 += 5;
        }
        if (B2.length <= A2) {
          d = y * z;
          s = /* void */
          n = x + d * v2 + z * w;
          break;
        }
      }
      default:
        throw InvalidParameter();
    }
  if (d === 0) {
    throw DivisionByZero();
  }
  P["s"] = s < 0 ? -1 : 1;
  P["n"] = Math.abs(n);
  P["d"] = Math.abs(d);
};
function modpow(b, e, m) {
  var r = 1;
  for (; e > 0; b = b * b % m, e >>= 1) {
    if (e & 1) {
      r = r * b % m;
    }
  }
  return r;
}
function cycleLen(n, d) {
  for (; d % 2 === 0; d /= 2) {
  }
  for (; d % 5 === 0; d /= 5) {
  }
  if (d === 1)
    return 0;
  var rem = 10 % d;
  var t = 1;
  for (; rem !== 1; t++) {
    rem = rem * 10 % d;
    if (t > MAX_CYCLE_LEN)
      return 0;
  }
  return t;
}
function cycleStart(n, d, len) {
  var rem1 = 1;
  var rem2 = modpow(10, len, d);
  for (var t = 0; t < 300; t++) {
    if (rem1 === rem2)
      return t;
    rem1 = rem1 * 10 % d;
    rem2 = rem2 * 10 % d;
  }
  return 0;
}
function gcd(a, b) {
  if (!a)
    return b;
  if (!b)
    return a;
  while (1) {
    a %= b;
    if (!a)
      return b;
    b %= a;
    if (!b)
      return a;
  }
}
function Fraction$1(a, b) {
  parse(a, b);
  if (this instanceof Fraction$1) {
    a = gcd(P["d"], P["n"]);
    this["s"] = P["s"];
    this["n"] = P["n"] / a;
    this["d"] = P["d"] / a;
  } else {
    return newFraction(P["s"] * P["n"], P["d"]);
  }
}
var DivisionByZero = function() {
  return new Error("Division by Zero");
};
var InvalidParameter = function() {
  return new Error("Invalid argument");
};
var NonIntegerParameter = function() {
  return new Error("Parameters must be integer");
};
Fraction$1.prototype = {
  "s": 1,
  "n": 0,
  "d": 1,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  "abs": function() {
    return newFraction(this["n"], this["d"]);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  "neg": function() {
    return newFraction(-this["s"] * this["n"], this["d"]);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  "add": function(a, b) {
    parse(a, b);
    return newFraction(
      this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
      this["d"] * P["d"]
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  "sub": function(a, b) {
    parse(a, b);
    return newFraction(
      this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
      this["d"] * P["d"]
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  "mul": function(a, b) {
    parse(a, b);
    return newFraction(
      this["s"] * P["s"] * this["n"] * P["n"],
      this["d"] * P["d"]
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  "div": function(a, b) {
    parse(a, b);
    return newFraction(
      this["s"] * P["s"] * this["n"] * P["d"],
      this["d"] * P["n"]
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  "clone": function() {
    return newFraction(this["s"] * this["n"], this["d"]);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   **/
  "mod": function(a, b) {
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction$1(NaN);
    }
    if (a === void 0) {
      return newFraction(this["s"] * this["n"] % this["d"], 1);
    }
    parse(a, b);
    if (0 === P["n"] && 0 === this["d"]) {
      throw DivisionByZero();
    }
    return newFraction(
      this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
      P["d"] * this["d"]
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  "gcd": function(a, b) {
    parse(a, b);
    return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  "lcm": function(a, b) {
    parse(a, b);
    if (P["n"] === 0 && this["n"] === 0) {
      return newFraction(0, 1);
    }
    return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  "ceil": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction$1(NaN);
    }
    return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  "floor": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction$1(NaN);
    }
    return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Rounds a rational number
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  "round": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction$1(NaN);
    }
    return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Rounds a rational number to a multiple of another rational number
   *
   * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
   **/
  "roundTo": function(a, b) {
    parse(a, b);
    return newFraction(this["s"] * Math.round(this["n"] * P["d"] / (this["d"] * P["n"])) * P["n"], P["d"]);
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  "inverse": function() {
    return newFraction(this["s"] * this["d"], this["n"]);
  },
  /**
   * Calculates the fraction to some rational exponent, if possible
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  "pow": function(a, b) {
    parse(a, b);
    if (P["d"] === 1) {
      if (P["s"] < 0) {
        return newFraction(Math.pow(this["s"] * this["d"], P["n"]), Math.pow(this["n"], P["n"]));
      } else {
        return newFraction(Math.pow(this["s"] * this["n"], P["n"]), Math.pow(this["d"], P["n"]));
      }
    }
    if (this["s"] < 0)
      return null;
    var N = factorize(this["n"]);
    var D2 = factorize(this["d"]);
    var n = 1;
    var d = 1;
    for (var k in N) {
      if (k === "1")
        continue;
      if (k === "0") {
        n = 0;
        break;
      }
      N[k] *= P["n"];
      if (N[k] % P["d"] === 0) {
        N[k] /= P["d"];
      } else
        return null;
      n *= Math.pow(k, N[k]);
    }
    for (var k in D2) {
      if (k === "1")
        continue;
      D2[k] *= P["n"];
      if (D2[k] % P["d"] === 0) {
        D2[k] /= P["d"];
      } else
        return null;
      d *= Math.pow(k, D2[k]);
    }
    if (P["s"] < 0) {
      return newFraction(d, n);
    }
    return newFraction(n, d);
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  "equals": function(a, b) {
    parse(a, b);
    return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"];
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  "compare": function(a, b) {
    parse(a, b);
    var t = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
    return (0 < t) - (t < 0);
  },
  "simplify": function(eps) {
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return this;
    }
    eps = eps || 1e-3;
    var thisABS = this["abs"]();
    var cont = thisABS["toContinued"]();
    for (var i = 1; i < cont.length; i++) {
      var s = newFraction(cont[i - 1], 1);
      for (var k = i - 2; k >= 0; k--) {
        s = s["inverse"]()["add"](cont[k]);
      }
      if (Math.abs(s["sub"](thisABS).valueOf()) < eps) {
        return s["mul"](this["s"]);
      }
    }
    return this;
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  "divisible": function(a, b) {
    parse(a, b);
    return !(!(P["n"] * this["d"]) || this["n"] * P["d"] % (P["n"] * this["d"]));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  "valueOf": function() {
    return this["s"] * this["n"] / this["d"];
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
   **/
  "toFraction": function(excludeWhole) {
    var whole, str = "";
    var n = this["n"];
    var d = this["d"];
    if (this["s"] < 0) {
      str += "-";
    }
    if (d === 1) {
      str += n;
    } else {
      if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
        str += whole;
        str += " ";
        n %= d;
      }
      str += n;
      str += "/";
      str += d;
    }
    return str;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  "toLatex": function(excludeWhole) {
    var whole, str = "";
    var n = this["n"];
    var d = this["d"];
    if (this["s"] < 0) {
      str += "-";
    }
    if (d === 1) {
      str += n;
    } else {
      if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
        str += whole;
        n %= d;
      }
      str += "\\frac{";
      str += n;
      str += "}{";
      str += d;
      str += "}";
    }
    return str;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  "toContinued": function() {
    var t;
    var a = this["n"];
    var b = this["d"];
    var res = [];
    if (isNaN(a) || isNaN(b)) {
      return res;
    }
    do {
      res.push(Math.floor(a / b));
      t = a % b;
      a = b;
      b = t;
    } while (a !== 1);
    return res;
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  "toString": function(dec) {
    var N = this["n"];
    var D2 = this["d"];
    if (isNaN(N) || isNaN(D2)) {
      return "NaN";
    }
    dec = dec || 15;
    var cycLen = cycleLen(N, D2);
    var cycOff = cycleStart(N, D2, cycLen);
    var str = this["s"] < 0 ? "-" : "";
    str += N / D2 | 0;
    N %= D2;
    N *= 10;
    if (N)
      str += ".";
    if (cycLen) {
      for (var i = cycOff; i--; ) {
        str += N / D2 | 0;
        N %= D2;
        N *= 10;
      }
      str += "(";
      for (var i = cycLen; i--; ) {
        str += N / D2 | 0;
        N %= D2;
        N *= 10;
      }
      str += ")";
    } else {
      for (var i = dec; N && i--; ) {
        str += N / D2 | 0;
        N %= D2;
        N *= 10;
      }
    }
    return str;
  }
};
var name$A = "Fraction";
var dependencies$A = [];
var createFractionClass = /* @__PURE__ */ factory(name$A, dependencies$A, () => {
  Fraction$1.prototype.type = "Fraction";
  Fraction$1.prototype.isFraction = true;
  Fraction$1.prototype.toJSON = function() {
    return {
      mathjs: "Fraction",
      n: this.s * this.n,
      d: this.d
    };
  };
  Fraction$1.fromJSON = function(json) {
    return new Fraction$1(json);
  };
  return Fraction$1;
}, {
  isClass: true
});
var name$z = "Matrix";
var dependencies$z = [];
var createMatrixClass = /* @__PURE__ */ factory(name$z, dependencies$z, () => {
  function Matrix2() {
    if (!(this instanceof Matrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
  }
  Matrix2.prototype.type = "Matrix";
  Matrix2.prototype.isMatrix = true;
  Matrix2.prototype.storage = function() {
    throw new Error("Cannot invoke storage on a Matrix interface");
  };
  Matrix2.prototype.datatype = function() {
    throw new Error("Cannot invoke datatype on a Matrix interface");
  };
  Matrix2.prototype.create = function(data, datatype) {
    throw new Error("Cannot invoke create on a Matrix interface");
  };
  Matrix2.prototype.subset = function(index, replacement, defaultValue2) {
    throw new Error("Cannot invoke subset on a Matrix interface");
  };
  Matrix2.prototype.get = function(index) {
    throw new Error("Cannot invoke get on a Matrix interface");
  };
  Matrix2.prototype.set = function(index, value, defaultValue2) {
    throw new Error("Cannot invoke set on a Matrix interface");
  };
  Matrix2.prototype.resize = function(size2, defaultValue2) {
    throw new Error("Cannot invoke resize on a Matrix interface");
  };
  Matrix2.prototype.reshape = function(size2, defaultValue2) {
    throw new Error("Cannot invoke reshape on a Matrix interface");
  };
  Matrix2.prototype.clone = function() {
    throw new Error("Cannot invoke clone on a Matrix interface");
  };
  Matrix2.prototype.size = function() {
    throw new Error("Cannot invoke size on a Matrix interface");
  };
  Matrix2.prototype.map = function(callback, skipZeros) {
    throw new Error("Cannot invoke map on a Matrix interface");
  };
  Matrix2.prototype.forEach = function(callback) {
    throw new Error("Cannot invoke forEach on a Matrix interface");
  };
  Matrix2.prototype[Symbol.iterator] = function() {
    throw new Error("Cannot iterate a Matrix interface");
  };
  Matrix2.prototype.toArray = function() {
    throw new Error("Cannot invoke toArray on a Matrix interface");
  };
  Matrix2.prototype.valueOf = function() {
    throw new Error("Cannot invoke valueOf on a Matrix interface");
  };
  Matrix2.prototype.format = function(options) {
    throw new Error("Cannot invoke format on a Matrix interface");
  };
  Matrix2.prototype.toString = function() {
    throw new Error("Cannot invoke toString on a Matrix interface");
  };
  return Matrix2;
}, {
  isClass: true
});
var name$y = "DenseMatrix";
var dependencies$y = ["Matrix"];
var createDenseMatrixClass = /* @__PURE__ */ factory(name$y, dependencies$y, (_ref) => {
  var {
    Matrix: Matrix2
  } = _ref;
  function DenseMatrix2(data, datatype) {
    if (!(this instanceof DenseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      if (data.type === "DenseMatrix") {
        this._data = clone$1(data._data);
        this._size = clone$1(data._size);
        this._datatype = datatype || data._datatype;
      } else {
        this._data = data.toArray();
        this._size = data.size();
        this._datatype = datatype || data._datatype;
      }
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      validate(this._data, this._size);
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      this._data = preprocess(data);
      this._size = arraySize(this._data);
      validate(this._data, this._size);
      this._datatype = datatype;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
    }
  }
  DenseMatrix2.prototype = new Matrix2();
  DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.type = "DenseMatrix";
  DenseMatrix2.prototype.isDenseMatrix = true;
  DenseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._data, typeOf);
  };
  DenseMatrix2.prototype.storage = function() {
    return "dense";
  };
  DenseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  DenseMatrix2.prototype.create = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.subset = function(index, replacement, defaultValue2) {
    switch (arguments.length) {
      case 1:
        return _get(this, index);
      case 2:
      case 3:
        return _set(this, index, replacement, defaultValue2);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  DenseMatrix2.prototype.get = function(index) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length !== this._size.length) {
      throw new DimensionError(index.length, this._size.length);
    }
    for (var x = 0; x < index.length; x++) {
      validateIndex(index[x], this._size[x]);
    }
    var data = this._data;
    for (var i = 0, ii = index.length; i < ii; i++) {
      var indexI = index[i];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    return data;
  };
  DenseMatrix2.prototype.set = function(index, value, defaultValue2) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length < this._size.length) {
      throw new DimensionError(index.length, this._size.length, "<");
    }
    var i, ii, indexI;
    var size2 = index.map(function(i2) {
      return i2 + 1;
    });
    _fit(this, size2, defaultValue2);
    var data = this._data;
    for (i = 0, ii = index.length - 1; i < ii; i++) {
      indexI = index[i];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    indexI = index[index.length - 1];
    validateIndex(indexI, data.length);
    data[indexI] = value;
    return this;
  };
  function _get(matrix2, index) {
    if (!isIndex(index)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = index.isScalar();
    if (isScalar) {
      return matrix2.get(index.min());
    } else {
      var size2 = index.size();
      if (size2.length !== matrix2._size.length) {
        throw new DimensionError(size2.length, matrix2._size.length);
      }
      var min2 = index.min();
      var max2 = index.max();
      for (var i = 0, ii = matrix2._size.length; i < ii; i++) {
        validateIndex(min2[i], matrix2._size[i]);
        validateIndex(max2[i], matrix2._size[i]);
      }
      return new DenseMatrix2(_getSubmatrix(matrix2._data, index, size2.length, 0), matrix2._datatype);
    }
  }
  function _getSubmatrix(data, index, dims, dim) {
    var last = dim === dims - 1;
    var range2 = index.dimension(dim);
    if (last) {
      return range2.map(function(i) {
        validateIndex(i, data.length);
        return data[i];
      }).valueOf();
    } else {
      return range2.map(function(i) {
        validateIndex(i, data.length);
        var child = data[i];
        return _getSubmatrix(child, index, dims, dim + 1);
      }).valueOf();
    }
  }
  function _set(matrix2, index, submatrix, defaultValue2) {
    if (!index || index.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index.size();
    var isScalar = index.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.valueOf();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix2.set(index.min(), submatrix, defaultValue2);
    } else {
      if (iSize.length < matrix2._size.length) {
        throw new DimensionError(iSize.length, matrix2._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i = 0;
        var outer = 0;
        while (iSize[i] === 1 && sSize[i] === 1) {
          i++;
        }
        while (iSize[i] === 1) {
          outer++;
          i++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      var size2 = index.max().map(function(i2) {
        return i2 + 1;
      });
      _fit(matrix2, size2, defaultValue2);
      var dims = iSize.length;
      var dim = 0;
      _setSubmatrix(matrix2._data, index, submatrix, dims, dim);
    }
    return matrix2;
  }
  function _setSubmatrix(data, index, submatrix, dims, dim) {
    var last = dim === dims - 1;
    var range2 = index.dimension(dim);
    if (last) {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        data[dataIndex] = submatrix[subIndex[0]];
      });
    } else {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
      });
    }
  }
  DenseMatrix2.prototype.resize = function(size2, defaultValue2, copy2) {
    if (!isCollection(size2)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size2.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    var m = copy2 ? this.clone() : this;
    return _resize2(m, sizeArray, defaultValue2);
  };
  function _resize2(matrix2, size2, defaultValue2) {
    if (size2.length === 0) {
      var v2 = matrix2._data;
      while (isArray(v2)) {
        v2 = v2[0];
      }
      return v2;
    }
    matrix2._size = size2.slice(0);
    matrix2._data = resize(matrix2._data, matrix2._size, defaultValue2);
    return matrix2;
  }
  DenseMatrix2.prototype.reshape = function(size2, copy2) {
    var m = copy2 ? this.clone() : this;
    m._data = reshape(m._data, size2);
    var currentLength = m._size.reduce((length, size3) => length * size3);
    m._size = processSizesWildcard(size2, currentLength);
    return m;
  };
  function _fit(matrix2, size2, defaultValue2) {
    var newSize = matrix2._size.slice(0);
    var changed = false;
    while (newSize.length < size2.length) {
      newSize.push(0);
      changed = true;
    }
    for (var i = 0, ii = size2.length; i < ii; i++) {
      if (size2[i] > newSize[i]) {
        newSize[i] = size2[i];
        changed = true;
      }
    }
    if (changed) {
      _resize2(matrix2, newSize, defaultValue2);
    }
  }
  DenseMatrix2.prototype.clone = function() {
    var m = new DenseMatrix2({
      data: clone$1(this._data),
      size: clone$1(this._size),
      datatype: this._datatype
    });
    return m;
  };
  DenseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  DenseMatrix2.prototype.map = function(callback) {
    var me = this;
    var recurse = function recurse2(value, index) {
      if (isArray(value)) {
        return value.map(function(child, i) {
          return recurse2(child, index.concat(i));
        });
      } else {
        return callback(value, index, me);
      }
    };
    var data = recurse(this._data, []);
    var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf) : void 0;
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.forEach = function(callback) {
    var me = this;
    var recurse = function recurse2(value, index) {
      if (isArray(value)) {
        value.forEach(function(child, i) {
          recurse2(child, index.concat(i));
        });
      } else {
        callback(value, index, me);
      }
    };
    recurse(this._data, []);
  };
  DenseMatrix2.prototype[Symbol.iterator] = function* () {
    var recurse = function* recurse2(value, index) {
      if (isArray(value)) {
        for (var i = 0; i < value.length; i++) {
          yield* recurse2(value[i], index.concat(i));
        }
      } else {
        yield {
          value,
          index
        };
      }
    };
    yield* recurse(this._data, []);
  };
  DenseMatrix2.prototype.rows = function() {
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    for (var row of data) {
      result.push(new DenseMatrix2([row], this._datatype));
    }
    return result;
  };
  DenseMatrix2.prototype.columns = function() {
    var _this = this;
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    var _loop = function _loop2(i2) {
      var col = data.map((row) => [row[i2]]);
      result.push(new DenseMatrix2(col, _this._datatype));
    };
    for (var i = 0; i < s[1]; i++) {
      _loop(i);
    }
    return result;
  };
  DenseMatrix2.prototype.toArray = function() {
    return clone$1(this._data);
  };
  DenseMatrix2.prototype.valueOf = function() {
    return this._data;
  };
  DenseMatrix2.prototype.format = function(options) {
    return format$1(this._data, options);
  };
  DenseMatrix2.prototype.toString = function() {
    return format$1(this._data);
  };
  DenseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "DenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  DenseMatrix2.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var data = [];
    for (var i = 0; i < n; i++) {
      data[i] = this._data[i + kSub][i + kSuper];
    }
    return new DenseMatrix2({
      data,
      size: [n],
      datatype: this._datatype
    });
  };
  DenseMatrix2.diagonal = function(size2, value, k, defaultValue2) {
    if (!isArray(size2)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size2.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size2 = size2.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size2[0];
    var columns = size2[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i) {
        return value[i];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i) {
        return value.get([i]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    if (!defaultValue2) {
      defaultValue2 = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
    }
    var data = [];
    if (size2.length > 0) {
      data = resize(data, size2, defaultValue2);
      for (var d = 0; d < n; d++) {
        data[d + kSub][d + kSuper] = _value(d);
      }
    }
    return new DenseMatrix2({
      data,
      size: [rows, columns]
    });
  };
  DenseMatrix2.fromJSON = function(json) {
    return new DenseMatrix2(json);
  };
  DenseMatrix2.prototype.swapRows = function(i, j) {
    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[0]);
    DenseMatrix2._swapRows(i, j, this._data);
    return this;
  };
  DenseMatrix2._swapRows = function(i, j, data) {
    var vi = data[i];
    data[i] = data[j];
    data[j] = vi;
  };
  function preprocess(data) {
    for (var i = 0, ii = data.length; i < ii; i++) {
      var elem = data[i];
      if (isArray(elem)) {
        data[i] = preprocess(elem);
      } else if (elem && elem.isMatrix === true) {
        data[i] = preprocess(elem.valueOf());
      }
    }
    return data;
  }
  return DenseMatrix2;
}, {
  isClass: true
});
function deepMap(array2, callback, skipZeros) {
  if (array2 && typeof array2.map === "function") {
    return array2.map(function(x) {
      return deepMap(x, callback);
    });
  } else {
    return callback(array2);
  }
}
var n1 = "number";
var n2 = "number, number";
function absNumber(a) {
  return Math.abs(a);
}
absNumber.signature = n1;
function addNumber(a, b) {
  return a + b;
}
addNumber.signature = n2;
function multiplyNumber(a, b) {
  return a * b;
}
multiplyNumber.signature = n2;
function unaryMinusNumber(x) {
  return -x;
}
unaryMinusNumber.signature = n1;
function nearlyEqual(x, y, epsilon) {
  if (epsilon === null || epsilon === void 0) {
    return x.eq(y);
  }
  if (x.eq(y)) {
    return true;
  }
  if (x.isNaN() || y.isNaN()) {
    return false;
  }
  if (x.isFinite() && y.isFinite()) {
    var diff = x.minus(y).abs();
    if (diff.isZero()) {
      return true;
    } else {
      var max2 = x.constructor.max(x.abs(), y.abs());
      return diff.lte(max2.times(epsilon));
    }
  }
  return false;
}
function complexEquals(x, y, epsilon) {
  return nearlyEqual$1(x.re, y.re, epsilon) && nearlyEqual$1(x.im, y.im, epsilon);
}
var name$x = "equalScalar";
var dependencies$x = ["typed", "config"];
var createEqualScalar = /* @__PURE__ */ factory(name$x, dependencies$x, (_ref) => {
  var {
    typed: typed2,
    config: config3
  } = _ref;
  return typed2(name$x, {
    "boolean, boolean": function booleanBoolean(x, y) {
      return x === y;
    },
    "number, number": function numberNumber(x, y) {
      return nearlyEqual$1(x, y, config3.epsilon);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.eq(y) || nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.equals(y);
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      return complexEquals(x, y, config3.epsilon);
    },
    "Unit, Unit": function UnitUnit(x, y) {
      if (!x.equalBase(y)) {
        throw new Error("Cannot compare units with different base");
      }
      return this(x.value, y.value);
    }
  });
});
factory(name$x, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$x, {
    "number, number": function numberNumber(x, y) {
      return nearlyEqual$1(x, y, config3.epsilon);
    }
  });
});
var name$w = "SparseMatrix";
var dependencies$w = ["typed", "equalScalar", "Matrix"];
var createSparseMatrixClass = /* @__PURE__ */ factory(name$w, dependencies$w, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2,
    Matrix: Matrix2
  } = _ref;
  function SparseMatrix2(data, datatype) {
    if (!(this instanceof SparseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      _createFromMatrix(this, data, datatype);
    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
      this._values = data.values;
      this._index = data.index;
      this._ptr = data.ptr;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      _createFromArray(this, data, datatype);
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._values = [];
      this._index = [];
      this._ptr = [0];
      this._size = [0, 0];
      this._datatype = datatype;
    }
  }
  function _createFromMatrix(matrix2, source, datatype) {
    if (source.type === "SparseMatrix") {
      matrix2._values = source._values ? clone$1(source._values) : void 0;
      matrix2._index = clone$1(source._index);
      matrix2._ptr = clone$1(source._ptr);
      matrix2._size = clone$1(source._size);
      matrix2._datatype = datatype || source._datatype;
    } else {
      _createFromArray(matrix2, source.valueOf(), datatype || source._datatype);
    }
  }
  function _createFromArray(matrix2, data, datatype) {
    matrix2._values = [];
    matrix2._index = [];
    matrix2._ptr = [];
    matrix2._datatype = datatype;
    var rows = data.length;
    var columns = 0;
    var eq = equalScalar2;
    var zero2 = 0;
    if (isString(datatype)) {
      eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
      zero2 = typed2.convert(0, datatype);
    }
    if (rows > 0) {
      var j = 0;
      do {
        matrix2._ptr.push(matrix2._index.length);
        for (var i = 0; i < rows; i++) {
          var row = data[i];
          if (isArray(row)) {
            if (j === 0 && columns < row.length) {
              columns = row.length;
            }
            if (j < row.length) {
              var v2 = row[j];
              if (!eq(v2, zero2)) {
                matrix2._values.push(v2);
                matrix2._index.push(i);
              }
            }
          } else {
            if (j === 0 && columns < 1) {
              columns = 1;
            }
            if (!eq(row, zero2)) {
              matrix2._values.push(row);
              matrix2._index.push(i);
            }
          }
        }
        j++;
      } while (j < columns);
    }
    matrix2._ptr.push(matrix2._index.length);
    matrix2._size = [rows, columns];
  }
  SparseMatrix2.prototype = new Matrix2();
  SparseMatrix2.prototype.createSparseMatrix = function(data, datatype) {
    return new SparseMatrix2(data, datatype);
  };
  SparseMatrix2.prototype.type = "SparseMatrix";
  SparseMatrix2.prototype.isSparseMatrix = true;
  SparseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._values, typeOf);
  };
  SparseMatrix2.prototype.storage = function() {
    return "sparse";
  };
  SparseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  SparseMatrix2.prototype.create = function(data, datatype) {
    return new SparseMatrix2(data, datatype);
  };
  SparseMatrix2.prototype.density = function() {
    var rows = this._size[0];
    var columns = this._size[1];
    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
  };
  SparseMatrix2.prototype.subset = function(index, replacement, defaultValue2) {
    if (!this._values) {
      throw new Error("Cannot invoke subset on a Pattern only matrix");
    }
    switch (arguments.length) {
      case 1:
        return _getsubset(this, index);
      case 2:
      case 3:
        return _setsubset(this, index, replacement, defaultValue2);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  function _getsubset(matrix2, idx) {
    if (!isIndex(idx)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = idx.isScalar();
    if (isScalar) {
      return matrix2.get(idx.min());
    }
    var size2 = idx.size();
    if (size2.length !== matrix2._size.length) {
      throw new DimensionError(size2.length, matrix2._size.length);
    }
    var i, ii, k, kk;
    var min2 = idx.min();
    var max2 = idx.max();
    for (i = 0, ii = matrix2._size.length; i < ii; i++) {
      validateIndex(min2[i], matrix2._size[i]);
      validateIndex(max2[i], matrix2._size[i]);
    }
    var mvalues = matrix2._values;
    var mindex = matrix2._index;
    var mptr = matrix2._ptr;
    var rows = idx.dimension(0);
    var columns = idx.dimension(1);
    var w = [];
    var pv = [];
    rows.forEach(function(i2, r) {
      pv[i2] = r[0];
      w[i2] = true;
    });
    var values = mvalues ? [] : void 0;
    var index = [];
    var ptr = [];
    columns.forEach(function(j) {
      ptr.push(index.length);
      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
        i = mindex[k];
        if (w[i] === true) {
          index.push(pv[i]);
          if (values) {
            values.push(mvalues[k]);
          }
        }
      }
    });
    ptr.push(index.length);
    return new SparseMatrix2({
      values,
      index,
      ptr,
      size: size2,
      datatype: matrix2._datatype
    });
  }
  function _setsubset(matrix2, index, submatrix, defaultValue2) {
    if (!index || index.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index.size();
    var isScalar = index.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.toArray();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix2.set(index.min(), submatrix, defaultValue2);
    } else {
      if (iSize.length !== 1 && iSize.length !== 2) {
        throw new DimensionError(iSize.length, matrix2._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i = 0;
        var outer = 0;
        while (iSize[i] === 1 && sSize[i] === 1) {
          i++;
        }
        while (iSize[i] === 1) {
          outer++;
          i++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      var x0 = index.min()[0];
      var y0 = index.min()[1];
      var m = sSize[0];
      var n = sSize[1];
      for (var x = 0; x < m; x++) {
        for (var y = 0; y < n; y++) {
          var v2 = submatrix[x][y];
          matrix2.set([x + x0, y + y0], v2, defaultValue2);
        }
      }
    }
    return matrix2;
  }
  SparseMatrix2.prototype.get = function(index) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length !== this._size.length) {
      throw new DimensionError(index.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke get on a Pattern only matrix");
    }
    var i = index[0];
    var j = index[1];
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[1]);
    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i) {
      return this._values[k];
    }
    return 0;
  };
  SparseMatrix2.prototype.set = function(index, v2, defaultValue2) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length !== this._size.length) {
      throw new DimensionError(index.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke set on a Pattern only matrix");
    }
    var i = index[0];
    var j = index[1];
    var rows = this._size[0];
    var columns = this._size[1];
    var eq = equalScalar2;
    var zero2 = 0;
    if (isString(this._datatype)) {
      eq = typed2.find(equalScalar2, [this._datatype, this._datatype]) || equalScalar2;
      zero2 = typed2.convert(0, this._datatype);
    }
    if (i > rows - 1 || j > columns - 1) {
      _resize2(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue2);
      rows = this._size[0];
      columns = this._size[1];
    }
    validateIndex(i, rows);
    validateIndex(j, columns);
    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i) {
      if (!eq(v2, zero2)) {
        this._values[k] = v2;
      } else {
        _remove(k, j, this._values, this._index, this._ptr);
      }
    } else {
      _insert(k, i, j, v2, this._values, this._index, this._ptr);
    }
    return this;
  };
  function _getValueIndex(i, top, bottom, index) {
    if (bottom - top === 0) {
      return bottom;
    }
    for (var r = top; r < bottom; r++) {
      if (index[r] === i) {
        return r;
      }
    }
    return top;
  }
  function _remove(k, j, values, index, ptr) {
    values.splice(k, 1);
    index.splice(k, 1);
    for (var x = j + 1; x < ptr.length; x++) {
      ptr[x]--;
    }
  }
  function _insert(k, i, j, v2, values, index, ptr) {
    values.splice(k, 0, v2);
    index.splice(k, 0, i);
    for (var x = j + 1; x < ptr.length; x++) {
      ptr[x]++;
    }
  }
  SparseMatrix2.prototype.resize = function(size2, defaultValue2, copy2) {
    if (!isCollection(size2)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size2.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    if (sizeArray.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    sizeArray.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format$1(sizeArray) + ")");
      }
    });
    var m = copy2 ? this.clone() : this;
    return _resize2(m, sizeArray[0], sizeArray[1], defaultValue2);
  };
  function _resize2(matrix2, rows, columns, defaultValue2) {
    var value = defaultValue2 || 0;
    var eq = equalScalar2;
    var zero2 = 0;
    if (isString(matrix2._datatype)) {
      eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
      zero2 = typed2.convert(0, matrix2._datatype);
      value = typed2.convert(value, matrix2._datatype);
    }
    var ins = !eq(value, zero2);
    var r = matrix2._size[0];
    var c2 = matrix2._size[1];
    var i, j, k;
    if (columns > c2) {
      for (j = c2; j < columns; j++) {
        matrix2._ptr[j] = matrix2._values.length;
        if (ins) {
          for (i = 0; i < r; i++) {
            matrix2._values.push(value);
            matrix2._index.push(i);
          }
        }
      }
      matrix2._ptr[columns] = matrix2._values.length;
    } else if (columns < c2) {
      matrix2._ptr.splice(columns + 1, c2 - columns);
      matrix2._values.splice(matrix2._ptr[columns], matrix2._values.length);
      matrix2._index.splice(matrix2._ptr[columns], matrix2._index.length);
    }
    c2 = columns;
    if (rows > r) {
      if (ins) {
        var n = 0;
        for (j = 0; j < c2; j++) {
          matrix2._ptr[j] = matrix2._ptr[j] + n;
          k = matrix2._ptr[j + 1] + n;
          var p = 0;
          for (i = r; i < rows; i++, p++) {
            matrix2._values.splice(k + p, 0, value);
            matrix2._index.splice(k + p, 0, i);
            n++;
          }
        }
        matrix2._ptr[c2] = matrix2._values.length;
      }
    } else if (rows < r) {
      var d = 0;
      for (j = 0; j < c2; j++) {
        matrix2._ptr[j] = matrix2._ptr[j] - d;
        var k0 = matrix2._ptr[j];
        var k1 = matrix2._ptr[j + 1] - d;
        for (k = k0; k < k1; k++) {
          i = matrix2._index[k];
          if (i > rows - 1) {
            matrix2._values.splice(k, 1);
            matrix2._index.splice(k, 1);
            d++;
          }
        }
      }
      matrix2._ptr[j] = matrix2._values.length;
    }
    matrix2._size[0] = rows;
    matrix2._size[1] = columns;
    return matrix2;
  }
  SparseMatrix2.prototype.reshape = function(sizes, copy2) {
    if (!isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length !== 2) {
      throw new Error("Sparse matrices can only be reshaped in two dimensions");
    }
    sizes.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
        throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format$1(sizes) + ")");
      }
    });
    var currentLength = this._size[0] * this._size[1];
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = sizes[0] * sizes[1];
    if (currentLength !== newLength) {
      throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
    }
    var m = copy2 ? this.clone() : this;
    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
      return m;
    }
    var colIndex = [];
    for (var i = 0; i < m._ptr.length; i++) {
      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
        colIndex.push(i);
      }
    }
    var values = m._values.slice();
    var rowIndex = m._index.slice();
    for (var _i = 0; _i < m._index.length; _i++) {
      var r1 = rowIndex[_i];
      var c1 = colIndex[_i];
      var flat = r1 * m._size[1] + c1;
      colIndex[_i] = flat % sizes[1];
      rowIndex[_i] = Math.floor(flat / sizes[1]);
    }
    m._values.length = 0;
    m._index.length = 0;
    m._ptr.length = sizes[1] + 1;
    m._size = sizes.slice();
    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
      m._ptr[_i2] = 0;
    }
    for (var h = 0; h < values.length; h++) {
      var _i3 = rowIndex[h];
      var _j = colIndex[h];
      var v2 = values[h];
      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
      _insert(k, _i3, _j, v2, m._values, m._index, m._ptr);
    }
    return m;
  };
  SparseMatrix2.prototype.clone = function() {
    var m = new SparseMatrix2({
      values: this._values ? clone$1(this._values) : void 0,
      index: clone$1(this._index),
      ptr: clone$1(this._ptr),
      size: clone$1(this._size),
      datatype: this._datatype
    });
    return m;
  };
  SparseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  SparseMatrix2.prototype.map = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke map on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    var invoke = function invoke2(v2, i, j) {
      return callback(v2, [i, j], me);
    };
    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
  };
  function _map(matrix2, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
    var values = [];
    var index = [];
    var ptr = [];
    var eq = equalScalar2;
    var zero2 = 0;
    if (isString(matrix2._datatype)) {
      eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
      zero2 = typed2.convert(0, matrix2._datatype);
    }
    var invoke = function invoke2(v2, x, y) {
      v2 = callback(v2, x, y);
      if (!eq(v2, zero2)) {
        values.push(v2);
        index.push(x);
      }
    };
    for (var j = minColumn; j <= maxColumn; j++) {
      ptr.push(values.length);
      var k0 = matrix2._ptr[j];
      var k1 = matrix2._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0; k < k1; k++) {
          var i = matrix2._index[k];
          if (i >= minRow && i <= maxRow) {
            invoke(matrix2._values[k], i - minRow, j - minColumn);
          }
        }
      } else {
        var _values = {};
        for (var _k = k0; _k < k1; _k++) {
          var _i4 = matrix2._index[_k];
          _values[_i4] = matrix2._values[_k];
        }
        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
          var value = _i5 in _values ? _values[_i5] : 0;
          invoke(value, _i5 - minRow, j - minColumn);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index,
      ptr,
      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
    });
  }
  SparseMatrix2.prototype.forEach = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke forEach on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0; k < k1; k++) {
          var i = this._index[k];
          callback(this._values[k], [i, j], me);
        }
      } else {
        var values = {};
        for (var _k2 = k0; _k2 < k1; _k2++) {
          var _i6 = this._index[_k2];
          values[_i6] = this._values[_k2];
        }
        for (var _i7 = 0; _i7 < rows; _i7++) {
          var value = _i7 in values ? values[_i7] : 0;
          callback(value, [_i7, j], me);
        }
      }
    }
  };
  SparseMatrix2.prototype[Symbol.iterator] = function* () {
    if (!this._values) {
      throw new Error("Cannot iterate a Pattern only matrix");
    }
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        var i = this._index[k];
        yield {
          value: this._values[k],
          index: [i, j]
        };
      }
    }
  };
  SparseMatrix2.prototype.toArray = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, true);
  };
  SparseMatrix2.prototype.valueOf = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, false);
  };
  function _toArray(values, index, ptr, size2, copy2) {
    var rows = size2[0];
    var columns = size2[1];
    var a = [];
    var i, j;
    for (i = 0; i < rows; i++) {
      a[i] = [];
      for (j = 0; j < columns; j++) {
        a[i][j] = 0;
      }
    }
    for (j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        i = index[k];
        a[i][j] = values ? copy2 ? clone$1(values[k]) : values[k] : 1;
      }
    }
    return a;
  }
  SparseMatrix2.prototype.format = function(options) {
    var rows = this._size[0];
    var columns = this._size[1];
    var density = this.density();
    var str = "Sparse Matrix [" + format$1(rows, options) + " x " + format$1(columns, options) + "] density: " + format$1(density, options) + "\n";
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        var i = this._index[k];
        str += "\n    (" + format$1(i, options) + ", " + format$1(j, options) + ") ==> " + (this._values ? format$1(this._values[k], options) : "X");
      }
    }
    return str;
  };
  SparseMatrix2.prototype.toString = function() {
    return format$1(this.toArray());
  };
  SparseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "SparseMatrix",
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  };
  SparseMatrix2.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var values = [];
    var index = [];
    var ptr = [];
    ptr[0] = 0;
    for (var j = kSuper; j < columns && values.length < n; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var x = k0; x < k1; x++) {
        var i = this._index[x];
        if (i === j - kSuper + kSub) {
          values.push(this._values[x]);
          index[values.length - 1] = i - kSub;
          break;
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index,
      ptr,
      size: [n, 1]
    });
  };
  SparseMatrix2.fromJSON = function(json) {
    return new SparseMatrix2(json);
  };
  SparseMatrix2.diagonal = function(size2, value, k, defaultValue2, datatype) {
    if (!isArray(size2)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size2.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size2 = size2.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var eq = equalScalar2;
    var zero2 = 0;
    if (isString(datatype)) {
      eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
      zero2 = typed2.convert(0, datatype);
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size2[0];
    var columns = size2[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i2) {
        return value[i2];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i2) {
        return value.get([i2]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    var values = [];
    var index = [];
    var ptr = [];
    for (var j = 0; j < columns; j++) {
      ptr.push(values.length);
      var i = j - kSuper;
      if (i >= 0 && i < n) {
        var v2 = _value(i);
        if (!eq(v2, zero2)) {
          index.push(i + kSub);
          values.push(v2);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index,
      ptr,
      size: [rows, columns]
    });
  };
  SparseMatrix2.prototype.swapRows = function(i, j) {
    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[0]);
    SparseMatrix2._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
    return this;
  };
  SparseMatrix2._forEachRow = function(j, values, index, ptr, callback) {
    var k0 = ptr[j];
    var k1 = ptr[j + 1];
    for (var k = k0; k < k1; k++) {
      callback(index[k], values[k]);
    }
  };
  SparseMatrix2._swapRows = function(x, y, columns, values, index, ptr) {
    for (var j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      var kx = _getValueIndex(x, k0, k1, index);
      var ky = _getValueIndex(y, k0, k1, index);
      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
        if (values) {
          var v2 = values[kx];
          values[kx] = values[ky];
          values[ky] = v2;
        }
        continue;
      }
      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
        var vx2 = values ? values[kx] : void 0;
        index.splice(ky, 0, y);
        if (values) {
          values.splice(ky, 0, vx2);
        }
        index.splice(ky <= kx ? kx + 1 : kx, 1);
        if (values) {
          values.splice(ky <= kx ? kx + 1 : kx, 1);
        }
        continue;
      }
      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
        var vy2 = values ? values[ky] : void 0;
        index.splice(kx, 0, x);
        if (values) {
          values.splice(kx, 0, vy2);
        }
        index.splice(kx <= ky ? ky + 1 : ky, 1);
        if (values) {
          values.splice(kx <= ky ? ky + 1 : ky, 1);
        }
      }
    }
  };
  return SparseMatrix2;
}, {
  isClass: true
});
var name$v = "number";
var dependencies$v = ["typed"];
function getNonDecimalNumberParts(input) {
  var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
  if (nonDecimalWithRadixMatch) {
    var radix = {
      "0b": 2,
      "0o": 8,
      "0x": 16
    }[nonDecimalWithRadixMatch[1]];
    var integerPart = nonDecimalWithRadixMatch[2];
    var fractionalPart = nonDecimalWithRadixMatch[3];
    return {
      input,
      radix,
      integerPart,
      fractionalPart
    };
  } else {
    return null;
  }
}
function makeNumberFromNonDecimalParts(parts) {
  var n = parseInt(parts.integerPart, parts.radix);
  var f = 0;
  for (var i = 0; i < parts.fractionalPart.length; i++) {
    var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
    f += digitValue / Math.pow(parts.radix, i + 1);
  }
  var result = n + f;
  if (isNaN(result)) {
    throw new SyntaxError('String "' + parts.input + '" is no valid number');
  }
  return result;
}
var createNumber = /* @__PURE__ */ factory(name$v, dependencies$v, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var number2 = typed2("number", {
    "": function _() {
      return 0;
    },
    number: function number3(x) {
      return x;
    },
    string: function string2(x) {
      if (x === "NaN")
        return NaN;
      var nonDecimalNumberParts = getNonDecimalNumberParts(x);
      if (nonDecimalNumberParts) {
        return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
      }
      var size2 = 0;
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        size2 = Number(wordSizeSuffixMatch[2]);
        x = wordSizeSuffixMatch[1];
      }
      var num = Number(x);
      if (isNaN(num)) {
        throw new SyntaxError('String "' + x + '" is no valid number');
      }
      if (wordSizeSuffixMatch) {
        if (num > 2 ** size2 - 1) {
          throw new SyntaxError('String "'.concat(x, '" is out of range'));
        }
        if (num >= 2 ** (size2 - 1)) {
          num = num - 2 ** size2;
        }
      }
      return num;
    },
    BigNumber: function BigNumber2(x) {
      return x.toNumber();
    },
    Fraction: function Fraction2(x) {
      return x.valueOf();
    },
    Unit: function Unit(x) {
      throw new Error("Second argument with valueless unit expected");
    },
    null: function _null(x) {
      return 0;
    },
    "Unit, string | Unit": function UnitStringUnit(unit2, valuelessUnit) {
      return unit2.toNumber(valuelessUnit);
    },
    "Array | Matrix": function ArrayMatrix(x) {
      return deepMap(x, this);
    }
  });
  number2.fromJSON = function(json) {
    return parseFloat(json.value);
  };
  return number2;
});
var name$u = "bignumber";
var dependencies$u = ["typed", "BigNumber"];
var createBignumber = /* @__PURE__ */ factory(name$u, dependencies$u, (_ref) => {
  var {
    typed: typed2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2("bignumber", {
    "": function _() {
      return new BigNumber2(0);
    },
    number: function number2(x) {
      return new BigNumber2(x + "");
    },
    string: function string2(x) {
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        var size2 = wordSizeSuffixMatch[2];
        var n = BigNumber2(wordSizeSuffixMatch[1]);
        var twoPowSize = new BigNumber2(2).pow(Number(size2));
        if (n.gt(twoPowSize.sub(1))) {
          throw new SyntaxError('String "'.concat(x, '" is out of range'));
        }
        var twoPowSizeSubOne = new BigNumber2(2).pow(Number(size2) - 1);
        if (n.gte(twoPowSizeSubOne)) {
          return n.sub(twoPowSize);
        } else {
          return n;
        }
      }
      return new BigNumber2(x);
    },
    BigNumber: function BigNumber3(x) {
      return x;
    },
    Fraction: function Fraction2(x) {
      return new BigNumber2(x.n).div(x.d).times(x.s);
    },
    null: function _null(x) {
      return new BigNumber2(0);
    },
    "Array | Matrix": function ArrayMatrix(x) {
      return deepMap(x, this);
    }
  });
});
var name$t = "fraction";
var dependencies$t = ["typed", "Fraction"];
var createFraction = /* @__PURE__ */ factory(name$t, dependencies$t, (_ref) => {
  var {
    typed: typed2,
    Fraction: Fraction2
  } = _ref;
  return typed2("fraction", {
    number: function number2(x) {
      if (!isFinite(x) || isNaN(x)) {
        throw new Error(x + " cannot be represented as a fraction");
      }
      return new Fraction2(x);
    },
    string: function string2(x) {
      return new Fraction2(x);
    },
    "number, number": function numberNumber(numerator, denominator) {
      return new Fraction2(numerator, denominator);
    },
    null: function _null(x) {
      return new Fraction2(0);
    },
    BigNumber: function BigNumber2(x) {
      return new Fraction2(x.toString());
    },
    Fraction: function Fraction3(x) {
      return x;
    },
    Object: function Object2(x) {
      return new Fraction2(x);
    },
    "Array | Matrix": function ArrayMatrix(x) {
      return deepMap(x, this);
    }
  });
});
var name$s = "matrix";
var dependencies$s = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
var createMatrix = /* @__PURE__ */ factory(name$s, dependencies$s, (_ref) => {
  var {
    typed: typed2,
    Matrix: Matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name$s, {
    "": function _() {
      return _create([]);
    },
    string: function string2(format2) {
      return _create([], format2);
    },
    "string, string": function stringString(format2, datatype) {
      return _create([], format2, datatype);
    },
    Array: function Array2(data) {
      return _create(data);
    },
    Matrix: function Matrix3(data) {
      return _create(data, data.storage());
    },
    "Array | Matrix, string": _create,
    "Array | Matrix, string, string": _create
  });
  function _create(data, format2, datatype) {
    if (format2 === "dense" || format2 === "default" || format2 === void 0) {
      return new DenseMatrix2(data, datatype);
    }
    if (format2 === "sparse") {
      return new SparseMatrix2(data, datatype);
    }
    throw new TypeError("Unknown matrix type " + JSON.stringify(format2) + ".");
  }
});
var name$r = "unaryMinus";
var dependencies$r = ["typed"];
var createUnaryMinus = /* @__PURE__ */ factory(name$r, dependencies$r, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$r, {
    number: unaryMinusNumber,
    Complex: function Complex2(x) {
      return x.neg();
    },
    BigNumber: function BigNumber2(x) {
      return x.neg();
    },
    Fraction: function Fraction2(x) {
      return x.neg();
    },
    Unit: function Unit(x) {
      var res = x.clone();
      res.value = this(x.value);
      return res;
    },
    "Array | Matrix": function ArrayMatrix(x) {
      return deepMap(x, this);
    }
    // TODO: add support for string
  });
});
var name$q = "abs";
var dependencies$q = ["typed"];
var createAbs = /* @__PURE__ */ factory(name$q, dependencies$q, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$q, {
    number: absNumber,
    Complex: function Complex2(x) {
      return x.abs();
    },
    BigNumber: function BigNumber2(x) {
      return x.abs();
    },
    Fraction: function Fraction2(x) {
      return x.abs();
    },
    "Array | Matrix": function ArrayMatrix(x) {
      return deepMap(x, this);
    },
    Unit: function Unit(x) {
      return x.abs();
    }
  });
});
var name$p = "addScalar";
var dependencies$p = ["typed"];
var createAddScalar = /* @__PURE__ */ factory(name$p, dependencies$p, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$p, {
    "number, number": addNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.add(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.plus(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.add(y);
    },
    "Unit, Unit": function UnitUnit(x, y) {
      if (x.value === null || x.value === void 0)
        throw new Error("Parameter x contains a unit with undefined value");
      if (y.value === null || y.value === void 0)
        throw new Error("Parameter y contains a unit with undefined value");
      if (!x.equalBase(y))
        throw new Error("Units do not match");
      var res = x.clone();
      res.value = this(res.value, y.value);
      res.fixPrefix = false;
      return res;
    }
  });
});
var name$o = "algorithm11";
var dependencies$o = ["typed", "equalScalar"];
var createAlgorithm11 = /* @__PURE__ */ factory(name$o, dependencies$o, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function algorithm11(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var i = aindex[k];
        var v2 = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
        if (!eq(v2, zero2)) {
          cindex.push(i);
          cvalues.push(v2);
        }
      }
    }
    cptr[columns] = cindex.length;
    return s.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$n = "algorithm14";
var dependencies$n = ["typed"];
var createAlgorithm14 = /* @__PURE__ */ factory(name$n, dependencies$n, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function algorithm14(a, b, callback, inverse) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
    return a.createDenseMatrix({
      data: cdata,
      size: clone$1(asize),
      datatype: dt
    });
  };
  function _iterate(f, level, s, n, av, bv, inverse) {
    var cv = [];
    if (level === s.length - 1) {
      for (var i = 0; i < n; i++) {
        cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
      }
    } else {
      for (var j = 0; j < n; j++) {
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
      }
    }
    return cv;
  }
});
var name$m = "algorithm01";
var dependencies$m = ["typed"];
var createAlgorithm01 = /* @__PURE__ */ factory(name$m, dependencies$m, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt = typeof adt === "string" && adt === bdt ? adt : void 0;
    var cf = dt ? typed2.find(callback, [dt, dt]) : callback;
    var i, j;
    var cdata = [];
    for (i = 0; i < rows; i++) {
      cdata[i] = [];
    }
    var x = [];
    var w = [];
    for (j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i = bindex[k];
        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        w[i] = mark;
      }
      for (i = 0; i < rows; i++) {
        if (w[i] === mark) {
          cdata[i][j] = x[i];
        } else {
          cdata[i][j] = adata[i][j];
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$l = "algorithm10";
var dependencies$l = ["typed", "DenseMatrix"];
var createAlgorithm10 = /* @__PURE__ */ factory(name$l, dependencies$l, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function algorithm10(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i = 0; i < rows; i++) {
        if (j === 0) {
          cdata[i] = [];
        }
        if (w[i] === mark) {
          cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
        } else {
          cdata[i][j] = b;
        }
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$k = "algorithm13";
var dependencies$k = ["typed"];
var createAlgorithm13 = /* @__PURE__ */ factory(name$k, dependencies$k, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function algorithm13(a, b, callback) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var csize = [];
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    for (var s = 0; s < asize.length; s++) {
      if (asize[s] !== bsize[s]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      csize[s] = asize[s];
    }
    var dt;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
    return a.createDenseMatrix({
      data: cdata,
      size: csize,
      datatype: dt
    });
  };
  function _iterate(f, level, s, n, av, bv) {
    var cv = [];
    if (level === s.length - 1) {
      for (var i = 0; i < n; i++) {
        cv[i] = f(av[i], bv[i]);
      }
    } else {
      for (var j = 0; j < n; j++) {
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
      }
    }
    return cv;
  }
});
var name$j = "algorithm03";
var dependencies$j = ["typed"];
var createAlgorithm03 = /* @__PURE__ */ factory(name$j, dependencies$j, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function algorithm03(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      zero2 = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    for (var z = 0; z < rows; z++) {
      cdata[z] = [];
    }
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        var i = bindex[k];
        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        w[i] = mark;
      }
      for (var y = 0; y < rows; y++) {
        if (w[y] === mark) {
          cdata[y][j] = x[y];
        } else {
          cdata[y][j] = inverse ? cf(zero2, adata[y][j]) : cf(adata[y][j], zero2);
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$i = "algorithm05";
var dependencies$i = ["typed", "equalScalar"];
var createAlgorithm05 = /* @__PURE__ */ factory(name$i, dependencies$i, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function algorithm05(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var xa = cvalues ? [] : void 0;
    var xb = cvalues ? [] : void 0;
    var wa = [];
    var wb = [];
    var i, j, k, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
        i = aindex[k];
        cindex.push(i);
        wa[i] = mark;
        if (xa) {
          xa[i] = avalues[k];
        }
      }
      for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
        i = bindex[k];
        if (wa[i] !== mark) {
          cindex.push(i);
        }
        wb[i] = mark;
        if (xb) {
          xb[i] = bvalues[k];
        }
      }
      if (cvalues) {
        k = cptr[j];
        while (k < cindex.length) {
          i = cindex[k];
          var wai = wa[i];
          var wbi = wb[i];
          if (wai === mark || wbi === mark) {
            var va = wai === mark ? xa[i] : zero2;
            var vb = wbi === mark ? xb[i] : zero2;
            var vc = cf(va, vb);
            if (!eq(vc, zero2)) {
              cvalues.push(vc);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$h = "algorithm12";
var dependencies$h = ["typed", "DenseMatrix"];
var createAlgorithm12 = /* @__PURE__ */ factory(name$h, dependencies$h, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function algorithm12(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i = 0; i < rows; i++) {
        if (j === 0) {
          cdata[i] = [];
        }
        if (w[i] === mark) {
          cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
        } else {
          cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
        }
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$g = "multiplyScalar";
var dependencies$g = ["typed"];
var createMultiplyScalar = /* @__PURE__ */ factory(name$g, dependencies$g, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("multiplyScalar", {
    "number, number": multiplyNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.mul(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.times(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.mul(y);
    },
    "number | Fraction | BigNumber | Complex, Unit": function numberFractionBigNumberComplexUnit(x, y) {
      var res = y.clone();
      res.value = res.value === null ? res._normalize(x) : this(res.value, x);
      return res;
    },
    "Unit, number | Fraction | BigNumber | Complex": function UnitNumberFractionBigNumberComplex(x, y) {
      var res = x.clone();
      res.value = res.value === null ? res._normalize(y) : this(res.value, y);
      return res;
    },
    "Unit, Unit": function UnitUnit(x, y) {
      return x.multiply(y);
    }
  });
});
var name$f = "multiply";
var dependencies$f = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
var createMultiply = /* @__PURE__ */ factory(name$f, dependencies$f, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    equalScalar: equalScalar2,
    dot: dot2
  } = _ref;
  var algorithm11 = createAlgorithm11({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var algorithm14 = createAlgorithm14({
    typed: typed2
  });
  function _validateMatrixDimensions(size1, size2) {
    switch (size1.length) {
      case 1:
        switch (size2.length) {
          case 1:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
            }
            break;
          case 2:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      case 2:
        switch (size2.length) {
          case 1:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
            }
            break;
          case 2:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      default:
        throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
    }
  }
  function _multiplyVectorVector(a, b, n) {
    if (n === 0) {
      throw new Error("Cannot multiply two empty vectors");
    }
    return dot2(a, b);
  }
  function _multiplyVectorMatrix(a, b) {
    if (b.storage() !== "dense") {
      throw new Error("Support for SparseMatrix not implemented");
    }
    return _multiplyVectorDenseMatrix(a, b);
  }
  function _multiplyVectorDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var alength = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c2 = [];
    for (var j = 0; j < bcolumns; j++) {
      var sum2 = mf(adata[0], bdata[0][j]);
      for (var i = 1; i < alength; i++) {
        sum2 = af(sum2, mf(adata[i], bdata[i][j]));
      }
      c2[j] = sum2;
    }
    return a.createDenseMatrix({
      data: c2,
      size: [bcolumns],
      datatype: dt
    });
  }
  var _multiplyMatrixVector = typed2("_multiplyMatrixVector", {
    "DenseMatrix, any": _multiplyDenseMatrixVector,
    "SparseMatrix, any": _multiplySparseMatrixVector
  });
  var _multiplyMatrixMatrix = typed2("_multiplyMatrixMatrix", {
    "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
    "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
    "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
    "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
  });
  function _multiplyDenseMatrixVector(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = asize[0];
    var acolumns = asize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c2 = [];
    for (var i = 0; i < arows; i++) {
      var row = adata[i];
      var sum2 = mf(row[0], bdata[0]);
      for (var j = 1; j < acolumns; j++) {
        sum2 = af(sum2, mf(row[j], bdata[j]));
      }
      c2[i] = sum2;
    }
    return a.createDenseMatrix({
      data: c2,
      size: [arows],
      datatype: dt
    });
  }
  function _multiplyDenseMatrixDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var arows = asize[0];
    var acolumns = asize[1];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c2 = [];
    for (var i = 0; i < arows; i++) {
      var row = adata[i];
      c2[i] = [];
      for (var j = 0; j < bcolumns; j++) {
        var sum2 = mf(row[0], bdata[0][j]);
        for (var x = 1; x < acolumns; x++) {
          sum2 = af(sum2, mf(row[x], bdata[x][j]));
        }
        c2[i][j] = sum2;
      }
    }
    return a.createDenseMatrix({
      data: c2,
      size: [arows, bcolumns],
      datatype: dt
    });
  }
  function _multiplyDenseMatrixSparseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (!bvalues) {
      throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
    }
    var arows = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero2 = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c2 = b.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var kb0 = bptr[jb];
      var kb1 = bptr[jb + 1];
      if (kb1 > kb0) {
        var last = 0;
        for (var i = 0; i < arows; i++) {
          var mark = i + 1;
          var cij = void 0;
          for (var kb = kb0; kb < kb1; kb++) {
            var ib = bindex[kb];
            if (last !== mark) {
              cij = mf(adata[i][ib], bvalues[kb]);
              last = mark;
            } else {
              cij = af(cij, mf(adata[i][ib], bvalues[kb]));
            }
          }
          if (last === mark && !eq(cij, zero2)) {
            cindex.push(i);
            cvalues.push(cij);
          }
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c2;
  }
  function _multiplySparseMatrixVector(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = a._size[0];
    var brows = b._size[0];
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero2 = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
    }
    var x = [];
    var w = [];
    cptr[0] = 0;
    for (var ib = 0; ib < brows; ib++) {
      var vbi = bdata[ib];
      if (!eq(vbi, zero2)) {
        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
          var ia = aindex[ka];
          if (!w[ia]) {
            w[ia] = true;
            cindex.push(ia);
            x[ia] = mf(vbi, avalues[ka]);
          } else {
            x[ia] = af(x[ia], mf(vbi, avalues[ka]));
          }
        }
      }
    }
    for (var p1 = cindex.length, p = 0; p < p1; p++) {
      var ic = cindex[p];
      cvalues[p] = x[ic];
    }
    cptr[1] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, 1],
      datatype: dt
    });
  }
  function _multiplySparseMatrixDenseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = a._size[0];
    var brows = b._size[0];
    var bcolumns = b._size[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero2 = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c2 = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    var x = [];
    var w = [];
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (var ib = 0; ib < brows; ib++) {
        var vbij = bdata[ib][jb];
        if (!eq(vbij, zero2)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            var ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(vbij, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbij, avalues[ka]));
            }
          }
        }
      }
      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x[ic];
      }
    }
    cptr[bcolumns] = cindex.length;
    return c2;
  }
  function _multiplySparseMatrixSparseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bdt = b._datatype;
    var arows = a._size[0];
    var bcolumns = b._size[1];
    var values = avalues && bvalues;
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var cvalues = values ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var c2 = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    var x = values ? [] : void 0;
    var w = [];
    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
        ib = bindex[kb];
        if (values) {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(bvalues[kb], avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
            }
          }
        } else {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
            }
          }
        }
      }
      if (values) {
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c2;
  }
  return typed2(name$f, extend$1({
    // we extend the signatures of multiplyScalar with signatures dealing with matrices
    "Array, Array": function ArrayArray(x, y) {
      _validateMatrixDimensions(arraySize(x), arraySize(y));
      var m = this(matrix2(x), matrix2(y));
      return isMatrix(m) ? m.valueOf() : m;
    },
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      var xsize = x.size();
      var ysize = y.size();
      _validateMatrixDimensions(xsize, ysize);
      if (xsize.length === 1) {
        if (ysize.length === 1) {
          return _multiplyVectorVector(x, y, xsize[0]);
        }
        return _multiplyVectorMatrix(x, y);
      }
      if (ysize.length === 1) {
        return _multiplyMatrixVector(x, y);
      }
      return _multiplyMatrixMatrix(x, y);
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return this(x, matrix2(y));
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return this(matrix2(x, y.storage()), y);
    },
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return algorithm11(x, y, multiplyScalar2, false);
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return algorithm14(x, y, multiplyScalar2, false);
    },
    "any, SparseMatrix": function anySparseMatrix(x, y) {
      return algorithm11(y, x, multiplyScalar2, true);
    },
    "any, DenseMatrix": function anyDenseMatrix(x, y) {
      return algorithm14(y, x, multiplyScalar2, true);
    },
    "Array, any": function ArrayAny(x, y) {
      return algorithm14(matrix2(x), y, multiplyScalar2, false).valueOf();
    },
    "any, Array": function anyArray(x, y) {
      return algorithm14(matrix2(y), x, multiplyScalar2, true).valueOf();
    },
    "any, any": multiplyScalar2,
    "any, any, ...any": function anyAnyAny(x, y, rest) {
      var result = this(x, y);
      for (var i = 0; i < rest.length; i++) {
        result = this(result, rest[i]);
      }
      return result;
    }
  }, multiplyScalar2.signatures));
});
var name$e = "subtract";
var dependencies$e = ["typed", "matrix", "equalScalar", "addScalar", "unaryMinus", "DenseMatrix"];
var createSubtract = /* @__PURE__ */ factory(name$e, dependencies$e, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    addScalar: addScalar2,
    unaryMinus: unaryMinus2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var algorithm01 = createAlgorithm01({
    typed: typed2
  });
  var algorithm03 = createAlgorithm03({
    typed: typed2
  });
  var algorithm05 = createAlgorithm05({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var algorithm10 = createAlgorithm10({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var algorithm13 = createAlgorithm13({
    typed: typed2
  });
  var algorithm14 = createAlgorithm14({
    typed: typed2
  });
  return typed2(name$e, {
    "number, number": function numberNumber(x, y) {
      return x - y;
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.sub(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.minus(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.sub(y);
    },
    "Unit, Unit": function UnitUnit(x, y) {
      if (x.value === null) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y)) {
        throw new Error("Units do not match");
      }
      var res = x.clone();
      res.value = this(res.value, y.value);
      res.fixPrefix = false;
      return res;
    },
    "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
      checkEqualDimensions(x, y);
      return algorithm05(x, y, this);
    },
    "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
      checkEqualDimensions(x, y);
      return algorithm03(y, x, this, true);
    },
    "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
      checkEqualDimensions(x, y);
      return algorithm01(x, y, this, false);
    },
    "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
      checkEqualDimensions(x, y);
      return algorithm13(x, y, this);
    },
    "Array, Array": function ArrayArray(x, y) {
      return this(matrix2(x), matrix2(y)).valueOf();
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return this(matrix2(x), y);
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return this(x, matrix2(y));
    },
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return algorithm10(x, unaryMinus2(y), addScalar2);
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return algorithm14(x, y, this);
    },
    "any, SparseMatrix": function anySparseMatrix(x, y) {
      return algorithm10(y, x, this, true);
    },
    "any, DenseMatrix": function anyDenseMatrix(x, y) {
      return algorithm14(y, x, this, true);
    },
    "Array, any": function ArrayAny(x, y) {
      return algorithm14(matrix2(x), y, this, false).valueOf();
    },
    "any, Array": function anyArray(x, y) {
      return algorithm14(matrix2(y), x, this, true).valueOf();
    }
  });
});
function checkEqualDimensions(x, y) {
  var xsize = x.size();
  var ysize = y.size();
  if (xsize.length !== ysize.length) {
    throw new DimensionError(xsize.length, ysize.length);
  }
}
var name$d = "algorithm07";
var dependencies$d = ["typed", "DenseMatrix"];
var createAlgorithm07 = /* @__PURE__ */ factory(name$d, dependencies$d, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function algorithm07(a, b, callback) {
    var asize = a._size;
    var adt = a._datatype;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      zero2 = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var i, j;
    var cdata = [];
    for (i = 0; i < rows; i++) {
      cdata[i] = [];
    }
    var xa = [];
    var xb = [];
    var wa = [];
    var wb = [];
    for (j = 0; j < columns; j++) {
      var mark = j + 1;
      _scatter(a, j, wa, xa, mark);
      _scatter(b, j, wb, xb, mark);
      for (i = 0; i < rows; i++) {
        var va = wa[i] === mark ? xa[i] : zero2;
        var vb = wb[i] === mark ? xb[i] : zero2;
        cdata[i][j] = cf(va, vb);
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
  function _scatter(m, j, w, x, mark) {
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
      var i = index[k];
      w[i] = mark;
      x[i] = values[k];
    }
  }
});
var name$c = "conj";
var dependencies$c = ["typed"];
var createConj = /* @__PURE__ */ factory(name$c, dependencies$c, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$c, {
    number: function number2(x) {
      return x;
    },
    BigNumber: function BigNumber2(x) {
      return x;
    },
    Complex: function Complex2(x) {
      return x.conjugate();
    },
    "Array | Matrix": function ArrayMatrix(x) {
      return deepMap(x, this);
    }
  });
});
var name$b = "identity";
var dependencies$b = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
var createIdentity = /* @__PURE__ */ factory(name$b, dependencies$b, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name$b, {
    "": function _() {
      return config3.matrix === "Matrix" ? matrix2([]) : [];
    },
    string: function string2(format2) {
      return matrix2(format2);
    },
    "number | BigNumber": function numberBigNumber(rows) {
      return _identity(rows, rows, config3.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, string": function numberBigNumberString(rows, format2) {
      return _identity(rows, rows, format2);
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
      return _identity(rows, cols, config3.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format2) {
      return _identity(rows, cols, format2);
    },
    Array: function Array2(size2) {
      return _identityVector(size2);
    },
    "Array, string": function ArrayString(size2, format2) {
      return _identityVector(size2, format2);
    },
    Matrix: function Matrix2(size2) {
      return _identityVector(size2.valueOf(), size2.storage());
    },
    "Matrix, string": function MatrixString(size2, format2) {
      return _identityVector(size2.valueOf(), format2);
    }
  });
  function _identityVector(size2, format2) {
    switch (size2.length) {
      case 0:
        return format2 ? matrix2(format2) : [];
      case 1:
        return _identity(size2[0], size2[0], format2);
      case 2:
        return _identity(size2[0], size2[1], format2);
      default:
        throw new Error("Vector containing two values expected");
    }
  }
  function _identity(rows, cols, format2) {
    var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber2 : null;
    if (isBigNumber(rows))
      rows = rows.toNumber();
    if (isBigNumber(cols))
      cols = cols.toNumber();
    if (!isInteger(rows) || rows < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    if (!isInteger(cols) || cols < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    var one2 = Big ? new BigNumber2(1) : 1;
    var defaultValue2 = Big ? new Big(0) : 0;
    var size2 = [rows, cols];
    if (format2) {
      if (format2 === "sparse") {
        return SparseMatrix2.diagonal(size2, one2, 0, defaultValue2);
      }
      if (format2 === "dense") {
        return DenseMatrix2.diagonal(size2, one2, 0, defaultValue2);
      }
      throw new TypeError('Unknown matrix type "'.concat(format2, '"'));
    }
    var res = resize([], size2, defaultValue2);
    var minimum = rows < cols ? rows : cols;
    for (var d = 0; d < minimum; d++) {
      res[d][d] = one2;
    }
    return res;
  }
});
function noBignumber() {
  throw new Error('No "bignumber" implementation available');
}
function noFraction() {
  throw new Error('No "fraction" implementation available');
}
function noMatrix() {
  throw new Error('No "matrix" implementation available');
}
var name$a = "size";
var dependencies$a = ["typed", "config", "?matrix"];
var createSize = /* @__PURE__ */ factory(name$a, dependencies$a, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2
  } = _ref;
  return typed2(name$a, {
    Matrix: function Matrix2(x) {
      return x.create(x.size());
    },
    Array: arraySize,
    string: function string2(x) {
      return config3.matrix === "Array" ? [x.length] : matrix2([x.length]);
    },
    "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x) {
      return config3.matrix === "Array" ? [] : matrix2 ? matrix2([]) : noMatrix();
    }
  });
});
var name$9 = "numeric";
var dependencies$9 = ["number", "?bignumber", "?fraction"];
var createNumeric = /* @__PURE__ */ factory(name$9, dependencies$9, (_ref) => {
  var {
    number: _number,
    bignumber: bignumber2,
    fraction: fraction2
  } = _ref;
  var validInputTypes = {
    string: true,
    number: true,
    BigNumber: true,
    Fraction: true
  };
  var validOutputTypes = {
    number: (x) => _number(x),
    BigNumber: bignumber2 ? (x) => bignumber2(x) : noBignumber,
    Fraction: fraction2 ? (x) => fraction2(x) : noFraction
  };
  return function numeric2(value, outputType) {
    var inputType = typeOf(value);
    if (!(inputType in validInputTypes)) {
      throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
    }
    if (!(outputType in validOutputTypes)) {
      throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
    }
    if (outputType === inputType) {
      return value;
    } else {
      return validOutputTypes[outputType](value);
    }
  };
});
var name$8 = "divideScalar";
var dependencies$8 = ["typed", "numeric"];
var createDivideScalar = /* @__PURE__ */ factory(name$8, dependencies$8, (_ref) => {
  var {
    typed: typed2,
    numeric: numeric2
  } = _ref;
  return typed2(name$8, {
    "number, number": function numberNumber(x, y) {
      return x / y;
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.div(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.div(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.div(y);
    },
    "Unit, number | Fraction | BigNumber": function UnitNumberFractionBigNumber(x, y) {
      var res = x.clone();
      var one2 = numeric2(1, typeOf(y));
      res.value = this(res.value === null ? res._normalize(one2) : res.value, y);
      return res;
    },
    "number | Fraction | BigNumber, Unit": function numberFractionBigNumberUnit(x, y) {
      var res = y.clone();
      res = res.pow(-1);
      var one2 = numeric2(1, typeOf(x));
      res.value = this(x, y.value === null ? y._normalize(one2) : y.value);
      return res;
    },
    "Unit, Unit": function UnitUnit(x, y) {
      return x.divide(y);
    }
  });
});
var name$7 = "smaller";
var dependencies$7 = ["typed", "config", "matrix", "DenseMatrix"];
var createSmaller = /* @__PURE__ */ factory(name$7, dependencies$7, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var algorithm03 = createAlgorithm03({
    typed: typed2
  });
  var algorithm07 = createAlgorithm07({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var algorithm12 = createAlgorithm12({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var algorithm13 = createAlgorithm13({
    typed: typed2
  });
  var algorithm14 = createAlgorithm14({
    typed: typed2
  });
  return typed2(name$7, {
    "boolean, boolean": function booleanBoolean(x, y) {
      return x < y;
    },
    "number, number": function numberNumber(x, y) {
      return x < y && !nearlyEqual$1(x, y, config3.epsilon);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.lt(y) && !nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.compare(y) === -1;
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      throw new TypeError("No ordering relation is defined for complex numbers");
    },
    "Unit, Unit": function UnitUnit(x, y) {
      if (!x.equalBase(y)) {
        throw new Error("Cannot compare units with different base");
      }
      return this(x.value, y.value);
    },
    "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
      return algorithm07(x, y, this);
    },
    "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
      return algorithm03(y, x, this, true);
    },
    "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
      return algorithm03(x, y, this, false);
    },
    "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
      return algorithm13(x, y, this);
    },
    "Array, Array": function ArrayArray(x, y) {
      return this(matrix2(x), matrix2(y)).valueOf();
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return this(matrix2(x), y);
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return this(x, matrix2(y));
    },
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return algorithm12(x, y, this, false);
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return algorithm14(x, y, this, false);
    },
    "any, SparseMatrix": function anySparseMatrix(x, y) {
      return algorithm12(y, x, this, true);
    },
    "any, DenseMatrix": function anyDenseMatrix(x, y) {
      return algorithm14(y, x, this, true);
    },
    "Array, any": function ArrayAny(x, y) {
      return algorithm14(matrix2(x), y, this, false).valueOf();
    },
    "any, Array": function anyArray(x, y) {
      return algorithm14(matrix2(y), x, this, true).valueOf();
    }
  });
});
var name$6 = "larger";
var dependencies$6 = ["typed", "config", "matrix", "DenseMatrix"];
var createLarger = /* @__PURE__ */ factory(name$6, dependencies$6, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var algorithm03 = createAlgorithm03({
    typed: typed2
  });
  var algorithm07 = createAlgorithm07({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var algorithm12 = createAlgorithm12({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var algorithm13 = createAlgorithm13({
    typed: typed2
  });
  var algorithm14 = createAlgorithm14({
    typed: typed2
  });
  return typed2(name$6, {
    "boolean, boolean": function booleanBoolean(x, y) {
      return x > y;
    },
    "number, number": function numberNumber(x, y) {
      return x > y && !nearlyEqual$1(x, y, config3.epsilon);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.gt(y) && !nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.compare(y) === 1;
    },
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    },
    "Unit, Unit": function UnitUnit(x, y) {
      if (!x.equalBase(y)) {
        throw new Error("Cannot compare units with different base");
      }
      return this(x.value, y.value);
    },
    "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
      return algorithm07(x, y, this);
    },
    "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
      return algorithm03(y, x, this, true);
    },
    "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
      return algorithm03(x, y, this, false);
    },
    "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
      return algorithm13(x, y, this);
    },
    "Array, Array": function ArrayArray(x, y) {
      return this(matrix2(x), matrix2(y)).valueOf();
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return this(matrix2(x), y);
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return this(x, matrix2(y));
    },
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return algorithm12(x, y, this, false);
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return algorithm14(x, y, this, false);
    },
    "any, SparseMatrix": function anySparseMatrix(x, y) {
      return algorithm12(y, x, this, true);
    },
    "any, DenseMatrix": function anyDenseMatrix(x, y) {
      return algorithm14(y, x, this, true);
    },
    "Array, any": function ArrayAny(x, y) {
      return algorithm14(matrix2(x), y, this, false).valueOf();
    },
    "any, Array": function anyArray(x, y) {
      return algorithm14(matrix2(y), x, this, true).valueOf();
    }
  });
});
var name$5 = "FibonacciHeap";
var dependencies$5 = ["smaller", "larger"];
var createFibonacciHeapClass = /* @__PURE__ */ factory(name$5, dependencies$5, (_ref) => {
  var {
    smaller: smaller2,
    larger: larger2
  } = _ref;
  var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
  function FibonacciHeap2() {
    if (!(this instanceof FibonacciHeap2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._minimum = null;
    this._size = 0;
  }
  FibonacciHeap2.prototype.type = "FibonacciHeap";
  FibonacciHeap2.prototype.isFibonacciHeap = true;
  FibonacciHeap2.prototype.insert = function(key, value) {
    var node = {
      key,
      value,
      degree: 0
    };
    if (this._minimum) {
      var minimum = this._minimum;
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      if (smaller2(key, minimum.key)) {
        this._minimum = node;
      }
    } else {
      node.left = node;
      node.right = node;
      this._minimum = node;
    }
    this._size++;
    return node;
  };
  FibonacciHeap2.prototype.size = function() {
    return this._size;
  };
  FibonacciHeap2.prototype.clear = function() {
    this._minimum = null;
    this._size = 0;
  };
  FibonacciHeap2.prototype.isEmpty = function() {
    return this._size === 0;
  };
  FibonacciHeap2.prototype.extractMinimum = function() {
    var node = this._minimum;
    if (node === null) {
      return node;
    }
    var minimum = this._minimum;
    var numberOfChildren = node.degree;
    var x = node.child;
    while (numberOfChildren > 0) {
      var tempRight = x.right;
      x.left.right = x.right;
      x.right.left = x.left;
      x.left = minimum;
      x.right = minimum.right;
      minimum.right = x;
      x.right.left = x;
      x.parent = null;
      x = tempRight;
      numberOfChildren--;
    }
    node.left.right = node.right;
    node.right.left = node.left;
    if (node === node.right) {
      minimum = null;
    } else {
      minimum = node.right;
      minimum = _findMinimumNode(minimum, this._size);
    }
    this._size--;
    this._minimum = minimum;
    return node;
  };
  FibonacciHeap2.prototype.remove = function(node) {
    this._minimum = _decreaseKey(this._minimum, node, -1);
    this.extractMinimum();
  };
  function _decreaseKey(minimum, node, key) {
    node.key = key;
    var parent = node.parent;
    if (parent && smaller2(node.key, parent.key)) {
      _cut(minimum, node, parent);
      _cascadingCut(minimum, parent);
    }
    if (smaller2(node.key, minimum.key)) {
      minimum = node;
    }
    return minimum;
  }
  function _cut(minimum, node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    parent.degree--;
    if (parent.child === node) {
      parent.child = node.right;
    }
    if (parent.degree === 0) {
      parent.child = null;
    }
    node.left = minimum;
    node.right = minimum.right;
    minimum.right = node;
    node.right.left = node;
    node.parent = null;
    node.mark = false;
  }
  function _cascadingCut(minimum, node) {
    var parent = node.parent;
    if (!parent) {
      return;
    }
    if (!node.mark) {
      node.mark = true;
    } else {
      _cut(minimum, node, parent);
      _cascadingCut(parent);
    }
  }
  var _linkNodes = function _linkNodes2(node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    node.parent = parent;
    if (!parent.child) {
      parent.child = node;
      node.right = node;
      node.left = node;
    } else {
      node.left = parent.child;
      node.right = parent.child.right;
      parent.child.right = node;
      node.right.left = node;
    }
    parent.degree++;
    node.mark = false;
  };
  function _findMinimumNode(minimum, size2) {
    var arraySize2 = Math.floor(Math.log(size2) * oneOverLogPhi) + 1;
    var array2 = new Array(arraySize2);
    var numRoots = 0;
    var x = minimum;
    if (x) {
      numRoots++;
      x = x.right;
      while (x !== minimum) {
        numRoots++;
        x = x.right;
      }
    }
    var y;
    while (numRoots > 0) {
      var d = x.degree;
      var next = x.right;
      while (true) {
        y = array2[d];
        if (!y) {
          break;
        }
        if (larger2(x.key, y.key)) {
          var temp2 = y;
          y = x;
          x = temp2;
        }
        _linkNodes(y, x);
        array2[d] = null;
        d++;
      }
      array2[d] = x;
      x = next;
      numRoots--;
    }
    minimum = null;
    for (var i = 0; i < arraySize2; i++) {
      y = array2[i];
      if (!y) {
        continue;
      }
      if (minimum) {
        y.left.right = y.right;
        y.right.left = y.left;
        y.left = minimum;
        y.right = minimum.right;
        minimum.right = y;
        y.right.left = y;
        if (smaller2(y.key, minimum.key)) {
          minimum = y;
        }
      } else {
        minimum = y;
      }
    }
    return minimum;
  }
  return FibonacciHeap2;
}, {
  isClass: true
});
var name$4 = "Spa";
var dependencies$4 = ["addScalar", "equalScalar", "FibonacciHeap"];
var createSpaClass = /* @__PURE__ */ factory(name$4, dependencies$4, (_ref) => {
  var {
    addScalar: addScalar2,
    equalScalar: equalScalar2,
    FibonacciHeap: FibonacciHeap2
  } = _ref;
  function Spa2() {
    if (!(this instanceof Spa2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._values = [];
    this._heap = new FibonacciHeap2();
  }
  Spa2.prototype.type = "Spa";
  Spa2.prototype.isSpa = true;
  Spa2.prototype.set = function(i, v2) {
    if (!this._values[i]) {
      var node = this._heap.insert(i, v2);
      this._values[i] = node;
    } else {
      this._values[i].value = v2;
    }
  };
  Spa2.prototype.get = function(i) {
    var node = this._values[i];
    if (node) {
      return node.value;
    }
    return 0;
  };
  Spa2.prototype.accumulate = function(i, v2) {
    var node = this._values[i];
    if (!node) {
      node = this._heap.insert(i, v2);
      this._values[i] = node;
    } else {
      node.value = addScalar2(node.value, v2);
    }
  };
  Spa2.prototype.forEach = function(from, to, callback) {
    var heap = this._heap;
    var values = this._values;
    var nodes = [];
    var node = heap.extractMinimum();
    if (node) {
      nodes.push(node);
    }
    while (node && node.key <= to) {
      if (node.key >= from) {
        if (!equalScalar2(node.value, 0)) {
          callback(node.key, node.value, this);
        }
      }
      node = heap.extractMinimum();
      if (node) {
        nodes.push(node);
      }
    }
    for (var i = 0; i < nodes.length; i++) {
      var n = nodes[i];
      node = heap.insert(n.key, n.value);
      values[node.key] = node;
    }
  };
  Spa2.prototype.swap = function(i, j) {
    var nodei = this._values[i];
    var nodej = this._values[j];
    if (!nodei && nodej) {
      nodei = this._heap.insert(i, nodej.value);
      this._heap.remove(nodej);
      this._values[i] = nodei;
      this._values[j] = void 0;
    } else if (nodei && !nodej) {
      nodej = this._heap.insert(j, nodei.value);
      this._heap.remove(nodei);
      this._values[j] = nodej;
      this._values[i] = void 0;
    } else if (nodei && nodej) {
      var v2 = nodei.value;
      nodei.value = nodej.value;
      nodej.value = v2;
    }
  };
  return Spa2;
}, {
  isClass: true
});
var name$3 = "dot";
var dependencies$3 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
var createDot = /* @__PURE__ */ factory(name$3, dependencies$3, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    conj: conj2,
    size: size2
  } = _ref;
  return typed2(name$3, {
    "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
    "SparseMatrix, SparseMatrix": _sparseDot
  });
  function _validateDim(x, y) {
    var xSize = _size(x);
    var ySize = _size(y);
    var xLen, yLen;
    if (xSize.length === 1) {
      xLen = xSize[0];
    } else if (xSize.length === 2 && xSize[1] === 1) {
      xLen = xSize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
    }
    if (ySize.length === 1) {
      yLen = ySize[0];
    } else if (ySize.length === 2 && ySize[1] === 1) {
      yLen = ySize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
    }
    if (xLen !== yLen)
      throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
    if (xLen === 0)
      throw new RangeError("Cannot calculate the dot product of empty vectors");
    return xLen;
  }
  function _denseDot(a, b) {
    var N = _validateDim(a, b);
    var adata = isMatrix(a) ? a._data : a;
    var adt = isMatrix(a) ? a._datatype : void 0;
    var bdata = isMatrix(b) ? b._data : b;
    var bdt = isMatrix(b) ? b._datatype : void 0;
    var aIsColumn = _size(a).length === 2;
    var bIsColumn = _size(b).length === 2;
    var add3 = addScalar2;
    var mul2 = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      var dt = adt;
      add3 = typed2.find(addScalar2, [dt, dt]);
      mul2 = typed2.find(multiplyScalar2, [dt, dt]);
    }
    if (!aIsColumn && !bIsColumn) {
      var c2 = mul2(conj2(adata[0]), bdata[0]);
      for (var i = 1; i < N; i++) {
        c2 = add3(c2, mul2(conj2(adata[i]), bdata[i]));
      }
      return c2;
    }
    if (!aIsColumn && bIsColumn) {
      var _c2 = mul2(conj2(adata[0]), bdata[0][0]);
      for (var _i = 1; _i < N; _i++) {
        _c2 = add3(_c2, mul2(conj2(adata[_i]), bdata[_i][0]));
      }
      return _c2;
    }
    if (aIsColumn && !bIsColumn) {
      var _c22 = mul2(conj2(adata[0][0]), bdata[0]);
      for (var _i2 = 1; _i2 < N; _i2++) {
        _c22 = add3(_c22, mul2(conj2(adata[_i2][0]), bdata[_i2]));
      }
      return _c22;
    }
    if (aIsColumn && bIsColumn) {
      var _c3 = mul2(conj2(adata[0][0]), bdata[0][0]);
      for (var _i3 = 1; _i3 < N; _i3++) {
        _c3 = add3(_c3, mul2(conj2(adata[_i3][0]), bdata[_i3][0]));
      }
      return _c3;
    }
  }
  function _sparseDot(x, y) {
    _validateDim(x, y);
    var xindex = x._index;
    var xvalues = x._values;
    var yindex = y._index;
    var yvalues = y._values;
    var c2 = 0;
    var add3 = addScalar2;
    var mul2 = multiplyScalar2;
    var i = 0;
    var j = 0;
    while (i < xindex.length && j < yindex.length) {
      var I = xindex[i];
      var J = yindex[j];
      if (I < J) {
        i++;
        continue;
      }
      if (I > J) {
        j++;
        continue;
      }
      if (I === J) {
        c2 = add3(c2, mul2(xvalues[i], yvalues[j]));
        i++;
        j++;
      }
    }
    return c2;
  }
  function _size(x) {
    return isMatrix(x) ? x.size() : size2(x);
  }
});
var name$2 = "lup";
var dependencies$2 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtract", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
var createLup = /* @__PURE__ */ factory(name$2, dependencies$2, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    abs: abs2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    larger: larger2,
    equalScalar: equalScalar2,
    unaryMinus: unaryMinus2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    Spa: Spa2
  } = _ref;
  return typed2(name$2, {
    DenseMatrix: function DenseMatrix3(m) {
      return _denseLUP(m);
    },
    SparseMatrix: function SparseMatrix3(m) {
      return _sparseLUP(m);
    },
    Array: function Array2(a) {
      var m = matrix2(a);
      var r = _denseLUP(m);
      return {
        L: r.L.valueOf(),
        U: r.U.valueOf(),
        p: r.p
      };
    }
  });
  function _denseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var data = clone$1(m._data);
    var ldata = [];
    var lsize = [rows, n];
    var udata = [];
    var usize = [n, columns];
    var i, j, k;
    var p = [];
    for (i = 0; i < rows; i++) {
      p[i] = i;
    }
    for (j = 0; j < columns; j++) {
      if (j > 0) {
        for (i = 0; i < rows; i++) {
          var min2 = Math.min(i, j);
          var s = 0;
          for (k = 0; k < min2; k++) {
            s = addScalar2(s, multiplyScalar2(data[i][k], data[k][j]));
          }
          data[i][j] = subtract2(data[i][j], s);
        }
      }
      var pi = j;
      var pabsv = 0;
      var vjj = 0;
      for (i = j; i < rows; i++) {
        var v2 = data[i][j];
        var absv = abs2(v2);
        if (larger2(absv, pabsv)) {
          pi = i;
          pabsv = absv;
          vjj = v2;
        }
      }
      if (j !== pi) {
        p[j] = [p[pi], p[pi] = p[j]][0];
        DenseMatrix2._swapRows(j, pi, data);
      }
      if (j < rows) {
        for (i = j + 1; i < rows; i++) {
          var vij = data[i][j];
          if (!equalScalar2(vij, 0)) {
            data[i][j] = divideScalar2(data[i][j], vjj);
          }
        }
      }
    }
    for (j = 0; j < columns; j++) {
      for (i = 0; i < rows; i++) {
        if (j === 0) {
          if (i < columns) {
            udata[i] = [];
          }
          ldata[i] = [];
        }
        if (i < j) {
          if (i < columns) {
            udata[i][j] = data[i][j];
          }
          if (j < rows) {
            ldata[i][j] = 0;
          }
          continue;
        }
        if (i === j) {
          if (i < columns) {
            udata[i][j] = data[i][j];
          }
          if (j < rows) {
            ldata[i][j] = 1;
          }
          continue;
        }
        if (i < columns) {
          udata[i][j] = 0;
        }
        if (j < rows) {
          ldata[i][j] = data[i][j];
        }
      }
    }
    var l = new DenseMatrix2({
      data: ldata,
      size: lsize
    });
    var u = new DenseMatrix2({
      data: udata,
      size: usize
    });
    var pv = [];
    for (i = 0, n = p.length; i < n; i++) {
      pv[p[i]] = i;
    }
    return {
      L: l,
      U: u,
      p: pv,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
  function _sparseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var lsize = [rows, n];
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var usize = [n, columns];
    var i, j, k;
    var pvCo = [];
    var pvOc = [];
    for (i = 0; i < rows; i++) {
      pvCo[i] = i;
      pvOc[i] = i;
    }
    var swapIndeces = function swapIndeces2(x, y) {
      var kx = pvOc[x];
      var ky = pvOc[y];
      pvCo[kx] = y;
      pvCo[ky] = x;
      pvOc[x] = ky;
      pvOc[y] = kx;
    };
    var _loop = function _loop2() {
      var spa = new Spa2();
      if (j < rows) {
        lptr.push(lvalues.length);
        lvalues.push(1);
        lindex.push(j);
      }
      uptr.push(uvalues.length);
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (k = k0; k < k1; k++) {
        i = index[k];
        spa.set(pvCo[i], values[k]);
      }
      if (j > 0) {
        spa.forEach(0, j - 1, function(k2, vkj) {
          SparseMatrix2._forEachRow(k2, lvalues, lindex, lptr, function(i2, vik) {
            if (i2 > k2) {
              spa.accumulate(i2, unaryMinus2(multiplyScalar2(vik, vkj)));
            }
          });
        });
      }
      var pi = j;
      var vjj = spa.get(j);
      var pabsv = abs2(vjj);
      spa.forEach(j + 1, rows - 1, function(x, v2) {
        var absv = abs2(v2);
        if (larger2(absv, pabsv)) {
          pi = x;
          pabsv = absv;
          vjj = v2;
        }
      });
      if (j !== pi) {
        SparseMatrix2._swapRows(j, pi, lsize[1], lvalues, lindex, lptr);
        SparseMatrix2._swapRows(j, pi, usize[1], uvalues, uindex, uptr);
        spa.swap(j, pi);
        swapIndeces(j, pi);
      }
      spa.forEach(0, rows - 1, function(x, v2) {
        if (x <= j) {
          uvalues.push(v2);
          uindex.push(x);
        } else {
          v2 = divideScalar2(v2, vjj);
          if (!equalScalar2(v2, 0)) {
            lvalues.push(v2);
            lindex.push(x);
          }
        }
      });
    };
    for (j = 0; j < columns; j++) {
      _loop();
    }
    uptr.push(uvalues.length);
    lptr.push(lvalues.length);
    return {
      L: new SparseMatrix2({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: lsize
      }),
      U: new SparseMatrix2({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: usize
      }),
      p: pvCo,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
});
var name$1 = "det";
var dependencies$1 = ["typed", "matrix", "subtract", "multiply", "unaryMinus", "lup"];
var createDet = /* @__PURE__ */ factory(name$1, dependencies$1, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    multiply: multiply2,
    unaryMinus: unaryMinus2,
    lup: lup2
  } = _ref;
  return typed2(name$1, {
    any: function any2(x) {
      return clone$1(x);
    },
    "Array | Matrix": function det2(x) {
      var size2;
      if (isMatrix(x)) {
        size2 = x.size();
      } else if (Array.isArray(x)) {
        x = matrix2(x);
        size2 = x.size();
      } else {
        size2 = [];
      }
      switch (size2.length) {
        case 0:
          return clone$1(x);
        case 1:
          if (size2[0] === 1) {
            return clone$1(x.valueOf()[0]);
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            return _det(x.clone().valueOf(), rows);
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format$1(size2) + ")");
      }
    }
  });
  function _det(matrix3, rows, cols) {
    if (rows === 1) {
      return clone$1(matrix3[0][0]);
    } else if (rows === 2) {
      return subtract2(multiply2(matrix3[0][0], matrix3[1][1]), multiply2(matrix3[1][0], matrix3[0][1]));
    } else {
      var decomp = lup2(matrix3);
      var det2 = decomp.U[0][0];
      for (var _i = 1; _i < rows; _i++) {
        det2 = multiply2(det2, decomp.U[_i][_i]);
      }
      var evenCycles = 0;
      var i = 0;
      var visited = [];
      while (true) {
        while (visited[i]) {
          i++;
        }
        if (i >= rows)
          break;
        var j = i;
        var cycleLen2 = 0;
        while (!visited[decomp.p[j]]) {
          visited[decomp.p[j]] = true;
          j = decomp.p[j];
          cycleLen2++;
        }
        if (cycleLen2 % 2 === 0) {
          evenCycles++;
        }
      }
      return evenCycles % 2 === 0 ? det2 : unaryMinus2(det2);
    }
  }
});
var name = "inv";
var dependencies = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
var createInv = /* @__PURE__ */ factory(name, dependencies, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    addScalar: addScalar2,
    multiply: multiply2,
    unaryMinus: unaryMinus2,
    det: det2,
    identity: identity2,
    abs: abs2
  } = _ref;
  return typed2(name, {
    "Array | Matrix": function ArrayMatrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (size2[0] === 1) {
            if (isMatrix(x)) {
              return matrix2([divideScalar2(1, x.valueOf()[0])]);
            } else {
              return [divideScalar2(1, x[0])];
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            if (isMatrix(x)) {
              return matrix2(_inv(x.valueOf(), rows, cols), x.storage());
            } else {
              return _inv(x, rows, cols);
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format$1(size2) + ")");
      }
    },
    any: function any2(x) {
      return divideScalar2(1, x);
    }
  });
  function _inv(mat, rows, cols) {
    var r, s, f, value, temp2;
    if (rows === 1) {
      value = mat[0][0];
      if (value === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar2(1, value)]];
    } else if (rows === 2) {
      var d = det2(mat);
      if (d === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar2(mat[1][1], d), divideScalar2(unaryMinus2(mat[0][1]), d)], [divideScalar2(unaryMinus2(mat[1][0]), d), divideScalar2(mat[0][0], d)]];
    } else {
      var A2 = mat.concat();
      for (r = 0; r < rows; r++) {
        A2[r] = A2[r].concat();
      }
      var B2 = identity2(rows).valueOf();
      for (var c2 = 0; c2 < cols; c2++) {
        var ABig = abs2(A2[c2][c2]);
        var rBig = c2;
        r = c2 + 1;
        while (r < rows) {
          if (abs2(A2[r][c2]) > ABig) {
            ABig = abs2(A2[r][c2]);
            rBig = r;
          }
          r++;
        }
        if (ABig === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        r = rBig;
        if (r !== c2) {
          temp2 = A2[c2];
          A2[c2] = A2[r];
          A2[r] = temp2;
          temp2 = B2[c2];
          B2[c2] = B2[r];
          B2[r] = temp2;
        }
        var Ac = A2[c2];
        var Bc = B2[c2];
        for (r = 0; r < rows; r++) {
          var Ar = A2[r];
          var Br = B2[r];
          if (r !== c2) {
            if (Ar[c2] !== 0) {
              f = divideScalar2(unaryMinus2(Ar[c2]), Ac[c2]);
              for (s = c2; s < cols; s++) {
                Ar[s] = addScalar2(Ar[s], multiply2(f, Ac[s]));
              }
              for (s = 0; s < cols; s++) {
                Br[s] = addScalar2(Br[s], multiply2(f, Bc[s]));
              }
            }
          } else {
            f = Ac[c2];
            for (s = c2; s < cols; s++) {
              Ar[s] = divideScalar2(Ar[s], f);
            }
            for (s = 0; s < cols; s++) {
              Br[s] = divideScalar2(Br[s], f);
            }
          }
        }
      }
      return B2;
    }
  }
});
var Complex = /* @__PURE__ */ createComplexClass({});
var BigNumber = /* @__PURE__ */ createBigNumberClass({
  config: config$1
});
var Matrix = /* @__PURE__ */ createMatrixClass({});
var Fraction = /* @__PURE__ */ createFractionClass({});
var DenseMatrix = /* @__PURE__ */ createDenseMatrixClass({
  Matrix
});
var typed = /* @__PURE__ */ createTyped({
  BigNumber,
  Complex,
  DenseMatrix,
  Fraction
});
var equalScalar = /* @__PURE__ */ createEqualScalar({
  config: config$1,
  typed
});
var number$1 = /* @__PURE__ */ createNumber({
  typed
});
var multiplyScalar = /* @__PURE__ */ createMultiplyScalar({
  typed
});
var fraction = /* @__PURE__ */ createFraction({
  Fraction,
  typed
});
var unaryMinus = /* @__PURE__ */ createUnaryMinus({
  typed
});
var addScalar = /* @__PURE__ */ createAddScalar({
  typed
});
var conj = /* @__PURE__ */ createConj({
  typed
});
var SparseMatrix = /* @__PURE__ */ createSparseMatrixClass({
  Matrix,
  equalScalar,
  typed
});
var matrix = /* @__PURE__ */ createMatrix({
  DenseMatrix,
  Matrix,
  SparseMatrix,
  typed
});
var abs = /* @__PURE__ */ createAbs({
  typed
});
var identity$1 = /* @__PURE__ */ createIdentity({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  config: config$1,
  matrix,
  typed
});
var size = /* @__PURE__ */ createSize({
  matrix,
  config: config$1,
  typed
});
var smaller = /* @__PURE__ */ createSmaller({
  DenseMatrix,
  config: config$1,
  matrix,
  typed
});
var larger = /* @__PURE__ */ createLarger({
  DenseMatrix,
  config: config$1,
  matrix,
  typed
});
var FibonacciHeap = /* @__PURE__ */ createFibonacciHeapClass({
  larger,
  smaller
});
var dot = /* @__PURE__ */ createDot({
  addScalar,
  conj,
  multiplyScalar,
  size,
  typed
});
var multiply = /* @__PURE__ */ createMultiply({
  addScalar,
  dot,
  equalScalar,
  matrix,
  multiplyScalar,
  typed
});
var bignumber = /* @__PURE__ */ createBignumber({
  BigNumber,
  typed
});
var numeric = /* @__PURE__ */ createNumeric({
  bignumber,
  fraction,
  number: number$1
});
var subtract = /* @__PURE__ */ createSubtract({
  DenseMatrix,
  addScalar,
  equalScalar,
  matrix,
  typed,
  unaryMinus
});
var divideScalar = /* @__PURE__ */ createDivideScalar({
  numeric,
  typed
});
var Spa = /* @__PURE__ */ createSpaClass({
  FibonacciHeap,
  addScalar,
  equalScalar
});
var lup = /* @__PURE__ */ createLup({
  DenseMatrix,
  Spa,
  SparseMatrix,
  abs,
  addScalar,
  divideScalar,
  equalScalar,
  larger,
  matrix,
  multiplyScalar,
  subtract,
  typed,
  unaryMinus
});
var det = /* @__PURE__ */ createDet({
  lup,
  matrix,
  multiply,
  subtract,
  typed,
  unaryMinus
});
var inv = /* @__PURE__ */ createInv({
  abs,
  addScalar,
  det,
  divideScalar,
  identity: identity$1,
  matrix,
  multiply,
  typed,
  unaryMinus
});
/**
 * k-d Tree JavaScript - V 1.01
 *
 * https://github.com/ubilabs/kd-tree-javascript
 *
 * @author Mircea Pricop <pricop@ubilabs.net>, 2012
 * @author Martin Kleppe <kleppe@ubilabs.net>, 2012
 * @author Ubilabs http://ubilabs.net, 2012
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
 */
function Node(obj, dimension, parent) {
  this.obj = obj;
  this.left = null;
  this.right = null;
  this.parent = parent;
  this.dimension = dimension;
}
function kdTree(points, metric, dimensions) {
  var self2 = this;
  function buildTree(points2, depth, parent) {
    var dim = depth % dimensions.length, median, node;
    if (points2.length === 0) {
      return null;
    }
    if (points2.length === 1) {
      return new Node(points2[0], dim, parent);
    }
    points2.sort(function(a, b) {
      return a[dimensions[dim]] - b[dimensions[dim]];
    });
    median = Math.floor(points2.length / 2);
    node = new Node(points2[median], dim, parent);
    node.left = buildTree(points2.slice(0, median), depth + 1, node);
    node.right = buildTree(points2.slice(median + 1), depth + 1, node);
    return node;
  }
  function loadTree(data) {
    self2.root = data;
    function restoreParent(root2) {
      if (root2.left) {
        root2.left.parent = root2;
        restoreParent(root2.left);
      }
      if (root2.right) {
        root2.right.parent = root2;
        restoreParent(root2.right);
      }
    }
    restoreParent(self2.root);
  }
  if (!Array.isArray(points))
    loadTree(points);
  else
    this.root = buildTree(points, 0, null);
  this.toJSON = function(src) {
    if (!src)
      src = this.root;
    var dest = new Node(src.obj, src.dimension, null);
    if (src.left)
      dest.left = self2.toJSON(src.left);
    if (src.right)
      dest.right = self2.toJSON(src.right);
    return dest;
  };
  this.insert = function(point) {
    function innerSearch(node, parent) {
      if (node === null) {
        return parent;
      }
      var dimension2 = dimensions[node.dimension];
      if (point[dimension2] < node.obj[dimension2]) {
        return innerSearch(node.left, node);
      } else {
        return innerSearch(node.right, node);
      }
    }
    var insertPosition = innerSearch(this.root, null), newNode, dimension;
    if (insertPosition === null) {
      this.root = new Node(point, 0, null);
      return;
    }
    newNode = new Node(
      point,
      (insertPosition.dimension + 1) % dimensions.length,
      insertPosition
    );
    dimension = dimensions[insertPosition.dimension];
    if (point[dimension] < insertPosition.obj[dimension]) {
      insertPosition.left = newNode;
    } else {
      insertPosition.right = newNode;
    }
  };
  this.remove = function(point) {
    var node;
    function nodeSearch(node2) {
      if (node2 === null) {
        return null;
      }
      if (node2.obj === point) {
        return node2;
      }
      var dimension = dimensions[node2.dimension];
      if (point[dimension] < node2.obj[dimension]) {
        return nodeSearch(node2.left);
      } else {
        return nodeSearch(node2.right);
      }
    }
    function removeNode2(node2) {
      var nextNode, nextObj, pDimension;
      function findMin(node3, dim) {
        var dimension, own, left, right, min2;
        if (node3 === null) {
          return null;
        }
        dimension = dimensions[dim];
        if (node3.dimension === dim) {
          if (node3.left !== null) {
            return findMin(node3.left, dim);
          }
          return node3;
        }
        own = node3.obj[dimension];
        left = findMin(node3.left, dim);
        right = findMin(node3.right, dim);
        min2 = node3;
        if (left !== null && left.obj[dimension] < own) {
          min2 = left;
        }
        if (right !== null && right.obj[dimension] < min2.obj[dimension]) {
          min2 = right;
        }
        return min2;
      }
      if (node2.left === null && node2.right === null) {
        if (node2.parent === null) {
          self2.root = null;
          return;
        }
        pDimension = dimensions[node2.parent.dimension];
        if (node2.obj[pDimension] < node2.parent.obj[pDimension]) {
          node2.parent.left = null;
        } else {
          node2.parent.right = null;
        }
        return;
      }
      if (node2.right !== null) {
        nextNode = findMin(node2.right, node2.dimension);
        nextObj = nextNode.obj;
        removeNode2(nextNode);
        node2.obj = nextObj;
      } else {
        nextNode = findMin(node2.left, node2.dimension);
        nextObj = nextNode.obj;
        removeNode2(nextNode);
        node2.right = node2.left;
        node2.left = null;
        node2.obj = nextObj;
      }
    }
    node = nodeSearch(self2.root);
    if (node === null) {
      return;
    }
    removeNode2(node);
  };
  this.nearest = function(point, maxNodes, maxDistance) {
    var i, result, bestNodes;
    bestNodes = new BinaryHeap(function(e) {
      return -e[1];
    });
    function nearestSearch(node) {
      var bestChild, dimension = dimensions[node.dimension], ownDistance = metric(point, node.obj), linearPoint = {}, linearDistance, otherChild, i2;
      function saveNode(node2, distance) {
        bestNodes.push([node2, distance]);
        if (bestNodes.size() > maxNodes) {
          bestNodes.pop();
        }
      }
      for (i2 = 0; i2 < dimensions.length; i2 += 1) {
        if (i2 === node.dimension) {
          linearPoint[dimensions[i2]] = point[dimensions[i2]];
        } else {
          linearPoint[dimensions[i2]] = node.obj[dimensions[i2]];
        }
      }
      linearDistance = metric(linearPoint, node.obj);
      if (node.right === null && node.left === null) {
        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
          saveNode(node, ownDistance);
        }
        return;
      }
      if (node.right === null) {
        bestChild = node.left;
      } else if (node.left === null) {
        bestChild = node.right;
      } else {
        if (point[dimension] < node.obj[dimension]) {
          bestChild = node.left;
        } else {
          bestChild = node.right;
        }
      }
      nearestSearch(bestChild);
      if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
        saveNode(node, ownDistance);
      }
      if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {
        if (bestChild === node.left) {
          otherChild = node.right;
        } else {
          otherChild = node.left;
        }
        if (otherChild !== null) {
          nearestSearch(otherChild);
        }
      }
    }
    if (maxDistance) {
      for (i = 0; i < maxNodes; i += 1) {
        bestNodes.push([null, maxDistance]);
      }
    }
    if (self2.root)
      nearestSearch(self2.root);
    result = [];
    for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {
      if (bestNodes.content[i][0]) {
        result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);
      }
    }
    return result;
  };
  this.balanceFactor = function() {
    function height(node) {
      if (node === null) {
        return 0;
      }
      return Math.max(height(node.left), height(node.right)) + 1;
    }
    function count(node) {
      if (node === null) {
        return 0;
      }
      return count(node.left) + count(node.right) + 1;
    }
    return height(self2.root) / (Math.log(count(self2.root)) / Math.log(2));
  };
}
function BinaryHeap(scoreFunction) {
  this.content = [];
  this.scoreFunction = scoreFunction;
}
BinaryHeap.prototype = {
  push: function(element) {
    this.content.push(element);
    this.bubbleUp(this.content.length - 1);
  },
  pop: function() {
    var result = this.content[0];
    var end = this.content.pop();
    if (this.content.length > 0) {
      this.content[0] = end;
      this.sinkDown(0);
    }
    return result;
  },
  peek: function() {
    return this.content[0];
  },
  remove: function(node) {
    var len = this.content.length;
    for (var i = 0; i < len; i++) {
      if (this.content[i] == node) {
        var end = this.content.pop();
        if (i != len - 1) {
          this.content[i] = end;
          if (this.scoreFunction(end) < this.scoreFunction(node))
            this.bubbleUp(i);
          else
            this.sinkDown(i);
        }
        return;
      }
    }
    throw new Error("Node not found.");
  },
  size: function() {
    return this.content.length;
  },
  bubbleUp: function(n) {
    var element = this.content[n];
    while (n > 0) {
      var parentN = Math.floor((n + 1) / 2) - 1, parent = this.content[parentN];
      if (this.scoreFunction(element) < this.scoreFunction(parent)) {
        this.content[parentN] = element;
        this.content[n] = parent;
        n = parentN;
      } else {
        break;
      }
    }
  },
  sinkDown: function(n) {
    var length = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
    while (true) {
      var child2N = (n + 1) * 2, child1N = child2N - 1;
      var swap = null;
      if (child1N < length) {
        var child1 = this.content[child1N], child1Score = this.scoreFunction(child1);
        if (child1Score < elemScore)
          swap = child1N;
      }
      if (child2N < length) {
        var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
        if (child2Score < (swap == null ? elemScore : child1Score)) {
          swap = child2N;
        }
      }
      if (swap != null) {
        this.content[n] = this.content[swap];
        this.content[swap] = element;
        n = swap;
      } else {
        break;
      }
    }
  }
};
function decodeBase64String(base64String, arrayType) {
  if (arrayType === Array) {
    return JSON.parse(window.atob(base64String));
  } else {
    var blob = window.atob(base64String), bytesPerElement = arrayType.BYTES_PER_ELEMENT, fLen = blob.length / bytesPerElement, dView = makeTypedReader(arrayType), result = new arrayType(fLen), p = 0;
    for (var j = 0; j < fLen; j++) {
      p = j * bytesPerElement;
      for (var k = 0; k < bytesPerElement; k++)
        dView.set(k, blob.charCodeAt(p + k));
      result[j] = dView.get();
    }
    return result;
  }
}
function makeTypedReader(arrayType) {
  let base = new DataView(new ArrayBuffer(arrayType.BYTES_PER_ELEMENT));
  let result = {
    set(offset, value) {
      base.setUint8(offset, value);
    }
  };
  if (arrayType === Float32Array)
    result.get = () => base.getFloat32(0, true);
  else if (arrayType === Float64Array)
    result.get = () => base.getFloat64(0, true);
  else if (arrayType === Int32Array)
    result.get = () => base.getInt32(0, true);
  else if (arrayType === Uint32Array)
    result.get = () => base.getUint32(0, true);
  else if (arrayType === Int16Array)
    result.get = () => base.getInt16(0, true);
  else if (arrayType === Uint16Array)
    result.get = () => base.getUint16(0, true);
  else if (arrayType === Int8Array)
    result.get = () => base.getInt8(0, true);
  else if (arrayType === Uint8Array)
    result.get = () => base.getUint8(0, true);
  else
    console.error(
      "unsupported array type - note that int64 arrays aren't fully supported yet"
    );
  return result;
}
function selectArrayType(format2) {
  switch (format2) {
    case "i8":
      return BigInt64Array;
    case "i4":
      return Int32Array;
    case "i2":
      return Int16Array;
    case "i1":
      return Int8Array;
    case "u8":
      return BigUint64Array;
    case "u4":
      return Uint32Array;
    case "u2":
      return Uint16Array;
    case "u1":
      return Uint8Array;
  }
}
class ColumnarData {
  constructor(schema, data, additionalFields = null) {
    __publicField(this, "columns", {});
    __publicField(this, "nestPositionColumns", {});
    // for nested fields
    __publicField(this, "schema");
    __publicField(this, "idMapping", /* @__PURE__ */ new Map());
    __publicField(this, "length", 0);
    __publicField(this, "computedData", {});
    this.schema = schema;
    if (data["_format"] == "compressed") {
      this.length = data["_length"];
      if (!data.ids) {
        console.error("compressed data object has no ids field");
        return;
      }
      let idType = selectArrayType(data["_idtype"]);
      let ids = decodeBase64String(data.ids.values, idType);
      ids.forEach((id2, i) => this.idMapping.set(id2, i));
      Object.keys(this.schema).forEach((col) => {
        let fieldName = this.schema[col].field || col;
        let val = data[fieldName];
        if (!val)
          return;
        if (this.schema[col].nested) {
          if (!!val.positions) {
            this.nestPositionColumns[col] = decodeBase64String(
              val.positions,
              Int32Array
            );
          } else if (!!val.interval) {
            this.nestPositionColumns[col] = new Int32Array(this.length);
            for (let k = 0; k < this.length; k++) {
              this.nestPositionColumns[col][k] = (k + 1) * val.interval;
            }
          }
        }
        this.columns[col] = decodeBase64String(
          val.values,
          this.schema[col].array == "id" ? idType : this.schema[col].array
        );
        if (!this.schema[col].nested && this.columns[col].length != this.length)
          console.warn(
            `field '${fieldName}' has incorrect length: expected ${this.length}, got ${this.columns[col].length}`
          );
      });
      if (!!additionalFields) {
        let newCols = {};
        Object.keys(additionalFields).forEach((f) => {
          let colSchema = this.schema[f];
          if (!colSchema) {
            console.warn("can't add additional fields without a schema column");
            return;
          }
          if (colSchema.nested) {
            console.warn(
              "can't currently add nested columns using additional fields"
            );
            return;
          }
          let arrayType = colSchema.array == "id" ? Int32Array : colSchema.array;
          let newCol = new arrayType(this.length);
          newCols[f] = newCol;
        });
        ids.forEach((id2, i) => {
          let pt = this.byID(id2);
          Object.keys(additionalFields).forEach((f) => {
            newCols[f][i] = additionalFields[f](pt);
          });
        });
        Object.keys(newCols).forEach(
          (col) => this.columns[col] = newCols[col]
        );
      }
    } else {
      this.length = Object.keys(data).length;
      Object.keys(this.schema).forEach((col) => {
        let len = this.length;
        if (this.schema[col].nested) {
          this.nestPositionColumns[col] = new Int32Array(this.length);
          len = Object.keys(data).map((id2) => data[id2]).reduce(
            (total, pt) => total + pt[this.schema[col].field || col].length,
            0
          );
        }
        let arrayType = this.schema[col].array == "id" ? Int32Array : this.schema[col].array;
        this.columns[col] = new arrayType(len);
      });
      Object.keys(data).forEach((id2, i) => {
        id2 = parseInt(id2);
        this.idMapping.set(id2, i);
        let pt = data[id2];
        if (!!additionalFields) {
          Object.keys(additionalFields).forEach((f) => {
            pt[f] = additionalFields[f](pt, id2);
          });
        }
        Object.keys(this.schema).forEach((col) => {
          let fieldVal = pt[this.schema[col].field || col];
          if (this.schema[col].nested) {
            let currentPos = i == 0 ? 0 : this.nestPositionColumns[col][i - 1];
            fieldVal.forEach(
              (val, j) => this.columns[col][currentPos + j] = val
            );
            this.nestPositionColumns[col][i] = currentPos + fieldVal.length;
          } else
            this.columns[col][i] = fieldVal;
        });
      });
    }
  }
  byID(id2) {
    if (!this.idMapping.has(id2))
      return null;
    let result = {};
    Object.keys(this.schema).forEach((col) => {
      result[col] = this.get(id2, col);
    });
    Object.keys(this.computedData).forEach((col) => {
      result[col] = this.computedData[col](id2);
    });
    return result;
  }
  has(id2) {
    return this.idMapping.has(id2);
  }
  get(id2, field, fallback = null) {
    if (!this.idMapping.has(id2))
      return fallback;
    if (!this.columns.hasOwnProperty(field)) {
      if (!this.computedData.hasOwnProperty(field))
        return fallback;
      return this.computedData[field](id2);
    }
    let i = this.idMapping.get(id2);
    if (this.schema[field].nested) {
      let pos = i == 0 ? 0 : this.nestPositionColumns[field][i - 1];
      let endPos = this.nestPositionColumns[field][i];
      return Array.from(this.columns[field].slice(pos, endPos));
    }
    return this.columns[field][i];
  }
  map(mapper) {
    return Array.from(this.idMapping.keys()).map((id2) => mapper(this.byID(id2)));
  }
  forEach(fn) {
    for (var id2 of this.idMapping.keys()) {
      fn(this.byID(id2));
    }
  }
  getIDs() {
    return Array.from(this.idMapping.keys());
  }
  size() {
    return this.idMapping.size;
  }
  getField(field) {
    if (!this.columns.hasOwnProperty(field))
      return null;
    return this.columns[field];
  }
  setComputedField(fieldName, valueFn) {
    this.computedData[fieldName] = valueFn;
  }
  removeComputedField(fieldName) {
    if (this.computedData.hasOwnProperty(fieldName))
      delete this.computedData[fieldName];
  }
  // Enables this ColumnarData to retrieve values from the field in the given other
  // ColumnarData when the first field name is requested. Values are only retrieved
  // when the ID exists in this ColumnarData.
  linkField(field, data, otherField = null) {
    this.setComputedField(field, (id2) => data.get(id2, otherField || field));
  }
  // Enables this ColumnarData to retrieve a row of the given other ColumnarData
  // when the given field name is requested. Values are only retrieved
  // when the ID exists in this ColumnarData.
  linkData(field, data) {
    this.setComputedField(field, (id2) => data.byID(id2));
  }
}
const FRAME_SCHEMA = {
  x: { array: Float32Array },
  y: { array: Float32Array },
  alpha: { array: Float32Array },
  r: { array: Float32Array },
  color: { array: Array },
  visible: { array: Array }
};
class ColumnarFrame extends ColumnarData {
  constructor(frame2, title, additionalFields = null) {
    super(FRAME_SCHEMA, frame2, additionalFields);
    __publicField(this, "_kdTree");
    __publicField(this, "title");
    __publicField(this, "neighborSet");
    this.title = title;
  }
  // Transforms all xy coordinates according to the given transformation matrix
  transform(transformation) {
    this.idMapping.forEach((i) => {
      let point = [this.columns.x[i], this.columns.y[i]];
      point = transformPoint(transformation, point);
      this.columns.x[i] = point[0];
      this.columns.y[i] = point[1];
    });
  }
  buildKdTree() {
    let coordinates = this.getIDs().map((id2) => ({
      id: id2,
      x: this.get(id2, "x"),
      y: this.get(id2, "y")
    }));
    let tree = new kdTree(coordinates, distance2, ["x", "y"]);
    this._kdTree = {
      _tree: tree,
      nearest: (pointID, k) => {
        if (!pointID || !this.has(pointID))
          return [];
        let results = tree.nearest(
          { x: this.get(pointID, "x"), y: this.get(pointID, "y") },
          k
        );
        return results.map((el) => parseInt(el[0].id));
      }
    };
  }
  neighbors(pointID, k) {
    if (!this._kdTree)
      this.buildKdTree();
    return this._kdTree.nearest(pointID, k);
  }
}
const NEIGHBORS_SCHEMA = {
  neighbors: { array: "id", nested: true }
};
class Neighbors extends ColumnarData {
  constructor(data) {
    super(NEIGHBORS_SCHEMA, data);
  }
}
function emptyNeighborData(ids) {
  let result = {};
  ids.forEach((id2) => result[id2] = { neighbors: [] });
  return result;
}
const PREVIEW_LINE_SCHEMA = {
  lineAlpha: { array: Float32Array },
  lineWidth: { array: Float32Array }
};
class FramePreview {
  constructor(frame2, previewFrame, dataFn = null) {
    __publicField(this, "frame");
    __publicField(this, "previewFrame");
    __publicField(this, "lineData");
    __publicField(this, "_sortedByAlpha");
    this.frame = frame2;
    this.previewFrame = previewFrame;
    this.lineData = new ColumnarData(
      PREVIEW_LINE_SCHEMA,
      !!dataFn ? Object.fromEntries(this.frame.getIDs().map((id2) => [id2, dataFn(id2)])) : {}
    );
  }
  /**
   * Returns the top k IDs with the highest alpha values, optionally filtering
   * to the given set of IDs.
   */
  getTopK(k, inSet = null) {
    if (this._sortedByAlpha == null) {
      let ids = this.frame.getIDs();
      this._sortedByAlpha = shuffle([...Array(ids.length).keys()]);
      let alphas = this.lineData.getField("lineAlpha");
      this._sortedByAlpha.sort((a, b) => alphas[b] - alphas[a]);
    }
    let result = [];
    this._sortedByAlpha.some((id2) => {
      if (inSet != null && !inSet.has(id2))
        return false;
      result.push(id2);
      return result.length >= k;
    });
    return result;
  }
  get(id2) {
    return this.lineData.byID(id2) || { lineAlpha: 0, lineWidth: 0 };
  }
}
class ProjectionPreview extends FramePreview {
  constructor(frame2, previewFrame, k = 10, similarityThreshold = 0.7) {
    super(
      frame2,
      previewFrame,
      (id2) => ProjectionPreview._calculate(
        id2,
        frame2,
        previewFrame,
        k,
        similarityThreshold
      )
    );
  }
  static _calculate(pointID, frame2, previewFrame, k = 10, similarityThreshold = 0.7) {
    let currentNeighbors = new Set(frame2.neighbors(pointID, k));
    let previewNeighbors = new Set(previewFrame.neighbors(pointID, k));
    let intersectionCount = 0;
    currentNeighbors.forEach((n) => {
      if (previewNeighbors.has(n)) {
        intersectionCount++;
      }
    });
    let fraction2 = intersectionCount / currentNeighbors.size;
    let intensity;
    if (fraction2 >= similarityThreshold) {
      intensity = { lineWidth: 0, lineAlpha: 0 };
    } else {
      intensity = {
        lineWidth: (1 - fraction2 / similarityThreshold) * 10,
        lineAlpha: 1 - fraction2 / similarityThreshold
      };
    }
    return intensity;
  }
}
class NeighborPreview extends FramePreview {
  constructor(frame2, previewFrame, k = 10, similarityThreshold = 0.3) {
    super(
      frame2,
      previewFrame,
      (id2) => NeighborPreview._calculate(
        id2,
        frame2,
        previewFrame,
        k,
        similarityThreshold
      )
    );
  }
  static _getNeighbors(frame2, pointID, k) {
    let n = frame2.get(pointID, "highlightIndexes");
    if (k < n.length)
      n = n.slice(0, k);
    return new Set(n);
  }
  static _calculate(pointID, frame2, previewFrame, k = 10, similarityThreshold = 0.3) {
    let currentNeighbors = this._getNeighbors(frame2, pointID, k);
    let previewNeighbors = this._getNeighbors(previewFrame, pointID, k);
    let intersectionCount = 0;
    currentNeighbors.forEach((n) => {
      if (previewNeighbors.has(n)) {
        intersectionCount++;
      }
    });
    let fraction2 = intersectionCount / currentNeighbors.size;
    let intensity;
    if (fraction2 >= similarityThreshold) {
      intensity = { lineWidth: 0, lineAlpha: 0 };
    } else {
      intensity = {
        lineWidth: Math.pow(1 - fraction2 / similarityThreshold, 3) * 5,
        //20.0,
        lineAlpha: Math.pow(1 - fraction2 / similarityThreshold, 3)
      };
    }
    return intensity;
  }
}
class PrecomputedPreview extends FramePreview {
  constructor(frame2, previewFrame, precomputedData, scale = 1) {
    super(
      frame2,
      previewFrame,
      (id2) => PrecomputedPreview._calculate(
        id2,
        frame2,
        previewFrame,
        precomputedData,
        scale
      )
    );
  }
  static _calculate(pointID, frame2, previewFrame, precomputedData, scale = 1) {
    let alpha = null;
    for (var comp of precomputedData) {
      if (comp.component.includes(pointID)) {
        alpha = comp.distance;
        break;
      }
    }
    if (!alpha) {
      return { lineAlpha: 0, lineWidth: 0 };
    }
    let dx = previewFrame.get(pointID, "x") - frame2.get(pointID, "x");
    let dy = previewFrame.get(pointID, "y") - frame2.get(pointID, "y");
    let distance = Math.sqrt(dx * dx + dy * dy);
    return {
      lineWidth: 10 * (distance / scale + 0.2),
      lineAlpha: alpha
    };
  }
}
const PreviewMode = {
  PROJECTION_SIMILARITY: "projectionNeighborSimilarity",
  NEIGHBOR_SIMILARITY: "neighborSimilarity",
  PRECOMPUTED: "precomputed"
};
class Dataset {
  constructor(rawData, colorKey) {
    __publicField(this, "frames", []);
    __publicField(this, "frameTransformations", []);
    __publicField(this, "neighborSets", []);
    __publicField(this, "colorKey", "color");
    __publicField(this, "length", 0);
    // number of points
    __publicField(this, "frameCount", 0);
    __publicField(this, "hasPreviews", false);
    __publicField(this, "previewMode", PreviewMode.PROJECTION_SIMILARITY);
    __publicField(this, "previewParameters", {});
    __publicField(this, "ids", []);
    __publicField(this, "supportsContinuousColorSchemes", true);
    __publicField(this, "thumbnailData", null);
    __publicField(this, "spritesheets", null);
    let frameSource;
    if (rawData["data"]) {
      frameSource = rawData.data;
      this.previews = rawData.previews;
      this.frameLabels = rawData.frameLabels;
      this.previewMode = rawData.previewMode || PreviewMode.PROJECTION_SIMILARITY;
    } else {
      frameSource = rawData;
      this.frameLabels = frameSource.map((f, i) => "Frame " + (i + 1));
    }
    this.colorKey = colorKey;
    this.frameCount = frameSource.length;
    this.hasPreviews = !!this.previews;
    this.reformat(frameSource);
    this.setNeighbors(this.frames.map((f) => emptyNeighborData(f.getIDs())));
  }
  reformat(rawData) {
    if (rawData.length == 0)
      return;
    this.frames = rawData.map((frame2, f) => {
      let ret = new ColumnarFrame(frame2, this.frameLabels[f], {
        color: (el) => this.colorKey == "constant" ? 0 : el[this.colorKey] || 0,
        alpha: (el) => el.alpha != void 0 ? el.alpha : 1,
        r: (el) => el.r != void 0 ? el.r : 1,
        visible: () => true
      });
      if (!!this.frameTransformations && this.frameTransformations.length > f) {
        ret.transform(this.frameTransformations[f]);
      }
      return ret;
    });
    let allIDs = /* @__PURE__ */ new Set();
    this.frames.forEach((frame2) => {
      frame2.getIDs().forEach((id2) => allIDs.add(id2));
    });
    this.ids = Array.from(allIDs);
    this.length = this.ids.length;
    this.supportsContinuousColorSchemes = this.frames.every((frame2) => {
      return !frame2.getField("color").some((v2) => isNaN(v2));
    });
  }
  getXExtent() {
    if (!this._xExtent) {
      let minVal = 1e9;
      let maxVal = -1e9;
      this.frames.forEach((frame2) => {
        let field = frame2.getField("x");
        minVal = field.reduce((curr, val) => Math.min(curr, val), minVal);
        maxVal = field.reduce((curr, val) => Math.max(curr, val), maxVal);
      });
      this._xExtent = [minVal, maxVal];
    }
    return this._xExtent;
  }
  getYExtent() {
    if (!this._yExtent) {
      let minVal = 1e9;
      let maxVal = -1e9;
      this.frames.forEach((frame2) => {
        let field = frame2.getField("y");
        minVal = field.reduce((curr, val) => Math.min(curr, val), minVal);
        maxVal = field.reduce((curr, val) => Math.max(curr, val), maxVal);
      });
      this._yExtent = [minVal, maxVal];
    }
    return this._yExtent;
  }
  getColorExtent(categorical = false) {
    if (categorical) {
      let uniqueColors = /* @__PURE__ */ new Set();
      this.frames.forEach((frame2) => {
        frame2.getField("color").forEach((c2) => uniqueColors.add(c2));
      });
      this._colorExtent = Array.from(uniqueColors).sort();
    } else {
      let minVal = 1e9;
      let maxVal = -1e9;
      this.frames.forEach((frame2, f) => {
        let field = frame2.getField("color");
        minVal = field.reduce((curr, val) => Math.min(curr, val), minVal);
        maxVal = field.reduce((curr, val) => Math.max(curr, val), maxVal);
      });
      this._colorExtent = [minVal, maxVal];
    }
    return this._colorExtent;
  }
  // Generates a color scale function using the given color scheme. The input
  // object can have a 'type' property (either "continuous" or "categorical"),
  // as well as a 'value' property that defines a d3 color scale function.
  colorScale(scheme2) {
    let colorType = scheme2.type || "continuous";
    if (colorType == "categorical") {
      return ordinal(scheme2.value).domain(this.getColorExtent(true));
    }
    return sequential(scheme2.value).domain(this.getColorExtent());
  }
  byID(id2) {
    let obj = { id: id2 };
    this.frames.forEach((frame2, f) => {
      let frameObj = frame2.byID(id2);
      if (!frameObj)
        return;
      Object.keys(frameObj).forEach((col) => {
        if (col == "id")
          return;
        if (!obj.hasOwnProperty(col))
          obj[col] = {};
        obj[col][f] = frameObj[col];
      });
    });
    return obj;
  }
  atFrame(id2, frame2) {
    return this.frames[frame2].byID(id2);
  }
  frame(frameNumber) {
    return this.frames[frameNumber];
  }
  map(mapper) {
    return this.ids.map(mapper);
  }
  filter(filterer) {
    return this.ids.filter(filterer);
  }
  forEach(fn) {
    this.ids.forEach(fn);
  }
  setPreviewMode(previewMode) {
    this.previewMode = previewMode;
  }
  setPreviewParameter(param, value) {
    this.previewParameters[param] = value;
  }
  getPreviewParameter(param) {
    if (this.previewParameters.hasOwnProperty(param))
      return this.previewParameters[param];
    if (param == "k")
      return 10;
    else if (param == "similarityThreshold")
      return 0.5;
  }
  previewInfo(frameNumber, previewFrameNumber) {
    let frame2 = this.frames[frameNumber];
    let previewFrame = this.frames[previewFrameNumber];
    if (this.previewMode == PreviewMode.PRECOMPUTED && this.hasPreviews && !!this.previews && !!this.previews[frameNumber] && !!this.previews[previewFrameNumber]) {
      let xex = this.getXExtent();
      let yex = this.getYExtent();
      let neighborScale = (xex[1] - xex[0] + yex[1] - yex[0]) / 2;
      return new PrecomputedPreview(
        frame2,
        previewFrame,
        this.previews[frameNumber][previewFrameNumber],
        neighborScale
      );
    } else if (this.previewMode == PreviewMode.PROJECTION_SIMILARITY) {
      return new ProjectionPreview(
        frame2,
        previewFrame,
        this.getPreviewParameter("k"),
        this.getPreviewParameter("similarityThreshold")
      );
    } else if (this.previewMode == PreviewMode.NEIGHBOR_SIMILARITY) {
      return new NeighborPreview(
        frame2,
        previewFrame,
        this.getPreviewParameter("k"),
        this.getPreviewParameter("similarityThreshold")
      );
    }
    return new FramePreview(frame2, previewFrame);
  }
  transform(frameTransformations) {
    let actualTransforms = !!this.frameTransformations ? this.frameTransformations.map(
      (old, i) => multiply(frameTransformations[i], inv(old))
    ) : frameTransformations;
    this.frames.forEach((frame2, f) => {
      if (!!actualTransforms && actualTransforms.length > f) {
        frame2.transform(actualTransforms[f]);
      }
    });
    this.frameTransformations = frameTransformations;
  }
  // Adds metadata to each point based on the given thumbnails.json data
  addThumbnails(thumbnailData) {
    if (!thumbnailData)
      return;
    let positionData = {};
    if (!!thumbnailData.items) {
      Object.keys(thumbnailData.items).forEach((id2) => {
        positionData[id2] = {
          text: thumbnailData.items[id2].name,
          description: thumbnailData.items[id2].description
        };
      });
    }
    if (!!thumbnailData.spritesheets) {
      this.spritesheets = thumbnailData.spritesheets;
      Object.keys(this.spritesheets).forEach(
        (sheet) => Object.keys(this.spritesheets[sheet].spec.frames).forEach((id2) => {
          if (!positionData[id2])
            positionData[id2] = {};
          positionData[id2].sheet = sheet;
          positionData[id2].texture = id2;
        })
      );
      this.thumbnailData = new ColumnarData(
        {
          sheet: { array: Array },
          texture: { array: Array },
          text: { array: Array },
          description: { array: Array }
        },
        positionData
      );
    } else {
      this.spritesheets = null;
      this.thumbnailData = new ColumnarData(
        {
          text: { array: Array },
          description: { array: Array }
        },
        positionData
      );
    }
    if (!!this.thumbnailData)
      this.frames.forEach((f) => f.linkData("label", this.thumbnailData));
  }
  removeThumbnails() {
    this.spritesheets = null;
    this.thumbnailData = null;
    this.frames.forEach((f) => f.removeComputedField("label"));
  }
  // neighborData should be a list of JSON objects, each representing a set of neighbors
  setNeighbors(neighborData) {
    if (neighborData.length != this.frames.length)
      console.warn("Neighbor data has different length than frames");
    this.neighborSets = neighborData.map((n) => new Neighbors(n));
    this.frames.forEach((f, i) => {
      f.linkField("highlightIndexes", this.neighborSets[i], "neighbors");
    });
  }
  clearNeighbors() {
    this.neighborSets = [];
    this.frames.forEach((f) => f.removeComputedField("highlightIndexes"));
  }
}
function get_each_context$7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_if_block$5(ctx) {
  let div2;
  let t;
  let mounted;
  let dispose;
  let if_block0 = !!/*d*/
  ctx[6].src && create_if_block_8$2(ctx);
  let if_block1 = (!/*d*/
  ctx[6].src || !/*mini*/
  ctx[4] || !!/*rate*/
  ctx[1] || !!/*change*/
  ctx[2]) && create_if_block_1$4(ctx);
  return {
    c() {
      div2 = element$2("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div2, "class", "thumbnail-row svelte-1df3mbt");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t);
      if (if_block1)
        if_block1.m(div2, null);
      if (!mounted) {
        dispose = [
          listen(
            div2,
            "click",
            /*click_handler*/
            ctx[10]
          ),
          listen(
            div2,
            "mouseover",
            /*mouseover_handler*/
            ctx[11]
          ),
          listen(
            div2,
            "mouseout",
            /*mouseout_handler*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!!/*d*/
      ctx2[6].src) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_8$2(ctx2);
          if_block0.c();
          if_block0.m(div2, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*d*/
      ctx2[6].src || !/*mini*/
      ctx2[4] || !!/*rate*/
      ctx2[1] || !!/*change*/
      ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$4(ctx2);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_8$2(ctx) {
  let div1;
  let img;
  let img_src_value;
  let img_width_value;
  let img_height_value;
  let img_style_value;
  let img_alt_value;
  let t;
  let div0;
  let div0_style_value;
  let div1_style_value;
  return {
    c() {
      div1 = element$2("div");
      img = element$2("img");
      t = space();
      div0 = element$2("div");
      attr(img, "class", "thumbnail-image svelte-1df3mbt");
      if (!src_url_equal(img.src, img_src_value = /*d*/
      ctx[6].src))
        attr(img, "src", img_src_value);
      attr(img, "width", img_width_value = `${/*d*/
      ctx[6].macroSize.w}px`);
      attr(img, "height", img_height_value = `${/*d*/
      ctx[6].macroSize.h}px`);
      attr(img, "style", img_style_value = `left: ${-/*d*/
      ctx[6].spec.frame.x}px; top: ${-/*d*/
      ctx[6].spec.frame.y}px; width: ${/*d*/
      ctx[6].macroSize.w}px; height: ${/*d*/
      ctx[6].macroSize.h}px;`);
      attr(img, "alt", img_alt_value = "Image preview for point " + /*d*/
      ctx[6].id);
      attr(div0, "class", "image-overlay svelte-1df3mbt");
      attr(div0, "style", div0_style_value = `width: ${/*d*/
      ctx[6].spec.frame.w}px; height: ${/*d*/
      ctx[6].spec.frame.h}px;`);
      toggle_class(
        div0,
        "diff-green",
        /*color*/
        ctx[3] == "green"
      );
      toggle_class(
        div0,
        "diff-red",
        /*color*/
        ctx[3] == "red"
      );
      attr(div1, "class", "image-parent svelte-1df3mbt");
      attr(div1, "style", div1_style_value = `width: ${/*d*/
      ctx[6].spec.frame.w}px; height: ${/*d*/
      ctx[6].spec.frame.h}px;`);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, img);
      append(div1, t);
      append(div1, div0);
    },
    p(ctx2, dirty) {
      if (dirty & /*d*/
      64 && !src_url_equal(img.src, img_src_value = /*d*/
      ctx2[6].src)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*d*/
      64 && img_width_value !== (img_width_value = `${/*d*/
      ctx2[6].macroSize.w}px`)) {
        attr(img, "width", img_width_value);
      }
      if (dirty & /*d*/
      64 && img_height_value !== (img_height_value = `${/*d*/
      ctx2[6].macroSize.h}px`)) {
        attr(img, "height", img_height_value);
      }
      if (dirty & /*d*/
      64 && img_style_value !== (img_style_value = `left: ${-/*d*/
      ctx2[6].spec.frame.x}px; top: ${-/*d*/
      ctx2[6].spec.frame.y}px; width: ${/*d*/
      ctx2[6].macroSize.w}px; height: ${/*d*/
      ctx2[6].macroSize.h}px;`)) {
        attr(img, "style", img_style_value);
      }
      if (dirty & /*d*/
      64 && img_alt_value !== (img_alt_value = "Image preview for point " + /*d*/
      ctx2[6].id)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*d*/
      64 && div0_style_value !== (div0_style_value = `width: ${/*d*/
      ctx2[6].spec.frame.w}px; height: ${/*d*/
      ctx2[6].spec.frame.h}px;`)) {
        attr(div0, "style", div0_style_value);
      }
      if (dirty & /*color*/
      8) {
        toggle_class(
          div0,
          "diff-green",
          /*color*/
          ctx2[3] == "green"
        );
      }
      if (dirty & /*color*/
      8) {
        toggle_class(
          div0,
          "diff-red",
          /*color*/
          ctx2[3] == "red"
        );
      }
      if (dirty & /*d*/
      64 && div1_style_value !== (div1_style_value = `width: ${/*d*/
      ctx2[6].spec.frame.w}px; height: ${/*d*/
      ctx2[6].spec.frame.h}px;`)) {
        attr(div1, "style", div1_style_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
    }
  };
}
function create_if_block_1$4(ctx) {
  let div2;
  let t0;
  let t1;
  let if_block0 = (
    /*d*/
    ctx[6].text && (!/*d*/
    ctx[6].src || !/*mini*/
    ctx[4]) && create_if_block_7$2(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (!!/*rate*/
    ctx2[1])
      return create_if_block_3$3;
    if (!!/*change*/
    ctx2[2])
      return create_if_block_4$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type && current_block_type(ctx);
  let if_block2 = (
    /*detail*/
    ctx[5] && !!/*d*/
    ctx[6].description && create_if_block_2$4(ctx)
  );
  return {
    c() {
      div2 = element$2("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(div2, "class", "thumbnail-text-section svelte-1df3mbt");
      toggle_class(div2, "text-section-with-change", !!/*change*/
      ctx[2]);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t0);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t1);
      if (if_block2)
        if_block2.m(div2, null);
    },
    p(ctx2, dirty) {
      if (
        /*d*/
        ctx2[6].text && (!/*d*/
        ctx2[6].src || !/*mini*/
        ctx2[4])
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_7$2(ctx2);
          if_block0.c();
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div2, t1);
        }
      }
      if (
        /*detail*/
        ctx2[5] && !!/*d*/
        ctx2[6].description
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_2$4(ctx2);
          if_block2.c();
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty & /*change*/
      4) {
        toggle_class(div2, "text-section-with-change", !!/*change*/
        ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_7$2(ctx) {
  let p;
  let t_value = (
    /*d*/
    ctx[6].text + ""
  );
  let t;
  return {
    c() {
      p = element$2("p");
      t = text(t_value);
      attr(p, "class", "svelte-1df3mbt");
      toggle_class(
        p,
        "text-red",
        /*color*/
        ctx[3] == "red"
      );
      toggle_class(
        p,
        "text-green",
        /*color*/
        ctx[3] == "green"
      );
      toggle_class(p, "label-with-change", !!/*change*/
      ctx[2]);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*d*/
      64 && t_value !== (t_value = /*d*/
      ctx2[6].text + ""))
        set_data(t, t_value);
      if (dirty & /*color*/
      8) {
        toggle_class(
          p,
          "text-red",
          /*color*/
          ctx2[3] == "red"
        );
      }
      if (dirty & /*color*/
      8) {
        toggle_class(
          p,
          "text-green",
          /*color*/
          ctx2[3] == "green"
        );
      }
      if (dirty & /*change*/
      4) {
        toggle_class(p, "label-with-change", !!/*change*/
        ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_4$3(ctx) {
  let div5;
  let div0;
  let t0;
  let div3;
  let div1;
  let t1;
  let div2;
  let t2;
  let div4;
  let if_block0 = (
    /*change*/
    ctx[2].lost > 0 && create_if_block_6$3(ctx)
  );
  let if_block1 = (
    /*change*/
    ctx[2].gained > 0 && create_if_block_5$3(ctx)
  );
  return {
    c() {
      div5 = element$2("div");
      div0 = element$2("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div3 = element$2("div");
      div1 = element$2("div");
      t1 = space();
      div2 = element$2("div");
      t2 = space();
      div4 = element$2("div");
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "change-text text-red svelte-1df3mbt");
      set_style(div0, "text-align", "right");
      attr(div1, "class", "count-bar-lost svelte-1df3mbt");
      set_style(div1, "left", ((0.5 - /*change*/
      ctx[2].lost / /*change*/
      (ctx[2].total * 2)) * 100).toFixed(0) + "%");
      set_style(div1, "right", "50%");
      attr(div2, "class", "count-bar-gained svelte-1df3mbt");
      set_style(div2, "left", "50%");
      set_style(
        div2,
        "width",
        /*change*/
        (ctx[2].gained / /*change*/
        (ctx[2].total * 2) * 100).toFixed(0) + "%"
      );
      attr(div3, "class", "count-bar svelte-1df3mbt");
      attr(div4, "class", "change-text text-green svelte-1df3mbt");
      set_style(div4, "text-align", "left");
      attr(div5, "class", "count-bar-parent svelte-1df3mbt");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div5, t0);
      append(div5, div3);
      append(div3, div1);
      append(div3, t1);
      append(div3, div2);
      append(div5, t2);
      append(div5, div4);
      if (if_block1)
        if_block1.m(div4, null);
    },
    p(ctx2, dirty) {
      if (
        /*change*/
        ctx2[2].lost > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6$3(ctx2);
          if_block0.c();
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*change*/
      4) {
        set_style(div1, "left", ((0.5 - /*change*/
        ctx2[2].lost / /*change*/
        (ctx2[2].total * 2)) * 100).toFixed(0) + "%");
      }
      if (dirty & /*change*/
      4) {
        set_style(
          div2,
          "width",
          /*change*/
          (ctx2[2].gained / /*change*/
          (ctx2[2].total * 2) * 100).toFixed(0) + "%"
        );
      }
      if (
        /*change*/
        ctx2[2].gained > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_5$3(ctx2);
          if_block1.c();
          if_block1.m(div4, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_3$3(ctx) {
  let div3;
  let div1;
  let div0;
  let t0;
  let div2;
  let t1_value = (
    /*rate*/
    ctx[1].count + ""
  );
  let t1;
  return {
    c() {
      div3 = element$2("div");
      div1 = element$2("div");
      div0 = element$2("div");
      t0 = space();
      div2 = element$2("div");
      t1 = text(t1_value);
      attr(div0, "class", "count-bar-filled svelte-1df3mbt");
      set_style(
        div0,
        "width",
        /*rate*/
        (ctx[1].count / /*rate*/
        ctx[1].total * 100).toFixed(0) + "%"
      );
      attr(div1, "class", "count-bar svelte-1df3mbt");
      attr(div2, "class", "count-text svelte-1df3mbt");
      attr(div3, "class", "count-bar-parent svelte-1df3mbt");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      append(div3, t0);
      append(div3, div2);
      append(div2, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*rate*/
      2) {
        set_style(
          div0,
          "width",
          /*rate*/
          (ctx2[1].count / /*rate*/
          ctx2[1].total * 100).toFixed(0) + "%"
        );
      }
      if (dirty & /*rate*/
      2 && t1_value !== (t1_value = /*rate*/
      ctx2[1].count + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
    }
  };
}
function create_if_block_6$3(ctx) {
  let t0;
  let t1_value = (
    /*change*/
    ctx[2].lost + ""
  );
  let t1;
  return {
    c() {
      t0 = text("–");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*change*/
      4 && t1_value !== (t1_value = /*change*/
      ctx2[2].lost + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_if_block_5$3(ctx) {
  let t0;
  let t1_value = (
    /*change*/
    ctx[2].gained + ""
  );
  let t1;
  return {
    c() {
      t0 = text("+");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*change*/
      4 && t1_value !== (t1_value = /*change*/
      ctx2[2].gained + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_if_block_2$4(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*d*/
    ctx[6].description.split("\n")
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty$2();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*d*/
      64) {
        each_value = ensure_array_like(
          /*d*/
          ctx2[6].description.split("\n")
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$7(ctx) {
  let p;
  let t_value = (
    /*line*/
    ctx[13] + ""
  );
  let t;
  return {
    c() {
      p = element$2("p");
      t = text(t_value);
      set_style(p, "color", "grey");
      attr(p, "class", "svelte-1df3mbt");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*d*/
      64 && t_value !== (t_value = /*line*/
      ctx2[13] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$a(ctx) {
  let if_block_anchor;
  let if_block = !!/*d*/
  ctx[6] && create_if_block$5(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty$2();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (!!/*d*/
      ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$5(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let { id: id2 } = $$props;
  let { rate = null } = $$props;
  let { change = null } = $$props;
  let { frame: frame2 = 0 } = $$props;
  let { color: color2 = "black" } = $$props;
  let { thumbnailProvider } = $$props;
  let { mini = false } = $$props;
  let { detail = false } = $$props;
  const dispatch2 = createEventDispatcher();
  let d;
  const click_handler = (e) => dispatch2("thumbnailClick", {
    id: d.id,
    keyPressed: e.metaKey || e.ctrlKey
  });
  const mouseover_handler = () => dispatch2("thumbnailHover", { id: id2 });
  const mouseout_handler = () => dispatch2("thumbnailHover", { id: null });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("rate" in $$props2)
      $$invalidate(1, rate = $$props2.rate);
    if ("change" in $$props2)
      $$invalidate(2, change = $$props2.change);
    if ("frame" in $$props2)
      $$invalidate(8, frame2 = $$props2.frame);
    if ("color" in $$props2)
      $$invalidate(3, color2 = $$props2.color);
    if ("thumbnailProvider" in $$props2)
      $$invalidate(9, thumbnailProvider = $$props2.thumbnailProvider);
    if ("mini" in $$props2)
      $$invalidate(4, mini = $$props2.mini);
    if ("detail" in $$props2)
      $$invalidate(5, detail = $$props2.detail);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*thumbnailProvider, id, frame*/
    769) {
      if (!!thumbnailProvider && id2 != null && frame2 >= 0) {
        $$invalidate(6, d = thumbnailProvider.get(id2, frame2));
      } else {
        $$invalidate(6, d = null);
      }
    }
  };
  return [
    id2,
    rate,
    change,
    color2,
    mini,
    detail,
    d,
    dispatch2,
    frame2,
    thumbnailProvider,
    click_handler,
    mouseover_handler,
    mouseout_handler
  ];
}
class Thumbnail extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$a, create_fragment$a, safe_not_equal, {
      id: 0,
      rate: 1,
      change: 2,
      frame: 8,
      color: 3,
      thumbnailProvider: 9,
      mini: 4,
      detail: 5
    });
  }
}
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  return child_ctx;
}
function get_each_context_2$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[39] = list[i];
  return child_ctx;
}
function create_else_block_3(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let t2;
  let div3;
  let t3;
  let div2;
  let t4;
  let current;
  let if_block0 = (
    /*$helpMessagesVisible*/
    ctx[14] && create_if_block_14(ctx)
  );
  let if_block1 = !!/*message*/
  ctx[8] && create_if_block_13(ctx);
  let each_value_3 = ensure_array_like(
    /*thumbnailIDs*/
    ctx[0].slice(
      0,
      /*showingFullSelection*/
      ctx[13] ? (
        /*thumbnailIDs*/
        ctx[0].length
      ) : MaxSelectionVisible
    )
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block2 = (
    /*thumbnailIDs*/
    ctx[0].length > MaxSelectionVisible && create_if_block_11(ctx)
  );
  return {
    c() {
      div1 = element$2("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element$2("div");
      t1 = text(
        /*primaryTitle*/
        ctx[4]
      );
      t2 = space();
      div3 = element$2("div");
      if (if_block1)
        if_block1.c();
      t3 = space();
      div2 = element$2("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "header-text svelte-17986h9");
      attr(div1, "class", "header-bar svelte-17986h9");
      attr(div2, "class", "svelte-17986h9");
      toggle_class(div2, "wrap-container", !!/*thumbnailProvider*/
      ctx[9] && /*thumbnailProvider*/
      ctx[9].hasImages && /*thumbnailIDs*/
      ctx[0].length > 1);
      attr(div3, "class", "thumbnails-container svelte-17986h9");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, t1);
      insert(target, t2, anchor);
      insert(target, div3, anchor);
      if (if_block1)
        if_block1.m(div3, null);
      append(div3, t3);
      append(div3, div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append(div3, t4);
      if (if_block2)
        if_block2.m(div3, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$helpMessagesVisible*/
        ctx2[14]
      ) {
        if (if_block0) {
          if (dirty[0] & /*$helpMessagesVisible*/
          16384) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*primaryTitle*/
      16)
        set_data(
          t1,
          /*primaryTitle*/
          ctx2[4]
        );
      if (!!/*message*/
      ctx2[8]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_13(ctx2);
          if_block1.c();
          if_block1.m(div3, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*thumbnailProvider, thumbnailIDs, showingFullSelection, frame, dispatch*/
      41537) {
        each_value_3 = ensure_array_like(
          /*thumbnailIDs*/
          ctx2[0].slice(
            0,
            /*showingFullSelection*/
            ctx2[13] ? (
              /*thumbnailIDs*/
              ctx2[0].length
            ) : MaxSelectionVisible
          )
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, null);
          }
        }
        group_outros();
        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & /*thumbnailProvider, thumbnailIDs*/
      513) {
        toggle_class(div2, "wrap-container", !!/*thumbnailProvider*/
        ctx2[9] && /*thumbnailProvider*/
        ctx2[9].hasImages && /*thumbnailIDs*/
        ctx2[0].length > 1);
      }
      if (
        /*thumbnailIDs*/
        ctx2[0].length > MaxSelectionVisible
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_11(ctx2);
          if_block2.c();
          if_block2.m(div3, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t2);
        detach(div3);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_8$1(ctx) {
  let div2;
  let p0;
  let t2;
  let p1;
  let strong1;
  let t3;
  let t4;
  let t5;
  let p2;
  let strong2;
  let t6;
  let t7;
  function select_block_type_1(ctx2, dirty) {
    if (getOSName() == "MacOS")
      return create_if_block_10$1;
    return create_else_block_2$1;
  }
  let current_block_type = select_block_type_1();
  let if_block0 = current_block_type(ctx);
  function select_block_type_2(ctx2, dirty) {
    if (getOSName() == "MacOS")
      return create_if_block_9$1;
    return create_else_block_1$1;
  }
  let current_block_type_1 = select_block_type_2();
  let if_block1 = current_block_type_1(ctx);
  return {
    c() {
      div2 = element$2("div");
      p0 = element$2("p");
      p0.innerHTML = `<strong>Click</strong> to select points`;
      t2 = space();
      p1 = element$2("p");
      strong1 = element$2("strong");
      if_block0.c();
      t3 = text(" + click");
      t4 = text(" to add to selection");
      t5 = space();
      p2 = element$2("p");
      strong2 = element$2("strong");
      if_block1.c();
      t6 = text(" + drag");
      t7 = text(" to select a region");
      attr(p0, "class", "svelte-17986h9");
      attr(p1, "class", "svelte-17986h9");
      attr(p2, "class", "svelte-17986h9");
      attr(div2, "class", "no-selection svelte-17986h9");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, p0);
      append(div2, t2);
      append(div2, p1);
      append(p1, strong1);
      if_block0.m(strong1, null);
      append(strong1, t3);
      append(p1, t4);
      append(div2, t5);
      append(div2, p2);
      append(p2, strong2);
      if_block1.m(strong2, null);
      append(strong2, t6);
      append(p2, t7);
    },
    p: noop$3,
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_block0.d();
      if_block1.d();
    }
  };
}
function create_if_block_14(ctx) {
  let helpmessage;
  let current;
  helpmessage = new HelpMessage({
    props: {
      pad: false,
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(helpmessage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helpmessage, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(helpmessage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpmessage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helpmessage, detaching);
    }
  };
}
function create_else_block_5(ctx) {
  let t;
  return {
    c() {
      t = text("Ctrl");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_15(ctx) {
  let t;
  return {
    c() {
      t = text("Cmd");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_default_slot_2$1(ctx) {
  let t0;
  let strong0;
  let t2;
  let t3;
  let strong1;
  let t5;
  function select_block_type_3(ctx2, dirty) {
    if (getOSName() == "MacOS")
      return create_if_block_15;
    return create_else_block_5;
  }
  let current_block_type = select_block_type_3();
  let if_block = current_block_type(ctx);
  return {
    c() {
      t0 = text("This area shows the ");
      strong0 = element$2("strong");
      strong0.textContent = "current selection";
      t2 = text(". ");
      if_block.c();
      t3 = text("\n          + click a point here to ");
      strong1 = element$2("strong");
      strong1.textContent = "remove it";
      t5 = text(" from the selection.");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, strong0, anchor);
      insert(target, t2, anchor);
      if_block.m(target, anchor);
      insert(target, t3, anchor);
      insert(target, strong1, anchor);
      insert(target, t5, anchor);
    },
    p: noop$3,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(strong0);
        detach(t2);
        detach(t3);
        detach(strong1);
        detach(t5);
      }
      if_block.d(detaching);
    }
  };
}
function create_if_block_13(ctx) {
  let p;
  let t;
  return {
    c() {
      p = element$2("p");
      t = text(
        /*message*/
        ctx[8]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*message*/
      256)
        set_data(
          t,
          /*message*/
          ctx2[8]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_each_block_3(ctx) {
  let thumbnail;
  let current;
  thumbnail = new Thumbnail({
    props: {
      thumbnailProvider: (
        /*thumbnailProvider*/
        ctx[9]
      ),
      id: (
        /*id*/
        ctx[39]
      ),
      frame: (
        /*frame*/
        ctx[6]
      ),
      mini: !!/*thumbnailProvider*/
      ctx[9] && /*thumbnailProvider*/
      ctx[9].hasImages && /*thumbnailIDs*/
      ctx[0].length > 1,
      detail: (
        /*thumbnailIDs*/
        ctx[0].length == 1
      )
    }
  });
  thumbnail.$on(
    "thumbnailClick",
    /*thumbnailClick_handler*/
    ctx[17]
  );
  thumbnail.$on(
    "thumbnailHover",
    /*thumbnailHover_handler*/
    ctx[18]
  );
  return {
    c() {
      create_component(thumbnail.$$.fragment);
    },
    m(target, anchor) {
      mount_component(thumbnail, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const thumbnail_changes = {};
      if (dirty[0] & /*thumbnailProvider*/
      512)
        thumbnail_changes.thumbnailProvider = /*thumbnailProvider*/
        ctx2[9];
      if (dirty[0] & /*thumbnailIDs, showingFullSelection*/
      8193)
        thumbnail_changes.id = /*id*/
        ctx2[39];
      if (dirty[0] & /*frame*/
      64)
        thumbnail_changes.frame = /*frame*/
        ctx2[6];
      if (dirty[0] & /*thumbnailProvider, thumbnailIDs*/
      513)
        thumbnail_changes.mini = !!/*thumbnailProvider*/
        ctx2[9] && /*thumbnailProvider*/
        ctx2[9].hasImages && /*thumbnailIDs*/
        ctx2[0].length > 1;
      if (dirty[0] & /*thumbnailIDs*/
      1)
        thumbnail_changes.detail = /*thumbnailIDs*/
        ctx2[0].length == 1;
      thumbnail.$set(thumbnail_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(thumbnail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(thumbnail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(thumbnail, detaching);
    }
  };
}
function create_if_block_11(ctx) {
  let a;
  let mounted;
  let dispose;
  function select_block_type_4(ctx2, dirty) {
    if (
      /*showingFullSelection*/
      ctx2[13]
    )
      return create_if_block_12;
    return create_else_block_4;
  }
  let current_block_type = select_block_type_4(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      a = element$2("a");
      if_block.c();
      attr(a, "class", "selection-toggle-link svelte-17986h9");
      attr(a, "href", "#");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if_block.m(a, null);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(
          /*click_handler*/
          ctx[19]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type_4(ctx2))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(a, null);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_4(ctx) {
  let t;
  return {
    c() {
      t = text("Show more");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_12(ctx) {
  let t;
  return {
    c() {
      t = text("Show less");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_else_block_2$1(ctx) {
  let t;
  return {
    c() {
      t = text("Ctrl");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_10$1(ctx) {
  let t;
  return {
    c() {
      t = text("Cmd");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_else_block_1$1(ctx) {
  let t;
  return {
    c() {
      t = text("Ctrl");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_9$1(ctx) {
  let t;
  return {
    c() {
      t = text("Cmd");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_2$3(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let t2;
  let div3;
  let div2;
  let t3;
  let t4;
  let t5;
  let if_block3_anchor;
  let current;
  let if_block0 = (
    /*$helpMessagesVisible*/
    ctx[14] && create_if_block_6$2(ctx)
  );
  let if_block1 = (
    /*previewSecondaryItems*/
    ctx[11].length > 0 && create_if_block_5$2(ctx)
  );
  let each_value_2 = ensure_array_like(
    /*secondaryItems*/
    ctx[10]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block2 = (
    /*previewSecondaryItems*/
    ctx[11].length > 0 && create_if_block_4$2(ctx)
  );
  let if_block3 = (
    /*thumbnailIDs*/
    ctx[0].length > 1 && create_if_block_3$2()
  );
  return {
    c() {
      div1 = element$2("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element$2("div");
      t1 = text(
        /*secondaryTitle*/
        ctx[5]
      );
      t2 = space();
      div3 = element$2("div");
      div2 = element$2("div");
      if (if_block1)
        if_block1.c();
      t3 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty$2();
      attr(div0, "class", "header-text svelte-17986h9");
      attr(div1, "class", "header-bar svelte-17986h9");
      attr(div2, "class", "thumbnail-column svelte-17986h9");
      attr(div3, "class", "thumbnails-container column-container svelte-17986h9");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, t1);
      insert(target, t2, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append(div3, t4);
      if (if_block2)
        if_block2.m(div3, null);
      insert(target, t5, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$helpMessagesVisible*/
        ctx2[14]
      ) {
        if (if_block0) {
          if (dirty[0] & /*$helpMessagesVisible*/
          16384) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*secondaryTitle*/
      32)
        set_data(
          t1,
          /*secondaryTitle*/
          ctx2[5]
        );
      if (
        /*previewSecondaryItems*/
        ctx2[11].length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_5$2(ctx2);
          if_block1.c();
          if_block1.m(div2, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*previewSecondaryItems, thumbnailProvider, secondaryItems, frame, thumbnailIDs, dispatch*/
      36417) {
        each_value_2 = ensure_array_like(
          /*secondaryItems*/
          ctx2[10]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2$1(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, null);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (
        /*previewSecondaryItems*/
        ctx2[11].length > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*previewSecondaryItems*/
          2048) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4$2(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div3, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*thumbnailIDs*/
        ctx2[0].length > 1
      ) {
        if (if_block3)
          ;
        else {
          if_block3 = create_if_block_3$2();
          if_block3.c();
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t2);
        detach(div3);
        detach(t5);
        detach(if_block3_anchor);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d(detaching);
    }
  };
}
function create_if_block_6$2(ctx) {
  let helpmessage;
  let current;
  helpmessage = new HelpMessage({
    props: {
      pad: false,
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(helpmessage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helpmessage, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(helpmessage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpmessage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helpmessage, detaching);
    }
  };
}
function create_else_block$3(ctx) {
  let t;
  return {
    c() {
      t = text("Ctrl");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_7$1(ctx) {
  let t;
  return {
    c() {
      t = text("Cmd");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_default_slot_1$1(ctx) {
  let t0;
  let strong0;
  let t2;
  let t3;
  let strong1;
  let t5;
  function select_block_type_5(ctx2, dirty) {
    if (getOSName() == "MacOS")
      return create_if_block_7$1;
    return create_else_block$3;
  }
  let current_block_type = select_block_type_5();
  let if_block = current_block_type(ctx);
  return {
    c() {
      t0 = text("This area shows the ");
      strong0 = element$2("strong");
      strong0.textContent = "nearest neighbors";
      t2 = text(" of the current\n          selection. ");
      if_block.c();
      t3 = text(" + click a point\n          here to ");
      strong1 = element$2("strong");
      strong1.textContent = "add it";
      t5 = text(" to the selection.");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, strong0, anchor);
      insert(target, t2, anchor);
      if_block.m(target, anchor);
      insert(target, t3, anchor);
      insert(target, strong1, anchor);
      insert(target, t5, anchor);
    },
    p: noop$3,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(strong0);
        detach(t2);
        detach(t3);
        detach(strong1);
        detach(t5);
      }
      if_block.d(detaching);
    }
  };
}
function create_if_block_5$2(ctx) {
  let div2;
  let t_value = (
    /*dataset*/
    ctx[3].frame(
      /*frame*/
      ctx[6]
    ).title + ""
  );
  let t;
  return {
    c() {
      div2 = element$2("div");
      t = text(t_value);
      attr(div2, "class", "subheader svelte-17986h9");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*dataset, frame*/
      72 && t_value !== (t_value = /*dataset*/
      ctx2[3].frame(
        /*frame*/
        ctx2[6]
      ).title + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_each_block_2$1(ctx) {
  let thumbnail;
  let current;
  function func2(...args) {
    return (
      /*func*/
      ctx[20](
        /*item*/
        ctx[32],
        ...args
      )
    );
  }
  thumbnail = new Thumbnail({
    props: {
      mini: (
        /*previewSecondaryItems*/
        ctx[11].length > 0
      ),
      thumbnailProvider: (
        /*thumbnailProvider*/
        ctx[9]
      ),
      id: (
        /*item*/
        ctx[32].id
      ),
      frame: (
        /*frame*/
        ctx[6]
      ),
      rate: !!/*item*/
      ctx[32].count ? {
        count: (
          /*item*/
          ctx[32].count
        ),
        total: (
          /*thumbnailIDs*/
          ctx[0].length
        )
      } : null,
      color: (
        /*previewSecondaryItems*/
        ctx[11].length > 0 && !/*previewSecondaryItems*/
        ctx[11].find(func2) ? "red" : "black"
      )
    }
  });
  thumbnail.$on(
    "thumbnailClick",
    /*thumbnailClick_handler_1*/
    ctx[21]
  );
  thumbnail.$on(
    "thumbnailHover",
    /*thumbnailHover_handler_1*/
    ctx[22]
  );
  return {
    c() {
      create_component(thumbnail.$$.fragment);
    },
    m(target, anchor) {
      mount_component(thumbnail, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const thumbnail_changes = {};
      if (dirty[0] & /*previewSecondaryItems*/
      2048)
        thumbnail_changes.mini = /*previewSecondaryItems*/
        ctx[11].length > 0;
      if (dirty[0] & /*thumbnailProvider*/
      512)
        thumbnail_changes.thumbnailProvider = /*thumbnailProvider*/
        ctx[9];
      if (dirty[0] & /*secondaryItems*/
      1024)
        thumbnail_changes.id = /*item*/
        ctx[32].id;
      if (dirty[0] & /*frame*/
      64)
        thumbnail_changes.frame = /*frame*/
        ctx[6];
      if (dirty[0] & /*secondaryItems, thumbnailIDs*/
      1025)
        thumbnail_changes.rate = !!/*item*/
        ctx[32].count ? {
          count: (
            /*item*/
            ctx[32].count
          ),
          total: (
            /*thumbnailIDs*/
            ctx[0].length
          )
        } : null;
      if (dirty[0] & /*previewSecondaryItems, secondaryItems*/
      3072)
        thumbnail_changes.color = /*previewSecondaryItems*/
        ctx[11].length > 0 && !/*previewSecondaryItems*/
        ctx[11].find(func2) ? "red" : "black";
      thumbnail.$set(thumbnail_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(thumbnail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(thumbnail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(thumbnail, detaching);
    }
  };
}
function create_if_block_4$2(ctx) {
  let div1;
  let div0;
  let t0_value = (
    /*dataset*/
    ctx[3].frame(
      /*previewFrame*/
      ctx[7]
    ).title + ""
  );
  let t0;
  let t1;
  let current;
  let each_value_1 = ensure_array_like(
    /*previewSecondaryItems*/
    ctx[11]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div1 = element$2("div");
      div0 = element$2("div");
      t0 = text(t0_value);
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "subheader svelte-17986h9");
      attr(div1, "class", "thumbnail-column svelte-17986h9");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*dataset, previewFrame*/
      136) && t0_value !== (t0_value = /*dataset*/
      ctx2[3].frame(
        /*previewFrame*/
        ctx2[7]
      ).title + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*thumbnailProvider, previewSecondaryItems, frame, thumbnailIDs, secondaryItems, dispatch*/
      36417) {
        each_value_1 = ensure_array_like(
          /*previewSecondaryItems*/
          ctx2[11]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1$2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$2(ctx) {
  let thumbnail;
  let current;
  function func_1(...args) {
    return (
      /*func_1*/
      ctx[23](
        /*item*/
        ctx[32],
        ...args
      )
    );
  }
  thumbnail = new Thumbnail({
    props: {
      mini: true,
      thumbnailProvider: (
        /*thumbnailProvider*/
        ctx[9]
      ),
      id: (
        /*item*/
        ctx[32].id
      ),
      frame: (
        /*frame*/
        ctx[6]
      ),
      rate: !!/*item*/
      ctx[32].count ? {
        count: (
          /*item*/
          ctx[32].count
        ),
        total: (
          /*thumbnailIDs*/
          ctx[0].length
        )
      } : null,
      color: (
        /*secondaryItems*/
        ctx[10].length > 0 && !/*secondaryItems*/
        ctx[10].find(func_1) ? "green" : "black"
      )
    }
  });
  thumbnail.$on(
    "thumbnailClick",
    /*thumbnailClick_handler_2*/
    ctx[24]
  );
  thumbnail.$on(
    "thumbnailHover",
    /*thumbnailHover_handler_2*/
    ctx[25]
  );
  return {
    c() {
      create_component(thumbnail.$$.fragment);
    },
    m(target, anchor) {
      mount_component(thumbnail, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const thumbnail_changes = {};
      if (dirty[0] & /*thumbnailProvider*/
      512)
        thumbnail_changes.thumbnailProvider = /*thumbnailProvider*/
        ctx[9];
      if (dirty[0] & /*previewSecondaryItems*/
      2048)
        thumbnail_changes.id = /*item*/
        ctx[32].id;
      if (dirty[0] & /*frame*/
      64)
        thumbnail_changes.frame = /*frame*/
        ctx[6];
      if (dirty[0] & /*previewSecondaryItems, thumbnailIDs*/
      2049)
        thumbnail_changes.rate = !!/*item*/
        ctx[32].count ? {
          count: (
            /*item*/
            ctx[32].count
          ),
          total: (
            /*thumbnailIDs*/
            ctx[0].length
          )
        } : null;
      if (dirty[0] & /*secondaryItems, previewSecondaryItems*/
      3072)
        thumbnail_changes.color = /*secondaryItems*/
        ctx[10].length > 0 && !/*secondaryItems*/
        ctx[10].find(func_1) ? "green" : "black";
      thumbnail.$set(thumbnail_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(thumbnail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(thumbnail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(thumbnail, detaching);
    }
  };
}
function create_if_block_3$2(ctx) {
  let div2;
  return {
    c() {
      div2 = element$2("div");
      div2.textContent = "Points sorted by average nearest neighbor rank; bars = # of selected\n        points containing each point as a neighbor";
      attr(div2, "class", "explanatory-text svelte-17986h9");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block$4(ctx) {
  let div1;
  let t0;
  let div0;
  let t2;
  let div3;
  let div2;
  let t3;
  let div4;
  let current;
  let if_block = (
    /*$helpMessagesVisible*/
    ctx[14] && create_if_block_1$3(ctx)
  );
  let each_value = ensure_array_like(
    /*commonChangeItems*/
    ctx[12]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div1 = element$2("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div0 = element$2("div");
      div0.textContent = "Common Changes";
      t2 = space();
      div3 = element$2("div");
      div2 = element$2("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      div4 = element$2("div");
      div4.textContent = "Bars = # of selected points for which each point was gained or lost as a\n      neighbor";
      attr(div0, "class", "header-text svelte-17986h9");
      attr(div1, "class", "header-bar svelte-17986h9");
      attr(div2, "class", "thumbnail-column svelte-17986h9");
      attr(div3, "class", "thumbnails-container column-container svelte-17986h9");
      attr(div4, "class", "explanatory-text svelte-17986h9");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t0);
      append(div1, div0);
      insert(target, t2, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      insert(target, t3, anchor);
      insert(target, div4, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$helpMessagesVisible*/
        ctx2[14]
      ) {
        if (if_block) {
          if (dirty[0] & /*$helpMessagesVisible*/
          16384) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty[0] & /*thumbnailProvider, commonChangeItems, frame, thumbnailIDs, dispatch*/
      37441) {
        each_value = ensure_array_like(
          /*commonChangeItems*/
          ctx2[12]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t2);
        detach(div3);
        detach(t3);
        detach(div4);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1$3(ctx) {
  let helpmessage;
  let current;
  helpmessage = new HelpMessage({
    props: {
      pad: false,
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(helpmessage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helpmessage, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(helpmessage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpmessage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helpmessage, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let t0;
  let strong0;
  let t2;
  let strong1;
  let t4;
  return {
    c() {
      t0 = text("This area shows the most common neighbors ");
      strong0 = element$2("strong");
      strong0.textContent = "added to";
      t2 = text("\n          and ");
      strong1 = element$2("strong");
      strong1.textContent = "removed from";
      t4 = text(" the current frame in the comparing frame.");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, strong0, anchor);
      insert(target, t2, anchor);
      insert(target, strong1, anchor);
      insert(target, t4, anchor);
    },
    p: noop$3,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(strong0);
        detach(t2);
        detach(strong1);
        detach(t4);
      }
    }
  };
}
function create_each_block$6(ctx) {
  let thumbnail;
  let current;
  thumbnail = new Thumbnail({
    props: {
      mini: true,
      thumbnailProvider: (
        /*thumbnailProvider*/
        ctx[9]
      ),
      id: (
        /*item*/
        ctx[32].id
      ),
      frame: (
        /*frame*/
        ctx[6]
      ),
      change: {
        gained: (
          /*item*/
          ctx[32].gained
        ),
        lost: (
          /*item*/
          ctx[32].lost
        ),
        total: (
          /*thumbnailIDs*/
          ctx[0].length
        )
      },
      color: "black"
    }
  });
  thumbnail.$on(
    "thumbnailClick",
    /*thumbnailClick_handler_3*/
    ctx[26]
  );
  thumbnail.$on(
    "thumbnailHover",
    /*thumbnailHover_handler_3*/
    ctx[27]
  );
  return {
    c() {
      create_component(thumbnail.$$.fragment);
    },
    m(target, anchor) {
      mount_component(thumbnail, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const thumbnail_changes = {};
      if (dirty[0] & /*thumbnailProvider*/
      512)
        thumbnail_changes.thumbnailProvider = /*thumbnailProvider*/
        ctx2[9];
      if (dirty[0] & /*commonChangeItems*/
      4096)
        thumbnail_changes.id = /*item*/
        ctx2[32].id;
      if (dirty[0] & /*frame*/
      64)
        thumbnail_changes.frame = /*frame*/
        ctx2[6];
      if (dirty[0] & /*commonChangeItems, thumbnailIDs*/
      4097)
        thumbnail_changes.change = {
          gained: (
            /*item*/
            ctx2[32].gained
          ),
          lost: (
            /*item*/
            ctx2[32].lost
          ),
          total: (
            /*thumbnailIDs*/
            ctx2[0].length
          )
        };
      thumbnail.$set(thumbnail_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(thumbnail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(thumbnail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(thumbnail, detaching);
    }
  };
}
function create_fragment$9(ctx) {
  let div2;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let current;
  const if_block_creators = [create_if_block_8$1, create_else_block_3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*thumbnailIDs*/
      ctx2[0].length == 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*secondaryItems*/
    ctx[10].length > 0 && create_if_block_2$3(ctx)
  );
  let if_block2 = (
    /*commonChangeItems*/
    ctx[12].length > 0 && create_if_block$4(ctx)
  );
  return {
    c() {
      div2 = element$2("div");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(div2, "class", "thumbnail-parent");
      set_style(div2, "width", !!/*width*/
      ctx[1] ? `${/*width*/
      ctx[1]}px` : "100%");
      set_style(div2, "height", !!/*height*/
      ctx[2] ? `${/*height*/
      ctx[2]}px` : "100%");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if_blocks[current_block_type_index].m(div2, null);
      append(div2, t0);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t1);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div2, t0);
      }
      if (
        /*secondaryItems*/
        ctx2[10].length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*secondaryItems*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*commonChangeItems*/
        ctx2[12].length > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*commonChangeItems*/
          4096) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$4(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*width*/
      2) {
        set_style(div2, "width", !!/*width*/
        ctx2[1] ? `${/*width*/
        ctx2[1]}px` : "100%");
      }
      if (!current || dirty[0] & /*height*/
      4) {
        set_style(div2, "height", !!/*height*/
        ctx2[2] ? `${/*height*/
        ctx2[2]}px` : "100%");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
const MaxSelectionVisible = 6;
function instance$9($$self, $$props, $$invalidate) {
  let $helpMessagesVisible;
  component_subscribe($$self, helpMessagesVisible, ($$value) => $$invalidate(14, $helpMessagesVisible = $$value));
  const dispatch2 = createEventDispatcher();
  let { width = null } = $$props;
  let { height = null } = $$props;
  let { dataset = null } = $$props;
  let { primaryTitle = "Selection" } = $$props;
  let { secondaryTitle = "Neighbors" } = $$props;
  let { thumbnailIDs = [] } = $$props;
  let { frame: frame2 = -1 } = $$props;
  let { previewFrame = -1 } = $$props;
  let { message = "" } = $$props;
  let { numNeighbors = 10 } = $$props;
  let { thumbnailProvider = null } = $$props;
  let secondaryItems = [];
  let previewSecondaryItems = [];
  let commonChangeItems = [];
  let showingFullSelection = false;
  function rankNeighbors(ids, inFrame, filters = null) {
    let individualNeighbors = ids.map((id2) => {
      let neighbors = dataset.frame(inFrame).get(id2, "highlightIndexes");
      if (!neighbors)
        return null;
      neighbors = neighbors.map((n, i) => ({ id: n, score: neighbors.length - i })).filter((n) => !ids.includes(n.id));
      if (!!filters) {
        if (filters.hasOwnProperty("exclude")) {
          let excludeNeighbors = dataset.frame(filters.exclude).get(id2, "highlightIndexes");
          if (!!excludeNeighbors) {
            excludeNeighbors = new Set(excludeNeighbors);
            neighbors = neighbors.filter((n) => !excludeNeighbors.has(n.id));
          }
        }
        if (filters.hasOwnProperty("intersect")) {
          let intersectNeighbors = dataset.frame(filters.intersect).get(id2, "highlightIndexes");
          if (!!intersectNeighbors) {
            intersectNeighbors = new Set(intersectNeighbors);
            neighbors = neighbors.filter((n) => intersectNeighbors.has(n.id));
          }
        }
      }
      return neighbors;
    });
    let totalRanks = /* @__PURE__ */ new Map();
    individualNeighbors.forEach((neighbors) => {
      if (!neighbors)
        return;
      neighbors.forEach((n) => {
        if (!totalRanks.has(n.id))
          totalRanks.set(n.id, { score: n.score, count: 1 });
        else {
          let existing = totalRanks.get(n.id);
          totalRanks.set(n.id, {
            score: existing.score + n.score,
            count: existing.count + 1
          });
        }
      });
    });
    return [...totalRanks.entries()].sort((a, b) => b[1].score - a[1].score).map((item) => ({ id: item[0], count: item[1].count }));
  }
  function _getRankedNeighbors(ids, inFrame) {
    return ids.map((id2) => {
      let neighbors = dataset.frame(inFrame).get(id2, "highlightIndexes");
      if (!neighbors)
        return null;
      neighbors = neighbors.map((n, i) => ({ id: n, score: neighbors.length - i })).filter((n) => !ids.includes(n.id));
      return neighbors;
    });
  }
  function makeDeltaNeighbors(ids, fromFrame, toFrame) {
    let fromNeighbors = _getRankedNeighbors(ids, fromFrame);
    let toNeighbors = _getRankedNeighbors(ids, toFrame);
    let totalRanks = /* @__PURE__ */ new Map();
    let updateFn = (id2, score, gained) => {
      if (totalRanks.has(id2)) {
        let curr = totalRanks.get(id2);
        totalRanks.set(id2, {
          id: id2,
          score: curr.score + score * (gained ? 1 : -1),
          gained: curr.gained + (gained ? 1 : 0),
          lost: curr.lost + (gained ? 0 : 1)
        });
      } else {
        totalRanks.set(id2, {
          id: id2,
          score: score * (gained ? 1 : -1),
          gained: gained ? 1 : 0,
          lost: gained ? 0 : 1
        });
      }
    };
    ids.forEach((_, i) => {
      let fromN = fromNeighbors[i];
      let toN = toNeighbors[i];
      let fromNIds = new Set(fromN.map((n) => n.id));
      let toNIds = new Set(toN.map((n) => n.id));
      fromN.forEach((n) => {
        if (!toNIds.has(n.id))
          updateFn(n.id, n.score, false);
      });
      toN.forEach((n) => {
        if (!fromNIds.has(n.id))
          updateFn(n.id, n.score, true);
      });
    });
    return [...totalRanks.entries()].sort((a, b) => b[1].score - a[1].score).map((item) => item[1]);
  }
  function updateNeighborArrays(primaryIDs, currentFrameNumber, previewFrameNumber) {
    if (previewFrameNumber >= 0 && previewFrameNumber != currentFrameNumber) {
      if (primaryIDs.length == 1) {
        $$invalidate(11, previewSecondaryItems = dataset.frame(previewFrameNumber).get(primaryIDs[0], "highlightIndexes").slice(0, numNeighbors).map((id2) => ({ id: id2 })));
        $$invalidate(12, commonChangeItems = []);
      } else if (primaryIDs.length > 1) {
        $$invalidate(11, previewSecondaryItems = rankNeighbors(primaryIDs, previewFrameNumber).slice(0, numNeighbors));
        let commonChanges = makeDeltaNeighbors(primaryIDs, currentFrameNumber, previewFrameNumber);
        $$invalidate(12, commonChangeItems = [
          ...commonChanges.slice(0, Math.floor(numNeighbors / 2)),
          ...commonChanges.slice(commonChanges.length - Math.floor(numNeighbors / 2))
        ]);
      } else {
        $$invalidate(12, commonChangeItems = []);
        $$invalidate(11, previewSecondaryItems = []);
      }
    } else {
      $$invalidate(12, commonChangeItems = []);
      $$invalidate(11, previewSecondaryItems = []);
    }
    if (currentFrameNumber >= 0) {
      if (primaryIDs.length == 1) {
        $$invalidate(10, secondaryItems = dataset.frame(currentFrameNumber).get(primaryIDs[0], "highlightIndexes").slice(0, numNeighbors).map((id2) => ({ id: id2 })));
      } else if (primaryIDs.length > 1) {
        $$invalidate(10, secondaryItems = rankNeighbors(primaryIDs, currentFrameNumber).slice(0, numNeighbors));
      } else {
        $$invalidate(10, secondaryItems = []);
      }
    }
  }
  onMount(() => {
    if (!!dataset.spritesheets) {
      $$invalidate(0, thumbnailIDs);
    }
  });
  const thumbnailClick_handler = (e) => {
    dispatch2("thumbnailClick", e.detail);
    dispatch2("logEvent", {
      type: "selection",
      source: "selectionList"
    });
  };
  function thumbnailHover_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = () => $$invalidate(13, showingFullSelection = !showingFullSelection);
  const func2 = (item, d) => d.id == item.id;
  const thumbnailClick_handler_1 = (e) => {
    dispatch2("thumbnailClick", e.detail);
    dispatch2("logEvent", {
      type: "selection",
      source: "selectionNeighbors"
    });
  };
  function thumbnailHover_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  const func_1 = (item, d) => d.id == item.id;
  const thumbnailClick_handler_2 = (e) => {
    dispatch2("thumbnailClick", e.detail);
    dispatch2("logEvent", {
      type: "selection",
      source: "selectionPreviewNeighbors"
    });
  };
  function thumbnailHover_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  const thumbnailClick_handler_3 = (e) => {
    dispatch2("thumbnailClick", e.detail);
    dispatch2("logEvent", {
      type: "selection",
      source: "commonChanges"
    });
  };
  function thumbnailHover_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(2, height = $$props2.height);
    if ("dataset" in $$props2)
      $$invalidate(3, dataset = $$props2.dataset);
    if ("primaryTitle" in $$props2)
      $$invalidate(4, primaryTitle = $$props2.primaryTitle);
    if ("secondaryTitle" in $$props2)
      $$invalidate(5, secondaryTitle = $$props2.secondaryTitle);
    if ("thumbnailIDs" in $$props2)
      $$invalidate(0, thumbnailIDs = $$props2.thumbnailIDs);
    if ("frame" in $$props2)
      $$invalidate(6, frame2 = $$props2.frame);
    if ("previewFrame" in $$props2)
      $$invalidate(7, previewFrame = $$props2.previewFrame);
    if ("message" in $$props2)
      $$invalidate(8, message = $$props2.message);
    if ("numNeighbors" in $$props2)
      $$invalidate(16, numNeighbors = $$props2.numNeighbors);
    if ("thumbnailProvider" in $$props2)
      $$invalidate(9, thumbnailProvider = $$props2.thumbnailProvider);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*thumbnailIDs, frame, previewFrame*/
    193) {
      updateNeighborArrays(thumbnailIDs, frame2, previewFrame);
    }
  };
  return [
    thumbnailIDs,
    width,
    height,
    dataset,
    primaryTitle,
    secondaryTitle,
    frame2,
    previewFrame,
    message,
    thumbnailProvider,
    secondaryItems,
    previewSecondaryItems,
    commonChangeItems,
    showingFullSelection,
    $helpMessagesVisible,
    dispatch2,
    numNeighbors,
    thumbnailClick_handler,
    thumbnailHover_handler,
    click_handler,
    func2,
    thumbnailClick_handler_1,
    thumbnailHover_handler_1,
    func_1,
    thumbnailClick_handler_2,
    thumbnailHover_handler_2,
    thumbnailClick_handler_3,
    thumbnailHover_handler_3
  ];
}
class DefaultThumbnailViewer extends SvelteComponent {
  constructor(options) {
    super();
    init$2(
      this,
      options,
      instance$9,
      create_fragment$9,
      safe_not_equal,
      {
        width: 1,
        height: 2,
        dataset: 3,
        primaryTitle: 4,
        secondaryTitle: 5,
        thumbnailIDs: 0,
        frame: 6,
        previewFrame: 7,
        message: 8,
        numNeighbors: 16,
        thumbnailProvider: 9
      },
      null,
      [-1, -1]
    );
  }
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name2) {
  var prefix2 = name2 += "", i = prefix2.indexOf(":");
  if (i >= 0 && (prefix2 = name2.slice(0, i)) !== "xmlns")
    name2 = name2.slice(i + 1);
  return namespaces.hasOwnProperty(prefix2) ? { space: namespaces[prefix2], local: name2 } : name2;
}
function creatorInherit(name2) {
  return function() {
    var document2 = this.ownerDocument, uri2 = this.namespaceURI;
    return uri2 === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name2) : document2.createElementNS(uri2, name2);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name2) {
  var fullname = namespace(name2);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
var nextId = 0;
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = {
  constructor: Local,
  get: function(node) {
    var id2 = this._;
    while (!(id2 in node))
      if (!(node = node.parentNode))
        return;
    return node[id2];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};
var matcher = function(selector2) {
  return function() {
    return this.matches(selector2);
  };
};
if (typeof document !== "undefined") {
  var element$1 = document.documentElement;
  if (!element$1.matches) {
    var vendorMatches = element$1.webkitMatchesSelector || element$1.msMatchesSelector || element$1.mozMatchesSelector || element$1.oMatchesSelector;
    matcher = function(selector2) {
      return function() {
        return vendorMatches.call(this, selector2);
      };
    };
  }
}
const matcher$1 = matcher;
var filterEvents = {};
if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = { mouseenter: "mouseover", mouseleave: "mouseout" };
  }
}
function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
      listener.call(this, event);
    }
  };
}
function contextListener(listener, index, group) {
  return function(event1) {
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
    }
  };
}
function parseTypenames$1(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name: name2 };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, capture);
    o = { type: typename.type, name: typename.name, value, listener, capture };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function selection_on(typename, value, capture) {
  var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  if (capture == null)
    capture = false;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, capture));
  return this;
}
function none() {
}
function selector(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
function empty() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty : function() {
    return this.querySelectorAll(selector2);
  };
}
function selection_selectAll(select2) {
  if (typeof select2 !== "function")
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select2.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}
function selection_filter(match) {
  if (typeof match !== "function")
    match = matcher$1(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
function sparse(update2) {
  return new Array(update2.length);
}
function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$2(x) {
  return function() {
    return x;
  };
}
var keyPrefix = "$";
function bindIndex(parent, group, enter, update2, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update2[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update2, exit, data, key) {
  var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update2[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {
      exit[i] = node;
    }
  }
}
function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) {
      data[++j] = d;
    });
    return data;
  }
  var bind2 = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant$2(value);
  for (var m = groups.length, update2 = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update2[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind2(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update2 = new Selection(update2, parents);
  update2._enter = enter;
  update2._exit = exit;
  return update2;
}
function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}
function selection_merge(selection2) {
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge3 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge3[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
function selection_sort(compare) {
  if (!compare)
    compare = ascending$1;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending$1(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() {
    nodes[++i] = this;
  });
  return nodes;
}
function selection_node() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node)
        return node;
    }
  }
  return null;
}
function selection_size() {
  var size2 = 0;
  this.each(function() {
    ++size2;
  });
  return size2;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}
function attrRemove(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name2, value) {
  return function() {
    this.setAttribute(name2, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.removeAttribute(name2);
    else
      this.setAttribute(name2, v2);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v2);
  };
}
function selection_attr(name2, value) {
  var fullname = namespace(name2);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}
function defaultView(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
function styleRemove(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant(name2, value, priority) {
  return function() {
    this.style.setProperty(name2, value, priority);
  };
}
function styleFunction(name2, value, priority) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.style.removeProperty(name2);
    else
      this.style.setProperty(name2, v2, priority);
  };
}
function selection_style(name2, value, priority) {
  var node;
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name2, value, priority == null ? "" : priority)) : defaultView(node = this.node()).getComputedStyle(node, null).getPropertyValue(name2);
}
function propertyRemove(name2) {
  return function() {
    delete this[name2];
  };
}
function propertyConstant(name2, value) {
  return function() {
    this[name2] = value;
  };
}
function propertyFunction(name2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      delete this[name2];
    else
      this[name2] = v2;
  };
}
function selection_property(name2, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name2, value)) : this.node()[name2];
}
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name2) {
    var i = this._names.indexOf(name2);
    if (i < 0) {
      this._names.push(name2);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name2) {
    var i = this._names.indexOf(name2);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name2) {
    return this._names.indexOf(name2) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name2, value) {
  var names = classArray(name2 + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.textContent = v2 == null ? "" : v2;
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.innerHTML = v2 == null ? "" : v2;
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name2) {
  var create2 = typeof name2 === "function" ? name2 : creator(name2);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name2, before) {
  var create2 = typeof name2 === "function" ? name2 : creator(name2), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function dispatchEvent(node, type2, params) {
  var window2 = defaultView(node), event = window2.CustomEvent;
  if (event) {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function selection_dispatch(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
Selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};
function select(selector2) {
  return typeof selector2 === "string" ? new Selection([[document.querySelector(selector2)]], [document.documentElement]) : new Selection([[selector2]], root);
}
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}
function exponent(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
function formatDefault(x, p) {
  x = x.toPrecision(p);
  out:
    for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (x[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        case "e":
          break out;
        default:
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
}
var prefixExponent;
function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0];
}
function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "": formatDefault,
  "%": function(x, p) {
    return (x * 100).toFixed(p);
  },
  "b": function(x) {
    return Math.round(x).toString(2);
  },
  "c": function(x) {
    return x + "";
  },
  "d": function(x) {
    return Math.round(x).toString(10);
  },
  "e": function(x, p) {
    return x.toExponential(p);
  },
  "f": function(x, p) {
    return x.toFixed(p);
  },
  "g": function(x, p) {
    return x.toPrecision(p);
  },
  "o": function(x) {
    return Math.round(x).toString(8);
  },
  "p": function(x, p) {
    return formatRounded(x * 100, p);
  },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) {
    return Math.round(x).toString(16).toUpperCase();
  },
  "x": function(x) {
    return Math.round(x).toString(16);
  }
};
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}
function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match, fill = match[1] || " ", align = match[2] || ">", sign3 = match[3] || "-", symbol = match[4] || "", zero2 = !!match[5], width = match[6] && +match[6], comma = !!match[7], precision = match[8] && +match[8].slice(1), type2 = match[9] || "";
  if (type2 === "n")
    comma = true, type2 = "g";
  else if (!formatTypes[type2])
    type2 = "";
  if (zero2 || fill === "0" && align === "=")
    zero2 = true, fill = "0", align = "=";
  this.fill = fill;
  this.align = align;
  this.sign = sign3;
  this.symbol = symbol;
  this.zero = zero2;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type2;
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0)) + this.type;
};
var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function identity(x) {
  return x;
}
function formatLocale(locale2) {
  var group = locale2.grouping && locale2.thousands ? formatGroup(locale2.grouping, locale2.thousands) : identity, currency = locale2.currency, decimal = locale2.decimal;
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, type2 = specifier.type;
    var prefix2 = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currency[1] : /[%p]/.test(type2) ? "%" : "";
    var formatType = formatTypes[type2], maybeSuffix = !type2 || /[defgprs%]/.test(type2);
    precision = precision == null ? type2 ? 6 : 12 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix2, valueSuffix = suffix, i, n, c2;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);
        value = formatType(value, precision);
        if (valueNegative) {
          i = -1, n = value.length;
          valueNegative = false;
          while (++i < n) {
            if (c2 = value.charCodeAt(i), 48 < c2 && c2 < 58 || type2 === "x" && 96 < c2 && c2 < 103 || type2 === "X" && 64 < c2 && c2 < 71) {
              valueNegative = true;
              break;
            }
          }
        }
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : "-" : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = valueSuffix + (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          return valuePrefix + value + valueSuffix + padding;
        case "=":
          return valuePrefix + padding + value + valueSuffix;
        case "^":
          return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
      }
      return padding + valuePrefix + value + valueSuffix;
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix2 = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale;
var format;
var formatPrefix;
defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent(max2) - exponent(step)) + 1;
}
var noop = { value: function() {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _)
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name: name2 };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _ = this._;
    for (var t in _)
      copy2[t] = _[t].slice();
    return new Dispatch(copy2);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get(type2, name2) {
  for (var i = 0, n = type2.length, c2; i < n; ++i) {
    if ((c2 = type2[i]).name === name2) {
      return c2.value;
    }
  }
}
function set(type2, name2, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name2) {
      type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name: name2, value: callback });
  return type2;
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function bisector(compare) {
  if (compare.length === 1)
    compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0)
          lo = mid + 1;
        else
          hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0)
          hi = mid;
        else
          lo = mid + 1;
      }
      return lo;
    }
  };
}
function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
function sequence(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range2 = new Array(n);
  while (++i < n) {
    range2[i] = start2 + i * step;
  }
  return range2;
}
var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function ticks(start2, stop, count) {
  var step = tickStep(start2, stop, count);
  return sequence(
    Math.ceil(start2 / step) * step,
    Math.floor(stop / step) * step + step / 2,
    // inclusive
    step
  );
}
function tickStep(start2, stop, count) {
  var step0 = Math.abs(stop - start2) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10)
    step1 *= 10;
  else if (error >= e5)
    step1 *= 5;
  else if (error >= e2)
    step1 *= 2;
  return stop < start2 ? -step1 : step1;
}
function sum(array2, f) {
  var s = 0, n = array2.length, a, i = -1;
  if (f == null) {
    while (++i < n)
      if (a = +array2[i])
        s += a;
  } else {
    while (++i < n)
      if (a = +f(array2[i], i, array2))
        s += a;
  }
  return s;
}
var prefix = "$";
function Map$1() {
}
Map$1.prototype = map$1.prototype = {
  constructor: Map$1,
  has: function(key) {
    return prefix + key in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this)
      if (property[0] === prefix)
        delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this)
      if (property[0] === prefix)
        keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this)
      if (property[0] === prefix)
        values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this)
      if (property[0] === prefix)
        entries.push({ key: property.slice(1), value: this[property] });
    return entries;
  },
  size: function() {
    var size2 = 0;
    for (var property in this)
      if (property[0] === prefix)
        ++size2;
    return size2;
  },
  empty: function() {
    for (var property in this)
      if (property[0] === prefix)
        return false;
    return true;
  },
  each: function(f) {
    for (var property in this)
      if (property[0] === prefix)
        f(this[property], property.slice(1), this);
  }
};
function map$1(object2, f) {
  var map2 = new Map$1();
  if (object2 instanceof Map$1)
    object2.each(function(value, key2) {
      map2.set(key2, value);
    });
  else if (Array.isArray(object2)) {
    var i = -1, n = object2.length, o;
    if (f == null)
      while (++i < n)
        map2.set(i, object2[i]);
    else
      while (++i < n)
        map2.set(f(o = object2[i], i, object2), o);
  } else if (object2)
    for (var key in object2)
      map2.set(key, object2[key]);
  return map2;
}
function Set$1() {
}
var proto = map$1.prototype;
Set$1.prototype = {
  constructor: Set$1,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};
var array = Array.prototype;
var map = array.map;
var slice = array.slice;
function define(constructor, factory2, prototype) {
  constructor.prototype = factory2.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color$1, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color$1(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color$1(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb$1(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb$1, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color$1(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r === max2)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max2)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;
var A = -0.14861, B = 1.78277, C = -0.29227, D = -0.90649, E = 1.97294, ED = E * D, EB = E * B, BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix$1(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Cubehelix, cubehelix$1, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh2 + B * sinh2)),
      255 * (l + a * (C * cosh2 + D * sinh2)),
      255 * (l + a * (E * cosh2)),
      this.opacity
    );
  }
}));
function constant$1(x) {
  return function() {
    return x;
  };
}
function linear$1(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear$1(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$1(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear$1(a, d) : constant$1(isNaN(a) ? b : a);
}
const rgb = function rgbGamma2(y) {
  var color2 = gamma(y);
  function rgb2(start2, end) {
    var r = color2((start2 = rgb$1(start2)).r, (end = rgb$1(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma2;
  return rgb2;
}(1);
function numberArray(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c2 = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c2[i] = a[i] * (1 - t) + b[i] * t;
    return c2;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x[i] = interpolateValue(a[i], b[i]);
  for (; i < nb; ++i)
    c2[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c2[i] = x[i](t);
    return c2;
  };
}
function date(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}
function reinterpolate(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}
function object(a, b) {
  var i = {}, c2 = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = interpolateValue(a[k], b[k]);
    } else {
      c2[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c2[k] = i[k](t);
    return c2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: reinterpolate(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}
function interpolateValue(a, b) {
  var t = typeof b, c2;
  return b == null || t === "boolean" ? constant$1(b) : (t === "number" ? reinterpolate : t === "string" ? (c2 = color$1(b)) ? (b = c2, rgb) : string : b instanceof color$1 ? rgb : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : reinterpolate)(a, b);
}
function interpolateRound(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}
function cubehelix(hue2) {
  return function cubehelixGamma(y) {
    y = +y;
    function cubehelix2(start2, end) {
      var h = hue2((start2 = cubehelix$1(start2)).h, (end = cubehelix$1(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.h = h(t);
        start2.s = s(t);
        start2.l = l(Math.pow(t, y));
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    cubehelix2.gamma = cubehelixGamma;
    return cubehelix2;
  }(1);
}
cubehelix(hue);
var cubehelixLong = cubehelix(nogamma);
function constant(x) {
  return function() {
    return x;
  };
}
function number(x) {
  return +x;
}
var unit = [0, 1];
function deinterpolateLinear(a, b) {
  return (b -= a = +a) ? function(x) {
    return (x - a) / b;
  } : constant(b);
}
function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) {
      return x <= a ? 0 : x >= b ? 1 : d(x);
    };
  };
}
function reinterpolateClamp(reinterpolate2) {
  return function(a, b) {
    var r = reinterpolate2(a = +a, b = +b);
    return function(t) {
      return t <= 0 ? a : t >= 1 ? b : r(t);
    };
  };
}
function bimap(domain, range2, deinterpolate, reinterpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = deinterpolate(d1, d0), r0 = reinterpolate2(r1, r0);
  else
    d0 = deinterpolate(d0, d1), r0 = reinterpolate2(r0, r1);
  return function(x) {
    return r0(d0(x));
  };
}
function polymap(domain, range2, deinterpolate, reinterpolate2) {
  var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate2(range2[i], range2[i + 1]);
  }
  return function(x) {
    var i2 = bisectRight(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp());
}
function continuous(deinterpolate, reinterpolate2) {
  var domain = unit, range2 = unit, interpolate2 = interpolateValue, clamp2 = false, piecewise, output, input;
  function rescale() {
    piecewise = Math.min(domain.length, range2.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x) {
    return (output || (output = piecewise(domain, range2, clamp2 ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate2)))(+x);
  }
  scale.invert = function(y) {
    return (input || (input = piecewise(range2, domain, deinterpolateLinear, clamp2 ? reinterpolateClamp(reinterpolate2) : reinterpolate2)))(+y);
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = map.call(_, number), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = slice.call(_), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_) {
    return range2 = slice.call(_), interpolate2 = interpolateRound, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, rescale()) : clamp2;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, rescale()) : interpolate2;
  };
  return rescale();
}
function tickFormat(domain, count, specifier) {
  var start2 = domain[0], stop = domain[domain.length - 1], step = tickStep(start2, stop, count == null ? 10 : count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function(count, specifier) {
    return tickFormat(domain(), count, specifier);
  };
  scale.nice = function(count) {
    var d = domain(), i = d.length - 1, n = count == null ? 10 : count, start2 = d[0], stop = d[i], step = tickStep(start2, stop, n);
    if (step) {
      step = tickStep(Math.floor(start2 / step) * step, Math.ceil(stop / step) * step, n);
      d[0] = Math.floor(start2 / step) * step;
      d[i] = Math.ceil(stop / step) * step;
      domain(d);
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous(deinterpolateLinear, reinterpolate);
  scale.copy = function() {
    return copy(scale, linear());
  };
  return linearish(scale);
}
function colors(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
}
colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");
colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");
colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");
cubehelixLong(cubehelix$1(300, 0.5, 0), cubehelix$1(-240, 0.5, 1));
cubehelixLong(cubehelix$1(-100, 0.75, 0.35), cubehelix$1(80, 1.5, 0.8));
cubehelixLong(cubehelix$1(260, 0.75, 0.35), cubehelix$1(80, 1.5, 0.8));
cubehelix$1();
function ramp(range2) {
  var n = range2.length;
  return function(t) {
    return range2[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var d3_identity = function d3_identity2(d) {
  return d;
};
var d3_reverse = function d3_reverse2(arr) {
  var mirror = [];
  for (var i = 0, l = arr.length; i < l; i++) {
    mirror[i] = arr[l - i - 1];
  }
  return mirror;
};
var d3_textWrapping = function d3_textWrapping2(text2, width) {
  text2.each(function() {
    var text3 = select(this), words = text3.text().split(/\s+/).reverse(), word, line = [], lineHeight = 1.2;
    text3.attr("y");
    var dy = parseFloat(text3.attr("dy")) || 0, tspan = text3.text(null).append("tspan").attr("x", 0).attr("dy", dy + "em");
    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width && line.length > 1) {
        line.pop();
        tspan.text(line.join(" "));
        line = [word];
        tspan = text3.append("tspan").attr("x", 0).attr("dy", lineHeight + dy + "em").text(word);
      }
    }
  });
};
var d3_mergeLabels = function d3_mergeLabels2() {
  var gen = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var labels = arguments[1];
  var domain = arguments[2];
  var range2 = arguments[3];
  var labelDelimiter = arguments[4];
  if ((typeof labels === "undefined" ? "undefined" : _typeof(labels)) === "object") {
    if (labels.length === 0)
      return gen;
    var i = labels.length;
    for (; i < gen.length; i++) {
      labels.push(gen[i]);
    }
    return labels;
  } else if (typeof labels === "function") {
    var customLabels = [];
    var genLength = gen.length;
    for (var _i = 0; _i < genLength; _i++) {
      customLabels.push(labels({
        i: _i,
        genLength,
        generatedLabels: gen,
        domain,
        range: range2,
        labelDelimiter
      }));
    }
    return customLabels;
  }
  return gen;
};
var d3_linearLegend = function d3_linearLegend2(scale, cells, labelFormat) {
  var data = [];
  if (cells.length > 1) {
    data = cells;
  } else {
    var domain = scale.domain(), increment = (domain[domain.length - 1] - domain[0]) / (cells - 1);
    var i = 0;
    for (; i < cells; i++) {
      data.push(domain[0] + i * increment);
    }
  }
  var labels = data.map(labelFormat);
  return {
    data,
    labels,
    feature: function feature(d) {
      return scale(d);
    }
  };
};
var d3_quantLegend = function d3_quantLegend2(scale, labelFormat, labelDelimiter) {
  var labels = scale.range().map(function(d) {
    var invert = scale.invertExtent(d);
    return labelFormat(invert[0]) + " " + labelDelimiter + " " + labelFormat(invert[1]);
  });
  return {
    data: scale.range(),
    labels,
    feature: d3_identity
  };
};
var d3_ordinalLegend = function d3_ordinalLegend2(scale) {
  return {
    data: scale.domain(),
    labels: scale.domain(),
    feature: function feature(d) {
      return scale(d);
    }
  };
};
var d3_cellOver = function d3_cellOver2(cellDispatcher, d, obj) {
  cellDispatcher.call("cellover", obj, d);
};
var d3_cellOut = function d3_cellOut2(cellDispatcher, d, obj) {
  cellDispatcher.call("cellout", obj, d);
};
var d3_cellClick = function d3_cellClick2(cellDispatcher, d, obj) {
  cellDispatcher.call("cellclick", obj, d);
};
var helper = {
  d3_drawShapes: function d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path) {
    if (shape === "rect") {
      shapes.attr("height", shapeHeight).attr("width", shapeWidth);
    } else if (shape === "circle") {
      shapes.attr("r", shapeRadius);
    } else if (shape === "line") {
      shapes.attr("x1", 0).attr("x2", shapeWidth).attr("y1", 0).attr("y2", 0);
    } else if (shape === "path") {
      shapes.attr("d", path);
    }
  },
  d3_addText: function d3_addText(svg, enter, labels, classPrefix, labelWidth) {
    enter.append("text").attr("class", classPrefix + "label");
    var text2 = svg.selectAll("g." + classPrefix + "cell text." + classPrefix + "label").data(labels).text(d3_identity);
    if (labelWidth) {
      svg.selectAll("g." + classPrefix + "cell text." + classPrefix + "label").call(d3_textWrapping, labelWidth);
    }
    return text2;
  },
  d3_calcType: function d3_calcType(scale, ascending2, cells, labels, labelFormat, labelDelimiter) {
    var type2 = scale.invertExtent ? d3_quantLegend(scale, labelFormat, labelDelimiter) : scale.ticks ? d3_linearLegend(scale, cells, labelFormat) : d3_ordinalLegend(scale);
    var range2 = scale.range && scale.range() || scale.domain();
    type2.labels = d3_mergeLabels(type2.labels, labels, scale.domain(), range2, labelDelimiter);
    if (ascending2) {
      type2.labels = d3_reverse(type2.labels);
      type2.data = d3_reverse(type2.data);
    }
    return type2;
  },
  d3_filterCells: function d3_filterCells(type2, cellFilter) {
    var filterCells = type2.data.map(function(d, i) {
      return { data: d, label: type2.labels[i] };
    }).filter(cellFilter);
    var dataValues = filterCells.map(function(d) {
      return d.data;
    });
    var labelValues = filterCells.map(function(d) {
      return d.label;
    });
    type2.data = type2.data.filter(function(d) {
      return dataValues.indexOf(d) !== -1;
    });
    type2.labels = type2.labels.filter(function(d) {
      return labelValues.indexOf(d) !== -1;
    });
    return type2;
  },
  d3_placement: function d3_placement(orient, cell, cellTrans, text2, textTrans, labelAlign) {
    cell.attr("transform", cellTrans);
    text2.attr("transform", textTrans);
    if (orient === "horizontal") {
      text2.style("text-anchor", labelAlign);
    }
  },
  d3_addEvents: function d3_addEvents(cells, dispatcher) {
    cells.on("mouseover.legend", function(d) {
      d3_cellOver(dispatcher, d, this);
    }).on("mouseout.legend", function(d) {
      d3_cellOut(dispatcher, d, this);
    }).on("click.legend", function(d) {
      d3_cellClick(dispatcher, d, this);
    });
  },
  d3_title: function d3_title(svg, title, classPrefix, titleWidth) {
    if (title !== "") {
      var titleText = svg.selectAll("text." + classPrefix + "legendTitle");
      titleText.data([title]).enter().append("text").attr("class", classPrefix + "legendTitle");
      svg.selectAll("text." + classPrefix + "legendTitle").text(title);
      if (titleWidth) {
        svg.selectAll("text." + classPrefix + "legendTitle").call(d3_textWrapping, titleWidth);
      }
      var cellsSvg = svg.select("." + classPrefix + "legendCells");
      var yOffset = svg.select("." + classPrefix + "legendTitle").nodes().map(function(d) {
        return d.getBBox().height;
      })[0], xOffset = -cellsSvg.nodes().map(function(d) {
        return d.getBBox().x;
      })[0];
      cellsSvg.attr("transform", "translate(" + xOffset + "," + yOffset + ")");
    }
  },
  d3_defaultLocale: {
    format,
    formatPrefix
  },
  d3_defaultFormatSpecifier: ".01f",
  d3_defaultDelimiter: "to"
};
function color() {
  var scale = linear(), shape = "rect", shapeWidth = 15, shapeHeight = 15, shapeRadius = 10, shapePadding = 2, cells = [5], cellFilter = void 0, labels = [], classPrefix = "", useClass = false, title = "", locale2 = helper.d3_defaultLocale, specifier = helper.d3_defaultFormatSpecifier, labelOffset = 10, labelAlign = "middle", labelDelimiter = helper.d3_defaultDelimiter, labelWrap = void 0, orient = "vertical", ascending2 = false, path = void 0, titleWidth = void 0, legendDispatcher = dispatch("cellover", "cellout", "cellclick");
  function legend(svg) {
    var type2 = helper.d3_calcType(scale, ascending2, cells, labels, locale2.format(specifier), labelDelimiter), legendG = svg.selectAll("g").data([scale]);
    legendG.enter().append("g").attr("class", classPrefix + "legendCells");
    if (cellFilter) {
      helper.d3_filterCells(type2, cellFilter);
    }
    var cell = svg.select("." + classPrefix + "legendCells").selectAll("." + classPrefix + "cell").data(type2.data);
    var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
    cellEnter.append(shape).attr("class", classPrefix + "swatch");
    var shapes = svg.selectAll("g." + classPrefix + "cell " + shape + "." + classPrefix + "swatch").data(type2.data);
    helper.d3_addEvents(cellEnter, legendDispatcher);
    cell.exit().transition().style("opacity", 0).remove();
    shapes.exit().transition().style("opacity", 0).remove();
    shapes = shapes.merge(shapes);
    helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path);
    var text2 = helper.d3_addText(svg, cellEnter, type2.labels, classPrefix, labelWrap);
    cell = cellEnter.merge(cell);
    var textSize = text2.nodes().map(function(d) {
      return d.getBBox();
    }), shapeSize = shapes.nodes().map(function(d) {
      return d.getBBox();
    });
    if (!useClass) {
      if (shape == "line") {
        shapes.style("stroke", type2.feature);
      } else {
        shapes.style("fill", type2.feature);
      }
    } else {
      shapes.attr("class", function(d) {
        return classPrefix + "swatch " + type2.feature(d);
      });
    }
    var cellTrans = void 0, textTrans = void 0, textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;
    if (orient === "vertical") {
      (function() {
        var cellSize = textSize.map(function(d, i) {
          return Math.max(d.height, shapeSize[i].height);
        });
        cellTrans = function cellTrans2(d, i) {
          var height = sum(cellSize.slice(0, i));
          return "translate(0, " + (height + i * shapePadding) + ")";
        };
        textTrans = function textTrans2(d, i) {
          return "translate( " + (shapeSize[i].width + shapeSize[i].x + labelOffset) + ", " + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ")";
        };
      })();
    } else if (orient === "horizontal") {
      cellTrans = function cellTrans2(d, i) {
        return "translate(" + i * (shapeSize[i].width + shapePadding) + ",0)";
      };
      textTrans = function textTrans2(d, i) {
        return "translate(" + (shapeSize[i].width * textAlign + shapeSize[i].x) + ",\n          " + (shapeSize[i].height + shapeSize[i].y + labelOffset + 8) + ")";
      };
    }
    helper.d3_placement(orient, cell, cellTrans, text2, textTrans, labelAlign);
    helper.d3_title(svg, title, classPrefix, titleWidth);
    cell.transition().style("opacity", 1);
  }
  legend.scale = function(_) {
    if (!arguments.length)
      return scale;
    scale = _;
    return legend;
  };
  legend.cells = function(_) {
    if (!arguments.length)
      return cells;
    if (_.length > 1 || _ >= 2) {
      cells = _;
    }
    return legend;
  };
  legend.cellFilter = function(_) {
    if (!arguments.length)
      return cellFilter;
    cellFilter = _;
    return legend;
  };
  legend.shape = function(_, d) {
    if (!arguments.length)
      return shape;
    if (_ == "rect" || _ == "circle" || _ == "line" || _ == "path" && typeof d === "string") {
      shape = _;
      path = d;
    }
    return legend;
  };
  legend.shapeWidth = function(_) {
    if (!arguments.length)
      return shapeWidth;
    shapeWidth = +_;
    return legend;
  };
  legend.shapeHeight = function(_) {
    if (!arguments.length)
      return shapeHeight;
    shapeHeight = +_;
    return legend;
  };
  legend.shapeRadius = function(_) {
    if (!arguments.length)
      return shapeRadius;
    shapeRadius = +_;
    return legend;
  };
  legend.shapePadding = function(_) {
    if (!arguments.length)
      return shapePadding;
    shapePadding = +_;
    return legend;
  };
  legend.labels = function(_) {
    if (!arguments.length)
      return labels;
    labels = _;
    return legend;
  };
  legend.labelAlign = function(_) {
    if (!arguments.length)
      return labelAlign;
    if (_ == "start" || _ == "end" || _ == "middle") {
      labelAlign = _;
    }
    return legend;
  };
  legend.locale = function(_) {
    if (!arguments.length)
      return locale2;
    locale2 = formatLocale(_);
    return legend;
  };
  legend.labelFormat = function(_) {
    if (!arguments.length)
      return legend.locale().format(specifier);
    specifier = formatSpecifier(_);
    return legend;
  };
  legend.labelOffset = function(_) {
    if (!arguments.length)
      return labelOffset;
    labelOffset = +_;
    return legend;
  };
  legend.labelDelimiter = function(_) {
    if (!arguments.length)
      return labelDelimiter;
    labelDelimiter = _;
    return legend;
  };
  legend.labelWrap = function(_) {
    if (!arguments.length)
      return labelWrap;
    labelWrap = _;
    return legend;
  };
  legend.useClass = function(_) {
    if (!arguments.length)
      return useClass;
    if (_ === true || _ === false) {
      useClass = _;
    }
    return legend;
  };
  legend.orient = function(_) {
    if (!arguments.length)
      return orient;
    _ = _.toLowerCase();
    if (_ == "horizontal" || _ == "vertical") {
      orient = _;
    }
    return legend;
  };
  legend.ascending = function(_) {
    if (!arguments.length)
      return ascending2;
    ascending2 = !!_;
    return legend;
  };
  legend.classPrefix = function(_) {
    if (!arguments.length)
      return classPrefix;
    classPrefix = _;
    return legend;
  };
  legend.title = function(_) {
    if (!arguments.length)
      return title;
    title = _;
    return legend;
  };
  legend.titleWidth = function(_) {
    if (!arguments.length)
      return titleWidth;
    titleWidth = _;
    return legend;
  };
  legend.textWrap = function(_) {
    if (!arguments.length)
      return textWrap;
    textWrap = _;
    return legend;
  };
  legend.on = function() {
    var value = legendDispatcher.on.apply(legendDispatcher, arguments);
    return value === legendDispatcher ? legend : value;
  };
  return legend;
}
function create_fragment$8(ctx) {
  let div2;
  return {
    c() {
      div2 = element$2("div");
      attr(div2, "class", "legend-container svelte-1a61m3u");
      set_style(
        div2,
        "max-width",
        /*width*/
        ctx[0] + "px"
      );
      set_style(
        div2,
        "max-height",
        /*height*/
        ctx[1] + "px"
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      ctx[9](div2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*width*/
      1) {
        set_style(
          div2,
          "max-width",
          /*width*/
          ctx2[0] + "px"
        );
      }
      if (dirty & /*height*/
      2) {
        set_style(
          div2,
          "max-height",
          /*height*/
          ctx2[1] + "px"
        );
      }
    },
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      ctx[9](null);
    }
  };
}
const CategoryRadius = 8;
const CategoryPadding = 8;
const ContinuousWidth = 30;
const ContinuousPadding = 1;
function instance$8($$self, $$props, $$invalidate) {
  let { width = 600 } = $$props;
  let { height = 500 } = $$props;
  let { colorScale = null } = $$props;
  let { numCells = 10 } = $$props;
  let { type: type2 = "categorical" } = $$props;
  let { fontSize = 12 } = $$props;
  let { fontWeight = "normal" } = $$props;
  let { fontFamily = "sans-serif" } = $$props;
  let container;
  let svg;
  function update2() {
    if (!!svg)
      svg.remove();
    if (!colorScale)
      return;
    let totalWidth;
    let totalHeight;
    if (type2 == "categorical") {
      totalWidth = Math.max(...colorScale.domain().map((v2) => getTextWidth(v2, `${fontWeight} ${fontSize}pt ${fontFamily}`))) + CategoryRadius * 2 + 40;
      totalHeight = colorScale.domain().length * (CategoryRadius * 2 + CategoryPadding) - CategoryPadding + 40;
    } else if (type2 == "continuous") {
      totalWidth = ContinuousWidth * numCells + ContinuousPadding * (numCells - 1) + 40;
      totalHeight = 60;
    }
    svg = select$1(container).append("svg").style("width", `${totalWidth}px`).style("height", `${totalHeight}px`).style("font-size", `${fontSize}pt`).style("font-weight", fontWeight).style("font-family", fontFamily);
    if (type2 == "categorical") {
      svg.append("g").attr("class", "legendOrdinal").attr("transform", "translate(20, 20)");
      let legendOrdinal = color().shape("circle").shapeRadius(CategoryRadius).shapePadding(CategoryPadding).orient("vertical").scale(colorScale);
      svg.select(".legendOrdinal").call(legendOrdinal);
    } else if (type2 == "continuous") {
      svg.append("g").attr("class", "legendLinear").attr("transform", "translate(20,20)");
      let legendLinear = color().shapeWidth(ContinuousWidth).shapePadding(ContinuousPadding).cells(numCells).orient("horizontal").scale(colorScale);
      svg.select(".legendLinear").call(legendLinear);
    }
  }
  onMount(() => {
    setTimeout(update2, 0);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(2, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("colorScale" in $$props2)
      $$invalidate(3, colorScale = $$props2.colorScale);
    if ("numCells" in $$props2)
      $$invalidate(4, numCells = $$props2.numCells);
    if ("type" in $$props2)
      $$invalidate(5, type2 = $$props2.type);
    if ("fontSize" in $$props2)
      $$invalidate(6, fontSize = $$props2.fontSize);
    if ("fontWeight" in $$props2)
      $$invalidate(7, fontWeight = $$props2.fontWeight);
    if ("fontFamily" in $$props2)
      $$invalidate(8, fontFamily = $$props2.fontFamily);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colorScale, width, height, container*/
    15) {
      if (!!colorScale && width > 0 && height > 0 && !!container) {
        update2();
      }
    }
  };
  return [
    width,
    height,
    container,
    colorScale,
    numCells,
    type2,
    fontSize,
    fontWeight,
    fontFamily,
    div_binding
  ];
}
class Legend extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$8, create_fragment$8, safe_not_equal, {
      width: 0,
      height: 1,
      colorScale: 3,
      numCells: 4,
      type: 5,
      fontSize: 6,
      fontWeight: 7,
      fontFamily: 8
    });
  }
}
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function create_each_block$5(ctx) {
  let div2;
  let t0_value = (
    /*option*/
    ctx[18].text + ""
  );
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[15](
        /*option*/
        ctx[18]
      )
    );
  }
  return {
    c() {
      div2 = element$2("div");
      t0 = text(t0_value);
      t1 = space();
      attr(div2, "class", "dropdown-item svelte-7xkvb7");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, t0);
      append(div2, t1);
      if (!mounted) {
        dispose = listen(div2, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*visibleOptions*/
      8 && t0_value !== (t0_value = /*option*/
      ctx[18].text + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$7(ctx) {
  let div2;
  let input;
  let input_style_value;
  let t;
  let ul;
  let div_style_value;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*visibleOptions*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
  }
  return {
    c() {
      div2 = element$2("div");
      input = element$2("input");
      t = space();
      ul = element$2("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(input, "type", "text");
      attr(input, "class", "autocomplete-input svelte-7xkvb7");
      attr(
        input,
        "placeholder",
        /*placeholder*/
        ctx[1]
      );
      attr(input, "data-toggle", "dropdown");
      attr(input, "style", input_style_value = /*fillWidth*/
      ctx[0] ? "width: 100%;" : "");
      attr(ul, "class", "dropdown-menu svelte-7xkvb7");
      set_style(
        ul,
        "visibility",
        /*autocompleteDropdownVisible*/
        ctx[5] ? "visible" : "hidden"
      );
      attr(ul, "role", "menu");
      attr(div2, "class", "autocomplete-container svelte-7xkvb7");
      attr(div2, "style", div_style_value = /*fillWidth*/
      ctx[0] ? "width: 100%;" : "");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, input);
      ctx[11](input);
      set_input_value(
        input,
        /*autocompleteText*/
        ctx[2]
      );
      append(div2, t);
      append(div2, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      ctx[16](ul);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[12]
          ),
          listen(
            input,
            "focus",
            /*focus_handler*/
            ctx[13]
          ),
          listen(
            input,
            "blur",
            /*blur_handler*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*placeholder*/
      2) {
        attr(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[1]
        );
      }
      if (dirty & /*fillWidth*/
      1 && input_style_value !== (input_style_value = /*fillWidth*/
      ctx2[0] ? "width: 100%;" : "")) {
        attr(input, "style", input_style_value);
      }
      if (dirty & /*autocompleteText*/
      4 && input.value !== /*autocompleteText*/
      ctx2[2]) {
        set_input_value(
          input,
          /*autocompleteText*/
          ctx2[2]
        );
      }
      if (dirty & /*onPointSelectorItemClick, visibleOptions*/
      136) {
        each_value = ensure_array_like(
          /*visibleOptions*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*autocompleteDropdownVisible*/
      32) {
        set_style(
          ul,
          "visibility",
          /*autocompleteDropdownVisible*/
          ctx2[5] ? "visible" : "hidden"
        );
      }
      if (dirty & /*fillWidth*/
      1 && div_style_value !== (div_style_value = /*fillWidth*/
      ctx2[0] ? "width: 100%;" : "")) {
        attr(div2, "style", div_style_value);
      }
    },
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      ctx[11](null);
      destroy_each(each_blocks, detaching);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { fillWidth = false } = $$props;
  let { placeholder = "Search..." } = $$props;
  let { maxOptions = -1 } = $$props;
  let autocomplete;
  let autocompleteDropdownVisible = false;
  let autocompleteDropdown;
  let autocompleteText;
  let selectedItem = null;
  let { options = [] } = $$props;
  let visibleOptions = [];
  function onPointSelectorItemClick(itemID) {
    $$invalidate(10, selectedItem = itemID);
    dispatch2("change", itemID);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      autocomplete = $$value;
      $$invalidate(4, autocomplete);
    });
  }
  function input_input_handler() {
    autocompleteText = this.value;
    $$invalidate(2, autocompleteText), $$invalidate(10, selectedItem);
  }
  const focus_handler = () => $$invalidate(5, autocompleteDropdownVisible = true);
  const blur_handler = () => {
    setTimeout(() => $$invalidate(5, autocompleteDropdownVisible = false), 500);
  };
  const click_handler = (option) => onPointSelectorItemClick(option.value);
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      autocompleteDropdown = $$value;
      $$invalidate(6, autocompleteDropdown);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("fillWidth" in $$props2)
      $$invalidate(0, fillWidth = $$props2.fillWidth);
    if ("placeholder" in $$props2)
      $$invalidate(1, placeholder = $$props2.placeholder);
    if ("maxOptions" in $$props2)
      $$invalidate(8, maxOptions = $$props2.maxOptions);
    if ("options" in $$props2)
      $$invalidate(9, options = $$props2.options);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selectedItem*/
    1024) {
      if (selectedItem != null)
        $$invalidate(2, autocompleteText = selectedItem.toString());
    }
    if ($$self.$$.dirty & /*autocompleteText, options, maxOptions, visibleOptions*/
    780) {
      {
        if (!!autocompleteText) {
          let searchTerm = autocompleteText.toLocaleLowerCase();
          $$invalidate(3, visibleOptions = options.filter((item) => item.text.toLocaleLowerCase().includes(searchTerm)));
          if (maxOptions >= 0 && visibleOptions.length > maxOptions)
            $$invalidate(3, visibleOptions = visibleOptions.slice(0, maxOptions));
        } else {
          $$invalidate(3, visibleOptions = []);
        }
      }
    }
  };
  return [
    fillWidth,
    placeholder,
    autocompleteText,
    visibleOptions,
    autocomplete,
    autocompleteDropdownVisible,
    autocompleteDropdown,
    onPointSelectorItemClick,
    maxOptions,
    options,
    selectedItem,
    input_binding,
    input_input_handler,
    focus_handler,
    blur_handler,
    click_handler,
    ul_binding
  ];
}
class Autocomplete extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$7, create_fragment$7, safe_not_equal, {
      fillWidth: 0,
      placeholder: 1,
      maxOptions: 8,
      options: 9
    });
  }
}
function create_if_block$3(ctx) {
  let div1;
  let div0;
  let div1_transition;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div1 = element$2("div");
      div0 = element$2("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "modal-container svelte-a2c59c");
      set_style(
        div0,
        "width",
        /*width*/
        ctx[1] + "px"
      );
      attr(div1, "class", "dimmer-view svelte-a2c59c");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*width*/
      2) {
        set_style(
          div0,
          "width",
          /*width*/
          ctx2[1] + "px"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div1_transition)
            div1_transition = create_bidirectional_transition(div1, fade, {}, true);
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, {}, false);
        div1_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div1_transition)
        div1_transition.end();
    }
  };
}
function create_fragment$6(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*visible*/
    ctx[0] && create_if_block$3(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty$2();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*visible*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*visible*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  createEventDispatcher();
  let { visible = false } = $$props;
  let { width = 300 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("visible" in $$props2)
      $$invalidate(0, visible = $$props2.visible);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [visible, width, $$scope, slots];
}
class Modal extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$6, create_fragment$6, safe_not_equal, { visible: 0, width: 1 });
  }
}
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  child_ctx[16] = i;
  return child_ctx;
}
function get_each_context_1$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_if_block_6$1(ctx) {
  let b;
  let t_value = (
    /*entry*/
    ctx[0].selectionName + ""
  );
  let t;
  return {
    c() {
      b = element$2("b");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, b, anchor);
      append(b, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*entry*/
      1 && t_value !== (t_value = /*entry*/
      ctx2[0].selectionName + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(b);
      }
    }
  };
}
function create_if_block_3$1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$1, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*thumbnailProvider*/
      ctx2[1].hasImages
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty$2();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$2(ctx) {
  let p;
  let t;
  let each_value_2 = ensure_array_like(
    /*selectionPreviewItems*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let if_block = (
    /*entry*/
    ctx[0].selectedIDs.length > /*selectionPreviewItems*/
    ctx[4].length && create_if_block_5$1(ctx)
  );
  return {
    c() {
      p = element$2("p");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      attr(p, "class", "accordion-subtitle svelte-166hsgf");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(p, null);
        }
      }
      append(p, t);
      if (if_block)
        if_block.m(p, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*entry, selectionPreviewItems*/
      17) {
        each_value_2 = ensure_array_like(
          /*selectionPreviewItems*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(p, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (
        /*entry*/
        ctx2[0].selectedIDs.length > /*selectionPreviewItems*/
        ctx2[4].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_5$1(ctx2);
          if_block.c();
          if_block.m(p, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_4$1(ctx) {
  let div2;
  let t0;
  let p;
  let t1_value = makeEtCeteraMessage(
    /*entry*/
    ctx[0].selectedIDs.length - /*isOpen*/
    (ctx[3] ? 6 : 3)
  ) + "";
  let t1;
  let current;
  let each_value_1 = ensure_array_like(
    /*entry*/
    ctx[0].selectedIDs.slice(
      0,
      /*isOpen*/
      ctx[3] ? 6 : 3
    )
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div2 = element$2("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      p = element$2("p");
      t1 = text(t1_value);
      attr(p, "class", "accordion-subtitle svelte-166hsgf");
      attr(div2, "class", "wrap-container svelte-166hsgf");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append(div2, t0);
      append(div2, p);
      append(p, t1);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*thumbnailProvider, entry, isOpen*/
      11) {
        each_value_1 = ensure_array_like(
          /*entry*/
          ctx2[0].selectedIDs.slice(
            0,
            /*isOpen*/
            ctx2[3] ? 6 : 3
          )
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, t0);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if ((!current || dirty & /*entry, isOpen*/
      9) && t1_value !== (t1_value = makeEtCeteraMessage(
        /*entry*/
        ctx2[0].selectedIDs.length - /*isOpen*/
        (ctx2[3] ? 6 : 3)
      ) + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_2(ctx) {
  let strong;
  let t0_value = (
    /*item*/
    ctx[14] + ""
  );
  let t0;
  let t1_value = (
    /*i*/
    ctx[16] == /*entry*/
    ctx[0].selectedIDs.length - 1 ? "" : ", "
  );
  let t1;
  return {
    c() {
      strong = element$2("strong");
      t0 = text(t0_value);
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, strong, anchor);
      append(strong, t0);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*selectionPreviewItems*/
      16 && t0_value !== (t0_value = /*item*/
      ctx2[14] + ""))
        set_data(t0, t0_value);
      if (dirty & /*entry*/
      1 && t1_value !== (t1_value = /*i*/
      ctx2[16] == /*entry*/
      ctx2[0].selectedIDs.length - 1 ? "" : ", "))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(strong);
        detach(t1);
      }
    }
  };
}
function create_if_block_5$1(ctx) {
  let t_value = makeEtCeteraMessage(
    /*entry*/
    ctx[0].selectedIDs.length - /*selectionPreviewItems*/
    ctx[4].length
  ) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*entry, selectionPreviewItems*/
      17 && t_value !== (t_value = makeEtCeteraMessage(
        /*entry*/
        ctx2[0].selectedIDs.length - /*selectionPreviewItems*/
        ctx2[4].length
      ) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_each_block_1$1(ctx) {
  let thumbnail;
  let current;
  thumbnail = new Thumbnail({
    props: {
      thumbnailProvider: (
        /*thumbnailProvider*/
        ctx[1]
      ),
      id: (
        /*id*/
        ctx[11]
      ),
      frame: (
        /*entry*/
        ctx[0].currentFrame
      ),
      mini: true,
      detail: false
    }
  });
  return {
    c() {
      create_component(thumbnail.$$.fragment);
    },
    m(target, anchor) {
      mount_component(thumbnail, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const thumbnail_changes = {};
      if (dirty & /*thumbnailProvider*/
      2)
        thumbnail_changes.thumbnailProvider = /*thumbnailProvider*/
        ctx2[1];
      if (dirty & /*entry, isOpen*/
      9)
        thumbnail_changes.id = /*id*/
        ctx2[11];
      if (dirty & /*entry*/
      1)
        thumbnail_changes.frame = /*entry*/
        ctx2[0].currentFrame;
      thumbnail.$set(thumbnail_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(thumbnail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(thumbnail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(thumbnail, detaching);
    }
  };
}
function create_if_block_2$2(ctx) {
  let p;
  let raw_value = (
    /*entry*/
    ctx[0].selectionDescription + ""
  );
  return {
    c() {
      p = element$2("p");
      attr(p, "class", "detail svelte-166hsgf");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      p.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty & /*entry*/
      1 && raw_value !== (raw_value = /*entry*/
      ctx2[0].selectionDescription + ""))
        p.innerHTML = raw_value;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_1$2(ctx) {
  let div2;
  let each_value = ensure_array_like(
    /*entry*/
    ctx[0].frameColors
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  return {
    c() {
      div2 = element$2("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div2, "class", "frame-color-bar svelte-166hsgf");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*entry*/
      1) {
        each_value = ensure_array_like(
          /*entry*/
          ctx2[0].frameColors
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div2, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$4(ctx) {
  let div2;
  let div_style_value;
  return {
    c() {
      div2 = element$2("div");
      attr(div2, "class", "frame-color-bar-item svelte-166hsgf");
      attr(div2, "style", div_style_value = `background-color: hsla(${/*color*/
      ctx[8][0]}, ${/*color*/
      ctx[8][1]}%, ${/*color*/
      ctx[8][2]}%, 1.0);`);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*entry*/
      1 && div_style_value !== (div_style_value = `background-color: hsla(${/*color*/
      ctx2[8][0]}, ${/*color*/
      ctx2[8][1]}%, ${/*color*/
      ctx2[8][2]}%, 1.0);`)) {
        attr(div2, "style", div_style_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block$2(ctx) {
  let p;
  let t0;
  let t1_value = (
    /*entry*/
    ctx[0].currentFrame + ""
  );
  let t1;
  let t2;
  let t3_value = (
    /*selectionComponents*/
    ctx[2].join(", ") + ""
  );
  let t3;
  let t4;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      p = element$2("p");
      t0 = text("Frame ");
      t1 = text(t1_value);
      t2 = text(", ");
      t3 = text(t3_value);
      t4 = space();
      button = element$2("button");
      button.textContent = "Load Selection";
      attr(p, "class", "detail summary-text svelte-166hsgf");
      attr(button, "class", "load-selection-btn btn btn-primary btn-sm jp-Dialog-button jp-mod-accept jp-mod-styled svelte-166hsgf");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      append(p, t1);
      append(p, t2);
      append(p, t3);
      insert(target, t4, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*entry*/
      1 && t1_value !== (t1_value = /*entry*/
      ctx2[0].currentFrame + ""))
        set_data(t1, t1_value);
      if (dirty & /*selectionComponents*/
      4 && t3_value !== (t3_value = /*selectionComponents*/
      ctx2[2].join(", ") + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
        detach(t4);
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5(ctx) {
  let button;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !!/*entry*/
  ctx[0].selectionName && create_if_block_6$1(ctx);
  let if_block1 = !!/*thumbnailProvider*/
  ctx[1] && !!/*entry*/
  ctx[0].selectedIDs && /*entry*/
  ctx[0].selectedIDs.length > 0 && create_if_block_3$1(ctx);
  let if_block2 = !!/*entry*/
  ctx[0].selectionDescription && create_if_block_2$2(ctx);
  let if_block3 = !!/*entry*/
  ctx[0].frameColors && create_if_block_1$2(ctx);
  let if_block4 = (
    /*isOpen*/
    ctx[3] && create_if_block$2(ctx)
  );
  return {
    c() {
      button = element$2("button");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      attr(
        button,
        "aria-expanded",
        /*isOpen*/
        ctx[3]
      );
      attr(button, "class", "accordion svelte-166hsgf");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (if_block0)
        if_block0.m(button, null);
      append(button, t0);
      if (if_block1)
        if_block1.m(button, null);
      append(button, t1);
      if (if_block2)
        if_block2.m(button, null);
      append(button, t2);
      if (if_block3)
        if_block3.m(button, null);
      append(button, t3);
      if (if_block4)
        if_block4.m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggle*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!!/*entry*/
      ctx2[0].selectionName) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6$1(ctx2);
          if_block0.c();
          if_block0.m(button, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!!/*thumbnailProvider*/
      ctx2[1] && !!/*entry*/
      ctx2[0].selectedIDs && /*entry*/
      ctx2[0].selectedIDs.length > 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*thumbnailProvider, entry*/
          3) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(button, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!!/*entry*/
      ctx2[0].selectionDescription) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_2$2(ctx2);
          if_block2.c();
          if_block2.m(button, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!!/*entry*/
      ctx2[0].frameColors) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_1$2(ctx2);
          if_block3.c();
          if_block3.m(button, t3);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*isOpen*/
        ctx2[3]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block$2(ctx2);
          if_block4.c();
          if_block4.m(button, null);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (!current || dirty & /*isOpen*/
      8) {
        attr(
          button,
          "aria-expanded",
          /*isOpen*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      mounted = false;
      dispose();
    }
  };
}
function makeEtCeteraMessage(num) {
  if (num == 1)
    return "and 1 other";
  else if (num <= 0)
    return "";
  return `and ${num} others`;
}
function instance$5($$self, $$props, $$invalidate) {
  let { entry } = $$props;
  let { thumbnailProvider = null } = $$props;
  let selectionPreviewItems = "";
  let selectionComponents = [];
  let isOpen = false;
  const toggle = () => $$invalidate(3, isOpen = !isOpen);
  const dispatch2 = createEventDispatcher();
  const click_handler = () => dispatch2("loadSelection", entry);
  $$self.$$set = ($$props2) => {
    if ("entry" in $$props2)
      $$invalidate(0, entry = $$props2.entry);
    if ("thumbnailProvider" in $$props2)
      $$invalidate(1, thumbnailProvider = $$props2.thumbnailProvider);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*thumbnailProvider, entry, isOpen*/
    11) {
      if (!!thumbnailProvider && !thumbnailProvider.hasImages && !!entry && !!entry.selectedIDs && entry.selectedIDs.length > 0) {
        let items = entry.selectedIDs.map((id2) => thumbnailProvider.get(id2, entry.currentFrame));
        $$invalidate(4, selectionPreviewItems = items.map((item) => item.text).slice(0, isOpen ? 10 : 3));
      }
    }
    if ($$self.$$.dirty & /*entry, selectionComponents*/
    5) {
      {
        $$invalidate(2, selectionComponents = []);
        if (!!entry.selectedIDs && entry.selectedIDs.length > 0)
          selectionComponents.push(`${entry.selectedIDs.length} selected`);
        if (!!entry.alignedIDs && entry.alignedIDs.length > 0)
          selectionComponents.push(`${entry.alignedIDs.length} aligned`);
        if (!!entry.filterIDs && entry.filterIDs.length > 0)
          selectionComponents.push(`${entry.filterIDs.length} filtered`);
      }
    }
  };
  return [
    entry,
    thumbnailProvider,
    selectionComponents,
    isOpen,
    selectionPreviewItems,
    toggle,
    dispatch2,
    click_handler
  ];
}
class SelectionBrowseItem extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$5, create_fragment$5, safe_not_equal, { entry: 0, thumbnailProvider: 1 });
  }
}
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_else_block$1(ctx) {
  let div2;
  let t;
  let current;
  let if_block = (
    /*$helpMessagesVisible*/
    ctx[6] && !!/*helpMessage*/
    ctx[5] && create_if_block_2$1(ctx)
  );
  let each_value = ensure_array_like(
    /*data*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div2 = element$2("div");
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div2, "class", "selection-browser-container svelte-1box2bm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$helpMessagesVisible*/
        ctx2[6] && !!/*helpMessage*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$helpMessagesVisible, helpMessage*/
          96) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & /*data, thumbnailProvider*/
      3) {
        each_value = ensure_array_like(
          /*data*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let div2;
  let t;
  return {
    c() {
      div2 = element$2("div");
      t = text(
        /*emptyMessage*/
        ctx[3]
      );
      attr(div2, "class", "placeholder-text svelte-1box2bm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*emptyMessage*/
      8)
        set_data(
          t,
          /*emptyMessage*/
          ctx2[3]
        );
    },
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block$1(ctx) {
  let div2;
  let t0;
  let t1;
  let i;
  return {
    c() {
      div2 = element$2("div");
      t0 = text(
        /*loadingMessage*/
        ctx[4]
      );
      t1 = space();
      i = element$2("i");
      attr(i, "class", "fa fa-spinner fa-spin");
      attr(div2, "class", "placeholder-text svelte-1box2bm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, t0);
      append(div2, t1);
      append(div2, i);
    },
    p(ctx2, dirty) {
      if (dirty & /*loadingMessage*/
      16)
        set_data(
          t0,
          /*loadingMessage*/
          ctx2[4]
        );
    },
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block_2$1(ctx) {
  let helpmessage;
  let current;
  helpmessage = new HelpMessage({
    props: {
      width: 240,
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(helpmessage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helpmessage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const helpmessage_changes = {};
      if (dirty & /*$$scope, helpMessage*/
      4128) {
        helpmessage_changes.$$scope = { dirty, ctx: ctx2 };
      }
      helpmessage.$set(helpmessage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(helpmessage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpmessage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helpmessage, detaching);
    }
  };
}
function create_default_slot$1(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty$2();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(
        /*helpMessage*/
        ctx[5],
        target,
        anchor
      );
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*helpMessage*/
      32)
        html_tag.p(
          /*helpMessage*/
          ctx2[5]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_each_block$3(ctx) {
  let selectionbrowseitem;
  let current;
  selectionbrowseitem = new SelectionBrowseItem({
    props: {
      entry: (
        /*entry*/
        ctx[9]
      ),
      thumbnailProvider: (
        /*thumbnailProvider*/
        ctx[1]
      )
    }
  });
  selectionbrowseitem.$on(
    "loadSelection",
    /*loadSelection_handler*/
    ctx[7]
  );
  return {
    c() {
      create_component(selectionbrowseitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectionbrowseitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectionbrowseitem_changes = {};
      if (dirty & /*data*/
      1)
        selectionbrowseitem_changes.entry = /*entry*/
        ctx2[9];
      if (dirty & /*thumbnailProvider*/
      2)
        selectionbrowseitem_changes.thumbnailProvider = /*thumbnailProvider*/
        ctx2[1];
      selectionbrowseitem.$set(selectionbrowseitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectionbrowseitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectionbrowseitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectionbrowseitem, detaching);
    }
  };
}
function create_fragment$4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1, create_if_block_1$1, create_else_block$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*loading*/
      ctx2[2]
    )
      return 0;
    if (
      /*data*/
      ctx2[0].length == 0
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty$2();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let $helpMessagesVisible;
  component_subscribe($$self, helpMessagesVisible, ($$value) => $$invalidate(6, $helpMessagesVisible = $$value));
  createEventDispatcher();
  let { data = [] } = $$props;
  let { thumbnailProvider = null } = $$props;
  let { loading = false } = $$props;
  let { emptyMessage = "No items yet" } = $$props;
  let { loadingMessage = "Loading..." } = $$props;
  let { helpMessage = "" } = $$props;
  function loadSelection_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("thumbnailProvider" in $$props2)
      $$invalidate(1, thumbnailProvider = $$props2.thumbnailProvider);
    if ("loading" in $$props2)
      $$invalidate(2, loading = $$props2.loading);
    if ("emptyMessage" in $$props2)
      $$invalidate(3, emptyMessage = $$props2.emptyMessage);
    if ("loadingMessage" in $$props2)
      $$invalidate(4, loadingMessage = $$props2.loadingMessage);
    if ("helpMessage" in $$props2)
      $$invalidate(5, helpMessage = $$props2.helpMessage);
  };
  return [
    data,
    thumbnailProvider,
    loading,
    emptyMessage,
    loadingMessage,
    helpMessage,
    $helpMessagesVisible,
    loadSelection_handler
  ];
}
class SelectionBrowser extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$4, create_fragment$4, safe_not_equal, {
      data: 0,
      thumbnailProvider: 1,
      loading: 2,
      emptyMessage: 3,
      loadingMessage: 4,
      helpMessage: 5
    });
  }
}
const get_summary_slot_changes = (dirty) => ({});
const get_summary_slot_context = (ctx) => ({});
function create_fragment$3(ctx) {
  let div3;
  let form;
  let div0;
  let label0;
  let t1;
  let br0;
  let t2;
  let input;
  let t3;
  let div1;
  let label1;
  let t5;
  let br1;
  let t6;
  let textarea;
  let t7;
  let div2;
  let h5;
  let t9;
  let t10;
  let div4;
  let button0;
  let t12;
  let button1;
  let current;
  let mounted;
  let dispose;
  const summary_slot_template = (
    /*#slots*/
    ctx[4].summary
  );
  const summary_slot = create_slot(
    summary_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_summary_slot_context
  );
  return {
    c() {
      div3 = element$2("div");
      form = element$2("form");
      div0 = element$2("div");
      label0 = element$2("label");
      label0.textContent = "Name of Selection:";
      t1 = space();
      br0 = element$2("br");
      t2 = space();
      input = element$2("input");
      t3 = space();
      div1 = element$2("div");
      label1 = element$2("label");
      label1.textContent = "Description:";
      t5 = space();
      br1 = element$2("br");
      t6 = space();
      textarea = element$2("textarea");
      t7 = space();
      div2 = element$2("div");
      h5 = element$2("h5");
      h5.textContent = "SUMMARY";
      t9 = space();
      if (summary_slot)
        summary_slot.c();
      t10 = space();
      div4 = element$2("div");
      button0 = element$2("button");
      button0.textContent = "Cancel";
      t12 = space();
      button1 = element$2("button");
      button1.textContent = "Save";
      attr(label0, "for", "name-of-selection");
      attr(label0, "class", "col-form-label");
      attr(input, "type", "text");
      attr(input, "class", "form-control");
      attr(input, "id", "name-of-selection");
      attr(div0, "class", "form-group");
      attr(label1, "for", "description");
      attr(label1, "class", "col-form-label");
      attr(textarea, "class", "form-control");
      attr(textarea, "id", "description");
      attr(div1, "class", "form-group");
      attr(div2, "class", "summary-info svelte-hvi61u");
      attr(div3, "class", "dialog-body");
      attr(button0, "type", "button");
      attr(button0, "class", "dialog-footer-button btn btn-secondary jp-Dialog-button jp-mod-reject jp-mod-styled svelte-hvi61u");
      attr(button1, "type", "button");
      attr(button1, "class", "dialog-footer-button btn btn-primary jp-Dialog-button jp-mod-accept jp-mod-styled svelte-hvi61u");
      attr(div4, "class", "dialog-footer svelte-hvi61u");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, form);
      append(form, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, br0);
      append(div0, t2);
      append(div0, input);
      set_input_value(
        input,
        /*name*/
        ctx[0]
      );
      append(form, t3);
      append(form, div1);
      append(div1, label1);
      append(div1, t5);
      append(div1, br1);
      append(div1, t6);
      append(div1, textarea);
      set_input_value(
        textarea,
        /*description*/
        ctx[1]
      );
      append(div3, t7);
      append(div3, div2);
      append(div2, h5);
      append(div2, t9);
      if (summary_slot) {
        summary_slot.m(div2, null);
      }
      insert(target, t10, anchor);
      insert(target, div4, anchor);
      append(div4, button0);
      append(div4, t12);
      append(div4, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[5]
          ),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[6]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[7]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*name*/
      1 && input.value !== /*name*/
      ctx2[0]) {
        set_input_value(
          input,
          /*name*/
          ctx2[0]
        );
      }
      if (dirty & /*description*/
      2) {
        set_input_value(
          textarea,
          /*description*/
          ctx2[1]
        );
      }
      if (summary_slot) {
        if (summary_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            summary_slot,
            summary_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              summary_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_summary_slot_changes
            ),
            get_summary_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(summary_slot, local);
      current = true;
    },
    o(local) {
      transition_out(summary_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
        detach(t10);
        detach(div4);
      }
      if (summary_slot)
        summary_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name: name2 = "" } = $$props;
  let { description = "" } = $$props;
  const dispatch2 = createEventDispatcher();
  function input_input_handler() {
    name2 = this.value;
    $$invalidate(0, name2);
  }
  function textarea_input_handler() {
    description = this.value;
    $$invalidate(1, description);
  }
  const click_handler = () => dispatch2("cancel");
  const click_handler_1 = () => dispatch2("save");
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name2 = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [
    name2,
    description,
    dispatch2,
    $$scope,
    slots,
    input_input_handler,
    textarea_input_handler,
    click_handler,
    click_handler_1
  ];
}
class SaveSelectionPane extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$3, create_fragment$3, safe_not_equal, { name: 0, description: 1 });
  }
}
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  child_ctx[7] = i;
  return child_ctx;
}
function create_each_block$2(ctx) {
  let li;
  let input;
  let input_value_value;
  let value_has_changed = false;
  let t0;
  let label;
  let t1_value = (
    /*option*/
    ctx[5].name + ""
  );
  let t1;
  let t2;
  let binding_group;
  let mounted;
  let dispose;
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[4][0]
  );
  return {
    c() {
      li = element$2("li");
      input = element$2("input");
      t0 = space();
      label = element$2("label");
      t1 = text(t1_value);
      t2 = space();
      attr(input, "class", "segmented-control__input svelte-1jy9oml");
      attr(input, "type", "radio");
      input.__value = input_value_value = /*option*/
      ctx[5].value;
      set_input_value(input, input.__value);
      attr(
        input,
        "name",
        /*randomID*/
        ctx[2]
      );
      attr(
        input,
        "id",
        /*randomID*/
        ctx[2] + "-" + /*i*/
        (ctx[7] + 1)
      );
      attr(label, "class", "segmented-control__label svelte-1jy9oml");
      attr(
        label,
        "for",
        /*randomID*/
        ctx[2] + "-" + /*i*/
        (ctx[7] + 1)
      );
      attr(li, "class", "segmented-control__item svelte-1jy9oml");
      set_style(li, "width", (100 / /*options*/
      ctx[1].length).toFixed(0) + "%");
      binding_group.p(input);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, input);
      input.checked = input.__value === /*selected*/
      ctx[0];
      append(li, t0);
      append(li, label);
      append(label, t1);
      append(li, t2);
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      2 && input_value_value !== (input_value_value = /*option*/
      ctx2[5].value)) {
        input.__value = input_value_value;
        set_input_value(input, input.__value);
        value_has_changed = true;
      }
      if (value_has_changed || dirty & /*selected, options*/
      3) {
        input.checked = input.__value === /*selected*/
        ctx2[0];
      }
      if (dirty & /*options*/
      2 && t1_value !== (t1_value = /*option*/
      ctx2[5].name + ""))
        set_data(t1, t1_value);
      if (dirty & /*options*/
      2) {
        set_style(li, "width", (100 / /*options*/
        ctx2[1].length).toFixed(0) + "%");
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      binding_group.r();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2(ctx) {
  let ul;
  let each_value = ensure_array_like(
    /*options*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  return {
    c() {
      ul = element$2("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(ul, "class", "segmented-control svelte-1jy9oml");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*options, randomID, selected*/
      7) {
        each_value = ensure_array_like(
          /*options*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let { selected = 1 } = $$props;
  let { options = [{ value: 1, name: "A" }, { value: 2, name: "B" }] } = $$props;
  let randomID = "segmented-control-" + Math.floor(Math.random() * 1e8);
  const $$binding_groups = [[]];
  function input_change_handler() {
    selected = this.__value;
    $$invalidate(0, selected);
  }
  $$self.$$set = ($$props2) => {
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
  };
  return [selected, options, randomID, input_change_handler, $$binding_groups];
}
class SegmentedControl extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$2, create_fragment$2, safe_not_equal, { selected: 0, options: 1 });
  }
}
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let option;
  let t_value = (
    /*scheme*/
    ctx[23] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element$2("option");
      t = text(t_value);
      option.__value = option_value_value = /*scheme*/
      ctx[23];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*colorSchemes*/
      64 && t_value !== (t_value = /*scheme*/
      ctx2[23] + ""))
        set_data(t, t_value);
      if (dirty & /*colorSchemes*/
      64 && option_value_value !== (option_value_value = /*scheme*/
      ctx2[23])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block$1(ctx) {
  let option;
  let t_value = (
    /*mode*/
    ctx[20] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element$2("option");
      t = text(t_value);
      option.__value = option_value_value = /*mode*/
      ctx[20];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*previewModes*/
      32 && t_value !== (t_value = /*mode*/
      ctx2[20] + ""))
        set_data(t, t_value);
      if (dirty & /*previewModes*/
      32 && option_value_value !== (option_value_value = /*mode*/
      ctx2[20])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_fragment$1(ctx) {
  let div6;
  let form;
  let div0;
  let label0;
  let t1;
  let select0;
  let t2;
  let div1;
  let label1;
  let t3;
  let t4;
  let t5;
  let input0;
  let t6;
  let p0;
  let t8;
  let div2;
  let input1;
  let t9;
  let label2;
  let t11;
  let div3;
  let label3;
  let t13;
  let select1;
  let t14;
  let div4;
  let label4;
  let t15;
  let t16;
  let t17;
  let input2;
  let t18;
  let p1;
  let t20;
  let div5;
  let label5;
  let t21;
  let t22_value = (
    /*similarityThreshold*/
    ctx[2].toFixed(2) + ""
  );
  let t22;
  let t23;
  let input3;
  let t24;
  let p2;
  let t26;
  let div7;
  let button;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like(
    /*colorSchemes*/
    ctx[6]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ensure_array_like(
    /*previewModes*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  return {
    c() {
      div6 = element$2("div");
      form = element$2("form");
      div0 = element$2("div");
      label0 = element$2("label");
      label0.textContent = "Color Scheme";
      t1 = space();
      select0 = element$2("select");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      div1 = element$2("div");
      label1 = element$2("label");
      t3 = text("Neighbor Count: ");
      t4 = text(
        /*numNeighborsValue*/
        ctx[7]
      );
      t5 = space();
      input0 = element$2("input");
      t6 = space();
      p0 = element$2("p");
      p0.textContent = "The number of neighbors displayed in the scatterplot and sidebar.";
      t8 = space();
      div2 = element$2("div");
      input1 = element$2("input");
      t9 = space();
      label2 = element$2("label");
      label2.textContent = "Show Legend";
      t11 = space();
      div3 = element$2("div");
      label3 = element$2("label");
      label3.textContent = "Preview Mode";
      t13 = space();
      select1 = element$2("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t14 = space();
      div4 = element$2("div");
      label4 = element$2("label");
      t15 = text("Preview Neighbor Count: ");
      t16 = text(
        /*previewK*/
        ctx[1]
      );
      t17 = space();
      input2 = element$2("input");
      t18 = space();
      p1 = element$2("p");
      p1.textContent = "The number of neighbors used to calculate pointwise similarity between\n      frames.";
      t20 = space();
      div5 = element$2("div");
      label5 = element$2("label");
      t21 = text("Similarity Threshold: ");
      t22 = text(t22_value);
      t23 = space();
      input3 = element$2("input");
      t24 = space();
      p2 = element$2("p");
      p2.textContent = "If the fraction of neighbors that stay constant between frames is above\n      this threshold, a preview line will not be shown.";
      t26 = space();
      div7 = element$2("div");
      button = element$2("button");
      button.textContent = "Close";
      attr(label0, "for", "color-scheme");
      attr(label0, "class", "col-form-label svelte-k9wp50");
      attr(select0, "id", "color-scheme");
      attr(select0, "class", "col-form-element svelte-k9wp50");
      if (
        /*colorScheme*/
        ctx[3] === void 0
      )
        add_render_callback(() => (
          /*select0_change_handler*/
          ctx[11].call(select0)
        ));
      attr(div0, "class", "form-row svelte-k9wp50");
      attr(label1, "for", "neighbor-k");
      attr(label1, "class", "col-form-label svelte-k9wp50");
      attr(input0, "class", "col-form-element svelte-k9wp50");
      attr(input0, "type", "range");
      attr(input0, "min", "5");
      attr(input0, "max", "100");
      attr(input0, "step", "5");
      attr(input0, "id", "neighbor-k");
      attr(div1, "class", "form-row svelte-k9wp50");
      attr(p0, "class", "help-text svelte-k9wp50");
      attr(input1, "type", "checkbox");
      attr(input1, "id", "show-legend");
      attr(label2, "for", "show-legend");
      set_style(label2, "padding-left", "12px");
      attr(div2, "class", "form-row svelte-k9wp50");
      attr(label3, "for", "preview-mode");
      attr(label3, "class", "col-form-label svelte-k9wp50");
      attr(select1, "id", "preview-mode");
      attr(select1, "class", "col-form-element svelte-k9wp50");
      if (
        /*previewMode*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select1_change_handler*/
          ctx[14].call(select1)
        ));
      attr(div3, "class", "form-row svelte-k9wp50");
      attr(label4, "for", "preview-k");
      attr(label4, "class", "col-form-label svelte-k9wp50");
      attr(input2, "class", "col-form-element svelte-k9wp50");
      attr(input2, "type", "range");
      attr(input2, "min", "5");
      attr(input2, "max", "100");
      attr(input2, "step", "5");
      attr(input2, "id", "preview-k");
      attr(div4, "class", "form-row svelte-k9wp50");
      attr(p1, "class", "help-text svelte-k9wp50");
      attr(label5, "for", "similarity-threshold");
      attr(label5, "class", "col-form-label svelte-k9wp50");
      attr(input3, "type", "range");
      attr(input3, "min", "0");
      attr(input3, "max", "1");
      attr(input3, "step", "0.05");
      attr(input3, "class", "col-form-element svelte-k9wp50");
      attr(input3, "id", "similarity-threshold");
      attr(div5, "class", "form-row svelte-k9wp50");
      attr(p2, "class", "help-text svelte-k9wp50");
      attr(div6, "class", "dialog-body");
      attr(button, "type", "button");
      attr(button, "class", "dialog-footer-button btn btn-secondary jp-Dialog-button jp-mod-reject jp-mod-styled svelte-k9wp50");
      attr(div7, "class", "dialog-footer svelte-k9wp50");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, form);
      append(form, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, select0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(select0, null);
        }
      }
      select_option(
        select0,
        /*colorScheme*/
        ctx[3],
        true
      );
      append(form, t2);
      append(form, div1);
      append(div1, label1);
      append(label1, t3);
      append(label1, t4);
      append(div1, t5);
      append(div1, input0);
      set_input_value(
        input0,
        /*numNeighborsValue*/
        ctx[7]
      );
      append(form, t6);
      append(form, p0);
      append(form, t8);
      append(form, div2);
      append(div2, input1);
      input1.checked = /*showLegend*/
      ctx[4];
      append(div2, t9);
      append(div2, label2);
      append(form, t11);
      append(form, div3);
      append(div3, label3);
      append(div3, t13);
      append(div3, select1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select1, null);
        }
      }
      select_option(
        select1,
        /*previewMode*/
        ctx[0],
        true
      );
      append(form, t14);
      append(form, div4);
      append(div4, label4);
      append(label4, t15);
      append(label4, t16);
      append(div4, t17);
      append(div4, input2);
      set_input_value(
        input2,
        /*previewK*/
        ctx[1]
      );
      append(form, t18);
      append(form, p1);
      append(form, t20);
      append(form, div5);
      append(div5, label5);
      append(label5, t21);
      append(label5, t22);
      append(div5, t23);
      append(div5, input3);
      set_input_value(
        input3,
        /*similarityThreshold*/
        ctx[2]
      );
      append(form, t24);
      append(form, p2);
      insert(target, t26, anchor);
      insert(target, div7, anchor);
      append(div7, button);
      if (!mounted) {
        dispose = [
          listen(
            select0,
            "change",
            /*select0_change_handler*/
            ctx[11]
          ),
          listen(
            input0,
            "change",
            /*input0_change_input_handler*/
            ctx[12]
          ),
          listen(
            input0,
            "input",
            /*input0_change_input_handler*/
            ctx[12]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[13]
          ),
          listen(
            select1,
            "change",
            /*select1_change_handler*/
            ctx[14]
          ),
          listen(
            input2,
            "change",
            /*input2_change_input_handler*/
            ctx[15]
          ),
          listen(
            input2,
            "input",
            /*input2_change_input_handler*/
            ctx[15]
          ),
          listen(
            input3,
            "change",
            /*input3_change_input_handler*/
            ctx[16]
          ),
          listen(
            input3,
            "input",
            /*input3_change_input_handler*/
            ctx[16]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[17]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*colorSchemes*/
      64) {
        each_value_1 = ensure_array_like(
          /*colorSchemes*/
          ctx2[6]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(select0, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*colorScheme, colorSchemes*/
      72) {
        select_option(
          select0,
          /*colorScheme*/
          ctx2[3]
        );
      }
      if (dirty & /*numNeighborsValue*/
      128)
        set_data(
          t4,
          /*numNeighborsValue*/
          ctx2[7]
        );
      if (dirty & /*numNeighborsValue*/
      128) {
        set_input_value(
          input0,
          /*numNeighborsValue*/
          ctx2[7]
        );
      }
      if (dirty & /*showLegend*/
      16) {
        input1.checked = /*showLegend*/
        ctx2[4];
      }
      if (dirty & /*previewModes*/
      32) {
        each_value = ensure_array_like(
          /*previewModes*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*previewMode, previewModes*/
      33) {
        select_option(
          select1,
          /*previewMode*/
          ctx2[0]
        );
      }
      if (dirty & /*previewK*/
      2)
        set_data(
          t16,
          /*previewK*/
          ctx2[1]
        );
      if (dirty & /*previewK*/
      2) {
        set_input_value(
          input2,
          /*previewK*/
          ctx2[1]
        );
      }
      if (dirty & /*similarityThreshold*/
      4 && t22_value !== (t22_value = /*similarityThreshold*/
      ctx2[2].toFixed(2) + ""))
        set_data(t22, t22_value);
      if (dirty & /*similarityThreshold*/
      4) {
        set_input_value(
          input3,
          /*similarityThreshold*/
          ctx2[2]
        );
      }
    },
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(div6);
        detach(t26);
        detach(div7);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let { previewMode = "" } = $$props;
  let { previewModes = [] } = $$props;
  let { numNeighbors = 10 } = $$props;
  let numNeighborsValue = 10;
  let oldNumNeighbors = 10;
  let numNeighborsTimeout = null;
  function updateNumNeighbors() {
    if (!!numNeighborsTimeout)
      clearTimeout(numNeighborsTimeout);
    numNeighborsTimeout = setTimeout(
      () => {
        $$invalidate(9, numNeighbors = numNeighborsValue);
      },
      100
    );
  }
  let { previewK = 10 } = $$props;
  let { similarityThreshold = 0.5 } = $$props;
  let { colorScheme = "" } = $$props;
  let { colorSchemes: colorSchemes2 = [] } = $$props;
  let { showLegend = true } = $$props;
  const dispatch2 = createEventDispatcher();
  function select0_change_handler() {
    colorScheme = select_value(this);
    $$invalidate(3, colorScheme);
    $$invalidate(6, colorSchemes2);
  }
  function input0_change_input_handler() {
    numNeighborsValue = to_number(this.value);
    $$invalidate(7, numNeighborsValue), $$invalidate(9, numNeighbors);
  }
  function input1_change_handler() {
    showLegend = this.checked;
    $$invalidate(4, showLegend);
  }
  function select1_change_handler() {
    previewMode = select_value(this);
    $$invalidate(0, previewMode);
    $$invalidate(5, previewModes);
  }
  function input2_change_input_handler() {
    previewK = to_number(this.value);
    $$invalidate(1, previewK);
  }
  function input3_change_input_handler() {
    similarityThreshold = to_number(this.value);
    $$invalidate(2, similarityThreshold);
  }
  const click_handler = () => dispatch2("close");
  $$self.$$set = ($$props2) => {
    if ("previewMode" in $$props2)
      $$invalidate(0, previewMode = $$props2.previewMode);
    if ("previewModes" in $$props2)
      $$invalidate(5, previewModes = $$props2.previewModes);
    if ("numNeighbors" in $$props2)
      $$invalidate(9, numNeighbors = $$props2.numNeighbors);
    if ("previewK" in $$props2)
      $$invalidate(1, previewK = $$props2.previewK);
    if ("similarityThreshold" in $$props2)
      $$invalidate(2, similarityThreshold = $$props2.similarityThreshold);
    if ("colorScheme" in $$props2)
      $$invalidate(3, colorScheme = $$props2.colorScheme);
    if ("colorSchemes" in $$props2)
      $$invalidate(6, colorSchemes2 = $$props2.colorSchemes);
    if ("showLegend" in $$props2)
      $$invalidate(4, showLegend = $$props2.showLegend);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*numNeighbors*/
    512) {
      $$invalidate(7, numNeighborsValue = numNeighbors);
    }
    if ($$self.$$.dirty & /*oldNumNeighbors, numNeighborsValue*/
    1152) {
      if (oldNumNeighbors != numNeighborsValue) {
        updateNumNeighbors();
        $$invalidate(10, oldNumNeighbors = numNeighborsValue);
      }
    }
  };
  return [
    previewMode,
    previewK,
    similarityThreshold,
    colorScheme,
    showLegend,
    previewModes,
    colorSchemes2,
    numNeighborsValue,
    dispatch2,
    numNeighbors,
    oldNumNeighbors,
    select0_change_handler,
    input0_change_input_handler,
    input1_change_handler,
    select1_change_handler,
    input2_change_input_handler,
    input3_change_input_handler,
    click_handler
  ];
}
class SettingsPane extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance$1, create_fragment$1, safe_not_equal, {
      previewMode: 0,
      previewModes: 5,
      numNeighbors: 9,
      previewK: 1,
      similarityThreshold: 2,
      colorScheme: 3,
      colorSchemes: 6,
      showLegend: 4
    });
  }
}
class ThumbnailProvider {
  constructor(dataset) {
    __publicField(this, "blobURLs", /* @__PURE__ */ new Map());
    __publicField(this, "hasImages", false);
    __publicField(this, "dataset");
    this.dataset = dataset;
    this.updateImageThumbnails();
  }
  updateImageThumbnails() {
    if (this.blobURLs.size > 0)
      this.destroy();
    if (!!this.dataset.spritesheets) {
      this.hasImages = true;
      Object.keys(this.dataset.spritesheets).forEach((sheet) => {
        let sheetInfo = this.dataset.spritesheets[sheet];
        let blob = base64ToBlob(sheetInfo.image, sheetInfo.imageFormat);
        this.blobURLs.set(sheet, URL.createObjectURL(blob));
      });
    } else {
      this.hasImages = false;
    }
  }
  destroy() {
    for (var sheet of this.blobURLs.keys()) {
      URL.revokeObjectURL(this.blobURLs.get(sheet));
    }
    this.blobURLs.clear();
    this.hasImages = false;
  }
  get(id2, inFrame, into = null) {
    if (into == null) {
      into = {};
    }
    let itemInfo = this.dataset.frame(inFrame).get(id2, "label");
    if (!itemInfo)
      return {
        id: id2,
        text: id2.toString()
      };
    into.id = id2;
    into.text = itemInfo.text;
    into.description = itemInfo.description;
    if (!!itemInfo.sheet && !!this.dataset.spritesheets && !!this.dataset.spritesheets[itemInfo.sheet]) {
      into.src = this.blobURLs.get(itemInfo.sheet);
      let sheet = this.dataset.spritesheets[itemInfo.sheet];
      into.spec = sheet.spec.frames[itemInfo.texture];
      into.macroSize = sheet.spec.meta.size;
    }
    return into;
  }
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[140] = list[i];
  return child_ctx;
}
function create_else_block_2(ctx) {
  let t;
  return {
    c() {
      t = text("No filter");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$3,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_10(ctx) {
  let t0_value = (
    /*$filterIDs*/
    ctx[5].length + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" points");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$filterIDs*/
      32 && t0_value !== (t0_value = /*$filterIDs*/
      ctx2[5].length + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_else_block_1(ctx) {
  let t;
  return {
    c() {
      t = text("No alignment");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$3,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_9(ctx) {
  let t0_value = (
    /*$alignedIDs*/
    ctx[6].length + ""
  );
  let t0;
  let t1;
  let t2;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" points, to frame ");
      t2 = text(
        /*$alignedFrame*/
        ctx[28]
      );
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$alignedIDs*/
      64 && t0_value !== (t0_value = /*$alignedIDs*/
      ctx2[6].length + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*$alignedFrame*/
      268435456)
        set_data(
          t2,
          /*$alignedFrame*/
          ctx2[28]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_summary_slot(ctx) {
  let div2;
  let p0;
  let strong0;
  let t1;
  let t2;
  let t3;
  let p1;
  let strong1;
  let t5;
  let t6;
  let p2;
  let strong2;
  let t8;
  let t9_value = (
    /*$selectedIDs*/
    ctx[11].length + ""
  );
  let t9;
  let t10;
  let t11;
  let p3;
  let strong3;
  let t13;
  function select_block_type(ctx2, dirty) {
    if (
      /*$filterIDs*/
      ctx2[5].length > 0
    )
      return create_if_block_10;
    return create_else_block_2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$alignedIDs*/
      ctx2[6].length > 0
    )
      return create_if_block_9;
    return create_else_block_1;
  }
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block1 = current_block_type_1(ctx);
  return {
    c() {
      div2 = element$2("div");
      p0 = element$2("p");
      strong0 = element$2("strong");
      strong0.textContent = "Frame number:";
      t1 = space();
      t2 = text(
        /*$currentFrame*/
        ctx[8]
      );
      t3 = space();
      p1 = element$2("p");
      strong1 = element$2("strong");
      strong1.textContent = "Filter:";
      t5 = space();
      if_block0.c();
      t6 = space();
      p2 = element$2("p");
      strong2 = element$2("strong");
      strong2.textContent = "Selected:";
      t8 = space();
      t9 = text(t9_value);
      t10 = text(" points");
      t11 = space();
      p3 = element$2("p");
      strong3 = element$2("strong");
      strong3.textContent = "Aligned:";
      t13 = space();
      if_block1.c();
      attr(div2, "slot", "summary");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, p0);
      append(p0, strong0);
      append(p0, t1);
      append(p0, t2);
      append(div2, t3);
      append(div2, p1);
      append(p1, strong1);
      append(p1, t5);
      if_block0.m(p1, null);
      append(div2, t6);
      append(div2, p2);
      append(p2, strong2);
      append(p2, t8);
      append(p2, t9);
      append(p2, t10);
      append(div2, t11);
      append(div2, p3);
      append(p3, strong3);
      append(p3, t13);
      if_block1.m(p3, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$currentFrame*/
      256)
        set_data(
          t2,
          /*$currentFrame*/
          ctx2[8]
        );
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(p1, null);
        }
      }
      if (dirty[0] & /*$selectedIDs*/
      2048 && t9_value !== (t9_value = /*$selectedIDs*/
      ctx2[11].length + ""))
        set_data(t9, t9_value);
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(p3, null);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_block0.d();
      if_block1.d();
    }
  };
}
function create_default_slot_3(ctx) {
  let saveselectionpane;
  let updating_name;
  let updating_description;
  let current;
  function saveselectionpane_name_binding(value) {
    ctx[94](value);
  }
  function saveselectionpane_description_binding(value) {
    ctx[95](value);
  }
  let saveselectionpane_props = {
    $$slots: { summary: [create_summary_slot] },
    $$scope: { ctx }
  };
  if (
    /*$selectionName*/
    ctx[30] !== void 0
  ) {
    saveselectionpane_props.name = /*$selectionName*/
    ctx[30];
  }
  if (
    /*$selectionDescription*/
    ctx[29] !== void 0
  ) {
    saveselectionpane_props.description = /*$selectionDescription*/
    ctx[29];
  }
  saveselectionpane = new SaveSelectionPane({ props: saveselectionpane_props });
  binding_callbacks.push(() => bind$4(saveselectionpane, "name", saveselectionpane_name_binding));
  binding_callbacks.push(() => bind$4(saveselectionpane, "description", saveselectionpane_description_binding));
  saveselectionpane.$on(
    "cancel",
    /*cancel_handler*/
    ctx[96]
  );
  saveselectionpane.$on(
    "save",
    /*saveSelection*/
    ctx[67]
  );
  return {
    c() {
      create_component(saveselectionpane.$$.fragment);
    },
    m(target, anchor) {
      mount_component(saveselectionpane, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const saveselectionpane_changes = {};
      if (dirty[0] & /*$alignedFrame, $alignedIDs, $selectedIDs, $filterIDs, $currentFrame*/
      268437856 | dirty[4] & /*$$scope*/
      524288) {
        saveselectionpane_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_name && dirty[0] & /*$selectionName*/
      1073741824) {
        updating_name = true;
        saveselectionpane_changes.name = /*$selectionName*/
        ctx2[30];
        add_flush_callback(() => updating_name = false);
      }
      if (!updating_description && dirty[0] & /*$selectionDescription*/
      536870912) {
        updating_description = true;
        saveselectionpane_changes.description = /*$selectionDescription*/
        ctx2[29];
        add_flush_callback(() => updating_description = false);
      }
      saveselectionpane.$set(saveselectionpane_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(saveselectionpane.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(saveselectionpane.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(saveselectionpane, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let settingspane;
  let updating_colorScheme;
  let updating_showLegend;
  let updating_previewMode;
  let updating_numNeighbors;
  let updating_previewK;
  let updating_similarityThreshold;
  let current;
  function settingspane_colorScheme_binding(value) {
    ctx[97](value);
  }
  function settingspane_showLegend_binding(value) {
    ctx[98](value);
  }
  function settingspane_previewMode_binding(value) {
    ctx[99](value);
  }
  function settingspane_numNeighbors_binding(value) {
    ctx[100](value);
  }
  function settingspane_previewK_binding(value) {
    ctx[101](value);
  }
  function settingspane_similarityThreshold_binding(value) {
    ctx[102](value);
  }
  let settingspane_props = {
    previewModes: Object.values(PreviewMode),
    colorSchemes: ColorSchemes.allColorSchemes.map(func)
  };
  if (
    /*$colorScheme*/
    ctx[14] !== void 0
  ) {
    settingspane_props.colorScheme = /*$colorScheme*/
    ctx[14];
  }
  if (
    /*showLegend*/
    ctx[23] !== void 0
  ) {
    settingspane_props.showLegend = /*showLegend*/
    ctx[23];
  }
  if (
    /*$previewMode*/
    ctx[9] !== void 0
  ) {
    settingspane_props.previewMode = /*$previewMode*/
    ctx[9];
  }
  if (
    /*$numNeighbors*/
    ctx[31] !== void 0
  ) {
    settingspane_props.numNeighbors = /*$numNeighbors*/
    ctx[31];
  }
  if (
    /*previewK*/
    ctx[2] !== void 0
  ) {
    settingspane_props.previewK = /*previewK*/
    ctx[2];
  }
  if (
    /*previewSimilarityThreshold*/
    ctx[3] !== void 0
  ) {
    settingspane_props.similarityThreshold = /*previewSimilarityThreshold*/
    ctx[3];
  }
  settingspane = new SettingsPane({ props: settingspane_props });
  binding_callbacks.push(() => bind$4(settingspane, "colorScheme", settingspane_colorScheme_binding));
  binding_callbacks.push(() => bind$4(settingspane, "showLegend", settingspane_showLegend_binding));
  binding_callbacks.push(() => bind$4(settingspane, "previewMode", settingspane_previewMode_binding));
  binding_callbacks.push(() => bind$4(settingspane, "numNeighbors", settingspane_numNeighbors_binding));
  binding_callbacks.push(() => bind$4(settingspane, "previewK", settingspane_previewK_binding));
  binding_callbacks.push(() => bind$4(settingspane, "similarityThreshold", settingspane_similarityThreshold_binding));
  settingspane.$on(
    "close",
    /*close_handler*/
    ctx[103]
  );
  return {
    c() {
      create_component(settingspane.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingspane, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingspane_changes = {};
      if (!updating_colorScheme && dirty[0] & /*$colorScheme*/
      16384) {
        updating_colorScheme = true;
        settingspane_changes.colorScheme = /*$colorScheme*/
        ctx2[14];
        add_flush_callback(() => updating_colorScheme = false);
      }
      if (!updating_showLegend && dirty[0] & /*showLegend*/
      8388608) {
        updating_showLegend = true;
        settingspane_changes.showLegend = /*showLegend*/
        ctx2[23];
        add_flush_callback(() => updating_showLegend = false);
      }
      if (!updating_previewMode && dirty[0] & /*$previewMode*/
      512) {
        updating_previewMode = true;
        settingspane_changes.previewMode = /*$previewMode*/
        ctx2[9];
        add_flush_callback(() => updating_previewMode = false);
      }
      if (!updating_numNeighbors && dirty[1] & /*$numNeighbors*/
      1) {
        updating_numNeighbors = true;
        settingspane_changes.numNeighbors = /*$numNeighbors*/
        ctx2[31];
        add_flush_callback(() => updating_numNeighbors = false);
      }
      if (!updating_previewK && dirty[0] & /*previewK*/
      4) {
        updating_previewK = true;
        settingspane_changes.previewK = /*previewK*/
        ctx2[2];
        add_flush_callback(() => updating_previewK = false);
      }
      if (!updating_similarityThreshold && dirty[0] & /*previewSimilarityThreshold*/
      8) {
        updating_similarityThreshold = true;
        settingspane_changes.similarityThreshold = /*previewSimilarityThreshold*/
        ctx2[3];
        add_flush_callback(() => updating_similarityThreshold = false);
      }
      settingspane.$set(settingspane_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingspane.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingspane.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingspane, detaching);
    }
  };
}
function create_else_block(ctx) {
  let div11;
  let div2;
  let t0;
  let div0;
  let t1;
  let div1;
  let t3;
  let div4;
  let div3;
  let synchronizedscatterplot;
  let updating_hoveredID;
  let updating_clickedIDs;
  let updating_alignedIDs;
  let updating_filterIDs;
  let t4;
  let t5;
  let div10;
  let div5;
  let t6;
  let autocomplete;
  let t7;
  let div6;
  let segmentedcontrol;
  let updating_selected;
  let t8;
  let div7;
  let current_block_type_index;
  let if_block3;
  let t9;
  let div9;
  let t10;
  let div8;
  let t11;
  let button0;
  let t12;
  let button0_class_value;
  let t13;
  let button1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$helpMessagesVisible*/
    ctx[33] && create_if_block_8(ctx)
  );
  let each_value = ensure_array_like([...range$1(
    /*dataset*/
    ctx[0].frameCount
  )]);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  function synchronizedscatterplot_hoveredID_binding(value) {
    ctx[106](value);
  }
  function synchronizedscatterplot_clickedIDs_binding(value) {
    ctx[107](value);
  }
  function synchronizedscatterplot_alignedIDs_binding(value) {
    ctx[108](value);
  }
  function synchronizedscatterplot_filterIDs_binding(value) {
    ctx[109](value);
  }
  let synchronizedscatterplot_props = {
    data: (
      /*dataset*/
      ctx[0]
    ),
    padding: (
      /*$plotPadding*/
      ctx[35]
    ),
    frame: (
      /*$currentFrame*/
      ctx[8]
    ),
    previewFrame: (
      /*$previewFrame*/
      ctx[7]
    ),
    numNeighbors: (
      /*$numNeighbors*/
      ctx[31]
    ),
    hoverable: true,
    showPreviewControls: true,
    animateTransitions: true,
    backgroundColor: (
      /*$previewFrame*/
      ctx[7] != /*$currentFrame*/
      ctx[8] && /*$previewFrame*/
      ctx[7] != -1 ? "#f8f8ff" : "white"
    ),
    colorScheme: (
      /*colorSchemeObject*/
      ctx[15]
    ),
    selectionOrderFn: (
      /*selectionOrderFn*/
      ctx[83]
    ),
    selectionUnits: !!/*$selectionUnit*/
    ctx[36] ? [
      "pixels",
      /*$selectionUnit*/
      ctx[36]
    ] : ["pixels"]
  };
  if (
    /*scatterplotHoveredID*/
    ctx[18] !== void 0
  ) {
    synchronizedscatterplot_props.hoveredID = /*scatterplotHoveredID*/
    ctx[18];
  }
  if (
    /*$selectedIDs*/
    ctx[11] !== void 0
  ) {
    synchronizedscatterplot_props.clickedIDs = /*$selectedIDs*/
    ctx[11];
  }
  if (
    /*$alignedIDs*/
    ctx[6] !== void 0
  ) {
    synchronizedscatterplot_props.alignedIDs = /*$alignedIDs*/
    ctx[6];
  }
  if (
    /*$filterIDs*/
    ctx[5] !== void 0
  ) {
    synchronizedscatterplot_props.filterIDs = /*$filterIDs*/
    ctx[5];
  }
  synchronizedscatterplot = new SynchronizedScatterplot({ props: synchronizedscatterplot_props });
  ctx[105](synchronizedscatterplot);
  binding_callbacks.push(() => bind$4(synchronizedscatterplot, "hoveredID", synchronizedscatterplot_hoveredID_binding));
  binding_callbacks.push(() => bind$4(synchronizedscatterplot, "clickedIDs", synchronizedscatterplot_clickedIDs_binding));
  binding_callbacks.push(() => bind$4(synchronizedscatterplot, "alignedIDs", synchronizedscatterplot_alignedIDs_binding));
  binding_callbacks.push(() => bind$4(synchronizedscatterplot, "filterIDs", synchronizedscatterplot_filterIDs_binding));
  synchronizedscatterplot.$on(
    "datahover",
    /*onScatterplotHover*/
    ctx[79]
  );
  synchronizedscatterplot.$on(
    "viewportChanged",
    /*viewportChanged_handler*/
    ctx[110]
  );
  synchronizedscatterplot.$on(
    "logEvent",
    /*logEvent_handler*/
    ctx[111]
  );
  let if_block1 = (
    /*showLegend*/
    ctx[23] && create_if_block_7(ctx)
  );
  let if_block2 = (
    /*$helpMessagesVisible*/
    ctx[33] && create_if_block_6(ctx)
  );
  autocomplete = new Autocomplete({
    props: {
      placeholder: "Search for a point...",
      options: (
        /*pointSelectorOptions*/
        ctx[25]
      ),
      maxOptions: 10,
      fillWidth: true
    }
  });
  autocomplete.$on(
    "change",
    /*change_handler*/
    ctx[112]
  );
  function segmentedcontrol_selected_binding(value) {
    ctx[113](value);
  }
  let segmentedcontrol_props = { options: (
    /*sidebarPaneOptions*/
    ctx[22]
  ) };
  if (
    /*$visibleSidebarPane*/
    ctx[27] !== void 0
  ) {
    segmentedcontrol_props.selected = /*$visibleSidebarPane*/
    ctx[27];
  }
  segmentedcontrol = new SegmentedControl({ props: segmentedcontrol_props });
  binding_callbacks.push(() => bind$4(segmentedcontrol, "selected", segmentedcontrol_selected_binding));
  const if_block_creators = [create_if_block_2, create_if_block_3, create_if_block_4, create_if_block_5];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*$visibleSidebarPane*/
      ctx2[27] == /*SidebarPanes*/
      ctx2[62].CURRENT && !!/*$thumbnailData*/
      ctx2[10] && !!/*$neighborData*/
      ctx2[13]
    )
      return 0;
    if (
      /*$visibleSidebarPane*/
      ctx2[27] == /*SidebarPanes*/
      ctx2[62].SAVED
    )
      return 1;
    if (
      /*$visibleSidebarPane*/
      ctx2[27] == /*SidebarPanes*/
      ctx2[62].RECENT
    )
      return 2;
    if (
      /*$visibleSidebarPane*/
      ctx2[27] == /*SidebarPanes*/
      ctx2[62].SUGGESTED
    )
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_3(ctx))) {
    if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block4 = (
    /*$allowsSavingSelections*/
    ctx[12] && create_if_block_1(ctx)
  );
  return {
    c() {
      div11 = element$2("div");
      div2 = element$2("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element$2("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      div1 = element$2("div");
      div1.textContent = "Similar color stripes = similar arrangements of selected points";
      t3 = space();
      div4 = element$2("div");
      div3 = element$2("div");
      create_component(synchronizedscatterplot.$$.fragment);
      t4 = space();
      if (if_block1)
        if_block1.c();
      t5 = space();
      div10 = element$2("div");
      div5 = element$2("div");
      if (if_block2)
        if_block2.c();
      t6 = space();
      create_component(autocomplete.$$.fragment);
      t7 = space();
      div6 = element$2("div");
      create_component(segmentedcontrol.$$.fragment);
      t8 = space();
      div7 = element$2("div");
      if (if_block3)
        if_block3.c();
      t9 = space();
      div9 = element$2("div");
      if (if_block4)
        if_block4.c();
      t10 = space();
      div8 = element$2("div");
      t11 = space();
      button0 = element$2("button");
      t12 = text("Help");
      t13 = space();
      button1 = element$2("button");
      button1.textContent = "Settings";
      attr(div0, "class", "frame-thumbnail-container svelte-1w0oifm");
      attr(div1, "class", "frame-sidebar-message svelte-1w0oifm");
      attr(div2, "class", "frame-sidebar svelte-1w0oifm");
      attr(div3, "class", "scatterplot-parent svelte-1w0oifm");
      attr(div4, "class", "scatterplot svelte-1w0oifm");
      attr(div5, "class", "search-bar svelte-1w0oifm");
      attr(div6, "class", "action-toolbar svelte-1w0oifm");
      attr(div7, "class", "sidebar-content svelte-1w0oifm");
      set_style(div8, "flex-grow", "1");
      attr(button0, "type", "button");
      attr(button0, "class", button0_class_value = "btn btn-sm jp-Dialog-button jp-mod-styled mr-2 " + /*$helpMessagesVisible*/
      (ctx[33] ? "jp-mod-accept btn-primary" : "jp-mod-reject btn-secondary") + " svelte-1w0oifm");
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-secondary btn-sm jp-Dialog-button jp-mod-reject jp-mod-styled svelte-1w0oifm");
      attr(div9, "class", "action-toolbar svelte-1w0oifm");
      attr(div10, "class", "sidebar svelte-1w0oifm");
      attr(div11, "class", "vis-container svelte-1w0oifm");
      set_style(
        div11,
        "height",
        /*fillHeight*/
        ctx[1] ? "100%" : "600px"
      );
    },
    m(target, anchor) {
      insert(target, div11, anchor);
      append(div11, div2);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t0);
      append(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div2, t1);
      append(div2, div1);
      append(div11, t3);
      append(div11, div4);
      append(div4, div3);
      mount_component(synchronizedscatterplot, div3, null);
      append(div3, t4);
      if (if_block1)
        if_block1.m(div3, null);
      append(div11, t5);
      append(div11, div10);
      append(div10, div5);
      if (if_block2)
        if_block2.m(div5, null);
      append(div5, t6);
      mount_component(autocomplete, div5, null);
      append(div10, t7);
      append(div10, div6);
      mount_component(segmentedcontrol, div6, null);
      append(div10, t8);
      append(div10, div7);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div7, null);
      }
      append(div10, t9);
      append(div10, div9);
      if (if_block4)
        if_block4.m(div9, null);
      append(div9, t10);
      append(div9, div8);
      append(div9, t11);
      append(div9, button0);
      append(button0, t12);
      append(div9, t13);
      append(div9, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", prevent_default(
            /*click_handler_1*/
            ctx[119]
          )),
          listen(button1, "click", prevent_default(
            /*click_handler_2*/
            ctx[120]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*$helpMessagesVisible*/
        ctx2[33]
      ) {
        if (if_block0) {
          if (dirty[1] & /*$helpMessagesVisible*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*$currentFrame, dataset, $previewFrame, colorSchemeObject*/
      33153 | dirty[1] & /*$frameColors*/
      8) {
        each_value = ensure_array_like([...range$1(
          /*dataset*/
          ctx2[0].frameCount
        )]);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const synchronizedscatterplot_changes = {};
      if (dirty[0] & /*dataset*/
      1)
        synchronizedscatterplot_changes.data = /*dataset*/
        ctx2[0];
      if (dirty[1] & /*$plotPadding*/
      16)
        synchronizedscatterplot_changes.padding = /*$plotPadding*/
        ctx2[35];
      if (dirty[0] & /*$currentFrame*/
      256)
        synchronizedscatterplot_changes.frame = /*$currentFrame*/
        ctx2[8];
      if (dirty[0] & /*$previewFrame*/
      128)
        synchronizedscatterplot_changes.previewFrame = /*$previewFrame*/
        ctx2[7];
      if (dirty[1] & /*$numNeighbors*/
      1)
        synchronizedscatterplot_changes.numNeighbors = /*$numNeighbors*/
        ctx2[31];
      if (dirty[0] & /*$previewFrame, $currentFrame*/
      384)
        synchronizedscatterplot_changes.backgroundColor = /*$previewFrame*/
        ctx2[7] != /*$currentFrame*/
        ctx2[8] && /*$previewFrame*/
        ctx2[7] != -1 ? "#f8f8ff" : "white";
      if (dirty[0] & /*colorSchemeObject*/
      32768)
        synchronizedscatterplot_changes.colorScheme = /*colorSchemeObject*/
        ctx2[15];
      if (dirty[1] & /*$selectionUnit*/
      32)
        synchronizedscatterplot_changes.selectionUnits = !!/*$selectionUnit*/
        ctx2[36] ? [
          "pixels",
          /*$selectionUnit*/
          ctx2[36]
        ] : ["pixels"];
      if (!updating_hoveredID && dirty[0] & /*scatterplotHoveredID*/
      262144) {
        updating_hoveredID = true;
        synchronizedscatterplot_changes.hoveredID = /*scatterplotHoveredID*/
        ctx2[18];
        add_flush_callback(() => updating_hoveredID = false);
      }
      if (!updating_clickedIDs && dirty[0] & /*$selectedIDs*/
      2048) {
        updating_clickedIDs = true;
        synchronizedscatterplot_changes.clickedIDs = /*$selectedIDs*/
        ctx2[11];
        add_flush_callback(() => updating_clickedIDs = false);
      }
      if (!updating_alignedIDs && dirty[0] & /*$alignedIDs*/
      64) {
        updating_alignedIDs = true;
        synchronizedscatterplot_changes.alignedIDs = /*$alignedIDs*/
        ctx2[6];
        add_flush_callback(() => updating_alignedIDs = false);
      }
      if (!updating_filterIDs && dirty[0] & /*$filterIDs*/
      32) {
        updating_filterIDs = true;
        synchronizedscatterplot_changes.filterIDs = /*$filterIDs*/
        ctx2[5];
        add_flush_callback(() => updating_filterIDs = false);
      }
      synchronizedscatterplot.$set(synchronizedscatterplot_changes);
      if (
        /*showLegend*/
        ctx2[23]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*showLegend*/
          8388608) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$helpMessagesVisible*/
        ctx2[33]
      ) {
        if (if_block2) {
          if (dirty[1] & /*$helpMessagesVisible*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_6(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div5, t6);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const autocomplete_changes = {};
      if (dirty[0] & /*pointSelectorOptions*/
      33554432)
        autocomplete_changes.options = /*pointSelectorOptions*/
        ctx2[25];
      autocomplete.$set(autocomplete_changes);
      const segmentedcontrol_changes = {};
      if (dirty[0] & /*sidebarPaneOptions*/
      4194304)
        segmentedcontrol_changes.options = /*sidebarPaneOptions*/
        ctx2[22];
      if (!updating_selected && dirty[0] & /*$visibleSidebarPane*/
      134217728) {
        updating_selected = true;
        segmentedcontrol_changes.selected = /*$visibleSidebarPane*/
        ctx2[27];
        add_flush_callback(() => updating_selected = false);
      }
      segmentedcontrol.$set(segmentedcontrol_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block3) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block3 = if_blocks[current_block_type_index];
          if (!if_block3) {
            if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block3.c();
          } else {
            if_block3.p(ctx2, dirty);
          }
          transition_in(if_block3, 1);
          if_block3.m(div7, null);
        } else {
          if_block3 = null;
        }
      }
      if (
        /*$allowsSavingSelections*/
        ctx2[12]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_1(ctx2);
          if_block4.c();
          if_block4.m(div9, t10);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (!current || dirty[1] & /*$helpMessagesVisible*/
      4 && button0_class_value !== (button0_class_value = "btn btn-sm jp-Dialog-button jp-mod-styled mr-2 " + /*$helpMessagesVisible*/
      (ctx2[33] ? "jp-mod-accept btn-primary" : "jp-mod-reject btn-secondary") + " svelte-1w0oifm")) {
        attr(button0, "class", button0_class_value);
      }
      if (!current || dirty[0] & /*fillHeight*/
      2) {
        set_style(
          div11,
          "height",
          /*fillHeight*/
          ctx2[1] ? "100%" : "600px"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(synchronizedscatterplot.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(autocomplete.$$.fragment, local);
      transition_in(segmentedcontrol.$$.fragment, local);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(synchronizedscatterplot.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(autocomplete.$$.fragment, local);
      transition_out(segmentedcontrol.$$.fragment, local);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div11);
      }
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      ctx[105](null);
      destroy_component(synchronizedscatterplot);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(autocomplete);
      destroy_component(segmentedcontrol);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block4)
        if_block4.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  let div2;
  return {
    c() {
      div2 = element$2("div");
      div2.innerHTML = `<div class="spinner-border text-primary" role="status"></div> <div class="loading-message text-center svelte-1w0oifm">Loading data...</div>`;
      attr(div2, "class", "loading-container svelte-1w0oifm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    p: noop$3,
    i: noop$3,
    o: noop$3,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block_8(ctx) {
  let helpmessage;
  let current;
  helpmessage = new HelpMessage({
    props: {
      width: 360,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(helpmessage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helpmessage, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(helpmessage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpmessage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helpmessage, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let t0;
  let strong0;
  let t2;
  let strong1;
  let t4;
  return {
    c() {
      t0 = text("Click a ");
      strong0 = element$2("strong");
      strong0.textContent = "frame thumbnail";
      t2 = text(" once to compare it with the\n          current frame, and click again to animate to that frame. You can\n          compare the ");
      strong1 = element$2("strong");
      strong1.textContent = "color stripes";
      t4 = text(" next to each thumbnail to get\n          a sense of how different the frames are.");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, strong0, anchor);
      insert(target, t2, anchor);
      insert(target, strong1, anchor);
      insert(target, t4, anchor);
    },
    p: noop$3,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(strong0);
        detach(t2);
        detach(strong1);
        detach(t4);
      }
    }
  };
}
function create_each_block(ctx) {
  let div2;
  let scatterplotthumbnail;
  let t;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[104](
        /*i*/
        ctx[140]
      )
    );
  }
  scatterplotthumbnail = new ScatterplotThumbnail({
    props: {
      isSelected: (
        /*$currentFrame*/
        ctx[8] == /*i*/
        ctx[140]
      ),
      isPreviewing: (
        /*$previewFrame*/
        ctx[7] == /*i*/
        ctx[140] && /*$previewFrame*/
        ctx[7] != /*$currentFrame*/
        ctx[8]
      ),
      colorScale: !!/*dataset*/
      ctx[0] ? (
        /*dataset*/
        ctx[0].colorScale(
          /*colorSchemeObject*/
          ctx[15]
        )
      ) : null,
      data: (
        /*dataset*/
        ctx[0]
      ),
      frame: !!/*dataset*/
      ctx[0] ? (
        /*dataset*/
        ctx[0].frame(
          /*i*/
          ctx[140]
        )
      ) : null,
      accentColor: !!/*$frameColors*/
      ctx[34] && /*$frameColors*/
      ctx[34].length > /*i*/
      ctx[140] ? (
        /*$frameColors*/
        ctx[34][
          /*i*/
          ctx[140]
        ]
      ) : null
    }
  });
  scatterplotthumbnail.$on("click", click_handler);
  return {
    c() {
      div2 = element$2("div");
      create_component(scatterplotthumbnail.$$.fragment);
      t = space();
      attr(div2, "class", "frame-thumbnail-item svelte-1w0oifm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(scatterplotthumbnail, div2, null);
      append(div2, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const scatterplotthumbnail_changes = {};
      if (dirty[0] & /*$currentFrame, dataset*/
      257)
        scatterplotthumbnail_changes.isSelected = /*$currentFrame*/
        ctx[8] == /*i*/
        ctx[140];
      if (dirty[0] & /*$previewFrame, dataset, $currentFrame*/
      385)
        scatterplotthumbnail_changes.isPreviewing = /*$previewFrame*/
        ctx[7] == /*i*/
        ctx[140] && /*$previewFrame*/
        ctx[7] != /*$currentFrame*/
        ctx[8];
      if (dirty[0] & /*dataset, colorSchemeObject*/
      32769)
        scatterplotthumbnail_changes.colorScale = !!/*dataset*/
        ctx[0] ? (
          /*dataset*/
          ctx[0].colorScale(
            /*colorSchemeObject*/
            ctx[15]
          )
        ) : null;
      if (dirty[0] & /*dataset*/
      1)
        scatterplotthumbnail_changes.data = /*dataset*/
        ctx[0];
      if (dirty[0] & /*dataset*/
      1)
        scatterplotthumbnail_changes.frame = !!/*dataset*/
        ctx[0] ? (
          /*dataset*/
          ctx[0].frame(
            /*i*/
            ctx[140]
          )
        ) : null;
      if (dirty[0] & /*dataset*/
      1 | dirty[1] & /*$frameColors*/
      8)
        scatterplotthumbnail_changes.accentColor = !!/*$frameColors*/
        ctx[34] && /*$frameColors*/
        ctx[34].length > /*i*/
        ctx[140] ? (
          /*$frameColors*/
          ctx[34][
            /*i*/
            ctx[140]
          ]
        ) : null;
      scatterplotthumbnail.$set(scatterplotthumbnail_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scatterplotthumbnail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scatterplotthumbnail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(scatterplotthumbnail);
    }
  };
}
function create_if_block_7(ctx) {
  let div2;
  let legend;
  let current;
  legend = new Legend({
    props: {
      colorScale: !!/*dataset*/
      ctx[0] ? (
        /*dataset*/
        ctx[0].colorScale(
          /*colorSchemeObject*/
          ctx[15]
        )
      ) : null,
      type: (
        /*colorSchemeObject*/
        ctx[15].type || "continuous"
      )
    }
  });
  return {
    c() {
      div2 = element$2("div");
      create_component(legend.$$.fragment);
      attr(div2, "class", "legend-container svelte-1w0oifm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(legend, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const legend_changes = {};
      if (dirty[0] & /*dataset, colorSchemeObject*/
      32769)
        legend_changes.colorScale = !!/*dataset*/
        ctx2[0] ? (
          /*dataset*/
          ctx2[0].colorScale(
            /*colorSchemeObject*/
            ctx2[15]
          )
        ) : null;
      if (dirty[0] & /*colorSchemeObject*/
      32768)
        legend_changes.type = /*colorSchemeObject*/
        ctx2[15].type || "continuous";
      legend.$set(legend_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(legend.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(legend.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(legend);
    }
  };
}
function create_if_block_6(ctx) {
  let helpmessage;
  let current;
  helpmessage = new HelpMessage({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(helpmessage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helpmessage, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(helpmessage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpmessage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helpmessage, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let t;
  return {
    c() {
      t = text("Search to select a point by its ID number or text description.");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_5(ctx) {
  let selectionbrowser;
  let current;
  selectionbrowser = new SelectionBrowser({
    props: {
      data: (
        /*$suggestedSelections*/
        ctx[38]
      ),
      thumbnailProvider: (
        /*thumbnailProvider*/
        ctx[17]
      ),
      loading: (
        /*$loadingSuggestions*/
        ctx[39]
      ),
      loadingMessage: "Loading suggestions" + /*$loadingSuggestionsProgress*/
      (ctx[40] > 0 ? ` (${/*$loadingSuggestionsProgress*/
      (ctx[40] * 100).toFixed(0)}%)` : "") + "...",
      emptyMessage: "No suggested selections right now." + /*$performanceSuggestionsMode*/
      (ctx[41] ? " Suggestions are in performance mode - will compute when less than 1,000 points are displayed." : (
        /*dataset*/
        ctx[0] != null && /*dataset*/
        ctx[0].frameCount <= 1 ? " Add more embeddings to see suggestions." : ""
      )),
      helpMessage: "This view lists <strong>Suggested Selections</strong>, which are groups of points that exhibit potentially interesting changes between frames. Try selecting different frames or moving around the scatter plot to see different suggestions."
    }
  });
  selectionbrowser.$on(
    "loadSelection",
    /*loadSelection_handler_2*/
    ctx[118]
  );
  return {
    c() {
      create_component(selectionbrowser.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectionbrowser, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectionbrowser_changes = {};
      if (dirty[1] & /*$suggestedSelections*/
      128)
        selectionbrowser_changes.data = /*$suggestedSelections*/
        ctx2[38];
      if (dirty[0] & /*thumbnailProvider*/
      131072)
        selectionbrowser_changes.thumbnailProvider = /*thumbnailProvider*/
        ctx2[17];
      if (dirty[1] & /*$loadingSuggestions*/
      256)
        selectionbrowser_changes.loading = /*$loadingSuggestions*/
        ctx2[39];
      if (dirty[1] & /*$loadingSuggestionsProgress*/
      512)
        selectionbrowser_changes.loadingMessage = "Loading suggestions" + /*$loadingSuggestionsProgress*/
        (ctx2[40] > 0 ? ` (${/*$loadingSuggestionsProgress*/
        (ctx2[40] * 100).toFixed(0)}%)` : "") + "...";
      if (dirty[0] & /*dataset*/
      1 | dirty[1] & /*$performanceSuggestionsMode*/
      1024)
        selectionbrowser_changes.emptyMessage = "No suggested selections right now." + /*$performanceSuggestionsMode*/
        (ctx2[41] ? " Suggestions are in performance mode - will compute when less than 1,000 points are displayed." : (
          /*dataset*/
          ctx2[0] != null && /*dataset*/
          ctx2[0].frameCount <= 1 ? " Add more embeddings to see suggestions." : ""
        ));
      selectionbrowser.$set(selectionbrowser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectionbrowser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectionbrowser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectionbrowser, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let selectionbrowser;
  let current;
  selectionbrowser = new SelectionBrowser({
    props: {
      data: (
        /*$selectionHistory*/
        ctx[26]
      ),
      thumbnailProvider: (
        /*thumbnailProvider*/
        ctx[17]
      ),
      emptyMessage: "No recent selections yet! Start selecting some points."
    }
  });
  selectionbrowser.$on(
    "loadSelection",
    /*loadSelection_handler_1*/
    ctx[117]
  );
  return {
    c() {
      create_component(selectionbrowser.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectionbrowser, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectionbrowser_changes = {};
      if (dirty[0] & /*$selectionHistory*/
      67108864)
        selectionbrowser_changes.data = /*$selectionHistory*/
        ctx2[26];
      if (dirty[0] & /*thumbnailProvider*/
      131072)
        selectionbrowser_changes.thumbnailProvider = /*thumbnailProvider*/
        ctx2[17];
      selectionbrowser.$set(selectionbrowser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectionbrowser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectionbrowser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectionbrowser, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let selectionbrowser;
  let current;
  selectionbrowser = new SelectionBrowser({
    props: {
      data: (
        /*$selectionList*/
        ctx[37]
      ),
      thumbnailProvider: (
        /*thumbnailProvider*/
        ctx[17]
      ),
      emptyMessage: "No saved selections yet! To create one, first select, align, or isolate some points, then click Save Selection."
    }
  });
  selectionbrowser.$on(
    "loadSelection",
    /*loadSelection_handler*/
    ctx[116]
  );
  return {
    c() {
      create_component(selectionbrowser.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectionbrowser, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectionbrowser_changes = {};
      if (dirty[1] & /*$selectionList*/
      64)
        selectionbrowser_changes.data = /*$selectionList*/
        ctx2[37];
      if (dirty[0] & /*thumbnailProvider*/
      131072)
        selectionbrowser_changes.thumbnailProvider = /*thumbnailProvider*/
        ctx2[17];
      selectionbrowser.$set(selectionbrowser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectionbrowser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectionbrowser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectionbrowser, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let defaultthumbnailviewer;
  let current;
  let defaultthumbnailviewer_props = {
    dataset: (
      /*dataset*/
      ctx[0]
    ),
    thumbnailProvider: (
      /*thumbnailProvider*/
      ctx[17]
    ),
    primaryTitle: (
      /*thumbnailHover*/
      ctx[20] ? "Hovered Point" : "Selection"
    ),
    frame: (
      /*$currentFrame*/
      ctx[8]
    ),
    previewFrame: (
      /*$previewFrame*/
      ctx[7]
    ),
    thumbnailIDs: (
      /*thumbnailIDs*/
      ctx[19]
    ),
    numNeighbors: (
      /*$numNeighbors*/
      ctx[31]
    )
  };
  defaultthumbnailviewer = new DefaultThumbnailViewer({ props: defaultthumbnailviewer_props });
  ctx[114](defaultthumbnailviewer);
  defaultthumbnailviewer.$on(
    "thumbnailClick",
    /*handleThumbnailClick*/
    ctx[77]
  );
  defaultthumbnailviewer.$on(
    "thumbnailHover",
    /*handleThumbnailHover*/
    ctx[78]
  );
  defaultthumbnailviewer.$on(
    "logEvent",
    /*logEvent_handler_1*/
    ctx[115]
  );
  return {
    c() {
      create_component(defaultthumbnailviewer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(defaultthumbnailviewer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const defaultthumbnailviewer_changes = {};
      if (dirty[0] & /*dataset*/
      1)
        defaultthumbnailviewer_changes.dataset = /*dataset*/
        ctx2[0];
      if (dirty[0] & /*thumbnailProvider*/
      131072)
        defaultthumbnailviewer_changes.thumbnailProvider = /*thumbnailProvider*/
        ctx2[17];
      if (dirty[0] & /*thumbnailHover*/
      1048576)
        defaultthumbnailviewer_changes.primaryTitle = /*thumbnailHover*/
        ctx2[20] ? "Hovered Point" : "Selection";
      if (dirty[0] & /*$currentFrame*/
      256)
        defaultthumbnailviewer_changes.frame = /*$currentFrame*/
        ctx2[8];
      if (dirty[0] & /*$previewFrame*/
      128)
        defaultthumbnailviewer_changes.previewFrame = /*$previewFrame*/
        ctx2[7];
      if (dirty[0] & /*thumbnailIDs*/
      524288)
        defaultthumbnailviewer_changes.thumbnailIDs = /*thumbnailIDs*/
        ctx2[19];
      if (dirty[1] & /*$numNeighbors*/
      1)
        defaultthumbnailviewer_changes.numNeighbors = /*$numNeighbors*/
        ctx2[31];
      defaultthumbnailviewer.$set(defaultthumbnailviewer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(defaultthumbnailviewer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(defaultthumbnailviewer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[114](null);
      destroy_component(defaultthumbnailviewer, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let button;
  let t;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element$2("button");
      t = text("Save Selection");
      attr(button, "type", "button");
      attr(button, "class", "btn btn-primary btn-sm jp-Dialog-button jp-mod-accept jp-mod-styled svelte-1w0oifm");
      button.disabled = button_disabled_value = /*$selectedIDs*/
      ctx[11].length == 0 && /*$alignedIDs*/
      ctx[6].length == 0 && /*$filterIDs*/
      ctx[5].length == 0;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(
          /*openSaveSelectionDialog*/
          ctx[66]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$selectedIDs, $alignedIDs, $filterIDs*/
      2144 && button_disabled_value !== (button_disabled_value = /*$selectedIDs*/
      ctx2[11].length == 0 && /*$alignedIDs*/
      ctx2[6].length == 0 && /*$filterIDs*/
      ctx2[5].length == 0)) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let modal0;
  let t0;
  let modal1;
  let t1;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  modal0 = new Modal({
    props: {
      visible: (
        /*isOpenDialogue*/
        ctx[21]
      ),
      width: 400,
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  modal1 = new Modal({
    props: {
      visible: (
        /*isSettingsOpen*/
        ctx[24]
      ),
      width: 400,
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (!/*dataset*/
    ctx2[0] || /*$isLoading*/
    ctx2[32])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      create_component(modal0.$$.fragment);
      t0 = space();
      create_component(modal1.$$.fragment);
      t1 = space();
      if_block.c();
      if_block_anchor = empty$2();
    },
    m(target, anchor) {
      mount_component(modal0, target, anchor);
      insert(target, t0, anchor);
      mount_component(modal1, target, anchor);
      insert(target, t1, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal0_changes = {};
      if (dirty[0] & /*isOpenDialogue*/
      2097152)
        modal0_changes.visible = /*isOpenDialogue*/
        ctx2[21];
      if (dirty[0] & /*$selectionName, $selectionDescription, isOpenDialogue, $alignedFrame, $alignedIDs, $selectedIDs, $filterIDs, $currentFrame*/
      1881147744 | dirty[4] & /*$$scope*/
      524288) {
        modal0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal0.$set(modal0_changes);
      const modal1_changes = {};
      if (dirty[0] & /*isSettingsOpen*/
      16777216)
        modal1_changes.visible = /*isSettingsOpen*/
        ctx2[24];
      if (dirty[0] & /*$colorScheme, showLegend, $previewMode, previewK, previewSimilarityThreshold, isSettingsOpen*/
      25182732 | dirty[1] & /*$numNeighbors*/
      1 | dirty[4] & /*$$scope*/
      524288) {
        modal1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal1.$set(modal1_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(modal0.$$.fragment, local);
      transition_in(modal1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(modal0.$$.fragment, local);
      transition_out(modal1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block_anchor);
      }
      destroy_component(modal0, detaching);
      destroy_component(modal1, detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
const HistoryLength = 25;
const SelectionOrderTimeout = 100;
const LoggingIntervalTime = 1e4;
const func = (c2) => c2.name;
function instance($$self, $$props, $$invalidate) {
  let $filterIDs;
  let $alignedIDs;
  let $previewFrame;
  let $currentFrame;
  let $interactionHistory;
  let $saveInteractionsFlag;
  let $selectionOrderRequest;
  let $selectionOrder;
  let $previewParameters;
  let $previewMode;
  let $thumbnailData;
  let $selectedIDs;
  let $recomputeSuggestionsFlag;
  let $suggestedSelectionWindow;
  let $selectionHistory;
  let $visibleSidebarPane;
  let $alignedFrame;
  let $saveSelectionFlag;
  let $selectionDescription;
  let $selectionName;
  let $allowsSavingSelections;
  let $neighborData;
  let $frameTransformations;
  let $data;
  let $colorScheme;
  let $numNeighbors;
  let $isLoading;
  let $helpMessagesVisible;
  let $frameColors;
  let $plotPadding;
  let $selectionUnit;
  let $selectionList;
  let $suggestedSelections;
  let $loadingSuggestions;
  let $loadingSuggestionsProgress;
  let $performanceSuggestionsMode;
  component_subscribe($$self, helpMessagesVisible, ($$value) => $$invalidate(33, $helpMessagesVisible = $$value));
  let { model } = $$props;
  let { fillHeight = false } = $$props;
  let isLoading = traitlet(model, "isLoading", false);
  component_subscribe($$self, isLoading, (value) => $$invalidate(32, $isLoading = value));
  let data = traitlet(model, "data", null);
  component_subscribe($$self, data, (value) => $$invalidate(93, $data = value));
  let neighborData = traitlet(model, "neighborData", []);
  component_subscribe($$self, neighborData, (value) => $$invalidate(13, $neighborData = value));
  let plotPadding = traitlet(model, "plotPadding", 10);
  component_subscribe($$self, plotPadding, (value) => $$invalidate(35, $plotPadding = value));
  let { dataset = null } = $$props;
  let frameTransformations = traitlet(model, "frameTransformations", []);
  component_subscribe($$self, frameTransformations, (value) => $$invalidate(92, $frameTransformations = value));
  let frameColors = traitlet(model, "frameColors", []);
  component_subscribe($$self, frameColors, (value) => $$invalidate(34, $frameColors = value));
  let thumbnailData = traitlet(model, "thumbnailData", {});
  component_subscribe($$self, thumbnailData, (value) => $$invalidate(10, $thumbnailData = value));
  let colorScheme = traitlet(model, "colorScheme", "tableau");
  component_subscribe($$self, colorScheme, (value) => $$invalidate(14, $colorScheme = value));
  let colorSchemeObject = ColorSchemes.getColorScheme($colorScheme);
  let previewMode = traitlet(model, "previewMode", PreviewMode.PROJECTION_SIMILARITY);
  component_subscribe($$self, previewMode, (value) => $$invalidate(9, $previewMode = value));
  let previewParameters = traitlet(model, "previewParameters", {});
  component_subscribe($$self, previewParameters, (value) => $$invalidate(91, $previewParameters = value));
  let previewK = 10;
  let previewSimilarityThreshold = 0.5;
  let numNeighbors = traitlet(model, "numNeighbors", 10);
  component_subscribe($$self, numNeighbors, (value) => $$invalidate(31, $numNeighbors = value));
  function updateDataset(rawData) {
    if (!!rawData && !!rawData["data"]) {
      $$invalidate(0, dataset = new Dataset(rawData, "color"));
      if (!!$frameTransformations && $frameTransformations.length > 0)
        updateTransformations(false);
    } else {
      $$invalidate(0, dataset = null);
    }
  }
  function updateTransformations(animate = true) {
    if (dataset.frameCount != $frameTransformations.length)
      return;
    dataset.transform($frameTransformations);
    if (!!canvas && animate) {
      canvas.animateDatasetUpdate();
    }
  }
  onMount(() => {
    console.log("Mounted DR widget successfully");
    setupLogging();
  });
  onDestroy(() => {
    destroyLogging();
  });
  let canvas;
  let thumbnailViewer;
  let thumbnailProvider;
  let scatterplotHoveredID = null;
  let selectedIDs = traitlet(model, "selectedIDs", []);
  component_subscribe($$self, selectedIDs, (value) => $$invalidate(11, $selectedIDs = value));
  let alignedIDs = traitlet(model, "alignedIDs", []);
  component_subscribe($$self, alignedIDs, (value) => $$invalidate(6, $alignedIDs = value));
  let alignedFrame = traitlet(model, "alignedFrame", 0);
  component_subscribe($$self, alignedFrame, (value) => $$invalidate(28, $alignedFrame = value));
  let thumbnailIDs = [];
  let thumbnailHover = false;
  let currentFrame = traitlet(model, "currentFrame", 0);
  component_subscribe($$self, currentFrame, (value) => $$invalidate(8, $currentFrame = value));
  let previewFrame = traitlet(model, "previewFrame", 0);
  component_subscribe($$self, previewFrame, (value) => $$invalidate(7, $previewFrame = value));
  let allowsSavingSelections = traitlet(model, "allowsSavingSelections", false);
  component_subscribe($$self, allowsSavingSelections, (value) => $$invalidate(12, $allowsSavingSelections = value));
  let saveSelectionFlag = traitlet(model, "saveSelectionFlag", false);
  component_subscribe($$self, saveSelectionFlag, (value) => $$invalidate(126, $saveSelectionFlag = value));
  let selectionName = traitlet(model, "selectionName", "");
  component_subscribe($$self, selectionName, (value) => $$invalidate(30, $selectionName = value));
  let selectionDescription = traitlet(model, "selectionDescription", "");
  component_subscribe($$self, selectionDescription, (value) => $$invalidate(29, $selectionDescription = value));
  let isOpenDialogue = false;
  const SidebarPanes = {
    CURRENT: 1,
    SAVED: 2,
    RECENT: 3,
    SUGGESTED: 4
  };
  let sidebarPaneOptions = [];
  let visibleSidebarPane = traitlet(model, "visibleSidebarPane", SidebarPanes.CURRENT);
  component_subscribe($$self, visibleSidebarPane, (value) => $$invalidate(27, $visibleSidebarPane = value));
  let filterIDs = traitlet(model, "filterIDs", []);
  component_subscribe($$self, filterIDs, (value) => $$invalidate(5, $filterIDs = value));
  let selectionList = traitlet(model, "selectionList", []);
  component_subscribe($$self, selectionList, (value) => $$invalidate(37, $selectionList = value));
  function openSaveSelectionDialog() {
    set_store_value(selectionName, $selectionName = "", $selectionName);
    set_store_value(selectionDescription, $selectionDescription = "", $selectionDescription);
    $$invalidate(21, isOpenDialogue = true);
  }
  function saveSelection(event) {
    set_store_value(saveSelectionFlag, $saveSelectionFlag = true, $saveSelectionFlag);
    $$invalidate(21, isOpenDialogue = false);
    logEvent({
      type: "saveSelection",
      numSelected: $selectedIDs.length,
      numAligned: $alignedIDs.length,
      numFiltered: $filterIDs.length
    });
  }
  function handleLoadSelection(event) {
    function filterFn(id2) {
      return dataset.frame(event.detail.currentFrame).has(id2);
    }
    if (event.detail.currentFrame < 0 || event.detail.currentFrame >= dataset.frameCount || event.detail.alignedFrame < 0 || event.detail.alignedFrame >= dataset.frameCount) {
      alert("This saved selection has an invalid frame number and cannot be loaded.");
    } else {
      let invalidSelected = !(event.detail.selectedIDs || []).every(filterFn);
      let invalidAligned = !(event.detail.alignedIDs || []).every(filterFn);
      let invalidFilter = !(event.detail.filterIDs || []).every(filterFn);
      set_store_value(currentFrame, $currentFrame = event.detail.currentFrame || $currentFrame || 0, $currentFrame);
      set_store_value(alignedFrame, $alignedFrame = event.detail.alignedFrame || $currentFrame || 0, $alignedFrame);
      if (!!event.detail.selectedIDs)
        set_store_value(selectedIDs, $selectedIDs = event.detail.selectedIDs.filter(filterFn), $selectedIDs);
      if (!!event.detail.alignedIDs)
        set_store_value(alignedIDs, $alignedIDs = event.detail.alignedIDs.filter(filterFn), $alignedIDs);
      if (!!event.detail.filterIDs)
        set_store_value(filterIDs, $filterIDs = event.detail.filterIDs.filter(filterFn), $filterIDs);
      if (invalidSelected || invalidAligned || invalidFilter) {
        let messages = [];
        if (invalidSelected)
          messages.push("invalid selected IDs");
        if (invalidAligned)
          messages.push("invalid aligned IDs");
        if (invalidFilter)
          messages.push("invalid filter IDs");
        alert("This saved selection had the following issues: " + messages.join(", ") + ". The remainder of the selection was loaded.");
      }
    }
    set_store_value(visibleSidebarPane, $visibleSidebarPane = SidebarPanes.CURRENT, $visibleSidebarPane);
    setTimeout(() => canvas.showVicinityOfClickedPoint());
  }
  let selectionHistory = traitlet(model, "selectionHistory", []);
  component_subscribe($$self, selectionHistory, (value) => $$invalidate(26, $selectionHistory = value));
  let oldSelectedIDs = [];
  function _makeSelectionObjectFromList(selection2) {
    return {
      selectionName: "",
      selectionDescription: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
      selectedIDs: selection2,
      currentFrame: $currentFrame
    };
  }
  function updateSelectionHistory(oldSelection, newSelection) {
    if (newSelection.length == 0)
      return;
    let selectionObj = _makeSelectionObjectFromList(newSelection);
    let idx = $selectionHistory.findIndex((sel) => {
      return sel.selectedIDs.every((id2) => newSelection.includes(id2)) && newSelection.every((id2) => sel.selectedIDs.includes(id2));
    });
    if (idx >= 0)
      set_store_value(selectionHistory, $selectionHistory = [...$selectionHistory.slice(0, idx), ...$selectionHistory.slice(idx + 1)], $selectionHistory);
    if ($selectionHistory.length == 0 || oldSelection.length == 0) {
      set_store_value(selectionHistory, $selectionHistory = [selectionObj, ...$selectionHistory], $selectionHistory);
    } else {
      let numAdded = newSelection.filter((id2) => !oldSelection.includes(id2)).length;
      let numRemoved = oldSelection.filter((id2) => !newSelection.includes(id2)).length;
      if (numAdded + numRemoved <= 1) {
        set_store_value(selectionHistory, $selectionHistory = [selectionObj, ...$selectionHistory.slice(1)], $selectionHistory);
      } else {
        set_store_value(selectionHistory, $selectionHistory = [selectionObj, ...$selectionHistory], $selectionHistory);
      }
    }
    if ($selectionHistory.length > HistoryLength) {
      set_store_value(selectionHistory, $selectionHistory = $selectionHistory.slice(0, HistoryLength), $selectionHistory);
    }
  }
  let suggestedSelections = traitlet(model, "suggestedSelections", []);
  component_subscribe($$self, suggestedSelections, (value) => $$invalidate(38, $suggestedSelections = value));
  let suggestedSelectionWindow = traitlet(model, "suggestedSelectionWindow", []);
  component_subscribe($$self, suggestedSelectionWindow, (value) => $$invalidate(125, $suggestedSelectionWindow = value));
  let loadingSuggestions = traitlet(model, "loadingSuggestions", false);
  component_subscribe($$self, loadingSuggestions, (value) => $$invalidate(39, $loadingSuggestions = value));
  let loadingSuggestionsProgress = traitlet(model, "loadingSuggestionsProgress", 0);
  component_subscribe($$self, loadingSuggestionsProgress, (value) => $$invalidate(40, $loadingSuggestionsProgress = value));
  let recomputeSuggestionsFlag = traitlet(model, "recomputeSuggestionsFlag", false);
  component_subscribe($$self, recomputeSuggestionsFlag, (value) => $$invalidate(124, $recomputeSuggestionsFlag = value));
  let performanceSuggestionsMode = traitlet(model, "performanceSuggestionsMode", false);
  component_subscribe($$self, performanceSuggestionsMode, (value) => $$invalidate(41, $performanceSuggestionsMode = value));
  function suggestInViewport(bbox) {
    if (!canvas)
      return;
    set_store_value(suggestedSelectionWindow, $suggestedSelectionWindow = bbox, $suggestedSelectionWindow);
    set_store_value(recomputeSuggestionsFlag, $recomputeSuggestionsFlag = true, $recomputeSuggestionsFlag);
  }
  function handleThumbnailClick(event) {
    if (event.detail.keyPressed) {
      let idx = $selectedIDs.indexOf(event.detail.id);
      if (idx == -1) {
        set_store_value(selectedIDs, $selectedIDs = [...$selectedIDs, event.detail.id], $selectedIDs);
      } else {
        set_store_value(selectedIDs, $selectedIDs = [...$selectedIDs.slice(0, idx), ...$selectedIDs.slice(idx + 1)], $selectedIDs);
      }
    } else {
      set_store_value(selectedIDs, $selectedIDs = [event.detail.id], $selectedIDs);
    }
  }
  function handleThumbnailHover(event) {
    $$invalidate(18, scatterplotHoveredID = event.detail.id);
  }
  let showLegend = true;
  function onScatterplotHover(e) {
    if (e.detail != null) {
      $$invalidate(19, thumbnailIDs = [e.detail]);
      $$invalidate(20, thumbnailHover = true);
    } else {
      $$invalidate(19, thumbnailIDs = $selectedIDs);
      $$invalidate(20, thumbnailHover = false);
    }
  }
  function updateThumbnails(td) {
    if (!!td && !!td.format)
      dataset.addThumbnails(td);
    else
      dataset.removeThumbnails();
    canvas.updateThumbnails();
    if (!!thumbnailProvider)
      thumbnailProvider.destroy();
    $$invalidate(17, thumbnailProvider = new ThumbnailProvider(dataset));
    updatePointSelectorOptions();
  }
  let isSettingsOpen = false;
  let pointSelectorOptions = [];
  function updatePointSelectorOptions() {
    if (dataset == null || $currentFrame < 0)
      return;
    let frame2 = dataset.frame($currentFrame);
    $$invalidate(25, pointSelectorOptions = frame2.getIDs().map((itemID) => {
      let label = frame2.get(itemID, "label");
      if (!!label && !!label.text) {
        return {
          value: itemID,
          text: `${itemID} - ${label.text}`
        };
      }
      return { value: itemID, text: itemID.toString() };
    }));
  }
  let selectionUnit = traitlet(model, "selectionUnit", "");
  component_subscribe($$self, selectionUnit, (value) => $$invalidate(36, $selectionUnit = value));
  let selectionOrderRequest = traitlet(model, "selectionOrderRequest", {});
  component_subscribe($$self, selectionOrderRequest, (value) => $$invalidate(89, $selectionOrderRequest = value));
  let selectionOrder = traitlet(model, "selectionOrder", []);
  component_subscribe($$self, selectionOrder, (value) => $$invalidate(90, $selectionOrder = value));
  async function selectionOrderFn(pointID, metric) {
    set_store_value(selectionOrder, $selectionOrder = [], $selectionOrder);
    set_store_value(
      selectionOrderRequest,
      $selectionOrderRequest = {
        centerID: pointID,
        frame: $currentFrame,
        metric
      },
      $selectionOrderRequest
    );
    return await _checkSelectionOrder();
  }
  async function _checkSelectionOrder() {
    if ($selectionOrder.length > 0) {
      set_store_value(selectionOrderRequest, $selectionOrderRequest = {}, $selectionOrderRequest);
      return $selectionOrder;
    }
    return await new Promise((resolve2) => {
      setTimeout(
        () => {
          resolve2(_checkSelectionOrder());
        },
        SelectionOrderTimeout
      );
    });
  }
  traitlet(model, "loggingEnabled", false);
  let interactionHistory = traitlet(model, "interactionHistory", []);
  component_subscribe($$self, interactionHistory, (value) => $$invalidate(122, $interactionHistory = value));
  let saveInteractionsFlag = traitlet(model, "saveInteractionsFlag", false);
  component_subscribe($$self, saveInteractionsFlag, (value) => $$invalidate(123, $saveInteractionsFlag = value));
  let loggingInterval = null;
  function setupLogging() {
    if (!!loggingInterval)
      clearInterval(loggingInterval);
    loggingInterval = setInterval(saveInteractionHistory, LoggingIntervalTime);
  }
  function destroyLogging() {
    if (!!loggingInterval)
      clearInterval(loggingInterval);
    loggingInterval = null;
  }
  function saveInteractionHistory() {
    set_store_value(saveInteractionsFlag, $saveInteractionsFlag = true, $saveInteractionsFlag);
  }
  function logEvent(event) {
    if (!event)
      return;
    event.timestamp = (/* @__PURE__ */ new Date()).toString();
    set_store_value(interactionHistory, $interactionHistory = [...$interactionHistory, event], $interactionHistory);
  }
  function saveselectionpane_name_binding(value) {
    $selectionName = value;
    selectionName.set($selectionName);
  }
  function saveselectionpane_description_binding(value) {
    $selectionDescription = value;
    selectionDescription.set($selectionDescription);
  }
  const cancel_handler = () => $$invalidate(21, isOpenDialogue = false);
  function settingspane_colorScheme_binding(value) {
    $colorScheme = value;
    colorScheme.set($colorScheme);
  }
  function settingspane_showLegend_binding(value) {
    showLegend = value;
    $$invalidate(23, showLegend);
  }
  function settingspane_previewMode_binding(value) {
    $previewMode = value;
    previewMode.set($previewMode);
  }
  function settingspane_numNeighbors_binding(value) {
    $numNeighbors = value;
    numNeighbors.set($numNeighbors);
  }
  function settingspane_previewK_binding(value) {
    previewK = value;
    $$invalidate(2, previewK);
  }
  function settingspane_similarityThreshold_binding(value) {
    previewSimilarityThreshold = value;
    $$invalidate(3, previewSimilarityThreshold);
  }
  const close_handler = () => $$invalidate(24, isSettingsOpen = false);
  const click_handler = (i) => {
    if ($previewFrame == i) {
      set_store_value(currentFrame, $currentFrame = i, $currentFrame);
      set_store_value(previewFrame, $previewFrame = -1, $previewFrame);
    } else if ($currentFrame != i)
      set_store_value(previewFrame, $previewFrame = i, $previewFrame);
    else if ($currentFrame == i)
      set_store_value(previewFrame, $previewFrame = -1, $previewFrame);
  };
  function synchronizedscatterplot_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      canvas = $$value;
      $$invalidate(4, canvas);
    });
  }
  function synchronizedscatterplot_hoveredID_binding(value) {
    scatterplotHoveredID = value;
    $$invalidate(18, scatterplotHoveredID);
  }
  function synchronizedscatterplot_clickedIDs_binding(value) {
    $selectedIDs = value;
    selectedIDs.set($selectedIDs);
  }
  function synchronizedscatterplot_alignedIDs_binding(value) {
    $alignedIDs = value;
    alignedIDs.set($alignedIDs);
  }
  function synchronizedscatterplot_filterIDs_binding(value) {
    $filterIDs = value;
    filterIDs.set($filterIDs);
  }
  const viewportChanged_handler = (e) => suggestInViewport(e.detail);
  const logEvent_handler = (e) => logEvent(e.detail);
  const change_handler = (e) => {
    set_store_value(selectedIDs, $selectedIDs = [e.detail], $selectedIDs);
    logEvent({
      type: "selection",
      source: "autocomplete"
    });
  };
  function segmentedcontrol_selected_binding(value) {
    $visibleSidebarPane = value;
    visibleSidebarPane.set($visibleSidebarPane);
  }
  function defaultthumbnailviewer_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thumbnailViewer = $$value;
      $$invalidate(16, thumbnailViewer);
    });
  }
  const logEvent_handler_1 = (e) => logEvent(e.detail);
  const loadSelection_handler = (e) => {
    handleLoadSelection(e);
    logEvent({ type: "loadSelection", source: "saved" });
  };
  const loadSelection_handler_1 = (e) => {
    handleLoadSelection(e);
    logEvent({ type: "loadSelection", source: "recents" });
  };
  const loadSelection_handler_2 = (e) => {
    handleLoadSelection(e);
    logEvent({
      type: "loadSelection",
      source: "suggested"
    });
  };
  const click_handler_1 = () => set_store_value(helpMessagesVisible, $helpMessagesVisible = !$helpMessagesVisible, $helpMessagesVisible);
  const click_handler_2 = () => $$invalidate(24, isSettingsOpen = true);
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(87, model = $$props2.model);
    if ("fillHeight" in $$props2)
      $$invalidate(1, fillHeight = $$props2.fillHeight);
    if ("dataset" in $$props2)
      $$invalidate(0, dataset = $$props2.dataset);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$colorScheme*/
    16384) {
      {
        let newScheme = ColorSchemes.getColorScheme($colorScheme);
        if (!!newScheme)
          $$invalidate(15, colorSchemeObject = newScheme);
      }
    }
    if ($$self.$$.dirty[0] & /*dataset*/
    1 | $$self.$$.dirty[2] & /*$frameTransformations*/
    1073741824) {
      if (!!$frameTransformations && $frameTransformations.length > 0 && !!dataset) {
        updateTransformations();
      }
    }
    if ($$self.$$.dirty[3] & /*$data*/
    1) {
      updateDataset($data);
    }
    if ($$self.$$.dirty[0] & /*$neighborData, dataset*/
    8193) {
      if (!!$neighborData && $neighborData.length > 0 && !!dataset) {
        dataset.setNeighbors($neighborData);
      }
    }
    if ($$self.$$.dirty[0] & /*$alignedIDs, $currentFrame*/
    320) {
      if ($alignedIDs.length == 0)
        set_store_value(alignedFrame, $alignedFrame = $currentFrame, $alignedFrame);
    }
    if ($$self.$$.dirty[0] & /*$allowsSavingSelections*/
    4096) {
      {
        if ($allowsSavingSelections)
          $$invalidate(22, sidebarPaneOptions = [
            {
              value: SidebarPanes.CURRENT,
              name: "Current"
            },
            { value: SidebarPanes.SAVED, name: "Saved" },
            {
              value: SidebarPanes.RECENT,
              name: "Recent"
            },
            {
              value: SidebarPanes.SUGGESTED,
              name: "Suggested"
            }
          ]);
        else
          $$invalidate(22, sidebarPaneOptions = [
            {
              value: SidebarPanes.CURRENT,
              name: "Current"
            },
            {
              value: SidebarPanes.RECENT,
              name: "Recent"
            },
            {
              value: SidebarPanes.SUGGESTED,
              name: "Suggested"
            }
          ]);
      }
    }
    if ($$self.$$.dirty[0] & /*$selectedIDs*/
    2048 | $$self.$$.dirty[2] & /*oldSelectedIDs*/
    67108864) {
      if (oldSelectedIDs !== $selectedIDs) {
        updateSelectionHistory(oldSelectedIDs, $selectedIDs);
        $$invalidate(88, oldSelectedIDs = $selectedIDs);
      }
    }
    if ($$self.$$.dirty[0] & /*$selectedIDs*/
    2048) {
      {
        $$invalidate(19, thumbnailIDs = $selectedIDs);
        $$invalidate(20, thumbnailHover = false);
      }
    }
    if ($$self.$$.dirty[0] & /*dataset, canvas, $thumbnailData*/
    1041) {
      if (!!dataset && !!canvas) {
        updateThumbnails($thumbnailData);
      }
    }
    if ($$self.$$.dirty[0] & /*dataset, $previewMode*/
    513) {
      if (!!dataset) {
        dataset.setPreviewMode($previewMode);
      }
    }
    if ($$self.$$.dirty[0] & /*previewK, previewSimilarityThreshold*/
    12) {
      set_store_value(
        previewParameters,
        $previewParameters = {
          k: previewK,
          similarityThreshold: previewSimilarityThreshold
        },
        $previewParameters
      );
    }
    if ($$self.$$.dirty[0] & /*dataset*/
    1 | $$self.$$.dirty[2] & /*$previewParameters*/
    536870912) {
      if (!!dataset) {
        Object.keys($previewParameters).forEach((k) => {
          dataset.setPreviewParameter(k, $previewParameters[k]);
        });
      }
    }
    if ($$self.$$.dirty[0] & /*dataset, $currentFrame*/
    257) {
      if (dataset != null && $currentFrame >= 0) {
        updatePointSelectorOptions();
      }
    }
    if ($$self.$$.dirty[2] & /*$selectionOrder, $selectionOrderRequest*/
    402653184) {
      {
        console.log("selection order:", $selectionOrder, "request:", $selectionOrderRequest);
      }
    }
    if ($$self.$$.dirty[0] & /*$currentFrame, $previewFrame*/
    384) {
      logEvent({
        type: "frameChange",
        current: $currentFrame,
        preview: $previewFrame
      });
    }
    if ($$self.$$.dirty[0] & /*$alignedIDs*/
    64) {
      logEvent({
        type: "align",
        numPoints: $alignedIDs.length
      });
    }
    if ($$self.$$.dirty[0] & /*$filterIDs*/
    32) {
      logEvent({
        type: "filter",
        numPoints: $filterIDs.length
      });
    }
  };
  return [
    dataset,
    fillHeight,
    previewK,
    previewSimilarityThreshold,
    canvas,
    $filterIDs,
    $alignedIDs,
    $previewFrame,
    $currentFrame,
    $previewMode,
    $thumbnailData,
    $selectedIDs,
    $allowsSavingSelections,
    $neighborData,
    $colorScheme,
    colorSchemeObject,
    thumbnailViewer,
    thumbnailProvider,
    scatterplotHoveredID,
    thumbnailIDs,
    thumbnailHover,
    isOpenDialogue,
    sidebarPaneOptions,
    showLegend,
    isSettingsOpen,
    pointSelectorOptions,
    $selectionHistory,
    $visibleSidebarPane,
    $alignedFrame,
    $selectionDescription,
    $selectionName,
    $numNeighbors,
    $isLoading,
    $helpMessagesVisible,
    $frameColors,
    $plotPadding,
    $selectionUnit,
    $selectionList,
    $suggestedSelections,
    $loadingSuggestions,
    $loadingSuggestionsProgress,
    $performanceSuggestionsMode,
    isLoading,
    data,
    neighborData,
    plotPadding,
    frameTransformations,
    frameColors,
    thumbnailData,
    colorScheme,
    previewMode,
    previewParameters,
    numNeighbors,
    selectedIDs,
    alignedIDs,
    alignedFrame,
    currentFrame,
    previewFrame,
    allowsSavingSelections,
    saveSelectionFlag,
    selectionName,
    selectionDescription,
    SidebarPanes,
    visibleSidebarPane,
    filterIDs,
    selectionList,
    openSaveSelectionDialog,
    saveSelection,
    handleLoadSelection,
    selectionHistory,
    suggestedSelections,
    suggestedSelectionWindow,
    loadingSuggestions,
    loadingSuggestionsProgress,
    recomputeSuggestionsFlag,
    performanceSuggestionsMode,
    suggestInViewport,
    handleThumbnailClick,
    handleThumbnailHover,
    onScatterplotHover,
    selectionUnit,
    selectionOrderRequest,
    selectionOrder,
    selectionOrderFn,
    interactionHistory,
    saveInteractionsFlag,
    logEvent,
    model,
    oldSelectedIDs,
    $selectionOrderRequest,
    $selectionOrder,
    $previewParameters,
    $frameTransformations,
    $data,
    saveselectionpane_name_binding,
    saveselectionpane_description_binding,
    cancel_handler,
    settingspane_colorScheme_binding,
    settingspane_showLegend_binding,
    settingspane_previewMode_binding,
    settingspane_numNeighbors_binding,
    settingspane_previewK_binding,
    settingspane_similarityThreshold_binding,
    close_handler,
    click_handler,
    synchronizedscatterplot_binding,
    synchronizedscatterplot_hoveredID_binding,
    synchronizedscatterplot_clickedIDs_binding,
    synchronizedscatterplot_alignedIDs_binding,
    synchronizedscatterplot_filterIDs_binding,
    viewportChanged_handler,
    logEvent_handler,
    change_handler,
    segmentedcontrol_selected_binding,
    defaultthumbnailviewer_binding,
    logEvent_handler_1,
    loadSelection_handler,
    loadSelection_handler_1,
    loadSelection_handler_2,
    click_handler_1,
    click_handler_2
  ];
}
class App extends SvelteComponent {
  constructor(options) {
    super();
    init$2(this, options, instance, create_fragment, safe_not_equal, { model: 87, fillHeight: 1, dataset: 0 }, null, [-1, -1, -1, -1, -1]);
  }
  get model() {
    return this.$$.ctx[87];
  }
  set model(model) {
    this.$$set({ model });
    flush();
  }
  get fillHeight() {
    return this.$$.ctx[1];
  }
  set fillHeight(fillHeight) {
    this.$$set({ fillHeight });
    flush();
  }
  get dataset() {
    return this.$$.ctx[0];
  }
  set dataset(dataset) {
    this.$$set({ dataset });
    flush();
  }
}
function render(view) {
  new App({
    target: view.el,
    props: {
      model: view.model
    }
  });
}
const widgetMain = { render };
export {
  widgetMain as default
};
